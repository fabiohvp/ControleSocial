
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    /**
     * Hot module replacement for Svelte in the Wild
     *
     * @export
     * @param {object} Component Svelte component
     * @param {object} [options={ target: document.body }] Options for the Svelte component
     * @param {string} [id='hmr'] ID for the component container
     * @param {string} [eventName='app-loaded'] Name of the event that triggers replacement of previous component
     * @returns
     */
    function HMR(Component, options = { target: document.body }, id = 'hmr', eventName = 'app-loaded') {
        const oldContainer = document.getElementById(id);

        // Create the new (temporarily hidden) component container
        const appContainer = document.createElement("div");
        if (oldContainer) appContainer.style.visibility = 'hidden';
        else appContainer.setAttribute('id', id); //ssr doesn't get an event, so we set the id now

        // Attach it to the target element
        options.target.appendChild(appContainer);

        // Wait for the app to load before replacing the component
        addEventListener(eventName, replaceComponent);

        function replaceComponent() {
            if (oldContainer) oldContainer.remove();
            // Show our component and take over the ID of the old container
            appContainer.style.visibility = 'initial';
            // delete (appContainer.style.visibility)
            appContainer.setAttribute('id', id);
        }

        return new Component({
            ...options,
            target: appContainer
        });
    }

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        if (value != null || input.value) {
            input.value = value;
        }
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(html, anchor = null) {
            this.e = element('div');
            this.a = anchor;
            this.u(html);
        }
        m(target, anchor = null) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(target, this.n[i], anchor);
            }
            this.t = target;
        }
        u(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        p(html) {
            this.d();
            this.u(html);
            this.m(this.t, this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                info.blocks[i] = null;
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next, lookup.has(block.key));
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error(`Cannot have duplicate keys in a keyed each`);
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if ($$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.22.3' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe,
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    /** @type {import('svelte/store').Writable<RouteNode>} */
    const route = writable(null); // the actual route being rendered
    const routes = writable([]); // all routes

    /** @type {import('svelte/store').Writable<RouteNode>} */
    const urlRoute = writable(null);  // the route matching the url

    /** 
     * @typedef {import('svelte/store').Writable<String>} Basepath
     * @type {Basepath} */
    const basepath = (() => {
        const { set, subscribe } = writable("");

        return {
            subscribe,
            set(value) {
                if (value.match(/^\//))
                    set(value);
                else console.warn('Basepaths must start with /');
            },
            update() { console.warn('Use assignment or set to update basepaths.'); }
        }
    })();

    const location$1 = derived( // the part of the url matching the basepath
        [basepath, urlRoute],
        ([$basepath, $route]) => {
            const url = window.location.pathname;
            const [, base, path] = url.match(`^(${$basepath})(${$route.regex})`) || [];
            return { base, path }
        }
    );

    const MATCH_PARAM = RegExp(/\:([^/()]+)/g);

    function handleScroll(element) {
      if (navigator.userAgent.includes('jsdom')) return false
      scrollAncestorsToTop(element);
      handleHash();
    }

    function handleHash() {
      if (navigator.userAgent.includes('jsdom')) return false
      const { hash } = window.location;
      if (hash) {
        const el = document.querySelector(hash);
        if (hash && el) el.scrollIntoView();
      }
    }

    function scrollAncestorsToTop(element) {
      if (
        element &&
        element.scrollTo &&
        element.dataset.routify !== 'scroll-lock'
      ) {
        element.style['scroll-behavior'] = "auto";
        element.scrollTo({ top: 0, behavior: 'auto' });
        element.style['scroll-behavior'] = "";
        scrollAncestorsToTop(element.parentElement);
      }
    }

    const pathToRegex = (str, recursive) => {
      const suffix = recursive ? '' : '/?$'; //fallbacks should match recursively
      str = str.replace(/\/_fallback?$/, '(/|$)');
      str = str.replace(/\/index$/, '(/index)?'); //index files should be matched even if not present in url
      str = str.replace(MATCH_PARAM, '([^/]+)') + suffix;
      return str
    };

    const pathToParams = string => {
      const params = [];
      let matches;
      while (matches = MATCH_PARAM.exec(string))
        params.push(matches[1]);
      return params
    };

    const pathToRank = ({ path }) => {
      return path
        .split('/')
        .filter(Boolean)
        .map(str => (str === '_fallback' ? 'A' : str.startsWith(':') ? 'B' : 'C'))
        .join('')
    };

    let warningSuppressed = false;

    /* eslint no-console: 0 */
    function suppressWarnings() {
      if (warningSuppressed) return
      const consoleWarn = console.warn;
      console.warn = function (msg, ...msgs) {
        const ignores = [
          "was created with unknown prop 'scoped'",
          "was created with unknown prop 'scopedSync'",
        ];
        if (!ignores.find(iMsg => msg.includes(iMsg)))
          return consoleWarn(msg, ...msgs)
      };
      warningSuppressed = true;
    }

    var defaultConfig = {
        queryHandler: {
            parse: search => fromEntries(new URLSearchParams(search)),
            stringify: params => '?' + (new URLSearchParams(params)).toString()
        }
    };


    function fromEntries(iterable) {
        return [...iterable].reduce((obj, [key, val]) => {
            obj[key] = val;
            return obj
        }, {})
    }

    /// <reference path="../typedef.js" />

    /** @ts-check */
    /**
     * @typedef {Object} RoutifyContext
     * @prop {ClientNode} component
     * @prop {ClientNode} layout
     * @prop {any} componentFile 
     * 
     *  @returns {import('svelte/store').Readable<RoutifyContext>} */
    function getRoutifyContext() {
      return getContext('routify')
    }

    /**
     * @callback AfterPageLoadHelper
     * @param {function} callback
     * 
     * @typedef {import('svelte/store').Readable<AfterPageLoadHelper> & {_hooks:Array<function>}} AfterPageLoadHelperStore
     * @type {AfterPageLoadHelperStore}
     */
    const afterPageLoad = {
      _hooks: [],
      subscribe: hookHandler
    };

    /** 
     * @callback BeforeUrlChangeHelper
     * @param {function} callback
     *
     * @typedef {import('svelte/store').Readable<BeforeUrlChangeHelper> & {_hooks:Array<function>}} BeforeUrlChangeHelperStore
     * @type {BeforeUrlChangeHelperStore}
     **/
    const beforeUrlChange = {
      _hooks: [],
      subscribe: hookHandler
    };

    function hookHandler(listener) {
      const hooks = this._hooks;
      const index = hooks.length;
      listener(callback => { hooks[index] = callback; });
      return () => delete hooks[index]
    }

    /**
     * We have to grab params and leftover from the context and not directly from the store.
     * Otherwise the context is updated before the component is destroyed. * 
     * @typedef {Object.<string, *>} ParamsHelper
     * @typedef {import('svelte/store').Readable<ParamsHelper>} ParamsHelperStore
     * @type {ParamsHelperStore}
     **/
    const params = {
      subscribe(listener) {
        return derived(
          route,
          route => route.params
        ).subscribe(listener)
      },
    };

    /**
     * @callback UrlHelper
     * @param {String=} path
     * @param {UrlParams=} params
     * @param {UrlOptions=} options
     * @return {String}
     *
     * @typedef {import('svelte/store').Readable<UrlHelper>} UrlHelperStore
     * @type {UrlHelperStore} 
     * */
    const url = {
      subscribe(listener) {
        const ctx = getRoutifyContext();
        return derived(
          [ctx, route, routes, location$1],
          args => makeUrlHelper(...args)
        ).subscribe(
          listener
        )
      }
    };

    /** 
     * @param {{component: ClientNode}} $ctx 
     * @param {RouteNode} $oldRoute 
     * @param {RouteNode[]} $routes 
     * @param {{base: string, path: string}} $location
     * @returns {UrlHelper}
     */
    function makeUrlHelper($ctx, $oldRoute, $routes, $location) {
      return function url(path, params, options) {
        const { component } = $ctx;
        path = path || './';

        const strict = options && options.strict !== false;
        if (!strict) path = path.replace(/index$/, '');

        if (path.match(/^\.\.?\//)) {
          //RELATIVE PATH
          let [, breadcrumbs, relativePath] = path.match(/^([\.\/]+)(.*)/);
          let dir = component.path.replace(/\/$/, '');
          const traverse = breadcrumbs.match(/\.\.\//g) || [];
          traverse.forEach(() => dir = dir.replace(/\/[^\/]+\/?$/, ''));
          path = `${dir}/${relativePath}`.replace(/\/$/, '');

        } else if (path.match(/^\//)) ; else {
          // NAMED PATH
          const matchingRoute = $routes.find(route => route.meta.name === path);
          if (matchingRoute) path = matchingRoute.shortPath;
        }

        /** @type {Object<string, *>} Parameters */
        const allParams = Object.assign({}, $oldRoute.params, component.params, params);
        let pathWithParams = path;
        for (const [key, value] of Object.entries(allParams)) {
          pathWithParams = pathWithParams.replace(`:${key}`, value);
        }

        const fullPath = $location.base + pathWithParams + _getQueryString(path, params);
        return fullPath.replace(/\?$/, '')
      }
    }

    /**
     * 
     * @param {string} path 
     * @param {object} params 
     */
    function _getQueryString(path, params) {
      if (!defaultConfig.queryHandler) return ""
      const pathParamKeys = pathToParams(path);
      const queryParams = {};
      if (params) Object.entries(params).forEach(([key, value]) => {
        if (!pathParamKeys.includes(key))
          queryParams[key] = value;
      });
      return defaultConfig.queryHandler.stringify(queryParams)
    }



    const _metatags = {
      props: {},
      templates: {},
      services: {
        plain: { propField: 'name', valueField: 'content' },
        twitter: { propField: 'name', valueField: 'content' },
        og: { propField: 'property', valueField: 'content' },
      },
      plugins: [
        {
          name: 'applyTemplate',
          condition: () => true,
          action: (prop, value) => {
            const template = _metatags.getLongest(_metatags.templates, prop) || (x => x);
            return [prop, template(value)]
          }
        },
        {
          name: 'createMeta',
          condition: () => true,
          action(prop, value) {
            _metatags.writeMeta(prop, value);
          }
        },
        {
          name: 'createOG',
          condition: prop => !prop.match(':'),
          action(prop, value) {
            _metatags.writeMeta(`og:${prop}`, value);
          }
        },
        {
          name: 'createTitle',
          condition: prop => prop === 'title',
          action(prop, value) {
            document.title = value;
          }
        }
      ],
      getLongest(repo, name) {
        const providers = repo[name];
        if (providers) {
          const currentPath = get_store_value(route).path;
          const allPaths = Object.keys(repo[name]);
          const matchingPaths = allPaths.filter(path => currentPath.includes(path));

          const longestKey = matchingPaths.sort((a, b) => b.length - a.length)[0];

          return providers[longestKey]
        }
      },
      writeMeta(prop, value) {
        const head = document.getElementsByTagName('head')[0];
        const match = prop.match(/(.+)\:/);
        const serviceName = match && match[1] || 'plain';
        const { propField, valueField } = metatags.services[serviceName] || metatags.services.plain;
        const oldElement = document.querySelector(`meta[${propField}='${prop}']`);
        if (oldElement) oldElement.remove();

        const newElement = document.createElement('meta');
        newElement.setAttribute(propField, prop);
        newElement.setAttribute(valueField, value);
        newElement.setAttribute('data-origin', 'routify');
        head.appendChild(newElement);
      },
      set(prop, value) {
        _metatags.plugins.forEach(plugin => {
          if (plugin.condition(prop, value))
            [prop, value] = plugin.action(prop, value) || [prop, value];
        });
      },
      clear() {
        const oldElement = document.querySelector(`meta`);
        if (oldElement) oldElement.remove();
      },
      template(name, fn) {
        const origin = _metatags.getOrigin();
        _metatags.templates[name] = _metatags.templates[name] || {};
        _metatags.templates[name][origin] = fn;
      },
      update() {
        Object.keys(_metatags.props).forEach((prop) => {
          let value = (_metatags.getLongest(_metatags.props, prop));
          _metatags.plugins.forEach(plugin => {
            if (plugin.condition(prop, value)) {
              [prop, value] = plugin.action(prop, value) || [prop, value];

            }
          });
        });
      },
      batchedUpdate() {
        if (!_metatags._pendingUpdate) {
          _metatags._pendingUpdate = true;
          setTimeout(() => {
            _metatags._pendingUpdate = false;
            this.update();
          });
        }
      },
      _updateQueued: false,
      getOrigin() {
        const routifyCtx = getRoutifyContext();
        return routifyCtx && get_store_value(routifyCtx).path || '/'
      },
      _pendingUpdate: false
    };


    /**
     * metatags
     * @prop {Object.<string, string>}
     */
    const metatags = new Proxy(_metatags, {
      set(target, name, value, receiver) {
        const { props, getOrigin } = target;

        if (Reflect.has(target, name))
          Reflect.set(target, name, value, receiver);
        else {
          props[name] = props[name] || {};
          props[name][getOrigin()] = value;
        }

        if (window['routify'].appLoaded)
          target.batchedUpdate();
        return true
      }
    });

    /* node_modules\@sveltech\routify\runtime\Route.svelte generated by Svelte v3.22.3 */
    const file = "node_modules\\@sveltech\\routify\\runtime\\Route.svelte";

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i].component;
    	child_ctx[21] = list[i].componentFile;
    	return child_ctx;
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i].component;
    	child_ctx[21] = list[i].componentFile;
    	return child_ctx;
    }

    // (122:0) {#if $context}
    function create_if_block_1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2, create_if_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$context*/ ctx[6].component.isLayout === false) return 0;
    		if (/*remainingLayouts*/ ctx[5].length) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(122:0) {#if $context}",
    		ctx
    	});

    	return block;
    }

    // (134:36) 
    function create_if_block_3(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value_1 = [/*$context*/ ctx[6]];
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*component*/ ctx[20].path;
    	validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);

    	for (let i = 0; i < 1; i += 1) {
    		let child_ctx = get_each_context_1(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$context, scoped, scopedSync, layout, remainingLayouts, decorator, Decorator, scopeToChild*/ 201326711) {
    				const each_value_1 = [/*$context*/ ctx[6]];
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < 1; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 1; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(134:36) ",
    		ctx
    	});

    	return block;
    }

    // (123:2) {#if $context.component.isLayout === false}
    function create_if_block_2(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = [/*$context*/ ctx[6]];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*component*/ ctx[20].path;
    	validate_each_keys(ctx, each_value, get_each_context, get_key);

    	for (let i = 0; i < 1; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$context, scoped, scopedSync, layout*/ 85) {
    				const each_value = [/*$context*/ ctx[6]];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < 1; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 1; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(123:2) {#if $context.component.isLayout === false}",
    		ctx
    	});

    	return block;
    }

    // (136:6) <svelte:component         this={componentFile}         let:scoped={scopeToChild}         let:decorator         {scoped}         {scopedSync}         {...layout.param || {}}>
    function create_default_slot(ctx) {
    	let t;
    	let current;

    	const route_1 = new Route({
    			props: {
    				layouts: [.../*remainingLayouts*/ ctx[5]],
    				Decorator: typeof /*decorator*/ ctx[27] !== "undefined"
    				? /*decorator*/ ctx[27]
    				: /*Decorator*/ ctx[1],
    				childOfDecorator: /*layout*/ ctx[4].isDecorator,
    				scoped: {
    					.../*scoped*/ ctx[0],
    					.../*scopeToChild*/ ctx[26]
    				}
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route_1.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(route_1, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const route_1_changes = {};
    			if (dirty & /*remainingLayouts*/ 32) route_1_changes.layouts = [.../*remainingLayouts*/ ctx[5]];

    			if (dirty & /*decorator, Decorator*/ 134217730) route_1_changes.Decorator = typeof /*decorator*/ ctx[27] !== "undefined"
    			? /*decorator*/ ctx[27]
    			: /*Decorator*/ ctx[1];

    			if (dirty & /*layout*/ 16) route_1_changes.childOfDecorator = /*layout*/ ctx[4].isDecorator;

    			if (dirty & /*scoped, scopeToChild*/ 67108865) route_1_changes.scoped = {
    				.../*scoped*/ ctx[0],
    				.../*scopeToChild*/ ctx[26]
    			};

    			route_1.$set(route_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route_1, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(136:6) <svelte:component         this={componentFile}         let:scoped={scopeToChild}         let:decorator         {scoped}         {scopedSync}         {...layout.param || {}}>",
    		ctx
    	});

    	return block;
    }

    // (135:4) {#each [$context] as { component, componentFile }
    function create_each_block_1(key_1, ctx) {
    	let first;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{ scoped: /*scoped*/ ctx[0] },
    		{ scopedSync: /*scopedSync*/ ctx[2] },
    		/*layout*/ ctx[4].param || {}
    	];

    	var switch_value = /*componentFile*/ ctx[21];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: {
    				default: [
    					create_default_slot,
    					({ scoped: scopeToChild, decorator }) => ({ 26: scopeToChild, 27: decorator }),
    					({ scoped: scopeToChild, decorator }) => (scopeToChild ? 67108864 : 0) | (decorator ? 134217728 : 0)
    				]
    			},
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*scoped, scopedSync, layout*/ 21)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*scoped*/ 1 && { scoped: /*scoped*/ ctx[0] },
    					dirty & /*scopedSync*/ 4 && { scopedSync: /*scopedSync*/ ctx[2] },
    					dirty & /*layout*/ 16 && get_spread_object(/*layout*/ ctx[4].param || {})
    				])
    			: {};

    			if (dirty & /*$$scope, remainingLayouts, decorator, Decorator, layout, scoped, scopeToChild*/ 469762099) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*componentFile*/ ctx[21])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(135:4) {#each [$context] as { component, componentFile }",
    		ctx
    	});

    	return block;
    }

    // (124:4) {#each [$context] as { component, componentFile }
    function create_each_block(key_1, ctx) {
    	let first;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{ scoped: /*scoped*/ ctx[0] },
    		{ scopedSync: /*scopedSync*/ ctx[2] },
    		/*layout*/ ctx[4].param || {}
    	];

    	var switch_value = /*componentFile*/ ctx[21];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*scoped, scopedSync, layout*/ 21)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*scoped*/ 1 && { scoped: /*scoped*/ ctx[0] },
    					dirty & /*scopedSync*/ 4 && { scopedSync: /*scopedSync*/ ctx[2] },
    					dirty & /*layout*/ 16 && get_spread_object(/*layout*/ ctx[4].param || {})
    				])
    			: {};

    			if (switch_value !== (switch_value = /*componentFile*/ ctx[21])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(124:4) {#each [$context] as { component, componentFile }",
    		ctx
    	});

    	return block;
    }

    // (154:0) {#if !parentElement}
    function create_if_block(ctx) {
    	let span;
    	let setParent_action;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			add_location(span, file, 154, 2, 4477);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, span, anchor);
    			if (remount) dispose();
    			dispose = action_destroyer(setParent_action = /*setParent*/ ctx[8].call(null, span));
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(154:0) {#if !parentElement}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$context*/ ctx[6] && create_if_block_1(ctx);
    	let if_block1 = !/*parentElement*/ ctx[3] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$context*/ ctx[6]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$context*/ 64) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*parentElement*/ ctx[3]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $context;
    	let $route;
    	validate_store(route, "route");
    	component_subscribe($$self, route, $$value => $$invalidate(14, $route = $$value));
    	let { layouts = [] } = $$props;
    	let { scoped = {} } = $$props;
    	let { Decorator = null } = $$props;
    	let { childOfDecorator = false } = $$props;
    	let scopedSync = {};
    	let layoutIsUpdated = false;
    	let isDecorator = false;

    	/** @type {HTMLElement} */
    	let parentElement;

    	/** @type {LayoutOrDecorator} */
    	let layout = null;

    	/** @type {LayoutOrDecorator} */
    	let lastLayout = null;

    	/** @type {LayoutOrDecorator[]} */
    	let remainingLayouts = [];

    	const context = writable(null);
    	validate_store(context, "context");
    	component_subscribe($$self, context, value => $$invalidate(6, $context = value));

    	/** @type {import("svelte/store").Writable<Context>} */
    	const parentContextStore = getContext("routify");

    	isDecorator = Decorator && !childOfDecorator;
    	setContext("routify", context);

    	/** @param {HTMLElement} el */
    	function setParent(el) {
    		$$invalidate(3, parentElement = el.parentElement);
    	}

    	/** @param {SvelteComponent} componentFile */
    	function onComponentLoaded(componentFile) {
    		/** @type {Context} */
    		const parentContext = get_store_value(parentContextStore);

    		$$invalidate(2, scopedSync = { ...scoped });
    		$$invalidate(13, lastLayout = layout);
    		if (remainingLayouts.length === 0) onLastComponentLoaded();

    		context.set({
    			layout: isDecorator ? parentContext.layout : layout,
    			component: layout,
    			componentFile,
    			child: isDecorator
    			? parentContext.child
    			: get_store_value(context) && get_store_value(context).child
    		});

    		if (parentContext && !isDecorator) parentContextStore.update(store => {
    			store.child = layout || store.child;
    			return store;
    		});
    	}

    	/**  @param {LayoutOrDecorator} layout */
    	function setComponent(layout) {
    		let PendingComponent = layout.component();
    		if (PendingComponent instanceof Promise) PendingComponent.then(onComponentLoaded); else onComponentLoaded(PendingComponent);
    	}

    	async function onLastComponentLoaded() {
    		afterPageLoad._hooks.forEach(hook => hook(layout.api));
    		await tick();
    		handleScroll(parentElement);
    		metatags.update();
    		if (!window["routify"].appLoaded) onAppLoaded();
    	}

    	async function onAppLoaded() {
    		const pagePath = $context.component.path;
    		const routePath = $route.path;
    		const isOnCurrentRoute = pagePath === routePath; //maybe we're getting redirected

    		// Let everyone know the last child has rendered
    		if (!window["routify"].stopAutoReady && isOnCurrentRoute) {
    			dispatchEvent(new CustomEvent("app-loaded"));
    			window["routify"].appLoaded = true;
    		}
    	}

    	const writable_props = ["layouts", "scoped", "Decorator", "childOfDecorator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Route> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Route", $$slots, []);

    	$$self.$set = $$props => {
    		if ("layouts" in $$props) $$invalidate(9, layouts = $$props.layouts);
    		if ("scoped" in $$props) $$invalidate(0, scoped = $$props.scoped);
    		if ("Decorator" in $$props) $$invalidate(1, Decorator = $$props.Decorator);
    		if ("childOfDecorator" in $$props) $$invalidate(10, childOfDecorator = $$props.childOfDecorator);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		setContext,
    		onDestroy,
    		onMount,
    		tick,
    		writable,
    		get: get_store_value,
    		metatags,
    		afterPageLoad,
    		route,
    		routes,
    		handleScroll,
    		layouts,
    		scoped,
    		Decorator,
    		childOfDecorator,
    		scopedSync,
    		layoutIsUpdated,
    		isDecorator,
    		parentElement,
    		layout,
    		lastLayout,
    		remainingLayouts,
    		context,
    		parentContextStore,
    		setParent,
    		onComponentLoaded,
    		setComponent,
    		onLastComponentLoaded,
    		onAppLoaded,
    		$context,
    		$route
    	});

    	$$self.$inject_state = $$props => {
    		if ("layouts" in $$props) $$invalidate(9, layouts = $$props.layouts);
    		if ("scoped" in $$props) $$invalidate(0, scoped = $$props.scoped);
    		if ("Decorator" in $$props) $$invalidate(1, Decorator = $$props.Decorator);
    		if ("childOfDecorator" in $$props) $$invalidate(10, childOfDecorator = $$props.childOfDecorator);
    		if ("scopedSync" in $$props) $$invalidate(2, scopedSync = $$props.scopedSync);
    		if ("layoutIsUpdated" in $$props) layoutIsUpdated = $$props.layoutIsUpdated;
    		if ("isDecorator" in $$props) $$invalidate(12, isDecorator = $$props.isDecorator);
    		if ("parentElement" in $$props) $$invalidate(3, parentElement = $$props.parentElement);
    		if ("layout" in $$props) $$invalidate(4, layout = $$props.layout);
    		if ("lastLayout" in $$props) $$invalidate(13, lastLayout = $$props.lastLayout);
    		if ("remainingLayouts" in $$props) $$invalidate(5, remainingLayouts = $$props.remainingLayouts);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isDecorator, Decorator, layouts*/ 4610) {
    			 if (isDecorator) {
    				const decoratorLayout = {
    					component: () => Decorator,
    					path: `${layouts[0].path}__decorator`,
    					isDecorator: true
    				};

    				$$invalidate(9, layouts = [decoratorLayout, ...layouts]);
    			}
    		}

    		if ($$self.$$.dirty & /*layouts*/ 512) {
    			 $$invalidate(4, [layout, ...remainingLayouts] = layouts, layout, ((($$invalidate(5, remainingLayouts), $$invalidate(9, layouts)), $$invalidate(12, isDecorator)), $$invalidate(1, Decorator)));
    		}

    		if ($$self.$$.dirty & /*lastLayout, layout*/ 8208) {
    			 layoutIsUpdated = !lastLayout || lastLayout.path !== layout.path;
    		}

    		if ($$self.$$.dirty & /*layout*/ 16) {
    			 setComponent(layout);
    		}
    	};

    	return [
    		scoped,
    		Decorator,
    		scopedSync,
    		parentElement,
    		layout,
    		remainingLayouts,
    		$context,
    		context,
    		setParent,
    		layouts,
    		childOfDecorator
    	];
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance, create_fragment, safe_not_equal, {
    			layouts: 9,
    			scoped: 0,
    			Decorator: 1,
    			childOfDecorator: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get layouts() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set layouts(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scoped() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scoped(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Decorator() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Decorator(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get childOfDecorator() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set childOfDecorator(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const { _hooks } = beforeUrlChange;

    function init$1(routes, callback) {
      /** @type { ClientNode | false } */
      let lastRoute = false;

      function updatePage(proxyToUrl, shallow) {
        const currentUrl = window.location.pathname;
        const url = proxyToUrl || currentUrl;

        const route$1 = urlToRoute(url, routes);
        const currentRoute = shallow && urlToRoute(currentUrl, routes);
        const contextRoute = currentRoute || route$1;
        const layouts = [...contextRoute.layouts, route$1];
        if (lastRoute) delete lastRoute.last; //todo is a page component the right place for the previous route?
        route$1.last = lastRoute;
        lastRoute = route$1;

        //set the route in the store
        if (!proxyToUrl)
          urlRoute.set(route$1);
        route.set(route$1);

        //run callback in Router.svelte
        callback(layouts);
      }

      const destroy = createEventListeners(updatePage);

      return { updatePage, destroy }
    }

    /**
     * svelte:window events doesn't work on refresh
     * @param {Function} updatePage
     */
    function createEventListeners(updatePage) {
    ['pushState', 'replaceState'].forEach(eventName => {
        const fn = history[eventName];
        history[eventName] = async function (state = {}, title, url) {
          const { id, path, params } = get_store_value(route);
          state = { id, path, params, ...state };
          const event = new Event(eventName.toLowerCase());
          Object.assign(event, { state, title, url });

          if (await runHooksBeforeUrlChange(event)) {
            fn.apply(this, [state, title, url]);
            return dispatchEvent(event)
          }
        };
      });

      let _ignoreNextPop = false;

      const listeners = {
        click: handleClick,
        pushstate: () => updatePage(),
        replacestate: () => updatePage(),
        popstate: async event => {
          if (_ignoreNextPop)
            _ignoreNextPop = false;
          else {
            if (await runHooksBeforeUrlChange(event)) {
              updatePage();
            } else {
              _ignoreNextPop = true;
              event.preventDefault();
              history.go(1);
            }
          }
        },
      };

      Object.entries(listeners).forEach(args => addEventListener(...args));

      const unregister = () => {
        Object.entries(listeners).forEach(args => removeEventListener(...args));
      };

      return unregister
    }

    function handleClick(event) {
      const el = event.target.closest('a');
      const href = el && el.getAttribute('href');

      if (
        event.ctrlKey ||
        event.metaKey ||
        event.altKey ||
        event.shiftKey ||
        event.button ||
        event.defaultPrevented
      )
        return
      if (!href || el.target || el.host !== location.host) return

      event.preventDefault();
      history.pushState({}, '', href);
    }

    async function runHooksBeforeUrlChange(event) {
      const route$1 = get_store_value(route);
      for (const hook of _hooks.filter(Boolean)) {
        // return false if the hook returns false
        if (await !hook(event, route$1)) return false //todo remove route from hook. Its API Can be accessed as $page
      }
      return true
    }

    function urlToRoute(url, routes) {
      const basepath$1 = get_store_value(basepath);
      const route = routes.find(route => url.match(`^${basepath$1}${route.regex}`));
      if (!route)
        throw new Error(
          `Route could not be found. Make sure ${url}.svelte or ${url}/index.svelte exists. A restart may be required.`
        )

      const [, base, path] = url.match(`^(${get_store_value(basepath)})(${route.regex})`);
      if (defaultConfig.queryHandler)
        route.params = defaultConfig.queryHandler.parse(window.location.search);

      if (route.paramKeys) {
        const layouts = layoutByPos(route.layouts);
        const fragments = path.split('/').filter(Boolean);
        const routeProps = getRouteProps(route.path);

        routeProps.forEach((prop, i) => {
          if (prop) {
            route.params[prop] = fragments[i];
            if (layouts[i]) layouts[i].param = { [prop]: fragments[i] };
            else route.param = { [prop]: fragments[i] };
          }
        });
      }

      route.leftover = url.replace(new RegExp(base + route.regex), '');

      return route
    }

    /**
     *
     * @param {array} layouts
     */
    function layoutByPos(layouts) {
      const arr = [];
      layouts.forEach(layout => {
        arr[layout.path.split('/').filter(Boolean).length - 1] = layout;
      });
      return arr
    }

    /**
     *
     * @param {string} url
     */
    function getRouteProps(url) {
      return url
        .split('/')
        .filter(Boolean)
        .map(f => f.match(/\:(.+)/))
        .map(f => f && f[1])
    }

    /* node_modules\@sveltech\routify\runtime\Router.svelte generated by Svelte v3.22.3 */

    const { Object: Object_1 } = globals;

    // (63:0) {#if layouts && $route !== null}
    function create_if_block$1(ctx) {
    	let current;

    	const route_1 = new Route({
    			props: { layouts: /*layouts*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(route_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const route_1_changes = {};
    			if (dirty & /*layouts*/ 1) route_1_changes.layouts = /*layouts*/ ctx[0];
    			route_1.$set(route_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(63:0) {#if layouts && $route !== null}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*layouts*/ ctx[0] && /*$route*/ ctx[1] !== null && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*layouts*/ ctx[0] && /*$route*/ ctx[1] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*layouts, $route*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $route;
    	validate_store(route, "route");
    	component_subscribe($$self, route, $$value => $$invalidate(1, $route = $$value));
    	let { routes: routes$1 } = $$props;
    	let { config = {} } = $$props;
    	let layouts;
    	let navigator;

    	Object.entries(config).forEach(([key, value]) => {
    		defaultConfig[key] = value;
    	});

    	suppressWarnings();

    	if (!window.routify) {
    		window.routify = {};
    	}

    	const updatePage = (...args) => navigator && navigator.updatePage(...args);
    	setContext("routifyupdatepage", updatePage);
    	const callback = res => $$invalidate(0, layouts = res);

    	const cleanup = () => {
    		if (!navigator) return;
    		navigator.destroy();
    		navigator = null;
    	};

    	let initTimeout = null;

    	// init is async to prevent a horrible bug that completely disable reactivity
    	// in the host component -- something like the component's update function is
    	// called before its fragment is created, and since the component is then seen
    	// as already dirty, it is never scheduled for update again, and remains dirty
    	// forever... I failed to isolate the precise conditions for the bug, but the
    	// faulty update is triggered by a change in the route store, and so offseting
    	// store initialization by one tick gives the host component some time to
    	// create its fragment. The root cause it probably a bug in Svelte with deeply
    	// intertwinned store and reactivity.
    	const doInit = () => {
    		clearTimeout(initTimeout);

    		initTimeout = setTimeout(() => {
    			cleanup();
    			navigator = init$1(routes$1, callback);
    			routes.set(routes$1);
    			navigator.updatePage();
    		});
    	};

    	onDestroy(cleanup);
    	const writable_props = ["routes", "config"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Router", $$slots, []);

    	$$self.$set = $$props => {
    		if ("routes" in $$props) $$invalidate(2, routes$1 = $$props.routes);
    		if ("config" in $$props) $$invalidate(3, config = $$props.config);
    	};

    	$$self.$capture_state = () => ({
    		setContext,
    		onDestroy,
    		Route,
    		init: init$1,
    		route,
    		routesStore: routes,
    		suppressWarnings,
    		defaultConfig,
    		routes: routes$1,
    		config,
    		layouts,
    		navigator,
    		updatePage,
    		callback,
    		cleanup,
    		initTimeout,
    		doInit,
    		$route
    	});

    	$$self.$inject_state = $$props => {
    		if ("routes" in $$props) $$invalidate(2, routes$1 = $$props.routes);
    		if ("config" in $$props) $$invalidate(3, config = $$props.config);
    		if ("layouts" in $$props) $$invalidate(0, layouts = $$props.layouts);
    		if ("navigator" in $$props) navigator = $$props.navigator;
    		if ("initTimeout" in $$props) initTimeout = $$props.initTimeout;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*routes*/ 4) {
    			 if (routes$1) doInit();
    		}
    	};

    	return [layouts, $route, routes$1, config];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { routes: 2, config: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*routes*/ ctx[2] === undefined && !("routes" in props)) {
    			console.warn("<Router> was created without expected prop 'routes'");
    		}
    	}

    	get routes() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get config() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set config(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /** 
     * Node payload
     * @typedef {Object} NodePayload
     * @property {RouteNode=} file current node
     * @property {RouteNode=} parent parent of the current node
     * @property {StateObject=} state state shared by every node in the walker
     * @property {Object=} scope scope inherited by descendants in the scope
     *
     * State Object
     * @typedef {Object} StateObject
     * @prop {TreePayload=} treePayload payload from the tree
     * 
     * Node walker proxy
     * @callback NodeWalkerProxy
     * @param {NodePayload} NodePayload
     */


    /**
     * Node middleware
     * @description Walks through the nodes of a tree
     * @example middleware = createNodeMiddleware(payload => {payload.file.name = 'hello'})(treePayload))
     * @param {NodeWalkerProxy} fn 
     */
    function createNodeMiddleware(fn) {

        /**    
         * NodeMiddleware payload receiver
         * @param {TreePayload} payload
         */
        const inner = async function execute(payload) {
            return await nodeMiddleware(payload.tree, fn, { state: { treePayload: payload } })
        };

        /**    
         * NodeMiddleware sync payload receiver
         * @param {TreePayload} payload
         */
        inner.sync = function executeSync(payload) {
            return nodeMiddlewareSync(payload.tree, fn, { state: { treePayload: payload } })
        };

        return inner
    }

    /**
     * Node walker
     * @param {Object} file mutable file
     * @param {NodeWalkerProxy} fn function to be called for each file
     * @param {NodePayload=} payload 
     */
    async function nodeMiddleware(file, fn, payload) {
        const { state, scope, parent } = payload || {};
        payload = {
            file,
            parent,
            state: state || {},            //state is shared by all files in the walk
            scope: clone(scope || {}),     //scope is inherited by descendants
        };

        await fn(payload);

        if (file.children) {
            payload.parent = file;
            await Promise.all(file.children.map(_file => nodeMiddleware(_file, fn, payload)));
        }
        return payload
    }

    /**
     * Node walker (sync version)
     * @param {Object} file mutable file
     * @param {NodeWalkerProxy} fn function to be called for each file
     * @param {NodePayload=} payload 
     */
    function nodeMiddlewareSync(file, fn, payload) {
        const { state, scope, parent } = payload || {};
        payload = {
            file,
            parent,
            state: state || {},            //state is shared by all files in the walk
            scope: clone(scope || {}),     //scope is inherited by descendants
        };

        fn(payload);

        if (file.children) {
            payload.parent = file;
            file.children.map(_file => nodeMiddlewareSync(_file, fn, payload));
        }
        return payload
    }


    /**
     * Clone with JSON
     * @param {T} obj 
     * @returns {T} JSON cloned object
     * @template T
     */
    function clone(obj) { return JSON.parse(JSON.stringify(obj)) }



    var middleware = { createNodeMiddleware, nodeMiddleware };
    var middleware_1 = middleware.createNodeMiddleware;

    const setRegex = middleware_1(({ file }) => {
        if (file.isPage || file.isFallback)
            file.regex = pathToRegex(file.path, file.isFallback);
    });
    const setParamKeys = middleware_1(({ file }) => {
        file.paramKeys = pathToParams(file.path);
    });

    const setShortPath = middleware_1(({ file }) => {
        if (file.isFallback || file.isIndex)
            file.shortPath = file.path.replace(/\/[^/]+$/, '');
        else file.shortPath = file.path;
    });
    const setRank = middleware_1(({ file }) => {
        file.ranking = pathToRank(file);
    });


    // todo delete?
    const addMetaChildren = middleware_1(({ file }) => {
        const node = file;
        const metaChildren = file.meta && file.meta.children || [];
        if (metaChildren.length) {
            node.children = node.children || [];
            node.children.push(...metaChildren.map(meta => ({ isMeta: true, ...meta, meta })));
        }
    });

    const setIsIndexable = middleware_1(payload => {
        const { file } = payload;
        const { isLayout, isFallback, meta } = file;
        file.isIndexable = !isLayout && !isFallback && meta.index !== false;
        file.isNonIndexable = !file.isIndexable;
    });


    const assignRelations = middleware_1(({ file, parent }) => {
        Object.defineProperty(file, 'parent', { get: () => parent });
        Object.defineProperty(file, 'nextSibling', { get: () => _getSibling(file, 1) });
        Object.defineProperty(file, 'prevSibling', { get: () => _getSibling(file, -1) });
        Object.defineProperty(file, 'lineage', { get: () => _getLineage(parent) });
    });

    function _getLineage(node, lineage = []){
        if(node){
            lineage.unshift(node);
            _getLineage(node.parent, lineage);
        }
        return lineage
    }

    /**
     * 
     * @param {RouteNode} file 
     * @param {Number} direction 
     */
    function _getSibling(file, direction) {
        if (!file.root) {
            const siblings = file.parent.children.filter(c => c.isIndexable);
            const index = siblings.indexOf(file);
            return siblings[index + direction]
        }
    }

    const assignIndex = middleware_1(({ file, parent }) => {
        if (file.isIndex) Object.defineProperty(parent, 'index', { get: () => file });
        if (file.isLayout)
            Object.defineProperty(parent, 'layout', { get: () => file });
    });

    const assignLayout = middleware_1(({ file, scope }) => {
        Object.defineProperty(file, 'layouts', { get: () => getLayouts(file) });
        function getLayouts(file) {
            const { parent } = file;
            const layout = parent && parent.layout;
            const isReset = layout && layout.isReset;
            const layouts = (parent && !isReset && getLayouts(parent)) || [];
            if (layout) layouts.push(layout);
            return layouts
        }
    });


    const createFlatList = treePayload => {
        middleware_1(payload => {
            if (payload.file.isPage || payload.file.isFallback)
            payload.state.treePayload.routes.push(payload.file);
        }).sync(treePayload);    
        treePayload.routes.sort((c, p) => (c.ranking >= p.ranking ? -1 : 1));
    };

    const setPrototype = middleware_1(({ file }) => {
        const Prototype = file.root
            ? Root
            : file.children
                ? file.isFile ? PageDir : Dir
                : file.isReset
                    ? Reset
                    : file.isLayout
                        ? Layout
                        : file.isFallback
                            ? Fallback
                            : Page;
        Object.setPrototypeOf(file, Prototype.prototype);

        function Layout() { }
        function Dir() { }
        function Fallback() { }
        function Page() { }
        function PageDir() { }
        function Reset() { }
        function Root() { }
    });

    var miscPlugins = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setRegex: setRegex,
        setParamKeys: setParamKeys,
        setShortPath: setShortPath,
        setRank: setRank,
        addMetaChildren: addMetaChildren,
        setIsIndexable: setIsIndexable,
        assignRelations: assignRelations,
        assignIndex: assignIndex,
        assignLayout: assignLayout,
        createFlatList: createFlatList,
        setPrototype: setPrototype
    });

    const assignAPI = middleware_1(({ file }) => {
        file.api = new ClientApi(file);
    });

    class ClientApi {
        constructor(file) {
            this.__file = file;
            Object.defineProperty(this, '__file', { enumerable: false });
            this.isMeta = !!file.isMeta;
            this.path = file.path;
            this.title = _prettyName(file);
            this.meta = file.meta;
        }

        get parent() { return !this.__file.root && this.__file.parent.api }
        get children() {
            return (this.__file.children || this.__file.isLayout && this.__file.parent.children || [])
                .filter(c => !c.isNonIndexable)
                .sort((a, b) => {
                    if(a.isMeta && b.isMeta) return 0
                    a = (a.meta.index || a.meta.title || a.path).toString();
                    b = (b.meta.index || b.meta.title || b.path).toString();
                    return a.localeCompare((b), undefined, { numeric: true, sensitivity: 'base' })
                })
                .map(({ api }) => api)
        }
        get next() { return _navigate(this, +1) }
        get prev() { return _navigate(this, -1) }
    }

    function _navigate(node, direction) {
        if (!node.__file.root) {
            const siblings = node.parent.children;
            const index = siblings.indexOf(node);
            return node.parent.children[index + direction]
        }
    }


    function _prettyName(file) {
        if (typeof file.meta.title !== 'undefined') return file.meta.title
        else return (file.shortPath || file.path)
            .split('/')
            .pop()
            .replace(/-/g, ' ')
    }

    const plugins = {...miscPlugins, assignAPI};

    function buildClientTree(tree) {
      const order = [
        // pages
        "setParamKeys", //pages only
        "setRegex", //pages only
        "setShortPath", //pages only
        "setRank", //pages only
        "assignLayout", //pages only,
        // all
        "setPrototype",
        "addMetaChildren",
        "assignRelations", //all (except meta components?)
        "setIsIndexable", //all
        "assignIndex", //all
        "assignAPI", //all
        // routes
        "createFlatList"
      ];

      const payload = { tree, routes: [] };
      for (let name of order) {
        const syncFn = plugins[name].sync || plugins[name];
        syncFn(payload);
      }
      return payload
    }

    /* node_modules\@fabiohvp\svelte-table\src\Sort.svelte generated by Svelte v3.22.3 */
    const file$1 = "node_modules\\@fabiohvp\\svelte-table\\src\\Sort.svelte";

    // (62:2) {:else}
    function create_else_block(ctx) {
    	let span;
    	let raw_value = /*labels*/ ctx[1].unsorted.html + "";
    	let span_title_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "title", span_title_value = /*labels*/ ctx[1].unsorted.title);
    			add_location(span, file$1, 62, 4, 1377);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			span.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*labels*/ 2 && raw_value !== (raw_value = /*labels*/ ctx[1].unsorted.html + "")) span.innerHTML = raw_value;
    			if (dirty & /*labels*/ 2 && span_title_value !== (span_title_value = /*labels*/ ctx[1].unsorted.title)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(62:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (58:27) 
    function create_if_block_1$1(ctx) {
    	let span;
    	let raw_value = /*labels*/ ctx[1].desc.html + "";
    	let span_title_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "title", span_title_value = /*labels*/ ctx[1].desc.title);
    			add_location(span, file$1, 58, 4, 1283);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			span.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*labels*/ 2 && raw_value !== (raw_value = /*labels*/ ctx[1].desc.html + "")) span.innerHTML = raw_value;
    			if (dirty & /*labels*/ 2 && span_title_value !== (span_title_value = /*labels*/ ctx[1].desc.title)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(58:27) ",
    		ctx
    	});

    	return block;
    }

    // (54:2) {#if dir === 'asc'}
    function create_if_block$2(ctx) {
    	let span;
    	let raw_value = /*labels*/ ctx[1].asc.html + "";
    	let span_title_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "title", span_title_value = /*labels*/ ctx[1].asc.title);
    			add_location(span, file$1, 54, 4, 1173);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			span.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*labels*/ 2 && raw_value !== (raw_value = /*labels*/ ctx[1].asc.html + "")) span.innerHTML = raw_value;
    			if (dirty & /*labels*/ 2 && span_title_value !== (span_title_value = /*labels*/ ctx[1].asc.title)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(54:2) {#if dir === 'asc'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let span;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*dir*/ ctx[0] === "asc") return create_if_block$2;
    		if (/*dir*/ ctx[0] === "desc") return create_if_block_1$1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			attr_dev(span, "class", "sort svelte-1fzpwfi");
    			add_location(span, file$1, 52, 0, 1106);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, span, anchor);
    			if_block.m(span, null);
    			if (remount) dispose();
    			dispose = listen_dev(span, "click", /*onClick*/ ctx[2], false, false, false);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_block.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let globalLabels;

    function setLabels(labels) {
    	globalLabels = labels;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	const stateContext = getContext("state");
    	let { dir = "none" } = $$props;
    	let { key } = $$props;

    	let { labels = {
    		asc: { title: "Ascending", html: "&#8593;" },
    		desc: { title: "Desceding", html: "&#8595;" },
    		unsorted: { title: "Unsorted", html: "&#8645;" },
    		...globalLabels
    	} } = $$props;

    	function onClick(event) {
    		const state = stateContext.getState();

    		const detail = {
    			originalEvent: event,
    			key,
    			dir: dir !== "desc" ? "desc" : "asc",
    			rows: state.filteredRows
    		};

    		dispatch("sort", detail);

    		if (detail.preventDefault !== true) {
    			$$invalidate(0, dir = detail.dir);
    		}

    		stateContext.setRows(detail.rows);
    	}

    	const writable_props = ["dir", "key", "labels"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Sort> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Sort", $$slots, []);

    	$$self.$set = $$props => {
    		if ("dir" in $$props) $$invalidate(0, dir = $$props.dir);
    		if ("key" in $$props) $$invalidate(3, key = $$props.key);
    		if ("labels" in $$props) $$invalidate(1, labels = $$props.labels);
    	};

    	$$self.$capture_state = () => ({
    		globalLabels,
    		setLabels,
    		createEventDispatcher,
    		getContext,
    		dispatch,
    		stateContext,
    		dir,
    		key,
    		labels,
    		onClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("dir" in $$props) $$invalidate(0, dir = $$props.dir);
    		if ("key" in $$props) $$invalidate(3, key = $$props.key);
    		if ("labels" in $$props) $$invalidate(1, labels = $$props.labels);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dir, labels, onClick, key];
    }

    class Sort extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { dir: 0, key: 3, labels: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sort",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*key*/ ctx[3] === undefined && !("key" in props)) {
    			console.warn("<Sort> was created without expected prop 'key'");
    		}
    	}

    	get dir() {
    		throw new Error("<Sort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dir(value) {
    		throw new Error("<Sort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<Sort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Sort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labels() {
    		throw new Error("<Sort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labels(value) {
    		throw new Error("<Sort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@fabiohvp\svelte-table\src\Search.svelte generated by Svelte v3.22.3 */
    const file$2 = "node_modules\\@fabiohvp\\svelte-table\\src\\Search.svelte";

    function create_fragment$3(ctx) {
    	let div;
    	let input;
    	let input_title_value;
    	let input_placeholder_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			attr_dev(input, "type", "search");
    			attr_dev(input, "title", input_title_value = /*labels*/ ctx[1].placeholder);
    			attr_dev(input, "placeholder", input_placeholder_value = /*labels*/ ctx[1].placeholder);
    			attr_dev(input, "class", "svelte-1bsquhb");
    			add_location(input, file$2, 84, 2, 1764);
    			attr_dev(div, "class", "search svelte-1bsquhb");
    			add_location(div, file$2, 83, 0, 1740);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*text*/ ctx[0]);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    				listen_dev(input, "keyup", /*onSearch*/ ctx[2], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*labels*/ 2 && input_title_value !== (input_title_value = /*labels*/ ctx[1].placeholder)) {
    				attr_dev(input, "title", input_title_value);
    			}

    			if (dirty & /*labels*/ 2 && input_placeholder_value !== (input_placeholder_value = /*labels*/ ctx[1].placeholder)) {
    				attr_dev(input, "placeholder", input_placeholder_value);
    			}

    			if (dirty & /*text*/ 1) {
    				set_input_value(input, /*text*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let globalLabels$1;

    function setLabels$1(labels) {
    	globalLabels$1 = labels;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	const stateContext = getContext("state");

    	let { filter = (row, text, index) => {
    		text = text.toLowerCase();

    		for (let i in row) {
    			if ((row[i] || "").toString().toLowerCase().indexOf(text) > -1) {
    				return true;
    			}
    		}

    		return false;
    	} } = $$props;

    	let { index = -1 } = $$props;
    	let { text = "" } = $$props;
    	let { labels = { placeholder: "Search", ...globalLabels$1 } } = $$props;

    	async function onSearch(event) {
    		const state = stateContext.getState();

    		const detail = {
    			originalEvent: event,
    			filter,
    			index,
    			text,
    			page: state.page,
    			pageIndex: state.pageIndex,
    			pageSize: state.pageSize,
    			rows: state.filteredRows
    		};

    		dispatch("search", detail);

    		if (detail.preventDefault !== true) {
    			if (detail.text.length === 0) {
    				stateContext.setRows(state.rows);
    			} else {
    				stateContext.setRows(detail.rows.filter(r => detail.filter(r, detail.text, index)));
    			}

    			stateContext.setPage(0, 0);
    		} else {
    			stateContext.setRows(detail.rows);
    		}
    	}

    	const writable_props = ["filter", "index", "text", "labels"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Search> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Search", $$slots, []);

    	function input_input_handler() {
    		text = this.value;
    		$$invalidate(0, text);
    	}

    	$$self.$set = $$props => {
    		if ("filter" in $$props) $$invalidate(3, filter = $$props.filter);
    		if ("index" in $$props) $$invalidate(4, index = $$props.index);
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("labels" in $$props) $$invalidate(1, labels = $$props.labels);
    	};

    	$$self.$capture_state = () => ({
    		globalLabels: globalLabels$1,
    		setLabels: setLabels$1,
    		createEventDispatcher,
    		getContext,
    		dispatch,
    		stateContext,
    		filter,
    		index,
    		text,
    		labels,
    		onSearch
    	});

    	$$self.$inject_state = $$props => {
    		if ("filter" in $$props) $$invalidate(3, filter = $$props.filter);
    		if ("index" in $$props) $$invalidate(4, index = $$props.index);
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("labels" in $$props) $$invalidate(1, labels = $$props.labels);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		text,
    		labels,
    		onSearch,
    		filter,
    		index,
    		dispatch,
    		stateContext,
    		input_input_handler
    	];
    }

    class Search extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { filter: 3, index: 4, text: 0, labels: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Search",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get filter() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filter(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labels() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labels(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@fabiohvp\svelte-table\src\Row.svelte generated by Svelte v3.22.3 */
    const file$3 = "node_modules\\@fabiohvp\\svelte-table\\src\\Row.svelte";

    function create_fragment$4(ctx) {
    	let tr;
    	let tr_class_value;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			if (default_slot) default_slot.c();
    			attr_dev(tr, "class", tr_class_value = "" + (null_to_empty(/*$$props*/ ctx[2].class) + " svelte-55z7vp"));
    			toggle_class(tr, "odd", /*index*/ ctx[0] % 2 !== 0);
    			toggle_class(tr, "even", /*index*/ ctx[0] % 2 === 0);
    			add_location(tr, file$3, 17, 0, 281);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, tr, anchor);

    			if (default_slot) {
    				default_slot.m(tr, null);
    			}

    			current = true;
    			if (remount) dispose();
    			dispose = listen_dev(tr, "click", /*onClick*/ ctx[1], false, false, false);
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[4], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null));
    				}
    			}

    			if (!current || dirty & /*$$props*/ 4 && tr_class_value !== (tr_class_value = "" + (null_to_empty(/*$$props*/ ctx[2].class) + " svelte-55z7vp"))) {
    				attr_dev(tr, "class", tr_class_value);
    			}

    			if (dirty & /*$$props, index*/ 5) {
    				toggle_class(tr, "odd", /*index*/ ctx[0] % 2 !== 0);
    			}

    			if (dirty & /*$$props, index*/ 5) {
    				toggle_class(tr, "even", /*index*/ ctx[0] % 2 === 0);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (default_slot) default_slot.d(detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	let { index = 0 } = $$props;

    	function onClick(event) {
    		dispatch("click", event);
    	}

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Row", $$slots, ['default']);

    	$$self.$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("index" in $$new_props) $$invalidate(0, index = $$new_props.index);
    		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		index,
    		onClick
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ("index" in $$props) $$invalidate(0, index = $$new_props.index);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [index, onClick, $$props, dispatch, $$scope, $$slots];
    }

    class Row extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { index: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Row",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get index() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@fabiohvp\svelte-table\src\Pagination.svelte generated by Svelte v3.22.3 */
    const file$4 = "node_modules\\@fabiohvp\\svelte-table\\src\\Pagination.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	return child_ctx;
    }

    // (84:4) {#if page + button >= 0 && page + button <= pageCount}
    function create_if_block$3(ctx) {
    	let li;
    	let button;
    	let t_value = /*page*/ ctx[1] + /*button*/ ctx[15] + 1 + "";
    	let t;
    	let dispose;

    	function click_handler_2(...args) {
    		return /*click_handler_2*/ ctx[12](/*button*/ ctx[15], ...args);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "svelte-11seuwy");
    			toggle_class(button, "active", /*page*/ ctx[1] === /*page*/ ctx[1] + /*button*/ ctx[15]);
    			add_location(button, file$4, 85, 8, 1784);
    			attr_dev(li, "class", "svelte-11seuwy");
    			add_location(li, file$4, 84, 6, 1770);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, t);
    			if (remount) dispose();
    			dispose = listen_dev(button, "click", click_handler_2, false, false, false);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*page, buttons*/ 3 && t_value !== (t_value = /*page*/ ctx[1] + /*button*/ ctx[15] + 1 + "")) set_data_dev(t, t_value);

    			if (dirty & /*page, buttons*/ 3) {
    				toggle_class(button, "active", /*page*/ ctx[1] === /*page*/ ctx[1] + /*button*/ ctx[15]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(84:4) {#if page + button >= 0 && page + button <= pageCount}",
    		ctx
    	});

    	return block;
    }

    // (83:2) {#each buttons as button}
    function create_each_block$1(ctx) {
    	let if_block_anchor;
    	let if_block = /*page*/ ctx[1] + /*button*/ ctx[15] >= 0 && /*page*/ ctx[1] + /*button*/ ctx[15] <= /*pageCount*/ ctx[3] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*page*/ ctx[1] + /*button*/ ctx[15] >= 0 && /*page*/ ctx[1] + /*button*/ ctx[15] <= /*pageCount*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(83:2) {#each buttons as button}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let ul;
    	let li0;
    	let button0;
    	let t0_value = /*labels*/ ctx[2].first + "";
    	let t0;
    	let button0_disabled_value;
    	let t1;
    	let li1;
    	let button1;
    	let t2_value = /*labels*/ ctx[2].previous + "";
    	let t2;
    	let button1_disabled_value;
    	let t3;
    	let t4;
    	let li2;
    	let button2;
    	let t5_value = /*labels*/ ctx[2].next + "";
    	let t5;
    	let button2_disabled_value;
    	let t6;
    	let li3;
    	let button3;
    	let t7_value = /*labels*/ ctx[2].last + "";
    	let t7;
    	let button3_disabled_value;
    	let dispose;
    	let each_value = /*buttons*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			button0 = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			li1 = element("li");
    			button1 = element("button");
    			t2 = text(t2_value);
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			li2 = element("li");
    			button2 = element("button");
    			t5 = text(t5_value);
    			t6 = space();
    			li3 = element("li");
    			button3 = element("button");
    			t7 = text(t7_value);
    			button0.disabled = button0_disabled_value = /*page*/ ctx[1] === 0;
    			attr_dev(button0, "class", "svelte-11seuwy");
    			add_location(button0, file$4, 73, 4, 1435);
    			attr_dev(li0, "class", "svelte-11seuwy");
    			add_location(li0, file$4, 72, 2, 1425);
    			button1.disabled = button1_disabled_value = /*page*/ ctx[1] === 0;
    			attr_dev(button1, "class", "svelte-11seuwy");
    			add_location(button1, file$4, 78, 4, 1556);
    			attr_dev(li1, "class", "svelte-11seuwy");
    			add_location(li1, file$4, 77, 2, 1546);
    			button2.disabled = button2_disabled_value = /*page*/ ctx[1] > /*pageCount*/ ctx[3] - 1;
    			attr_dev(button2, "class", "svelte-11seuwy");
    			add_location(button2, file$4, 94, 4, 1994);
    			attr_dev(li2, "class", "svelte-11seuwy");
    			add_location(li2, file$4, 93, 2, 1984);
    			button3.disabled = button3_disabled_value = /*page*/ ctx[1] >= /*pageCount*/ ctx[3];
    			attr_dev(button3, "class", "svelte-11seuwy");
    			add_location(button3, file$4, 101, 4, 2145);
    			attr_dev(li3, "class", "svelte-11seuwy");
    			add_location(li3, file$4, 100, 2, 2135);
    			attr_dev(ul, "class", "svelte-11seuwy");
    			add_location(ul, file$4, 71, 0, 1417);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, button0);
    			append_dev(button0, t0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			append_dev(li1, button1);
    			append_dev(button1, t2);
    			append_dev(ul, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(ul, t4);
    			append_dev(ul, li2);
    			append_dev(li2, button2);
    			append_dev(button2, t5);
    			append_dev(ul, t6);
    			append_dev(ul, li3);
    			append_dev(li3, button3);
    			append_dev(button3, t7);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(button0, "click", /*click_handler*/ ctx[10], false, false, false),
    				listen_dev(button1, "click", /*click_handler_1*/ ctx[11], false, false, false),
    				listen_dev(button2, "click", /*click_handler_3*/ ctx[13], false, false, false),
    				listen_dev(button3, "click", /*click_handler_4*/ ctx[14], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*labels*/ 4 && t0_value !== (t0_value = /*labels*/ ctx[2].first + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*page*/ 2 && button0_disabled_value !== (button0_disabled_value = /*page*/ ctx[1] === 0)) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			if (dirty & /*labels*/ 4 && t2_value !== (t2_value = /*labels*/ ctx[2].previous + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*page*/ 2 && button1_disabled_value !== (button1_disabled_value = /*page*/ ctx[1] === 0)) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty & /*page, buttons, onChange, pageCount*/ 27) {
    				each_value = /*buttons*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, t4);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*labels*/ 4 && t5_value !== (t5_value = /*labels*/ ctx[2].next + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*page, pageCount*/ 10 && button2_disabled_value !== (button2_disabled_value = /*page*/ ctx[1] > /*pageCount*/ ctx[3] - 1)) {
    				prop_dev(button2, "disabled", button2_disabled_value);
    			}

    			if (dirty & /*labels*/ 4 && t7_value !== (t7_value = /*labels*/ ctx[2].last + "")) set_data_dev(t7, t7_value);

    			if (dirty & /*page, pageCount*/ 10 && button3_disabled_value !== (button3_disabled_value = /*page*/ ctx[1] >= /*pageCount*/ ctx[3])) {
    				prop_dev(button3, "disabled", button3_disabled_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let globalLabels$2;

    function setLabels$2(labels) {
    	globalLabels$2 = labels;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	const stateContext = getContext("state");
    	let { buttons = [-2, -1, 0, 1, 2] } = $$props;
    	let { count } = $$props;
    	let { page = 0 } = $$props;
    	let { pageSize } = $$props;
    	let { serverSide = false } = $$props;

    	let { labels = {
    		first: "First",
    		last: "Last",
    		next: "Next",
    		previous: "Previous",
    		...globalLabels$2
    	} } = $$props;

    	function onChange(event, page) {
    		const state = stateContext.getState();

    		const detail = {
    			originalEvent: event,
    			page,
    			pageIndex: serverSide ? 0 : page * state.pageSize,
    			pageSize: state.pageSize
    		};

    		dispatch("pageChange", detail);

    		if (detail.preventDefault !== true) {
    			stateContext.setPage(detail.page, detail.pageIndex);
    		}
    	}

    	const writable_props = ["buttons", "count", "page", "pageSize", "serverSide", "labels"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Pagination> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Pagination", $$slots, []);
    	const click_handler = e => onChange(e, 0);
    	const click_handler_1 = e => onChange(e, page - 1);
    	const click_handler_2 = (button, e) => onChange(e, page + button);
    	const click_handler_3 = e => onChange(e, page + 1);
    	const click_handler_4 = e => onChange(e, pageCount);

    	$$self.$set = $$props => {
    		if ("buttons" in $$props) $$invalidate(0, buttons = $$props.buttons);
    		if ("count" in $$props) $$invalidate(5, count = $$props.count);
    		if ("page" in $$props) $$invalidate(1, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(6, pageSize = $$props.pageSize);
    		if ("serverSide" in $$props) $$invalidate(7, serverSide = $$props.serverSide);
    		if ("labels" in $$props) $$invalidate(2, labels = $$props.labels);
    	};

    	$$self.$capture_state = () => ({
    		globalLabels: globalLabels$2,
    		setLabels: setLabels$2,
    		createEventDispatcher,
    		getContext,
    		dispatch,
    		stateContext,
    		buttons,
    		count,
    		page,
    		pageSize,
    		serverSide,
    		labels,
    		onChange,
    		pageCount
    	});

    	$$self.$inject_state = $$props => {
    		if ("buttons" in $$props) $$invalidate(0, buttons = $$props.buttons);
    		if ("count" in $$props) $$invalidate(5, count = $$props.count);
    		if ("page" in $$props) $$invalidate(1, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(6, pageSize = $$props.pageSize);
    		if ("serverSide" in $$props) $$invalidate(7, serverSide = $$props.serverSide);
    		if ("labels" in $$props) $$invalidate(2, labels = $$props.labels);
    		if ("pageCount" in $$props) $$invalidate(3, pageCount = $$props.pageCount);
    	};

    	let pageCount;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*count, pageSize*/ 96) {
    			 $$invalidate(3, pageCount = Math.floor(count / pageSize));
    		}
    	};

    	return [
    		buttons,
    		page,
    		labels,
    		pageCount,
    		onChange,
    		count,
    		pageSize,
    		serverSide,
    		dispatch,
    		stateContext,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4
    	];
    }

    class Pagination extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
    			buttons: 0,
    			count: 5,
    			page: 1,
    			pageSize: 6,
    			serverSide: 7,
    			labels: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pagination",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*count*/ ctx[5] === undefined && !("count" in props)) {
    			console.warn("<Pagination> was created without expected prop 'count'");
    		}

    		if (/*pageSize*/ ctx[6] === undefined && !("pageSize" in props)) {
    			console.warn("<Pagination> was created without expected prop 'pageSize'");
    		}
    	}

    	get buttons() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttons(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get page() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set page(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pageSize() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pageSize(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get serverSide() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set serverSide(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labels() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labels(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@fabiohvp\svelte-table\src\index.svelte generated by Svelte v3.22.3 */
    const file$5 = "node_modules\\@fabiohvp\\svelte-table\\src\\index.svelte";
    const get_bottom_slot_changes = dirty => ({ rows: dirty & /*visibleRows*/ 128 });
    const get_bottom_slot_context = ctx => ({ rows: /*visibleRows*/ ctx[7] });
    const get_foot_slot_changes = dirty => ({ rows: dirty & /*visibleRows*/ 128 });
    const get_foot_slot_context = ctx => ({ rows: /*visibleRows*/ ctx[7] });
    const get_default_slot_changes = dirty => ({ rows: dirty & /*visibleRows*/ 128 });
    const get_default_slot_context = ctx => ({ rows: /*visibleRows*/ ctx[7] });
    const get_head_slot_changes = dirty => ({ rows: dirty & /*visibleRows*/ 128 });
    const get_head_slot_context = ctx => ({ rows: /*visibleRows*/ ctx[7] });
    const get_top_slot_changes = dirty => ({ rows: dirty & /*visibleRows*/ 128 });
    const get_top_slot_context = ctx => ({ rows: /*visibleRows*/ ctx[7] });

    // (153:17)     
    function fallback_block_1(ctx) {
    	let div;
    	let current;
    	var switch_value = Search;

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props());
    		switch_instance.$on("search", /*onSearch*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "slot-top svelte-16st3gf");
    			add_location(div, file$5, 153, 2, 3348);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = Search)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("search", /*onSearch*/ ctx[9]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(153:17)     ",
    		ctx
    	});

    	return block;
    }

    // (181:2) {:else}
    function create_else_block$1(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, visibleRows*/ 65664) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[16], get_default_slot_context), get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, get_default_slot_changes));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(181:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (171:37) 
    function create_if_block_1$2(ctx) {
    	let tbody;
    	let tr;
    	let td;
    	let span;
    	let raw_value = /*labels*/ ctx[5].empty + "";

    	const block = {
    		c: function create() {
    			tbody = element("tbody");
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			attr_dev(span, "class", "svelte-16st3gf");
    			add_location(span, file$5, 174, 10, 3856);
    			attr_dev(td, "class", "center svelte-16st3gf");
    			attr_dev(td, "colspan", "100%");
    			add_location(td, file$5, 173, 8, 3810);
    			add_location(tr, file$5, 172, 6, 3796);
    			add_location(tbody, file$5, 171, 4, 3781);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr);
    			append_dev(tr, td);
    			append_dev(td, span);
    			span.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*labels*/ 32 && raw_value !== (raw_value = /*labels*/ ctx[5].empty + "")) span.innerHTML = raw_value;		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tbody);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(171:37) ",
    		ctx
    	});

    	return block;
    }

    // (161:2) {#if loading}
    function create_if_block$4(ctx) {
    	let tbody;
    	let tr;
    	let td;
    	let span;
    	let raw_value = /*labels*/ ctx[5].loading + "";

    	const block = {
    		c: function create() {
    			tbody = element("tbody");
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			attr_dev(span, "class", "svelte-16st3gf");
    			add_location(span, file$5, 164, 10, 3633);
    			attr_dev(td, "class", "center svelte-16st3gf");
    			attr_dev(td, "colspan", "100%");
    			add_location(td, file$5, 163, 8, 3587);
    			add_location(tr, file$5, 162, 6, 3573);
    			add_location(tbody, file$5, 161, 4, 3558);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr);
    			append_dev(tr, td);
    			append_dev(td, span);
    			span.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*labels*/ 32 && raw_value !== (raw_value = /*labels*/ ctx[5].loading + "")) span.innerHTML = raw_value;		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tbody);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(161:2) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (187:20)     
    function fallback_block(ctx) {
    	let div;
    	let current;
    	var switch_value = Pagination;

    	function switch_props(ctx) {
    		return {
    			props: {
    				page: /*page*/ ctx[0],
    				pageSize: /*pageSize*/ ctx[2],
    				serverSide: /*serverSide*/ ctx[4],
    				count: /*filteredRows*/ ctx[6].length - 1
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("pageChange", /*onPageChange*/ ctx[8]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "slot-bottom svelte-16st3gf");
    			add_location(div, file$5, 187, 2, 4072);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*page*/ 1) switch_instance_changes.page = /*page*/ ctx[0];
    			if (dirty & /*pageSize*/ 4) switch_instance_changes.pageSize = /*pageSize*/ ctx[2];
    			if (dirty & /*serverSide*/ 16) switch_instance_changes.serverSide = /*serverSide*/ ctx[4];
    			if (dirty & /*filteredRows*/ 64) switch_instance_changes.count = /*filteredRows*/ ctx[6].length - 1;

    			if (switch_value !== (switch_value = Pagination)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("pageChange", /*onPageChange*/ ctx[8]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(187:20)     ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let t0;
    	let table;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let t2;
    	let table_class_value;
    	let t3;
    	let current;
    	const top_slot_template = /*$$slots*/ ctx[17].top;
    	const top_slot = create_slot(top_slot_template, ctx, /*$$scope*/ ctx[16], get_top_slot_context);
    	const top_slot_or_fallback = top_slot || fallback_block_1(ctx);
    	const head_slot_template = /*$$slots*/ ctx[17].head;
    	const head_slot = create_slot(head_slot_template, ctx, /*$$scope*/ ctx[16], get_head_slot_context);
    	const if_block_creators = [create_if_block$4, create_if_block_1$2, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[1]) return 0;
    		if (/*visibleRows*/ ctx[7].length === 0) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const foot_slot_template = /*$$slots*/ ctx[17].foot;
    	const foot_slot = create_slot(foot_slot_template, ctx, /*$$scope*/ ctx[16], get_foot_slot_context);
    	const bottom_slot_template = /*$$slots*/ ctx[17].bottom;
    	const bottom_slot = create_slot(bottom_slot_template, ctx, /*$$scope*/ ctx[16], get_bottom_slot_context);
    	const bottom_slot_or_fallback = bottom_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			if (top_slot_or_fallback) top_slot_or_fallback.c();
    			t0 = space();
    			table = element("table");
    			if (head_slot) head_slot.c();
    			t1 = space();
    			if_block.c();
    			t2 = space();
    			if (foot_slot) foot_slot.c();
    			t3 = space();
    			if (bottom_slot_or_fallback) bottom_slot_or_fallback.c();
    			attr_dev(table, "class", table_class_value = "" + (null_to_empty("table " + /*$$props*/ ctx[10].class) + " svelte-16st3gf"));
    			toggle_class(table, "responsive", /*responsive*/ ctx[3]);
    			add_location(table, file$5, 158, 0, 3454);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (top_slot_or_fallback) {
    				top_slot_or_fallback.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);

    			if (head_slot) {
    				head_slot.m(table, null);
    			}

    			append_dev(table, t1);
    			if_blocks[current_block_type_index].m(table, null);
    			append_dev(table, t2);

    			if (foot_slot) {
    				foot_slot.m(table, null);
    			}

    			insert_dev(target, t3, anchor);

    			if (bottom_slot_or_fallback) {
    				bottom_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (top_slot) {
    				if (top_slot.p && dirty & /*$$scope, visibleRows*/ 65664) {
    					top_slot.p(get_slot_context(top_slot_template, ctx, /*$$scope*/ ctx[16], get_top_slot_context), get_slot_changes(top_slot_template, /*$$scope*/ ctx[16], dirty, get_top_slot_changes));
    				}
    			}

    			if (head_slot) {
    				if (head_slot.p && dirty & /*$$scope, visibleRows*/ 65664) {
    					head_slot.p(get_slot_context(head_slot_template, ctx, /*$$scope*/ ctx[16], get_head_slot_context), get_slot_changes(head_slot_template, /*$$scope*/ ctx[16], dirty, get_head_slot_changes));
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(table, t2);
    			}

    			if (foot_slot) {
    				if (foot_slot.p && dirty & /*$$scope, visibleRows*/ 65664) {
    					foot_slot.p(get_slot_context(foot_slot_template, ctx, /*$$scope*/ ctx[16], get_foot_slot_context), get_slot_changes(foot_slot_template, /*$$scope*/ ctx[16], dirty, get_foot_slot_changes));
    				}
    			}

    			if (!current || dirty & /*$$props*/ 1024 && table_class_value !== (table_class_value = "" + (null_to_empty("table " + /*$$props*/ ctx[10].class) + " svelte-16st3gf"))) {
    				attr_dev(table, "class", table_class_value);
    			}

    			if (dirty & /*$$props, responsive*/ 1032) {
    				toggle_class(table, "responsive", /*responsive*/ ctx[3]);
    			}

    			if (bottom_slot) {
    				if (bottom_slot.p && dirty & /*$$scope, visibleRows*/ 65664) {
    					bottom_slot.p(get_slot_context(bottom_slot_template, ctx, /*$$scope*/ ctx[16], get_bottom_slot_context), get_slot_changes(bottom_slot_template, /*$$scope*/ ctx[16], dirty, get_bottom_slot_changes));
    				}
    			} else {
    				if (bottom_slot_or_fallback && bottom_slot_or_fallback.p && dirty & /*page, pageSize, serverSide, filteredRows*/ 85) {
    					bottom_slot_or_fallback.p(ctx, dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(top_slot_or_fallback, local);
    			transition_in(head_slot, local);
    			transition_in(if_block);
    			transition_in(foot_slot, local);
    			transition_in(bottom_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(top_slot_or_fallback, local);
    			transition_out(head_slot, local);
    			transition_out(if_block);
    			transition_out(foot_slot, local);
    			transition_out(bottom_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (top_slot_or_fallback) top_slot_or_fallback.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    			if (head_slot) head_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (foot_slot) foot_slot.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (bottom_slot_or_fallback) bottom_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let globalLabels$3;

    function setTableLabels(labels) {
    	globalLabels$3 = labels;
    }

    const setPaginationLabels = setLabels$2;
    const setSearchLabels = setLabels$1;
    const setSortLabels = setLabels;

    function instance$6($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	let { loading = false } = $$props;
    	let { page = 0 } = $$props;
    	let { pageIndex = 0 } = $$props;
    	let { pageSize = 10 } = $$props;
    	let { responsive = true } = $$props;
    	let { rows } = $$props;
    	let { serverSide = false } = $$props;

    	let { labels = {
    		empty: "No records available",
    		loading: "Loading data",
    		...globalLabels$3
    	} } = $$props;

    	let buttons = [-2, -1, 0, 1, 2];
    	let pageCount = 0;

    	setContext("state", {
    		getState: () => ({
    			page,
    			pageIndex,
    			pageSize,
    			rows,
    			filteredRows
    		}),
    		setPage: (_page, _pageIndex) => {
    			$$invalidate(0, page = _page);
    			$$invalidate(11, pageIndex = _pageIndex);
    		},
    		setRows: _rows => $$invalidate(6, filteredRows = _rows)
    	});

    	function onPageChange(event) {
    		dispatch("pageChange", event.detail);
    	}

    	function onSearch(event) {
    		dispatch("search", event.detail);
    	}

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Src", $$slots, ['top','head','default','foot','bottom']);

    	$$self.$set = $$new_props => {
    		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("loading" in $$new_props) $$invalidate(1, loading = $$new_props.loading);
    		if ("page" in $$new_props) $$invalidate(0, page = $$new_props.page);
    		if ("pageIndex" in $$new_props) $$invalidate(11, pageIndex = $$new_props.pageIndex);
    		if ("pageSize" in $$new_props) $$invalidate(2, pageSize = $$new_props.pageSize);
    		if ("responsive" in $$new_props) $$invalidate(3, responsive = $$new_props.responsive);
    		if ("rows" in $$new_props) $$invalidate(12, rows = $$new_props.rows);
    		if ("serverSide" in $$new_props) $$invalidate(4, serverSide = $$new_props.serverSide);
    		if ("labels" in $$new_props) $$invalidate(5, labels = $$new_props.labels);
    		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Pagination,
    		_setPaginationLabels: setLabels$2,
    		Row,
    		Search,
    		_setSearchLabels: setLabels$1,
    		Sort,
    		_setSortLabels: setLabels,
    		globalLabels: globalLabels$3,
    		setTableLabels,
    		setPaginationLabels,
    		setSearchLabels,
    		setSortLabels,
    		createEventDispatcher,
    		setContext,
    		dispatch,
    		loading,
    		page,
    		pageIndex,
    		pageSize,
    		responsive,
    		rows,
    		serverSide,
    		labels,
    		buttons,
    		pageCount,
    		onPageChange,
    		onSearch,
    		filteredRows,
    		visibleRows
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
    		if ("loading" in $$props) $$invalidate(1, loading = $$new_props.loading);
    		if ("page" in $$props) $$invalidate(0, page = $$new_props.page);
    		if ("pageIndex" in $$props) $$invalidate(11, pageIndex = $$new_props.pageIndex);
    		if ("pageSize" in $$props) $$invalidate(2, pageSize = $$new_props.pageSize);
    		if ("responsive" in $$props) $$invalidate(3, responsive = $$new_props.responsive);
    		if ("rows" in $$props) $$invalidate(12, rows = $$new_props.rows);
    		if ("serverSide" in $$props) $$invalidate(4, serverSide = $$new_props.serverSide);
    		if ("labels" in $$props) $$invalidate(5, labels = $$new_props.labels);
    		if ("buttons" in $$props) buttons = $$new_props.buttons;
    		if ("pageCount" in $$props) pageCount = $$new_props.pageCount;
    		if ("filteredRows" in $$props) $$invalidate(6, filteredRows = $$new_props.filteredRows);
    		if ("visibleRows" in $$props) $$invalidate(7, visibleRows = $$new_props.visibleRows);
    	};

    	let filteredRows;
    	let visibleRows;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*rows*/ 4096) {
    			 $$invalidate(6, filteredRows = rows);
    		}

    		if ($$self.$$.dirty & /*filteredRows, pageIndex, pageSize*/ 2116) {
    			 $$invalidate(7, visibleRows = filteredRows.slice(pageIndex, pageIndex + pageSize));
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		page,
    		loading,
    		pageSize,
    		responsive,
    		serverSide,
    		labels,
    		filteredRows,
    		visibleRows,
    		onPageChange,
    		onSearch,
    		$$props,
    		pageIndex,
    		rows,
    		dispatch,
    		buttons,
    		pageCount,
    		$$scope,
    		$$slots
    	];
    }

    class Src extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
    			loading: 1,
    			page: 0,
    			pageIndex: 11,
    			pageSize: 2,
    			responsive: 3,
    			rows: 12,
    			serverSide: 4,
    			labels: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Src",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*rows*/ ctx[12] === undefined && !("rows" in props)) {
    			console.warn("<Src> was created without expected prop 'rows'");
    		}
    	}

    	get loading() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get page() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set page(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pageIndex() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pageIndex(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pageSize() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pageSize(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get responsive() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set responsive(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get serverSide() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set serverSide(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labels() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labels(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var bind = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    /*global toString:true*/

    // utils is a library of generic helper functions non-specific to axios

    var toString = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = merge(result[key], val);
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Function equal to merge with the difference being that no reference
     * to original objects is kept.
     *
     * @see merge
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function deepMerge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = deepMerge(result[key], val);
        } else if (typeof val === 'object') {
          result[key] = deepMerge({}, val);
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    var utils = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      deepMerge: deepMerge,
      extend: extend,
      trim: trim
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    var buildFullPath = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password || '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        // Listen for ready state
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }

          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        };

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          var cookies$1 = cookies;

          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies$1.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config.responseType !== 'json') {
              throw e;
            }
          }
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (requestData === undefined) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    var defaults = {
      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) { /* Ignore */ }
        }
        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
      var defaultToConfig2Keys = [
        'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
        'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath'
      ];

      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        }
      });

      utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
        if (utils.isObject(config2[prop])) {
          config[prop] = utils.deepMerge(config1[prop], config2[prop]);
        } else if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (utils.isObject(config1[prop])) {
          config[prop] = utils.deepMerge(config1[prop]);
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys);

      var otherKeys = Object
        .keys(config2)
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });

      utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      return config;
    };

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config);

      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }

      // Hook up interceptors middleware
      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);

      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios_1;

    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios.Cancel = Cancel_1;
    axios.CancelToken = CancelToken_1;
    axios.isCancel = isCancel;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;

    var axios_1 = axios;

    // Allow use of default import syntax in TypeScript
    var _default = axios;
    axios_1.default = _default;

    var axios$1 = axios_1;

    function create() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = (Math.random() * 16) | 0,
          v = c == "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      });
    }

    let _token;
    const token = createTokenStore();

    const apiProtocol = "http";
    const apiPort = 8999;
    const apiDomain = "localhost";

    const socketProtocol = "ws";
    const socketPort = 8999;
    const socketDomain = apiDomain;


    function createTokenStore() {
    	_token = localStorage.getItem("user");

    	if (_token) {
    		_token = JSON.parse(_token);
    	}

    	const { subscribe, set } = writable(_token);

    	function signIn(user) {
    		if (user) {
    			user.roles = user.roles.split(",");
    			localStorage.setItem("user", JSON.stringify(user));
    			_token = user;
    			set(_token);
    		}
    		else {
    			signOut();
    		}
    	}

    	function signOut() {
    		localStorage.removeItem("user");
    		_token = undefined;
    		set(_token);
    	}

    	function isAuthenticated() {
    		if (_token) {
    			const expirationDate = new Date(_token.expiration);
    			if (new Date() > expirationDate) {
    				signOut();
    				return false;
    			}
    			return true;
    		}
    		return false;
    	}

    	function hasRoles(roles) {
    		if (_token) {
    			if (roles) {
    				return _token.roles.indexOf(roles) > -1;
    			}
    			return true;
    		}
    		return false;
    	}

    	return {
    		subscribe,
    		signIn,
    		signOut,
    		isAuthenticated,
    		hasRoles
    	};
    }

    function getApiUrl(endpoint) {
    	return `${apiProtocol}://${apiDomain}:${apiPort}/api/${endpoint}`;
    }

    function getSocketUrl(endpoint = "socket") {
    	return `${socketProtocol}://${socketDomain}:${socketPort}/${endpoint}`;
    }

    function createSocket() {
    	const socket = new WebSocket(getSocketUrl());

    	socket.guid = create();
    	socket.autoClose = true;

    	socket.onopen = function (event) {
    		//console.log("[socket:open] Connection established", event);
    		socket.send(JSON.stringify({ type: "handshake", value: socket.guid }));
    	};

    	socket.onclose = function (event) {
    		if (event.wasClean) ; else {
    			// e.g. server process killed or network down
    			// event.code is usually 1006 in this case
    			console.warn("[socket:close] Connection died", event);
    		}
    	};

    	socket.onerror = function (error) {
    		console.warn("[socket:error]", error);
    	};

    	return socket;
    }

    function createStore() {
    	return writable({});
    }

    function get(endpoint, config = null) {
    	config = getConfig(config);
    	return axios$1.get(endpoint, config);
    }

    axios$1.interceptors.response.use(function (response) {
    	return response;
    }, function (error) {
    	error.response.Message = error.response.statusText;
    	return Promise.resolve({
    		data: [{
    			error: error.response
    		}]
    	});
    });

    function post(endpoint, data, config = null) {
    	config = getConfig(config);
    	return axios$1.post(endpoint, data, config);
    }

    function getConfig(config) {
    	if (!config) {
    		config = {};
    	}

    	const socket = config.socket || createSocket();
    	const headers = {
    		"socket-guid": socket.guid
    	};

    	if (_token) {
    		headers.Authorization = `Bearer ${_token.token}`;
    	}

    	config = {
    		socket,
    		headers,
    		...config
    	};

    	const onMessage = config.socket.onmessage;
    	const onTransformResponse = config.transformResponse;

    	config.socket.onmessage = function (event) {
    		let preventDefault = false;

    		if (onMessage) {
    			preventDefault = onMessage(event);
    		}

    		if (preventDefault !== true) {
    			const json = JSON.parse(event.data);
    			pushResult(config, json);
    		}
    	};

    	config.transformResponse = axios$1.defaults.transformResponse.concat((json) => {
    		if (config.socket.autoClose) {
    			config.socket.close();
    		}
    		let preventDefault = false;

    		if (onTransformResponse) {
    			preventDefault = onTransformResponse(json);
    		}

    		if (preventDefault !== true) {
    			for (let i in json) {
    				pushResult(config, json[i]);
    			}
    		}
    		return json;
    	});

    	return config;
    }

    function pushResult(config, json) {
    	if (config.store && json.id) {
    		config.store.update(s => {
    			s[json.id] = json;
    			return s;
    		});
    	}
    }

    var api = {
    	createSocket,
    	createStore,
    	get,
    	getApiUrl,
    	post,
    	token
    };

    function list() {
    	return [
    		{
    			id: "list",
    			run: "Seed.List",
    			args: []
    		}
    	];
    }

    function seed(files) {
    	const formData = new FormData();

    	for (let i = 0; i < files.length; i++) {
    		formData.append("args[]", files[i]);
    	}
    	formData.append("id", "seed");
    	formData.append("run", "Seed.Seed");

    	return formData;
    }

    var seedApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        list: list,
        seed: seed
    });

    function sortDate(rows, dir, key) {
    	return [...rows].sort((a, b) =>
    		dir === "asc" ? a[key] - b[key] : b[key] - a[key]
    	);
    }

    function sortNumber(rows, dir, key) {
    	return [...rows].sort((a, b) =>
    		dir === "asc" ? a[key] - b[key] : b[key] - a[key]
    	);
    }

    function sortString(rows, dir, key) {
    	return [...rows].sort((a, b) =>
    		dir === "asc"
    			? ("" + a[key]).localeCompare(b[key])
    			: ("" + b[key]).localeCompare(a[key])
    	);
    }

    /* src\pages\admin\index.svelte generated by Svelte v3.22.3 */
    const file$6 = "src\\pages\\admin\\index.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	return child_ctx;
    }

    // (106:0) {#if files.length > 0}
    function create_if_block_1$3(ctx) {
    	let div;
    	let h3;
    	let t1;
    	let each_value_1 = /*files*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			h3.textContent = "Files";
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h3, "class", "font-semibold text-xl");
    			add_location(h3, file$6, 107, 4, 2883);
    			add_location(div, file$6, 106, 2, 2872);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*files*/ 1) {
    				each_value_1 = /*files*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(106:0) {#if files.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (109:4) {#each files as file}
    function create_each_block_1$1(ctx) {
    	let p;
    	let span;
    	let t0_value = /*file*/ ctx[21].name + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			add_location(span, file$6, 110, 8, 2975);
    			add_location(p, file$6, 109, 6, 2962);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, span);
    			append_dev(span, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*files*/ 1 && t0_value !== (t0_value = /*file*/ ctx[21].name + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(109:4) {#each files as file}",
    		ctx
    	});

    	return block;
    }

    // (117:0) {#if uploading}
    function create_if_block$5(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t0;
    	let span;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			span = element("span");
    			t1 = text(/*percent*/ ctx[1]);
    			t2 = text("%");
    			attr_dev(div0, "class", "bg-blue-400 py-3 h-full");
    			set_style(div0, "width", /*percent*/ ctx[1] + "%");
    			add_location(div0, file$6, 119, 6, 3151);
    			attr_dev(span, "class", "absolute w-full text-center text-white top-0");
    			add_location(span, file$6, 120, 6, 3224);
    			attr_dev(div1, "class", "shadow w-full bg-gray-300 mt-2 relative");
    			add_location(div1, file$6, 118, 4, 3090);
    			attr_dev(div2, "class", "w-full");
    			add_location(div2, file$6, 117, 2, 3064);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div1, t0);
    			append_dev(div1, span);
    			append_dev(span, t1);
    			append_dev(span, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*percent*/ 2) {
    				set_style(div0, "width", /*percent*/ ctx[1] + "%");
    			}

    			if (dirty & /*percent*/ 2) set_data_dev(t1, /*percent*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(117:0) {#if uploading}",
    		ctx
    	});

    	return block;
    }

    // (129:2) <thead slot="head">
    function create_head_slot(ctx) {
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let t1;
    	let th1;
    	let t2;
    	let t3;
    	let th2;
    	let t4;
    	let current;
    	const sort0 = new Sort({ props: { key: "id" }, $$inline: true });
    	sort0.$on("sort", /*onSortNumber*/ ctx[11]);

    	const sort1 = new Sort({
    			props: { key: "arquivo" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortString*/ ctx[13]);

    	const sort2 = new Sort({
    			props: { key: "dataCriacao" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortDate*/ ctx[12]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text("Id\r\n        ");
    			create_component(sort0.$$.fragment);
    			t1 = space();
    			th1 = element("th");
    			t2 = text("Arquivo\r\n        ");
    			create_component(sort1.$$.fragment);
    			t3 = space();
    			th2 = element("th");
    			t4 = text("Data de criação\r\n        ");
    			create_component(sort2.$$.fragment);
    			add_location(th0, file$6, 130, 6, 3451);
    			add_location(th1, file$6, 134, 6, 3538);
    			add_location(th2, file$6, 138, 6, 3635);
    			add_location(tr, file$6, 129, 4, 3439);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$6, 128, 2, 3414);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			mount_component(sort0, th0, null);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			mount_component(sort1, th1, null);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			mount_component(sort2, th2, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot.name,
    		type: "slot",
    		source: "(129:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (147:6) <Row {index}>
    function create_default_slot_1(ctx) {
    	let td0;
    	let t0_value = /*row*/ ctx[18].id + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*row*/ ctx[18].arquivo + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*dateFormatter*/ ctx[6].format(/*row*/ ctx[18].dataCriacao) + "";
    	let t4;
    	let t5;

    	const block = {
    		c: function create() {
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(td0, "data-label", "Id");
    			attr_dev(td0, "class", "font-bold");
    			add_location(td0, file$6, 147, 8, 3838);
    			attr_dev(td1, "label", "Arquivo");
    			add_location(td1, file$6, 148, 8, 3899);
    			attr_dev(td2, "label", "Data de criação");
    			add_location(td2, file$6, 149, 8, 3947);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td0, anchor);
    			append_dev(td0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, td1, anchor);
    			append_dev(td1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, td2, anchor);
    			append_dev(td2, t4);
    			insert_dev(target, t5, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2*/ 131072 && t0_value !== (t0_value = /*row*/ ctx[18].id + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*rows2*/ 131072 && t2_value !== (t2_value = /*row*/ ctx[18].arquivo + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*rows2*/ 131072 && t4_value !== (t4_value = /*dateFormatter*/ ctx[6].format(/*row*/ ctx[18].dataCriacao) + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(td1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(td2);
    			if (detaching) detach_dev(t5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(147:6) <Row {index}>",
    		ctx
    	});

    	return block;
    }

    // (146:4) {#each rows2 as row, index (row)}
    function create_each_block$2(key_1, ctx) {
    	let first;
    	let current;

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[20],
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};
    			if (dirty & /*rows2*/ 131072) row_changes.index = /*index*/ ctx[20];

    			if (dirty & /*$$scope, rows2*/ 16908288) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(146:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (128:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$1(ctx) {
    	let t;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*rows2*/ ctx[17];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[18];
    	validate_each_keys(ctx, each_value, get_each_context$2, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$2(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			t = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(tbody, file$6, 144, 2, 3761);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, dateFormatter*/ 131136) {
    				const each_value = /*rows2*/ ctx[17];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(128:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div1;
    	let input;
    	let t0;
    	let div0;
    	let h4;
    	let t1;
    	let br;
    	let t2;
    	let t3;
    	let p;
    	let t5;
    	let button;
    	let svg;
    	let path0;
    	let path1;
    	let t6;
    	let span;
    	let t8;
    	let t9;
    	let t10;
    	let current;
    	let dispose;
    	let if_block0 = /*files*/ ctx[0].length > 0 && create_if_block_1$3(ctx);
    	let if_block1 = /*uploading*/ ctx[2] && create_if_block$5(ctx);

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[3],
    				page: /*page*/ ctx[7],
    				pageSize: /*pageSize*/ ctx[8],
    				rows: /*rows*/ ctx[4],
    				$$slots: {
    					default: [
    						create_default_slot$1,
    						({ rows: rows2 }) => ({ 17: rows2 }),
    						({ rows: rows2 }) => rows2 ? 131072 : 0
    					],
    					head: [
    						create_head_slot,
    						({ rows: rows2 }) => ({ 17: rows2 }),
    						({ rows: rows2 }) => rows2 ? 131072 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			input = element("input");
    			t0 = space();
    			div0 = element("div");
    			h4 = element("h4");
    			t1 = text("Arraste seus arquivos aqui\r\n      ");
    			br = element("br");
    			t2 = text("\r\n      ou");
    			t3 = space();
    			p = element("p");
    			p.textContent = "Clique aqui para selecionar os arquivos";
    			t5 = space();
    			button = element("button");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t6 = space();
    			span = element("span");
    			span.textContent = "Enviar";
    			t8 = space();
    			if (if_block0) if_block0.c();
    			t9 = space();
    			if (if_block1) if_block1.c();
    			t10 = space();
    			create_component(table.$$.fragment);
    			attr_dev(input, "type", "file");
    			input.multiple = true;
    			attr_dev(input, "class", "cursor-pointer relative block opacity-0 w-full h-full p-20 z-50");
    			add_location(input, file$6, 71, 2, 1933);
    			add_location(br, file$6, 79, 6, 2199);
    			add_location(h4, file$6, 77, 4, 2153);
    			attr_dev(p, "class", "");
    			add_location(p, file$6, 82, 4, 2232);
    			attr_dev(div0, "class", "text-center p-10 absolute top-0 right-0 left-0 m-auto");
    			add_location(div0, file$6, 76, 2, 2080);
    			attr_dev(div1, "class", "border border-dashed border-gray-500 relative");
    			add_location(div1, file$6, 70, 0, 1870);
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			attr_dev(path0, "fill", "none");
    			add_location(path0, file$6, 99, 4, 2704);
    			attr_dev(path1, "d", "M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z");
    			add_location(path1, file$6, 100, 4, 2748);
    			attr_dev(svg, "fill", "#FFF");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$6, 93, 2, 2578);
    			add_location(span, file$6, 102, 2, 2812);
    			button.disabled = /*uploadDisabled*/ ctx[5];
    			attr_dev(button, "class", "bg-green-400 hover:bg-blue-light text-white font-bold py-2 px-4 w-full\r\n  flex items-center justify-center mt-2");
    			toggle_class(button, "opacity-50", /*uploadDisabled*/ ctx[5]);
    			toggle_class(button, "cursor-not-allowed", /*uploadDisabled*/ ctx[5]);
    			add_location(button, file$6, 86, 0, 2309);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, input);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, h4);
    			append_dev(h4, t1);
    			append_dev(h4, br);
    			append_dev(h4, t2);
    			append_dev(div0, t3);
    			append_dev(div0, p);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(button, t6);
    			append_dev(button, span);
    			insert_dev(target, t8, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t9, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(input, "change", /*onChange*/ ctx[9], false, false, false),
    				listen_dev(button, "click", /*onSubmit*/ ctx[10], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*uploadDisabled*/ 32) {
    				prop_dev(button, "disabled", /*uploadDisabled*/ ctx[5]);
    			}

    			if (dirty & /*uploadDisabled*/ 32) {
    				toggle_class(button, "opacity-50", /*uploadDisabled*/ ctx[5]);
    			}

    			if (dirty & /*uploadDisabled*/ 32) {
    				toggle_class(button, "cursor-not-allowed", /*uploadDisabled*/ ctx[5]);
    			}

    			if (/*files*/ ctx[0].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					if_block0.m(t9.parentNode, t9);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*uploading*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					if_block1.m(t10.parentNode, t10);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const table_changes = {};
    			if (dirty & /*loading*/ 8) table_changes.loading = /*loading*/ ctx[3];
    			if (dirty & /*rows*/ 16) table_changes.rows = /*rows*/ ctx[4];

    			if (dirty & /*$$scope, rows2*/ 16908288) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t8);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t9);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(table, detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $route;
    	validate_store(route, "route");
    	component_subscribe($$self, route, $$value => $$invalidate(14, $route = $$value));

    	const dateFormatter = new Intl.DateTimeFormat("pt-BR",
    	{
    			year: "numeric",
    			month: "2-digit",
    			day: "2-digit",
    			hour: "2-digit",
    			minute: "2-digit",
    			second: "2-digit"
    		});

    	const store = api.createStore();
    	let files = [];
    	let percent = 0;
    	let uploading = false;
    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 20;

    	async function refresh({ params }) {
    		$$invalidate(4, rows = await api.post(api.getApiUrl("DWControleSocial"), list()));

    		$$invalidate(4, rows = rows.data[0].value.map(r => {
    			r.dataCriacao = new Date(r.dataCriacao);
    			return r;
    		}));

    		$$invalidate(3, loading = false);
    	}

    	async function onChange(event) {
    		$$invalidate(0, files = event.target.files);
    		$$invalidate(2, uploading = false);
    	}

    	async function onSubmit() {
    		$$invalidate(2, uploading = true);
    		$$invalidate(1, percent = 0);
    		const formData = seed(files);

    		await api.post(api.getApiUrl("DWControleSocial/Upload"), formData, {
    			store,
    			onUploadProgress(progressEvent) {
    				$$invalidate(1, percent = Math.round(progressEvent.loaded * 100 / progressEvent.total));
    			}
    		});
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(4, rows = sortNumber(rows, dir, key));
    	}

    	function onSortDate({ detail: { dir, key } }) {
    		$$invalidate(4, rows = sortDate(rows, dir, key));
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(4, rows = sortString(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Admin> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Admin", $$slots, []);

    	$$self.$capture_state = () => ({
    		route,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		seedApi,
    		sortDate,
    		sortNumber,
    		sortString,
    		dateFormatter,
    		store,
    		files,
    		percent,
    		uploading,
    		loading,
    		rows,
    		page,
    		pageSize,
    		refresh,
    		onChange,
    		onSubmit,
    		onSortNumber,
    		onSortDate,
    		onSortString,
    		$route,
    		uploadDisabled
    	});

    	$$self.$inject_state = $$props => {
    		if ("files" in $$props) $$invalidate(0, files = $$props.files);
    		if ("percent" in $$props) $$invalidate(1, percent = $$props.percent);
    		if ("uploading" in $$props) $$invalidate(2, uploading = $$props.uploading);
    		if ("loading" in $$props) $$invalidate(3, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(4, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(7, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(8, pageSize = $$props.pageSize);
    		if ("uploadDisabled" in $$props) $$invalidate(5, uploadDisabled = $$props.uploadDisabled);
    	};

    	let uploadDisabled;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$route*/ 16384) {
    			 refresh($route);
    		}

    		if ($$self.$$.dirty & /*uploading*/ 4) {
    			 $$invalidate(5, uploadDisabled = uploading);
    		}
    	};

    	return [
    		files,
    		percent,
    		uploading,
    		loading,
    		rows,
    		uploadDisabled,
    		dateFormatter,
    		page,
    		pageSize,
    		onChange,
    		onSubmit,
    		onSortNumber,
    		onSortDate,
    		onSortString
    	];
    }

    class Admin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Admin",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    function signIn(email, senha) {
    	return {
    		id: "signIn",
    		run: "Autenticacao.SignIn",
    		args: [email, senha]
    	};
    }

    function signOut() {
    	return {
    		id: "signOut",
    		run: "Autenticacao.SignOut",
    		args: []
    	};
    }

    var autenticacaoApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        signIn: signIn,
        signOut: signOut
    });

    /* src\pages\admin\_components\Login.svelte generated by Svelte v3.22.3 */
    const file$7 = "src\\pages\\admin\\_components\\Login.svelte";

    // (55:0) {#if !isAuthenticated}
    function create_if_block$6(ctx) {
    	let div4;
    	let div3;
    	let div0;
    	let label0;
    	let t1;
    	let input0;
    	let t2;
    	let div1;
    	let label1;
    	let t4;
    	let input1;
    	let t5;
    	let t6;
    	let div2;
    	let button;
    	let dispose;
    	let if_block = /*error*/ ctx[3] && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Email";
    			t1 = space();
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			label1 = element("label");
    			label1.textContent = "Senha";
    			t4 = space();
    			input1 = element("input");
    			t5 = space();
    			if (if_block) if_block.c();
    			t6 = space();
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "Autenticar";
    			attr_dev(label0, "class", "block text-md font-light mb-2");
    			add_location(label0, file$7, 58, 8, 1432);
    			attr_dev(input0, "class", "w-full border-gray-500 appearance-none border p-4 font-light\r\n          leading-tight focus:outline-none focus:shadow-outline");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Email");
    			add_location(input0, file$7, 59, 8, 1500);
    			attr_dev(div0, "class", "mb-4");
    			add_location(div0, file$7, 57, 6, 1404);
    			attr_dev(label1, "class", "block text-md font-light mb-2");
    			add_location(label1, file$7, 67, 8, 1787);
    			attr_dev(input1, "class", "w-full border-gray-500 appearance-none border p-4 font-light\r\n          leading-tight focus:outline-none focus:shadow-outline");
    			attr_dev(input1, "type", "password");
    			attr_dev(input1, "placeholder", "Senha");
    			add_location(input1, file$7, 68, 8, 1855);
    			attr_dev(div1, "class", "mb-4");
    			add_location(div1, file$7, 66, 6, 1759);
    			attr_dev(button, "class", "bg-indigo-600 hover:bg-blue-700 text-white font-light py-2 px-6\r\n          rounded focus:outline-none focus:shadow-outline");
    			attr_dev(button, "type", "button");
    			add_location(button, file$7, 79, 8, 2270);
    			attr_dev(div2, "class", "flex items-center justify-between mb-5");
    			add_location(div2, file$7, 78, 6, 2208);
    			attr_dev(div3, "class", "w-full");
    			add_location(div3, file$7, 56, 4, 1376);
    			attr_dev(div4, "class", "container mx-auto");
    			add_location(div4, file$7, 55, 2, 1339);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, label0);
    			append_dev(div0, t1);
    			append_dev(div0, input0);
    			/*input0_binding*/ ctx[9](input0);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			append_dev(div1, label1);
    			append_dev(div1, t4);
    			append_dev(div1, input1);
    			/*input1_binding*/ ctx[10](input1);
    			append_dev(div3, t5);
    			if (if_block) if_block.m(div3, null);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			if (remount) dispose();
    			dispose = listen_dev(button, "click", /*onSignIn*/ ctx[4], false, false, false);
    		},
    		p: function update(ctx, dirty) {
    			if (/*error*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$4(ctx);
    					if_block.c();
    					if_block.m(div3, t6);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			/*input0_binding*/ ctx[9](null);
    			/*input1_binding*/ ctx[10](null);
    			if (if_block) if_block.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(55:0) {#if !isAuthenticated}",
    		ctx
    	});

    	return block;
    }

    // (76:6) {#if error}
    function create_if_block_1$4(ctx) {
    	let p;
    	let t_value = /*error*/ ctx[3].Message + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "text-red-600 mb-2");
    			add_location(p, file$7, 76, 8, 2139);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*error*/ 8 && t_value !== (t_value = /*error*/ ctx[3].Message + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(76:6) {#if error}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let if_block_anchor;
    	let if_block = !/*isAuthenticated*/ ctx[0] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*isAuthenticated*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $token;
    	validate_store(token, "token");
    	component_subscribe($$self, token, $$value => $$invalidate(5, $token = $$value));
    	const dispatch = createEventDispatcher();
    	let isAuthenticated;
    	let email;
    	let senha;
    	let error;

    	function refreshUser(_token) {
    		$$invalidate(0, isAuthenticated = token.isAuthenticated());
    	}

    	async function onSignIn() {
    		$$invalidate(3, error = undefined);
    		const res = await api.post(api.getApiUrl("DWControleSocial/Authenticate"), signIn(email.value, senha.value));
    		const data = res.data[0];

    		if (data.error) {
    			$$invalidate(3, error = data.error);
    			dispatch("error", data.error);
    		} else {
    			token.signIn(res.data[0].value);
    			dispatch("login", res.data[0].value);
    		}
    	}

    	async function onSignOut() {
    		$$invalidate(3, error = undefined);
    		token.signOut();
    		const res = await api.post(api.getApiUrl("DWControleSocial/Authenticate"), signOut());
    		const data = res.data[0];

    		if (data.error) {
    			$$invalidate(3, error = data.error);
    			dispatch("error", data.error);
    		} else {
    			token.signOut();
    			dispatch("logout", res.data[0].value);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Login", $$slots, []);

    	function input0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(1, email = $$value);
    		});
    	}

    	function input1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(2, senha = $$value);
    		});
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		api,
    		token,
    		autenticacaoApi,
    		dispatch,
    		isAuthenticated,
    		email,
    		senha,
    		error,
    		refreshUser,
    		onSignIn,
    		onSignOut,
    		$token
    	});

    	$$self.$inject_state = $$props => {
    		if ("isAuthenticated" in $$props) $$invalidate(0, isAuthenticated = $$props.isAuthenticated);
    		if ("email" in $$props) $$invalidate(1, email = $$props.email);
    		if ("senha" in $$props) $$invalidate(2, senha = $$props.senha);
    		if ("error" in $$props) $$invalidate(3, error = $$props.error);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$token*/ 32) {
    			 refreshUser();
    		}
    	};

    	return [
    		isAuthenticated,
    		email,
    		senha,
    		error,
    		onSignIn,
    		$token,
    		dispatch,
    		refreshUser,
    		onSignOut,
    		input0_binding,
    		input1_binding
    	];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src\pages\admin\_layout.svelte generated by Svelte v3.22.3 */
    const file$8 = "src\\pages\\admin\\_layout.svelte";

    // (25:2) {:else}
    function create_else_block_1(ctx) {
    	let current;
    	const login = new Login({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(login.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(login, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(login.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(login.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(login, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(25:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:2) {#if isAuthenticated}
    function create_if_block$7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$5, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*hasRoles*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(21:2) {#if isAuthenticated}",
    		ctx
    	});

    	return block;
    }

    // (24:4) {:else}
    function create_else_block$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("teste");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(24:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (22:4) {#if hasRoles}
    function create_if_block_1$5(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[5], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(22:4) {#if hasRoles}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let t;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$7, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isAuthenticated*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t = space();
    			div = element("div");
    			if_block.c();
    			document.title = "CIDADES - PLATAFORMA PARA TRANSPARÊNCIA PÚBLICA";
    			attr_dev(div, "class", "p-4");
    			add_location(div, file$8, 19, 0, 476);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $token;
    	let $route;
    	validate_store(token, "token");
    	component_subscribe($$self, token, $$value => $$invalidate(2, $token = $$value));
    	validate_store(route, "route");
    	component_subscribe($$self, route, $$value => $$invalidate(3, $route = $$value));
    	let isAuthenticated;
    	let hasRoles;

    	function refreshUser(_token) {
    		$$invalidate(0, isAuthenticated = token.isAuthenticated());
    		$$invalidate(1, hasRoles = token.hasRoles($route.meta.roles));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layout> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Layout", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		route,
    		Login,
    		token,
    		isAuthenticated,
    		hasRoles,
    		refreshUser,
    		$token,
    		$route
    	});

    	$$self.$inject_state = $$props => {
    		if ("isAuthenticated" in $$props) $$invalidate(0, isAuthenticated = $$props.isAuthenticated);
    		if ("hasRoles" in $$props) $$invalidate(1, hasRoles = $$props.hasRoles);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$token*/ 4) {
    			 refreshUser();
    		}
    	};

    	return [isAuthenticated, hasRoles, $token, $route, refreshUser, $$scope, $$slots];
    }

    class Layout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Layout",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src\components\Navigation\Link.svelte generated by Svelte v3.22.3 */
    const file$9 = "src\\components\\Navigation\\Link.svelte";

    function create_fragment$a(ctx) {
    	let a;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

    	let a_levels = [
    		{ href: /*$url*/ ctx[6](/*href*/ ctx[1]) },
    		{ title: /*title*/ ctx[2] },
    		{ rel: /*rel*/ ctx[5] },
    		{ target: /*target*/ ctx[3] },
    		{ class: /*$$props*/ ctx[7].class },
    		/*props*/ ctx[4]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			toggle_class(a, "selected", /*selected*/ ctx[0]);
    			toggle_class(a, "svelte-1cthq4r", true);
    			add_location(a, file$9, 23, 0, 511);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1024) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[10], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null));
    				}
    			}

    			set_attributes(a, get_spread_update(a_levels, [
    				dirty & /*$url, href*/ 66 && { href: /*$url*/ ctx[6](/*href*/ ctx[1]) },
    				dirty & /*title*/ 4 && { title: /*title*/ ctx[2] },
    				dirty & /*rel*/ 32 && { rel: /*rel*/ ctx[5] },
    				dirty & /*target*/ 8 && { target: /*target*/ ctx[3] },
    				dirty & /*$$props*/ 128 && { class: /*$$props*/ ctx[7].class },
    				dirty & /*props*/ 16 && /*props*/ ctx[4]
    			]));

    			toggle_class(a, "selected", /*selected*/ ctx[0]);
    			toggle_class(a, "svelte-1cthq4r", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $url;
    	validate_store(url, "url");
    	component_subscribe($$self, url, $$value => $$invalidate(6, $url = $$value));
    	let { segment = undefined } = $$props;
    	let { href = "." } = $$props;
    	let { exact = true } = $$props;
    	let { title = "" } = $$props;
    	let { target = undefined } = $$props;
    	let { props = undefined } = $$props;
    	let { selected = false } = $$props;
    	let { rel = undefined } = $$props;
    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Link", $$slots, ['default']);

    	$$self.$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("segment" in $$new_props) $$invalidate(8, segment = $$new_props.segment);
    		if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
    		if ("exact" in $$new_props) $$invalidate(9, exact = $$new_props.exact);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("target" in $$new_props) $$invalidate(3, target = $$new_props.target);
    		if ("props" in $$new_props) $$invalidate(4, props = $$new_props.props);
    		if ("selected" in $$new_props) $$invalidate(0, selected = $$new_props.selected);
    		if ("rel" in $$new_props) $$invalidate(5, rel = $$new_props.rel);
    		if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		url,
    		segment,
    		href,
    		exact,
    		title,
    		target,
    		props,
    		selected,
    		rel,
    		$url
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ("segment" in $$props) $$invalidate(8, segment = $$new_props.segment);
    		if ("href" in $$props) $$invalidate(1, href = $$new_props.href);
    		if ("exact" in $$props) $$invalidate(9, exact = $$new_props.exact);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("target" in $$props) $$invalidate(3, target = $$new_props.target);
    		if ("props" in $$props) $$invalidate(4, props = $$new_props.props);
    		if ("selected" in $$props) $$invalidate(0, selected = $$new_props.selected);
    		if ("rel" in $$props) $$invalidate(5, rel = $$new_props.rel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*exact, segment, href*/ 770) {
    			 $$invalidate(0, selected = exact ? segment === href : href.indexOf(segment));
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		selected,
    		href,
    		title,
    		target,
    		props,
    		rel,
    		$url,
    		$$props,
    		segment,
    		exact,
    		$$scope,
    		$$slots
    	];
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			segment: 8,
    			href: 1,
    			exact: 9,
    			title: 2,
    			target: 3,
    			props: 4,
    			selected: 0,
    			rel: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get segment() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set segment(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get exact() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set exact(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get props() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set props(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rel() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rel(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\index.svelte generated by Svelte v3.22.3 */
    const file$a = "src\\pages\\index.svelte";

    // (17:8) <Link href="/municipio/2020/001/consolidado/despesas" title="Despesas">
    function create_default_slot_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Clique aqui para visualizar as Despesas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(17:8) <Link href=\\\"/municipio/2020/001/consolidado/despesas\\\" title=\\\"Despesas\\\">",
    		ctx
    	});

    	return block;
    }

    // (22:8) <Link href="/municipio/2020/001/consolidado/receitas" title="Receitas">
    function create_default_slot$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Clique aqui para visualizar as Receitas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(22:8) <Link href=\\\"/municipio/2020/001/consolidado/receitas\\\" title=\\\"Receitas\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let t0;
    	let div2;
    	let div1;
    	let p0;
    	let t2;
    	let div0;
    	let p1;
    	let t4;
    	let p2;
    	let t5;
    	let p3;
    	let current;

    	const link0 = new Link({
    			props: {
    				href: "/municipio/2020/001/consolidado/despesas",
    				title: "Despesas",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const link1 = new Link({
    			props: {
    				href: "/municipio/2020/001/consolidado/receitas",
    				title: "Receitas",
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			p0 = element("p");
    			p0.textContent = "Painel de Controle Social";
    			t2 = space();
    			div0 = element("div");
    			p1 = element("p");
    			p1.textContent = "Aqui você acompanha a aplicação do dinheiro público ES.";
    			t4 = space();
    			p2 = element("p");
    			create_component(link0.$$.fragment);
    			t5 = space();
    			p3 = element("p");
    			create_component(link1.$$.fragment);
    			document.title = "CIDADES - PLATAFORMA PARA TRANSPARÊNCIA PÚBLICA";
    			attr_dev(p0, "class", "text-3xl");
    			add_location(p0, file$a, 10, 4, 295);
    			attr_dev(p1, "class", "text-lg");
    			add_location(p1, file$a, 12, 6, 363);
    			attr_dev(p2, "class", "mt-4 text-blue-700");
    			add_location(p2, file$a, 15, 6, 467);
    			attr_dev(p3, "class", "mt-2 text-blue-700");
    			add_location(p3, file$a, 20, 6, 666);
    			add_location(div0, file$a, 11, 4, 350);
    			attr_dev(div1, "class", "m-auto w-full lg:w-1/2 p-8 rounded bg-white");
    			add_location(div1, file$a, 9, 2, 232);
    			attr_dev(div2, "class", "bg-gray-200 w-full h-screen flex");
    			add_location(div2, file$a, 8, 0, 182);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, p0);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			append_dev(div0, p1);
    			append_dev(div0, t4);
    			append_dev(div0, p2);
    			mount_component(link0, p2, null);
    			append_dev(div0, t5);
    			append_dev(div0, p3);
    			mount_component(link1, p3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			destroy_component(link0);
    			destroy_component(link1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Pages> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Pages", $$slots, []);
    	$$self.$capture_state = () => ({ Link });
    	return [];
    }

    class Pages extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pages",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    function format2Decimals(value) {
    	if (!value) {
    		return (0.0).toFixed(2);
    	}
    	return value.toFixed(2);
    }

    function format(value) {
    	if (value) {
    		return value.toLocaleString('pt-br', { minimumFractionDigits: 2 });
    	}
    	return "";
    }

    /* src\pages\municipio\[ano]\indicadores\_components\Barra.svelte generated by Svelte v3.22.3 */
    const file$b = "src\\pages\\municipio\\[ano]\\indicadores\\_components\\Barra.svelte";

    function create_fragment$c(ctx) {
    	let div1;
    	let div0;
    	let div0_style_value;
    	let div1_style_value;
    	let div1_title_value;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "h-full svelte-1rcaoam");
    			attr_dev(div0, "style", div0_style_value = `width:${/*absoluteValue*/ ctx[3]}%;max-width:100%;min-width:1px;${/*marginLeft*/ ctx[5]}`);
    			toggle_class(div0, "positive", /*isPositivo*/ ctx[2](/*value*/ ctx[1]));
    			toggle_class(div0, "negative", !/*isPositivo*/ ctx[2](/*value*/ ctx[1]));
    			add_location(div0, file$b, 28, 2, 584);
    			attr_dev(div1, "class", "w-full text-right");
    			attr_dev(div1, "style", div1_style_value = `height:${/*height*/ ctx[0]}`);
    			attr_dev(div1, "title", div1_title_value = /*formatted*/ ctx[4] + "%");
    			add_location(div1, file$b, 24, 0, 489);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*absoluteValue, marginLeft*/ 40 && div0_style_value !== (div0_style_value = `width:${/*absoluteValue*/ ctx[3]}%;max-width:100%;min-width:1px;${/*marginLeft*/ ctx[5]}`)) {
    				attr_dev(div0, "style", div0_style_value);
    			}

    			if (dirty & /*isPositivo, value*/ 6) {
    				toggle_class(div0, "positive", /*isPositivo*/ ctx[2](/*value*/ ctx[1]));
    			}

    			if (dirty & /*isPositivo, value*/ 6) {
    				toggle_class(div0, "negative", !/*isPositivo*/ ctx[2](/*value*/ ctx[1]));
    			}

    			if (dirty & /*height*/ 1 && div1_style_value !== (div1_style_value = `height:${/*height*/ ctx[0]}`)) {
    				attr_dev(div1, "style", div1_style_value);
    			}

    			if (dirty & /*formatted*/ 16 && div1_title_value !== (div1_title_value = /*formatted*/ ctx[4] + "%")) {
    				attr_dev(div1, "title", div1_title_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { height = "10px" } = $$props;
    	let { value } = $$props;
    	let { isPositivo = v => v >= 0 } = $$props;
    	const writable_props = ["height", "value", "isPositivo"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Barra> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Barra", $$slots, []);

    	$$self.$set = $$props => {
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("isPositivo" in $$props) $$invalidate(2, isPositivo = $$props.isPositivo);
    	};

    	$$self.$capture_state = () => ({
    		format2Decimals,
    		height,
    		value,
    		isPositivo,
    		absoluteValue,
    		formatted,
    		marginLeft
    	});

    	$$self.$inject_state = $$props => {
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("isPositivo" in $$props) $$invalidate(2, isPositivo = $$props.isPositivo);
    		if ("absoluteValue" in $$props) $$invalidate(3, absoluteValue = $$props.absoluteValue);
    		if ("formatted" in $$props) $$invalidate(4, formatted = $$props.formatted);
    		if ("marginLeft" in $$props) $$invalidate(5, marginLeft = $$props.marginLeft);
    	};

    	let absoluteValue;
    	let formatted;
    	let marginLeft;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 2) {
    			 $$invalidate(3, absoluteValue = Math.abs(value));
    		}

    		if ($$self.$$.dirty & /*value*/ 2) {
    			 $$invalidate(4, formatted = format2Decimals(value));
    		}

    		if ($$self.$$.dirty & /*absoluteValue*/ 8) {
    			 $$invalidate(5, marginLeft = absoluteValue > 100
    			? ""
    			: `margin-left:${100 - absoluteValue}%;`);
    		}
    	};

    	return [height, value, isPositivo, absoluteValue, formatted, marginLeft];
    }

    class Barra extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { height: 0, value: 1, isPositivo: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Barra",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[1] === undefined && !("value" in props)) {
    			console.warn("<Barra> was created without expected prop 'value'");
    		}
    	}

    	get height() {
    		throw new Error("<Barra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Barra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Barra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Barra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isPositivo() {
    		throw new Error("<Barra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isPositivo(value) {
    		throw new Error("<Barra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\_components\RealComBarra.svelte generated by Svelte v3.22.3 */
    const file$c = "src\\pages\\municipio\\[ano]\\indicadores\\_components\\RealComBarra.svelte";

    function create_fragment$d(ctx) {
    	let td;
    	let t0;
    	let t1;
    	let t2;
    	let td_title_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const barra = new Barra({
    			props: {
    				value: /*value*/ ctx[1] * 100 / /*total*/ ctx[2],
    				isPositivo: /*isPositivo*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			t1 = text(/*formatted*/ ctx[4]);
    			t2 = space();
    			create_component(barra.$$.fragment);
    			attr_dev(td, "data-label", /*label*/ ctx[0]);
    			attr_dev(td, "class", "text-right");
    			attr_dev(td, "title", td_title_value = "R$" + /*formatted*/ ctx[4]);
    			add_location(td, file$c, 12, 0, 280);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);

    			if (default_slot) {
    				default_slot.m(td, null);
    			}

    			append_dev(td, t0);
    			append_dev(td, t1);
    			append_dev(td, t2);
    			mount_component(barra, td, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[5], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null));
    				}
    			}

    			if (!current || dirty & /*formatted*/ 16) set_data_dev(t1, /*formatted*/ ctx[4]);
    			const barra_changes = {};
    			if (dirty & /*value, total*/ 6) barra_changes.value = /*value*/ ctx[1] * 100 / /*total*/ ctx[2];
    			if (dirty & /*isPositivo*/ 8) barra_changes.isPositivo = /*isPositivo*/ ctx[3];
    			barra.$set(barra_changes);

    			if (!current || dirty & /*label*/ 1) {
    				attr_dev(td, "data-label", /*label*/ ctx[0]);
    			}

    			if (!current || dirty & /*formatted*/ 16 && td_title_value !== (td_title_value = "R$" + /*formatted*/ ctx[4])) {
    				attr_dev(td, "title", td_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(barra.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(barra.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (default_slot) default_slot.d(detaching);
    			destroy_component(barra);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { value } = $$props;
    	let { total } = $$props;
    	let { isPositivo = v => v >= 0 } = $$props;
    	const writable_props = ["label", "value", "total", "isPositivo"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RealComBarra> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("RealComBarra", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("total" in $$props) $$invalidate(2, total = $$props.total);
    		if ("isPositivo" in $$props) $$invalidate(3, isPositivo = $$props.isPositivo);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Barra,
    		format2Decimals,
    		label,
    		value,
    		total,
    		isPositivo,
    		formatted
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("total" in $$props) $$invalidate(2, total = $$props.total);
    		if ("isPositivo" in $$props) $$invalidate(3, isPositivo = $$props.isPositivo);
    		if ("formatted" in $$props) $$invalidate(4, formatted = $$props.formatted);
    	};

    	let formatted;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 2) {
    			 $$invalidate(4, formatted = format2Decimals(value));
    		}
    	};

    	return [label, value, total, isPositivo, formatted, $$scope, $$slots];
    }

    class RealComBarra extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
    			label: 0,
    			value: 1,
    			total: 2,
    			isPositivo: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RealComBarra",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
    			console.warn("<RealComBarra> was created without expected prop 'label'");
    		}

    		if (/*value*/ ctx[1] === undefined && !("value" in props)) {
    			console.warn("<RealComBarra> was created without expected prop 'value'");
    		}

    		if (/*total*/ ctx[2] === undefined && !("total" in props)) {
    			console.warn("<RealComBarra> was created without expected prop 'total'");
    		}
    	}

    	get label() {
    		throw new Error("<RealComBarra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<RealComBarra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<RealComBarra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<RealComBarra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get total() {
    		throw new Error("<RealComBarra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set total(value) {
    		throw new Error("<RealComBarra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isPositivo() {
    		throw new Error("<RealComBarra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isPositivo(value) {
    		throw new Error("<RealComBarra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\_components\Total.svelte generated by Svelte v3.22.3 */
    const file$d = "src\\pages\\municipio\\[ano]\\indicadores\\_components\\Total.svelte";

    function create_fragment$e(ctx) {
    	let td;
    	let t0;
    	let t1_value = format2Decimals(/*total*/ ctx[1]) + "";
    	let t1;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			td = element("td");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			t1 = text(t1_value);
    			attr_dev(td, "data-label", /*label*/ ctx[0]);
    			attr_dev(td, "class", "text-right font-bold");
    			add_location(td, file$d, 7, 0, 136);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);

    			if (default_slot) {
    				default_slot.m(td, null);
    			}

    			append_dev(td, t0);
    			append_dev(td, t1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[2], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null));
    				}
    			}

    			if ((!current || dirty & /*total*/ 2) && t1_value !== (t1_value = format2Decimals(/*total*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*label*/ 1) {
    				attr_dev(td, "data-label", /*label*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { total } = $$props;
    	const writable_props = ["label", "total"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Total> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Total", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("total" in $$props) $$invalidate(1, total = $$props.total);
    		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ format2Decimals, label, total });

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("total" in $$props) $$invalidate(1, total = $$props.total);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [label, total, $$scope, $$slots];
    }

    class Total extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { label: 0, total: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Total",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
    			console.warn("<Total> was created without expected prop 'label'");
    		}

    		if (/*total*/ ctx[1] === undefined && !("total" in props)) {
    			console.warn("<Total> was created without expected prop 'total'");
    		}
    	}

    	get label() {
    		throw new Error("<Total>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Total>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get total() {
    		throw new Error("<Total>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set total(value) {
    		throw new Error("<Total>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\composicao-receita-arrecadada\index.svelte generated by Svelte v3.22.3 */
    const file$e = "src\\pages\\municipio\\[ano]\\indicadores\\composicao-receita-arrecadada\\index.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (72:2) <thead slot="head">
    function create_head_slot$1(ctx) {
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let t1;
    	let th1;
    	let t2;
    	let t3;
    	let th2;
    	let t4;
    	let t5;
    	let th3;
    	let t6;
    	let t7;
    	let th4;
    	let t8;
    	let t9;
    	let th5;
    	let t10;
    	let t11;
    	let th6;
    	let t12;
    	let current;

    	const sort0 = new Sort({
    			props: { key: "municipio" },
    			$$inline: true
    		});

    	sort0.$on("sort", /*onSortString*/ ctx[5]);

    	const sort1 = new Sort({
    			props: { key: "receitasDoMunicipio" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort2 = new Sort({
    			props: { key: "transferenciaDoEstado" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort3 = new Sort({
    			props: { key: "transferenciaDaUniao" },
    			$$inline: true
    		});

    	sort3.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort4 = new Sort({
    			props: { key: "operacoesDeCredito" },
    			$$inline: true
    		});

    	sort4.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort5 = new Sort({
    			props: { key: "outrasTransferencias" },
    			$$inline: true
    		});

    	sort5.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort6 = new Sort({
    			props: { key: "arrecadada" },
    			$$inline: true
    		});

    	sort6.$on("sort", /*onSortNumber*/ ctx[6]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text("Municípios\r\n        ");
    			create_component(sort0.$$.fragment);
    			t1 = space();
    			th1 = element("th");
    			t2 = text("Receitas próprias\r\n        ");
    			create_component(sort1.$$.fragment);
    			t3 = space();
    			th2 = element("th");
    			t4 = text("Estado\r\n        ");
    			create_component(sort2.$$.fragment);
    			t5 = space();
    			th3 = element("th");
    			t6 = text("União\r\n        ");
    			create_component(sort3.$$.fragment);
    			t7 = space();
    			th4 = element("th");
    			t8 = text("Operações de crédito\r\n        ");
    			create_component(sort4.$$.fragment);
    			t9 = space();
    			th5 = element("th");
    			t10 = text("Outras\r\n        ");
    			create_component(sort5.$$.fragment);
    			t11 = space();
    			th6 = element("th");
    			t12 = text("Arrecadada\r\n        ");
    			create_component(sort6.$$.fragment);
    			add_location(th0, file$e, 73, 6, 1991);
    			add_location(th1, file$e, 77, 6, 2093);
    			add_location(th2, file$e, 81, 6, 2212);
    			add_location(th3, file$e, 85, 6, 2322);
    			add_location(th4, file$e, 89, 6, 2430);
    			add_location(th5, file$e, 93, 6, 2551);
    			add_location(th6, file$e, 97, 6, 2660);
    			add_location(tr, file$e, 72, 4, 1979);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$e, 71, 2, 1954);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			mount_component(sort0, th0, null);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			mount_component(sort1, th1, null);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			mount_component(sort2, th2, null);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			mount_component(sort3, th3, null);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			mount_component(sort4, th4, null);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(th5, t10);
    			mount_component(sort5, th5, null);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(th6, t12);
    			mount_component(sort6, th6, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			transition_in(sort3.$$.fragment, local);
    			transition_in(sort4.$$.fragment, local);
    			transition_in(sort5.$$.fragment, local);
    			transition_in(sort6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			transition_out(sort3.$$.fragment, local);
    			transition_out(sort4.$$.fragment, local);
    			transition_out(sort5.$$.fragment, local);
    			transition_out(sort6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    			destroy_component(sort3);
    			destroy_component(sort4);
    			destroy_component(sort5);
    			destroy_component(sort6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot$1.name,
    		type: "slot",
    		source: "(72:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (106:6) <Row {index} on:click={() => onCellClick(row)}>
    function create_default_slot_2(ctx) {
    	let td;
    	let t0_value = /*row*/ ctx[11].municipio + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let current;

    	const realcombarra0 = new RealComBarra({
    			props: {
    				label: "Receitas próprias",
    				value: /*row*/ ctx[11].receitasDoMunicipio,
    				total: /*totais*/ ctx[2].receitasDoMunicipio
    			},
    			$$inline: true
    		});

    	const realcombarra1 = new RealComBarra({
    			props: {
    				label: "Estado",
    				value: /*row*/ ctx[11].transferenciaDoEstado,
    				total: /*totais*/ ctx[2].transferenciaDoEstado
    			},
    			$$inline: true
    		});

    	const realcombarra2 = new RealComBarra({
    			props: {
    				label: "União",
    				value: /*row*/ ctx[11].transferenciaDaUniao,
    				total: /*totais*/ ctx[2].transferenciaDaUniao
    			},
    			$$inline: true
    		});

    	const realcombarra3 = new RealComBarra({
    			props: {
    				label: "Operações de crédito",
    				value: /*row*/ ctx[11].operacoesDeCredito,
    				total: /*totais*/ ctx[2].operacoesDeCredito
    			},
    			$$inline: true
    		});

    	const realcombarra4 = new RealComBarra({
    			props: {
    				label: "Outras",
    				value: /*row*/ ctx[11].outrasTransferencias,
    				total: /*totais*/ ctx[2].outrasTransferencias
    			},
    			$$inline: true
    		});

    	const realcombarra5 = new RealComBarra({
    			props: {
    				label: "Arrecadada",
    				value: /*row*/ ctx[11].arrecadada,
    				total: /*totais*/ ctx[2].arrecadada
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(realcombarra0.$$.fragment);
    			t2 = space();
    			create_component(realcombarra1.$$.fragment);
    			t3 = space();
    			create_component(realcombarra2.$$.fragment);
    			t4 = space();
    			create_component(realcombarra3.$$.fragment);
    			t5 = space();
    			create_component(realcombarra4.$$.fragment);
    			t6 = space();
    			create_component(realcombarra5.$$.fragment);
    			attr_dev(td, "data-label", "Município");
    			attr_dev(td, "class", "font-bold");
    			add_location(td, file$e, 106, 8, 2893);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t0);
    			insert_dev(target, t1, anchor);
    			mount_component(realcombarra0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(realcombarra1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(realcombarra2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(realcombarra3, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(realcombarra4, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(realcombarra5, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*rows2*/ 1024) && t0_value !== (t0_value = /*row*/ ctx[11].municipio + "")) set_data_dev(t0, t0_value);
    			const realcombarra0_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra0_changes.value = /*row*/ ctx[11].receitasDoMunicipio;
    			if (dirty & /*totais*/ 4) realcombarra0_changes.total = /*totais*/ ctx[2].receitasDoMunicipio;
    			realcombarra0.$set(realcombarra0_changes);
    			const realcombarra1_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra1_changes.value = /*row*/ ctx[11].transferenciaDoEstado;
    			if (dirty & /*totais*/ 4) realcombarra1_changes.total = /*totais*/ ctx[2].transferenciaDoEstado;
    			realcombarra1.$set(realcombarra1_changes);
    			const realcombarra2_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra2_changes.value = /*row*/ ctx[11].transferenciaDaUniao;
    			if (dirty & /*totais*/ 4) realcombarra2_changes.total = /*totais*/ ctx[2].transferenciaDaUniao;
    			realcombarra2.$set(realcombarra2_changes);
    			const realcombarra3_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra3_changes.value = /*row*/ ctx[11].operacoesDeCredito;
    			if (dirty & /*totais*/ 4) realcombarra3_changes.total = /*totais*/ ctx[2].operacoesDeCredito;
    			realcombarra3.$set(realcombarra3_changes);
    			const realcombarra4_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra4_changes.value = /*row*/ ctx[11].outrasTransferencias;
    			if (dirty & /*totais*/ 4) realcombarra4_changes.total = /*totais*/ ctx[2].outrasTransferencias;
    			realcombarra4.$set(realcombarra4_changes);
    			const realcombarra5_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra5_changes.value = /*row*/ ctx[11].arrecadada;
    			if (dirty & /*totais*/ 4) realcombarra5_changes.total = /*totais*/ ctx[2].arrecadada;
    			realcombarra5.$set(realcombarra5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(realcombarra0.$$.fragment, local);
    			transition_in(realcombarra1.$$.fragment, local);
    			transition_in(realcombarra2.$$.fragment, local);
    			transition_in(realcombarra3.$$.fragment, local);
    			transition_in(realcombarra4.$$.fragment, local);
    			transition_in(realcombarra5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(realcombarra0.$$.fragment, local);
    			transition_out(realcombarra1.$$.fragment, local);
    			transition_out(realcombarra2.$$.fragment, local);
    			transition_out(realcombarra3.$$.fragment, local);
    			transition_out(realcombarra4.$$.fragment, local);
    			transition_out(realcombarra5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(realcombarra0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(realcombarra1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(realcombarra2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(realcombarra3, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(realcombarra4, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(realcombarra5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(106:6) <Row {index} on:click={() => onCellClick(row)}>",
    		ctx
    	});

    	return block;
    }

    // (105:4) {#each rows2 as row, index (row)}
    function create_each_block$3(key_1, ctx) {
    	let first;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[9](/*row*/ ctx[11], ...args);
    	}

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[13],
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*rows2*/ 1024) row_changes.index = /*index*/ ctx[13];

    			if (dirty & /*$$scope, rows2, totais*/ 17412) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(105:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (134:4) <Row>
    function create_default_slot_1$2(ctx) {
    	let td;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let current;

    	const total0 = new Total({
    			props: {
    				label: "Receitas próprias",
    				total: /*totais*/ ctx[2].receitasDoMunicipio
    			},
    			$$inline: true
    		});

    	const total1 = new Total({
    			props: {
    				label: "Estado",
    				total: /*totais*/ ctx[2].transferenciaDoEstado
    			},
    			$$inline: true
    		});

    	const total2 = new Total({
    			props: {
    				label: "União",
    				total: /*totais*/ ctx[2].transferenciaDaUniao
    			},
    			$$inline: true
    		});

    	const total3 = new Total({
    			props: {
    				label: "Operações de crédito",
    				total: /*totais*/ ctx[2].operacoesDeCredito
    			},
    			$$inline: true
    		});

    	const total4 = new Total({
    			props: {
    				label: "Outras",
    				total: /*totais*/ ctx[2].outrasTransferencias
    			},
    			$$inline: true
    		});

    	const total5 = new Total({
    			props: {
    				label: "Arrecadada",
    				total: /*totais*/ ctx[2].arrecadada
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			td.textContent = "Totais";
    			t1 = space();
    			create_component(total0.$$.fragment);
    			t2 = space();
    			create_component(total1.$$.fragment);
    			t3 = space();
    			create_component(total2.$$.fragment);
    			t4 = space();
    			create_component(total3.$$.fragment);
    			t5 = space();
    			create_component(total4.$$.fragment);
    			t6 = space();
    			create_component(total5.$$.fragment);
    			attr_dev(td, "data-label", "Total");
    			add_location(td, file$e, 134, 6, 3866);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(total0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(total1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(total2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(total3, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(total4, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(total5, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const total0_changes = {};
    			if (dirty & /*totais*/ 4) total0_changes.total = /*totais*/ ctx[2].receitasDoMunicipio;
    			total0.$set(total0_changes);
    			const total1_changes = {};
    			if (dirty & /*totais*/ 4) total1_changes.total = /*totais*/ ctx[2].transferenciaDoEstado;
    			total1.$set(total1_changes);
    			const total2_changes = {};
    			if (dirty & /*totais*/ 4) total2_changes.total = /*totais*/ ctx[2].transferenciaDaUniao;
    			total2.$set(total2_changes);
    			const total3_changes = {};
    			if (dirty & /*totais*/ 4) total3_changes.total = /*totais*/ ctx[2].operacoesDeCredito;
    			total3.$set(total3_changes);
    			const total4_changes = {};
    			if (dirty & /*totais*/ 4) total4_changes.total = /*totais*/ ctx[2].outrasTransferencias;
    			total4.$set(total4_changes);
    			const total5_changes = {};
    			if (dirty & /*totais*/ 4) total5_changes.total = /*totais*/ ctx[2].arrecadada;
    			total5.$set(total5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(total0.$$.fragment, local);
    			transition_in(total1.$$.fragment, local);
    			transition_in(total2.$$.fragment, local);
    			transition_in(total3.$$.fragment, local);
    			transition_in(total4.$$.fragment, local);
    			transition_in(total5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(total0.$$.fragment, local);
    			transition_out(total1.$$.fragment, local);
    			transition_out(total2.$$.fragment, local);
    			transition_out(total3.$$.fragment, local);
    			transition_out(total4.$$.fragment, local);
    			transition_out(total5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(total0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(total1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(total2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(total3, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(total4, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(total5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(134:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (145:2) <span slot="bottom" />
    function create_bottom_slot(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "bottom");
    			add_location(span, file$e, 144, 2, 4354);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_bottom_slot.name,
    		type: "slot",
    		source: "(145:2) <span slot=\\\"bottom\\\" />",
    		ctx
    	});

    	return block;
    }

    // (71:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$3(ctx) {
    	let t0;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let t2;
    	let current;
    	let each_value = /*rows2*/ ctx[10];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[11];
    	validate_each_keys(ctx, each_value, get_each_context$3, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$3(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
    	}

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(row.$$.fragment);
    			t2 = space();
    			add_location(tbody, file$e, 103, 2, 2782);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t1);
    			mount_component(row, tbody, null);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, onCellClick, totais*/ 1028) {
    				const each_value = /*rows2*/ ctx[10];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$3, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$3, t1, get_each_context$3);
    				check_outros();
    			}

    			const row_changes = {};

    			if (dirty & /*$$scope, totais*/ 16388) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(row);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(71:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let t;
    	let current;

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[0],
    				page: /*page*/ ctx[3],
    				pageSize: /*pageSize*/ ctx[4],
    				rows: /*rows*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$3,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					bottom: [
    						create_bottom_slot,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					head: [
    						create_head_slot$1,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(table.$$.fragment);
    			document.title = "Composição da Receita Arrecadada";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const table_changes = {};
    			if (dirty & /*loading*/ 1) table_changes.loading = /*loading*/ ctx[0];
    			if (dirty & /*rows*/ 2) table_changes.rows = /*rows*/ ctx[1];

    			if (dirty & /*$$scope, totais, rows2*/ 17412) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onCellClick(row) {
    	
    } //alert(JSON.stringify(row));

    function instance$f($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(7, $params = $$value));
    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 100;
    	let totais = {};

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		$$invalidate(0, loading = true);

    		const res = await axios$1.post(api.getApiUrl("DWControleSocial"), [
    			{
    				run: "Municipio.Indicador.ComposicaoReceitaArrecadada",
    				args: [ano]
    			}
    		]);

    		const data = res.data[0].value;

    		$$invalidate(2, totais = {
    			operacoesDeCredito: data.reduce((a, b) => a + b.operacoesDeCredito, 0),
    			receitasDoMunicipio: data.reduce((a, b) => a + b.receitasDoMunicipio, 0),
    			transferenciaDaUniao: data.reduce((a, b) => a + b.transferenciaDaUniao, 0),
    			transferenciaDoEstado: data.reduce((a, b) => a + b.transferenciaDoEstado, 0),
    			outrasTransferencias: data.reduce((a, b) => a + b.outrasTransferencias, 0),
    			arrecadada: data.reduce((a, b) => a + b.arrecadada, 0)
    		});

    		$$invalidate(1, rows = res.data[0].value);
    		$$invalidate(0, loading = false);
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortString(rows, dir, key));
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortNumber(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Composicao_receita_arrecadada> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Composicao_receita_arrecadada", $$slots, []);
    	const click_handler = row => onCellClick();

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		sortNumber,
    		sortString,
    		RealComBarra,
    		Total,
    		loading,
    		rows,
    		page,
    		pageSize,
    		totais,
    		refresh,
    		onCellClick,
    		onSortString,
    		onSortNumber,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(3, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(4, pageSize = $$props.pageSize);
    		if ("totais" in $$props) $$invalidate(2, totais = $$props.totais);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 128) {
    			 refresh($params);
    		}
    	};

    	return [
    		loading,
    		rows,
    		totais,
    		page,
    		pageSize,
    		onSortString,
    		onSortNumber,
    		$params,
    		refresh,
    		click_handler
    	];
    }

    class Composicao_receita_arrecadada extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Composicao_receita_arrecadada",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    //https://github.com/JDMcKinstry/JavaScriptDateFormat

    const mesesAbreviados = [
      "Jan",
      "Fev",
      "Mar",
      "Abr",
      "Mai",
      "Jun",
      "Jul",
      "Ago",
      "Set",
      "Out",
      "Nov",
      "Dez"
    ];
    mesesAbreviados[NaN] = "";
    mesesAbreviados[undefined] = "";

    const meses = [
      "Janeiro",
      "Fevereiro",
      "Março",
      "Abril",
      "Maio",
      "Junho",
      "Julho",
      "Agosto",
      "Setembro",
      "Outubro",
      "Novembro",
      "Dezembro"
    ];
    meses[NaN] = "";
    meses[undefined] = "";

    const dias = [
      "Domingo",
      "Segunda-feira",
      "Terça-feira",
      "Quarta-feira",
      "Quinta-feira",
      "Sexta-feira",
      "Sábado"
    ];
    dias[NaN] = "";
    dias[undefined] = "";

    function dateFormat(dt, str, showFormatted) {
      function addHours(d, v) {
        d.setHours(d.getHours() + parseFloat(v));
        return d;
      }
      function getDayName(d, sf) {
        return sf ? dias[d.getDay()].substr(0, 3) : dias[d.getDay()];
      }
      function getWeek(d) {
        let a = new Date(d.getFullYear(), 0, 1);
        return Math.ceil(((d - a) / 864e5 + a.getDay() + 1) / 7);
      }
      function getMonthName(d, shortForm) {
        return shortForm ? meses[d.getMonth()].substr(0, 3) : meses[d.getMonth()];
      }
      let formats = {
          /*	DAY	*/
          d: function() {
            let a = this.getDate();
            return a > 9 ? a : "0" + a;
          },
          D: function() {
            return getDayName(this, true);
          },
          j: function() {
            return this.getDate();
          },
          l: function() {
            return getDayName(this);
          },
          N: function() {
            return this.getDay() + 1;
          },
          S: function() {
            return "º";
            // let a = this.getDate();
            // return /^1[0-9]$/.test(a)
            //   ? "º"
            //   : /1$/.test(a)
            //   ? "st"
            //   : /2$/.test(a)
            //   ? "nd"
            //   : /3$/.test(a)
            //   ? "rd"
            //   : "th";
          },
          w: function() {
            return this.getDay();
          },
          z: function() {
            return Math.round(
              Math.abs(
                (this.getTime() - new Date("1/1/" + this.getFullYear()).getTime()) /
                  8.64e7
              )
            );
          },
          /*	WEEK	*/
          W: function() {
            return getWeek(this);
          },
          /*	MONTH	*/
          F: function() {
            return getMonthName(this);
          },
          m: function() {
            let a = this.getMonth() + 1;
            return a > 9 ? a : "0" + a;
          },
          M: function() {
            return getMonthName(this, true);
          },
          n: function() {
            return this.getMonth() + 1;
          },
          t: function() {
            return new Date(this.getFullYear(), this.getMonth() + 1, 0).getDate();
          },
          /*	YEAR	*/
          L: function() {
            let a = this.getFullYear();
            return (0 == a % 4 && 0 != a % 100) || 0 == a % 400;
          },
          o: function() {
            return parseInt(this.getFullYear());
          }, //	todo: base on week's parent year
          Y: function() {
            return parseInt(this.getFullYear());
          },
          y: function() {
            return parseInt((this.getFullYear() + "").substr(-2));
          },
          /*	TIME	*/
          a: function() {
            return this.getHours() >= 12 ? "pm" : "am";
          },
          A: function() {
            return this.getHours() >= 12 ? "PM" : "AM";
          },
          B: function() {
            return (
              "@" +
              (
                "00" +
                Math.floor(
                  ((((this.getHours() + 1) % 24) * 60 + this.getMinutes()) * 60 +
                    this.getSeconds() +
                    this.getMilliseconds() * 0.001) /
                    86.4
                )
              ).slice(-3)
            );
          },
          g: function() {
            let a = this.getHours();
            return a == 0 ? 12 : a <= 12 ? a : a - 12;
          }, //	12-hour format of an hour without leading zeros
          G: function() {
            return this.getHours();
          }, //	24-hour format of an hour without leading zeros
          h: function() {
            let a = this.getHours();
            a = a <= 12 ? a : a - 12;
            return a == 0 ? 12 : a > 9 ? a : "0" + a;
          }, //		12-hour format of an hour with leading zeros
          H: function() {
            let a = this.getHours();
            return a > 9 ? a : "0" + a;
          }, //		24-hour format of an hour with leading zeros
          i: function() {
            let a = this.getMinutes();
            return a > 9 ? a : "0" + a;
          }, //	Minutes with leading zeros
          s: function() {
            let a = this.getSeconds();
            return a > 9 ? a : "0" + a;
          }, //	Seconds, with leading zeros
          u: function() {
            return this.getMilliseconds();
          }, //	this is NOT microseconds ... it's JS :P,
          /*	TIMEZONE	*/
          e: function() {
            let a = this.toString().match(/ ([A-Z]{3,4})([-|+]?\d{4})/);
            return a.length > 1 ? a[1] : "";
          },
          I: function() {
            let a = new Date(this.getFullYear(), 0, 1),
              b = new Date(this.getFullYear(), 6, 1),
              c = Math.max(a.getTimezoneOffset(), b.getTimezoneOffset());
            return this.getTimezoneOffset() < c ? 1 : 0;
          },
          O: function() {
            let a = this.toString().match(/ ([A-Z]{3,4})([-|+]?\d{4})/);
            return a.length > 2 ? a[2] : "";
          },
          P: function() {
            let a = this.toString().match(/ ([A-Z]{3,4})([-|+]?\d{4})/);
            return a.length > 2 ? a[2].substr(0, 3) + ":" + a[2].substr(3, 2) : "";
          },
          T: function() {
            return this.toLocaleString("en", { timeZoneName: "short" })
              .split(" ")
              .pop();
          }, //	may not be reliable on Apple Systems	//	NOTE: Apple Sux
          Z: function() {
            return this.getTimezoneOffset() * 60;
          },
          /*	FULL DATE/TIME	*/
          c: function() {
            return addHours(
              new Date(this),
              -(this.getTimezoneOffset() / 60)
            ).toISOString();
          },
          r: function() {
            return addHours(
              new Date(this),
              -(this.getTimezoneOffset() / 60)
            ).toISOString();
          },
          U: function() {
            return (this.getTime() / 1000) | 0;
          }
        },
        compound = {
          commonLogFormat: "d/M/Y:G:i:s",
          exif: "Y:m:d G:i:s",
          isoYearWeek: "Y\\WW",
          isoYearWeek2: "Y-\\WW",
          isoYearWeekDay: "Y\\WWj",
          isoYearWeekDay2: "Y-\\WW-j",
          mySQL: "Y-m-d h:i:s",
          postgreSQL: "Y.z",
          postgreSQL2: "Yz",
          soap: "Y-m-d\\TH:i:s.u",
          soap2: "Y-m-d\\TH:i:s.uP",
          unixTimestamp: "@U",
          xmlrpc: "Ymd\\TG:i:s",
          xmlrpcCompact: "Ymd\\tGis",
          wddx: "Y-n-j\\TG:i:s"
        },
        constants = {
          AMERICAN: "F j, Y",
          AMERICANSHORT: "m/d/Y",
          AMERICANSHORTWTIME: "m/d/Y h:i:sA",
          ATOM: "Y-m-d\\TH:i:sP",
          COOKIE: "l, d-M-Y H:i:s T",
          EUROPEAN: "j F Y",
          EUROPEANSHORT: "d.m.Y",
          EUROPEANSHORTWTIME: "d.m.Y H:i:s",
          ISO8601: "Y-m-d\\TH:i:sO",
          LEGAL: "j F Y",
          RFC822: "D, d M y H:i:s O",
          RFC850: "l, d-M-y H:i:s T",
          RFC1036: "D, d M y H:i:s O",
          RFC1123: "D, d M Y H:i:s O",
          RFC2822: "D, d M Y H:i:s O",
          RFC3339: "Y-m-d\\TH:i:sP",
          RSS: "D, d M Y H:i:s O",
          W3C: "Y-m-d\\TH:i:sP"
        },
        pretty = {
          "pretty-a": "g:i.sA l jS \\o\\f F, Y",
          "pretty-b": "g:iA l jS \\o\\f F, Y",
          "pretty-c": "n/d/Y g:iA",
          "pretty-d": "n/d/Y",
          "pretty-e": "F jS - g:ia",
          "pretty-f": "g:iA",
          "pretty-g": "F jS, Y",
          "pretty-h": "F jS, Y g:mA"
        },
        br = {
          extenso: function() {
            return (
              formats["d"].apply(this) +
              " de " +
              getMonthName(this).toLocaleLowerCase() +
              " de " +
              this.getFullYear()
            );
          }
          //   'dd/mm/yyyy': function() {
          // 	return formats["d"].apply(this) + '/' + formats["d"].apply(this) + '/' + formats["d"].apply(this);
          //   }
        };

      if (str) {
        if (br[str]) {
          return br[str].apply(dt);
        }
        if (str == "compound") {
          if (showFormatted === false) return compound;
          let r = {};
          for (let x in compound) r[x] = dateFormat(dt, compound[x]);
          return r;
        } else if (compound[str]) {
          return dateFormat(dt, compound[str], showFormatted);
        }

        if (str == "constants") {
          if (showFormatted === false) return constants;
          let r = {};
          for (let x in constants) r[x] = dateFormat(dt, constants[x]);
          return r;
        } else if (constants[str]) {
          return dateFormat(dt, constants[str], showFormatted);
        }

        if (str == "pretty") {
          if (showFormatted === false) return pretty;
          let r = {};
          for (let x in pretty) r[x] = dateFormat(dt, pretty[x]);
          return r;
        } else if (pretty[str]) {
          return dateFormat(dt, pretty[str], showFormatted);
        }

        let ret = str.split(""),
          lc = "";

        for (let x in ret) {
          let c = ret[x];
          if (c && /[a-z]/i.test(c) && !/\\/.test(lc + c)) {
            ret[x] = formats[c] ? formats[c].apply(dt) : c;
          }
          lc = ret[x];
        }
        return ret.join("").replace(/\\/g, "");
      }
      return dt;
    }

    /* src\pages\municipio\[ano]\indicadores\_components\PercentualComBarra.svelte generated by Svelte v3.22.3 */
    const file$f = "src\\pages\\municipio\\[ano]\\indicadores\\_components\\PercentualComBarra.svelte";

    function create_fragment$g(ctx) {
    	let td;
    	let t0;
    	let t1;
    	let t2;
    	let td_title_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const barra = new Barra({
    			props: {
    				value: /*value*/ ctx[1],
    				isPositivo: /*isPositivo*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			t1 = text(/*formatted*/ ctx[3]);
    			t2 = text("%\r\n  ");
    			create_component(barra.$$.fragment);
    			attr_dev(td, "data-label", /*label*/ ctx[0]);
    			attr_dev(td, "class", "text-right");
    			attr_dev(td, "title", td_title_value = /*formatted*/ ctx[3] + "%");
    			add_location(td, file$f, 11, 0, 259);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);

    			if (default_slot) {
    				default_slot.m(td, null);
    			}

    			append_dev(td, t0);
    			append_dev(td, t1);
    			append_dev(td, t2);
    			mount_component(barra, td, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[4], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null));
    				}
    			}

    			if (!current || dirty & /*formatted*/ 8) set_data_dev(t1, /*formatted*/ ctx[3]);
    			const barra_changes = {};
    			if (dirty & /*value*/ 2) barra_changes.value = /*value*/ ctx[1];
    			if (dirty & /*isPositivo*/ 4) barra_changes.isPositivo = /*isPositivo*/ ctx[2];
    			barra.$set(barra_changes);

    			if (!current || dirty & /*label*/ 1) {
    				attr_dev(td, "data-label", /*label*/ ctx[0]);
    			}

    			if (!current || dirty & /*formatted*/ 8 && td_title_value !== (td_title_value = /*formatted*/ ctx[3] + "%")) {
    				attr_dev(td, "title", td_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(barra.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(barra.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (default_slot) default_slot.d(detaching);
    			destroy_component(barra);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { value } = $$props;
    	let { isPositivo = v => v >= 0 } = $$props;
    	const writable_props = ["label", "value", "isPositivo"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PercentualComBarra> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("PercentualComBarra", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("isPositivo" in $$props) $$invalidate(2, isPositivo = $$props.isPositivo);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Barra,
    		format2Decimals,
    		label,
    		value,
    		isPositivo,
    		formatted
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("isPositivo" in $$props) $$invalidate(2, isPositivo = $$props.isPositivo);
    		if ("formatted" in $$props) $$invalidate(3, formatted = $$props.formatted);
    	};

    	let formatted;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 2) {
    			 $$invalidate(3, formatted = format2Decimals(value));
    		}
    	};

    	return [label, value, isPositivo, formatted, $$scope, $$slots];
    }

    class PercentualComBarra extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { label: 0, value: 1, isPositivo: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PercentualComBarra",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
    			console.warn("<PercentualComBarra> was created without expected prop 'label'");
    		}

    		if (/*value*/ ctx[1] === undefined && !("value" in props)) {
    			console.warn("<PercentualComBarra> was created without expected prop 'value'");
    		}
    	}

    	get label() {
    		throw new Error("<PercentualComBarra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<PercentualComBarra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<PercentualComBarra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<PercentualComBarra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isPositivo() {
    		throw new Error("<PercentualComBarra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isPositivo(value) {
    		throw new Error("<PercentualComBarra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\despesas\index.svelte generated by Svelte v3.22.3 */
    const file$g = "src\\pages\\municipio\\[ano]\\indicadores\\despesas\\index.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (70:2) <thead slot="head">
    function create_head_slot$2(ctx) {
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t4;
    	let t5;
    	let th3;
    	let t6;
    	let t7;
    	let th4;
    	let t8;
    	let t9;
    	let th5;
    	let t10;
    	let t11;
    	let th6;
    	let t12;
    	let t13;
    	let th7;
    	let t14;
    	let t15;
    	let th8;
    	let t16;
    	let t17;
    	let th9;
    	let t18;
    	let t19;
    	let th10;
    	let t20;
    	let current;

    	const sort0 = new Sort({
    			props: { key: "municipio" },
    			$$inline: true
    		});

    	sort0.$on("sort", /*onSortString*/ ctx[5]);

    	const sort1 = new Sort({
    			props: { key: "prevista" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort2 = new Sort({
    			props: { key: "empenhada" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort3 = new Sort({
    			props: { key: "empenhadaPerCapita" },
    			$$inline: true
    		});

    	sort3.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort4 = new Sort({
    			props: { key: "liquidada" },
    			$$inline: true
    		});

    	sort4.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort5 = new Sort({
    			props: { key: "liquidadaPerCapita" },
    			$$inline: true
    		});

    	sort5.$on("sort", /*onSortNumber*/ ctx[6]);
    	const sort6 = new Sort({ props: { key: "paga" }, $$inline: true });
    	sort6.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort7 = new Sort({
    			props: { key: "pagaPerCapita" },
    			$$inline: true
    		});

    	sort7.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort8 = new Sort({
    			props: { key: "resultadoOrcamentario" },
    			$$inline: true
    		});

    	sort8.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort9 = new Sort({
    			props: { key: "desempenho" },
    			$$inline: true
    		});

    	sort9.$on("sort", /*onSortNumber*/ ctx[6]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text("Municípios\r\n        ");
    			create_component(sort0.$$.fragment);
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Mês";
    			t3 = space();
    			th2 = element("th");
    			t4 = text("Prevista\r\n        ");
    			create_component(sort1.$$.fragment);
    			t5 = space();
    			th3 = element("th");
    			t6 = text("Empenhada\r\n        ");
    			create_component(sort2.$$.fragment);
    			t7 = space();
    			th4 = element("th");
    			t8 = text("Per capita\r\n        ");
    			create_component(sort3.$$.fragment);
    			t9 = space();
    			th5 = element("th");
    			t10 = text("Liquidada\r\n        ");
    			create_component(sort4.$$.fragment);
    			t11 = space();
    			th6 = element("th");
    			t12 = text("Per capita\r\n        ");
    			create_component(sort5.$$.fragment);
    			t13 = space();
    			th7 = element("th");
    			t14 = text("Paga\r\n        ");
    			create_component(sort6.$$.fragment);
    			t15 = space();
    			th8 = element("th");
    			t16 = text("Per capita\r\n        ");
    			create_component(sort7.$$.fragment);
    			t17 = space();
    			th9 = element("th");
    			t18 = text("Resultado orçamentário\r\n        ");
    			create_component(sort8.$$.fragment);
    			t19 = space();
    			th10 = element("th");
    			t20 = text("Desempenho\r\n        ");
    			create_component(sort9.$$.fragment);
    			add_location(th0, file$g, 71, 6, 2109);
    			set_style(th1, "width", "20px");
    			add_location(th1, file$g, 75, 6, 2211);
    			add_location(th2, file$g, 76, 6, 2251);
    			add_location(th3, file$g, 80, 6, 2350);
    			add_location(th4, file$g, 84, 6, 2451);
    			add_location(th5, file$g, 88, 6, 2562);
    			add_location(th6, file$g, 92, 6, 2663);
    			add_location(th7, file$g, 96, 6, 2774);
    			add_location(th8, file$g, 100, 6, 2865);
    			add_location(th9, file$g, 104, 6, 2971);
    			add_location(th10, file$g, 108, 6, 3097);
    			add_location(tr, file$g, 70, 4, 2097);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$g, 69, 2, 2072);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			mount_component(sort0, th0, null);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			mount_component(sort1, th2, null);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			mount_component(sort2, th3, null);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			mount_component(sort3, th4, null);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(th5, t10);
    			mount_component(sort4, th5, null);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(th6, t12);
    			mount_component(sort5, th6, null);
    			append_dev(tr, t13);
    			append_dev(tr, th7);
    			append_dev(th7, t14);
    			mount_component(sort6, th7, null);
    			append_dev(tr, t15);
    			append_dev(tr, th8);
    			append_dev(th8, t16);
    			mount_component(sort7, th8, null);
    			append_dev(tr, t17);
    			append_dev(tr, th9);
    			append_dev(th9, t18);
    			mount_component(sort8, th9, null);
    			append_dev(tr, t19);
    			append_dev(tr, th10);
    			append_dev(th10, t20);
    			mount_component(sort9, th10, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			transition_in(sort3.$$.fragment, local);
    			transition_in(sort4.$$.fragment, local);
    			transition_in(sort5.$$.fragment, local);
    			transition_in(sort6.$$.fragment, local);
    			transition_in(sort7.$$.fragment, local);
    			transition_in(sort8.$$.fragment, local);
    			transition_in(sort9.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			transition_out(sort3.$$.fragment, local);
    			transition_out(sort4.$$.fragment, local);
    			transition_out(sort5.$$.fragment, local);
    			transition_out(sort6.$$.fragment, local);
    			transition_out(sort7.$$.fragment, local);
    			transition_out(sort8.$$.fragment, local);
    			transition_out(sort9.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    			destroy_component(sort3);
    			destroy_component(sort4);
    			destroy_component(sort5);
    			destroy_component(sort6);
    			destroy_component(sort7);
    			destroy_component(sort8);
    			destroy_component(sort9);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot$2.name,
    		type: "slot",
    		source: "(70:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (117:6) <Row {index} on:click={() => onCellClick(row)}>
    function create_default_slot_2$1(ctx) {
    	let td0;
    	let t0_value = /*row*/ ctx[11].municipio + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = mesesAbreviados[/*row*/ ctx[11].mes - 1] + "";
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let current;

    	const realcombarra0 = new RealComBarra({
    			props: {
    				label: "Prevista",
    				value: /*row*/ ctx[11].prevista,
    				total: /*totais*/ ctx[2].prevista
    			},
    			$$inline: true
    		});

    	const realcombarra1 = new RealComBarra({
    			props: {
    				label: "Empenhada",
    				value: /*row*/ ctx[11].empenhada,
    				total: /*totais*/ ctx[2].empenhada
    			},
    			$$inline: true
    		});

    	const realcombarra2 = new RealComBarra({
    			props: {
    				label: "Per capita",
    				value: /*row*/ ctx[11].empenhadaPerCapita,
    				total: /*totais*/ ctx[2].empenhadaPerCapita
    			},
    			$$inline: true
    		});

    	const realcombarra3 = new RealComBarra({
    			props: {
    				label: "Liquidada",
    				value: /*row*/ ctx[11].liquidada,
    				total: /*totais*/ ctx[2].liquidada
    			},
    			$$inline: true
    		});

    	const realcombarra4 = new RealComBarra({
    			props: {
    				label: "Per capita",
    				value: /*row*/ ctx[11].liquidadaPerCapita,
    				total: /*totais*/ ctx[2].liquidadaPerCapita
    			},
    			$$inline: true
    		});

    	const realcombarra5 = new RealComBarra({
    			props: {
    				label: "Paga",
    				value: /*row*/ ctx[11].paga,
    				total: /*totais*/ ctx[2].paga
    			},
    			$$inline: true
    		});

    	const realcombarra6 = new RealComBarra({
    			props: {
    				label: "Per capita",
    				value: /*row*/ ctx[11].pagaPerCapita,
    				total: /*totais*/ ctx[2].pagaPerCapita
    			},
    			$$inline: true
    		});

    	const realcombarra7 = new RealComBarra({
    			props: {
    				label: "Resultado orçamentário",
    				value: /*row*/ ctx[11].resultadoOrcamentario,
    				total: /*totais*/ ctx[2].resultadoOrcamentario
    			},
    			$$inline: true
    		});

    	const percentualcombarra = new PercentualComBarra({
    			props: {
    				label: "Desempenho",
    				value: /*row*/ ctx[11].desempenho
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			create_component(realcombarra0.$$.fragment);
    			t4 = space();
    			create_component(realcombarra1.$$.fragment);
    			t5 = space();
    			create_component(realcombarra2.$$.fragment);
    			t6 = space();
    			create_component(realcombarra3.$$.fragment);
    			t7 = space();
    			create_component(realcombarra4.$$.fragment);
    			t8 = space();
    			create_component(realcombarra5.$$.fragment);
    			t9 = space();
    			create_component(realcombarra6.$$.fragment);
    			t10 = space();
    			create_component(realcombarra7.$$.fragment);
    			t11 = space();
    			create_component(percentualcombarra.$$.fragment);
    			attr_dev(td0, "data-label", "Município");
    			attr_dev(td0, "class", "font-bold");
    			add_location(td0, file$g, 117, 8, 3330);
    			attr_dev(td1, "class", "text-center");
    			add_location(td1, file$g, 118, 8, 3405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td0, anchor);
    			append_dev(td0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, td1, anchor);
    			append_dev(td1, t2);
    			insert_dev(target, t3, anchor);
    			mount_component(realcombarra0, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(realcombarra1, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(realcombarra2, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(realcombarra3, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(realcombarra4, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(realcombarra5, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(realcombarra6, target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(realcombarra7, target, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(percentualcombarra, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*rows2*/ 1024) && t0_value !== (t0_value = /*row*/ ctx[11].municipio + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*rows2*/ 1024) && t2_value !== (t2_value = mesesAbreviados[/*row*/ ctx[11].mes - 1] + "")) set_data_dev(t2, t2_value);
    			const realcombarra0_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra0_changes.value = /*row*/ ctx[11].prevista;
    			if (dirty & /*totais*/ 4) realcombarra0_changes.total = /*totais*/ ctx[2].prevista;
    			realcombarra0.$set(realcombarra0_changes);
    			const realcombarra1_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra1_changes.value = /*row*/ ctx[11].empenhada;
    			if (dirty & /*totais*/ 4) realcombarra1_changes.total = /*totais*/ ctx[2].empenhada;
    			realcombarra1.$set(realcombarra1_changes);
    			const realcombarra2_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra2_changes.value = /*row*/ ctx[11].empenhadaPerCapita;
    			if (dirty & /*totais*/ 4) realcombarra2_changes.total = /*totais*/ ctx[2].empenhadaPerCapita;
    			realcombarra2.$set(realcombarra2_changes);
    			const realcombarra3_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra3_changes.value = /*row*/ ctx[11].liquidada;
    			if (dirty & /*totais*/ 4) realcombarra3_changes.total = /*totais*/ ctx[2].liquidada;
    			realcombarra3.$set(realcombarra3_changes);
    			const realcombarra4_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra4_changes.value = /*row*/ ctx[11].liquidadaPerCapita;
    			if (dirty & /*totais*/ 4) realcombarra4_changes.total = /*totais*/ ctx[2].liquidadaPerCapita;
    			realcombarra4.$set(realcombarra4_changes);
    			const realcombarra5_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra5_changes.value = /*row*/ ctx[11].paga;
    			if (dirty & /*totais*/ 4) realcombarra5_changes.total = /*totais*/ ctx[2].paga;
    			realcombarra5.$set(realcombarra5_changes);
    			const realcombarra6_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra6_changes.value = /*row*/ ctx[11].pagaPerCapita;
    			if (dirty & /*totais*/ 4) realcombarra6_changes.total = /*totais*/ ctx[2].pagaPerCapita;
    			realcombarra6.$set(realcombarra6_changes);
    			const realcombarra7_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra7_changes.value = /*row*/ ctx[11].resultadoOrcamentario;
    			if (dirty & /*totais*/ 4) realcombarra7_changes.total = /*totais*/ ctx[2].resultadoOrcamentario;
    			realcombarra7.$set(realcombarra7_changes);
    			const percentualcombarra_changes = {};
    			if (dirty & /*rows2*/ 1024) percentualcombarra_changes.value = /*row*/ ctx[11].desempenho;
    			percentualcombarra.$set(percentualcombarra_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(realcombarra0.$$.fragment, local);
    			transition_in(realcombarra1.$$.fragment, local);
    			transition_in(realcombarra2.$$.fragment, local);
    			transition_in(realcombarra3.$$.fragment, local);
    			transition_in(realcombarra4.$$.fragment, local);
    			transition_in(realcombarra5.$$.fragment, local);
    			transition_in(realcombarra6.$$.fragment, local);
    			transition_in(realcombarra7.$$.fragment, local);
    			transition_in(percentualcombarra.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(realcombarra0.$$.fragment, local);
    			transition_out(realcombarra1.$$.fragment, local);
    			transition_out(realcombarra2.$$.fragment, local);
    			transition_out(realcombarra3.$$.fragment, local);
    			transition_out(realcombarra4.$$.fragment, local);
    			transition_out(realcombarra5.$$.fragment, local);
    			transition_out(realcombarra6.$$.fragment, local);
    			transition_out(realcombarra7.$$.fragment, local);
    			transition_out(percentualcombarra.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(td1);
    			if (detaching) detach_dev(t3);
    			destroy_component(realcombarra0, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(realcombarra1, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(realcombarra2, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(realcombarra3, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(realcombarra4, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(realcombarra5, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(realcombarra6, detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(realcombarra7, detaching);
    			if (detaching) detach_dev(t11);
    			destroy_component(percentualcombarra, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(117:6) <Row {index} on:click={() => onCellClick(row)}>",
    		ctx
    	});

    	return block;
    }

    // (116:4) {#each rows2 as row, index (row)}
    function create_each_block$4(key_1, ctx) {
    	let first;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[9](/*row*/ ctx[11], ...args);
    	}

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[13],
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*rows2*/ 1024) row_changes.index = /*index*/ ctx[13];

    			if (dirty & /*$$scope, rows2, totais*/ 17412) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(116:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (152:4) <Row>
    function create_default_slot_1$3(ctx) {
    	let td;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let current;

    	const total0 = new Total({
    			props: {
    				label: "Prevista",
    				total: /*totais*/ ctx[2].prevista
    			},
    			$$inline: true
    		});

    	const total1 = new Total({
    			props: {
    				label: "Empenhada",
    				total: /*totais*/ ctx[2].empenhada
    			},
    			$$inline: true
    		});

    	const total2 = new Total({
    			props: {
    				label: "Per capita",
    				total: /*totais*/ ctx[2].empenhadaPerCapita
    			},
    			$$inline: true
    		});

    	const total3 = new Total({
    			props: {
    				label: "Liquidada",
    				total: /*totais*/ ctx[2].liquidada
    			},
    			$$inline: true
    		});

    	const total4 = new Total({
    			props: {
    				label: "Per capita",
    				total: /*totais*/ ctx[2].liquidadaPerCapita
    			},
    			$$inline: true
    		});

    	const total5 = new Total({
    			props: {
    				label: "Paga",
    				total: /*totais*/ ctx[2].paga
    			},
    			$$inline: true
    		});

    	const total6 = new Total({
    			props: {
    				label: "Per capita",
    				total: /*totais*/ ctx[2].pagaPerCapita
    			},
    			$$inline: true
    		});

    	const total7 = new Total({
    			props: {
    				label: "Resultado orçamentário",
    				total: /*totais*/ ctx[2].resultadoOrcamentario
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			td.textContent = "Totais";
    			t1 = space();
    			create_component(total0.$$.fragment);
    			t2 = space();
    			create_component(total1.$$.fragment);
    			t3 = space();
    			create_component(total2.$$.fragment);
    			t4 = space();
    			create_component(total3.$$.fragment);
    			t5 = space();
    			create_component(total4.$$.fragment);
    			t6 = space();
    			create_component(total5.$$.fragment);
    			t7 = space();
    			create_component(total6.$$.fragment);
    			t8 = space();
    			create_component(total7.$$.fragment);
    			attr_dev(td, "data-label", "Total");
    			add_location(td, file$g, 152, 6, 4609);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(total0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(total1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(total2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(total3, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(total4, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(total5, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(total6, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(total7, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const total0_changes = {};
    			if (dirty & /*totais*/ 4) total0_changes.total = /*totais*/ ctx[2].prevista;
    			total0.$set(total0_changes);
    			const total1_changes = {};
    			if (dirty & /*totais*/ 4) total1_changes.total = /*totais*/ ctx[2].empenhada;
    			total1.$set(total1_changes);
    			const total2_changes = {};
    			if (dirty & /*totais*/ 4) total2_changes.total = /*totais*/ ctx[2].empenhadaPerCapita;
    			total2.$set(total2_changes);
    			const total3_changes = {};
    			if (dirty & /*totais*/ 4) total3_changes.total = /*totais*/ ctx[2].liquidada;
    			total3.$set(total3_changes);
    			const total4_changes = {};
    			if (dirty & /*totais*/ 4) total4_changes.total = /*totais*/ ctx[2].liquidadaPerCapita;
    			total4.$set(total4_changes);
    			const total5_changes = {};
    			if (dirty & /*totais*/ 4) total5_changes.total = /*totais*/ ctx[2].paga;
    			total5.$set(total5_changes);
    			const total6_changes = {};
    			if (dirty & /*totais*/ 4) total6_changes.total = /*totais*/ ctx[2].pagaPerCapita;
    			total6.$set(total6_changes);
    			const total7_changes = {};
    			if (dirty & /*totais*/ 4) total7_changes.total = /*totais*/ ctx[2].resultadoOrcamentario;
    			total7.$set(total7_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(total0.$$.fragment, local);
    			transition_in(total1.$$.fragment, local);
    			transition_in(total2.$$.fragment, local);
    			transition_in(total3.$$.fragment, local);
    			transition_in(total4.$$.fragment, local);
    			transition_in(total5.$$.fragment, local);
    			transition_in(total6.$$.fragment, local);
    			transition_in(total7.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(total0.$$.fragment, local);
    			transition_out(total1.$$.fragment, local);
    			transition_out(total2.$$.fragment, local);
    			transition_out(total3.$$.fragment, local);
    			transition_out(total4.$$.fragment, local);
    			transition_out(total5.$$.fragment, local);
    			transition_out(total6.$$.fragment, local);
    			transition_out(total7.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(total0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(total1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(total2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(total3, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(total4, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(total5, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(total6, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(total7, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(152:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (167:2) <span slot="bottom" />
    function create_bottom_slot$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "bottom");
    			add_location(span, file$g, 166, 2, 5209);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_bottom_slot$1.name,
    		type: "slot",
    		source: "(167:2) <span slot=\\\"bottom\\\" />",
    		ctx
    	});

    	return block;
    }

    // (69:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$4(ctx) {
    	let t0;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let t2;
    	let current;
    	let each_value = /*rows2*/ ctx[10];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[11];
    	validate_each_keys(ctx, each_value, get_each_context$4, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$4(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
    	}

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(row.$$.fragment);
    			t2 = space();
    			add_location(tbody, file$g, 114, 2, 3219);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t1);
    			mount_component(row, tbody, null);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, onCellClick, totais, mesesAbreviados*/ 1028) {
    				const each_value = /*rows2*/ ctx[10];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$4, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$4, t1, get_each_context$4);
    				check_outros();
    			}

    			const row_changes = {};

    			if (dirty & /*$$scope, totais*/ 16388) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(row);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(69:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let t;
    	let current;

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[0],
    				page: /*page*/ ctx[3],
    				pageSize: /*pageSize*/ ctx[4],
    				rows: /*rows*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$4,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					bottom: [
    						create_bottom_slot$1,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					head: [
    						create_head_slot$2,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(table.$$.fragment);
    			document.title = "Despesas";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const table_changes = {};
    			if (dirty & /*loading*/ 1) table_changes.loading = /*loading*/ ctx[0];
    			if (dirty & /*rows*/ 2) table_changes.rows = /*rows*/ ctx[1];

    			if (dirty & /*$$scope, totais, rows2*/ 17412) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onCellClick$1(row) {
    	
    } //alert(JSON.stringify(row));

    function instance$h($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(7, $params = $$value));
    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 100;
    	let totais = {};

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		$$invalidate(0, loading = true);

    		const res = await axios$1.post(api.getApiUrl("DWControleSocial"), [
    			{
    				run: "Municipio.Indicador.Despesas",
    				args: [ano]
    			}
    		]);

    		const data = res.data[0].value;

    		$$invalidate(2, totais = {
    			empenhada: data.reduce((a, b) => a + b.empenhada, 0),
    			empenhadaPerCapita: data.reduce((a, b) => a + b.empenhadaPerCapita, 0),
    			liquidada: data.reduce((a, b) => a + b.liquidada, 0),
    			liquidadaPerCapita: data.reduce((a, b) => a + b.liquidadaPerCapita, 0),
    			paga: data.reduce((a, b) => a + b.paga, 0),
    			pagaPerCapita: data.reduce((a, b) => a + b.pagaPerCapita, 0),
    			prevista: data.reduce((a, b) => a + b.prevista, 0),
    			resultadoOrcamentario: data.reduce((a, b) => a + b.resultadoOrcamentario, 0)
    		});

    		$$invalidate(1, rows = res.data[0].value);
    		$$invalidate(0, loading = false);
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortString(rows, dir, key));
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortNumber(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Despesas> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Despesas", $$slots, []);
    	const click_handler = row => onCellClick$1();

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		mesesAbreviados,
    		sortNumber,
    		sortString,
    		Total,
    		RealComBarra,
    		PercentualComBarra,
    		loading,
    		rows,
    		page,
    		pageSize,
    		totais,
    		refresh,
    		onCellClick: onCellClick$1,
    		onSortString,
    		onSortNumber,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(3, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(4, pageSize = $$props.pageSize);
    		if ("totais" in $$props) $$invalidate(2, totais = $$props.totais);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 128) {
    			 refresh($params);
    		}
    	};

    	return [
    		loading,
    		rows,
    		totais,
    		page,
    		pageSize,
    		onSortString,
    		onSortNumber,
    		$params,
    		refresh,
    		click_handler
    	];
    }

    class Despesas extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Despesas",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\despesas-em-destaque\index.svelte generated by Svelte v3.22.3 */
    const file$h = "src\\pages\\municipio\\[ano]\\indicadores\\despesas-em-destaque\\index.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (61:2) <thead slot="head">
    function create_head_slot$3(ctx) {
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let t1;
    	let th1;
    	let t2;
    	let t3;
    	let th2;
    	let t4;
    	let t5;
    	let th3;
    	let t6;
    	let t7;
    	let th4;
    	let t8;
    	let current;

    	const sort0 = new Sort({
    			props: { key: "municipio" },
    			$$inline: true
    		});

    	sort0.$on("sort", /*onSortString*/ ctx[5]);

    	const sort1 = new Sort({
    			props: { key: "diarias" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort2 = new Sort({
    			props: { key: "materialDeConsumo" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort3 = new Sort({
    			props: { key: "materialPermanente" },
    			$$inline: true
    		});

    	sort3.$on("sort", /*onSortNumber*/ ctx[6]);
    	const sort4 = new Sort({ props: { key: "obras" }, $$inline: true });
    	sort4.$on("sort", /*onSortNumber*/ ctx[6]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text("Municípios\r\n        ");
    			create_component(sort0.$$.fragment);
    			t1 = space();
    			th1 = element("th");
    			t2 = text("Diárias\r\n        ");
    			create_component(sort1.$$.fragment);
    			t3 = space();
    			th2 = element("th");
    			t4 = text("Material de consumo\r\n        ");
    			create_component(sort2.$$.fragment);
    			t5 = space();
    			th3 = element("th");
    			t6 = text("Material permanente\r\n        ");
    			create_component(sort3.$$.fragment);
    			t7 = space();
    			th4 = element("th");
    			t8 = text("Obras\r\n        ");
    			create_component(sort4.$$.fragment);
    			add_location(th0, file$h, 62, 6, 1681);
    			add_location(th1, file$h, 66, 6, 1783);
    			add_location(th2, file$h, 70, 6, 1880);
    			add_location(th3, file$h, 74, 6, 1999);
    			add_location(th4, file$h, 78, 6, 2119);
    			add_location(tr, file$h, 61, 4, 1669);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$h, 60, 2, 1644);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			mount_component(sort0, th0, null);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			mount_component(sort1, th1, null);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			mount_component(sort2, th2, null);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			mount_component(sort3, th3, null);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			mount_component(sort4, th4, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			transition_in(sort3.$$.fragment, local);
    			transition_in(sort4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			transition_out(sort3.$$.fragment, local);
    			transition_out(sort4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    			destroy_component(sort3);
    			destroy_component(sort4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot$3.name,
    		type: "slot",
    		source: "(61:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (87:6) <Row {index} on:click={() => onCellClick(row)}>
    function create_default_slot_2$2(ctx) {
    	let td;
    	let t0_value = /*row*/ ctx[11].municipio + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let current;

    	const realcombarra0 = new RealComBarra({
    			props: {
    				label: "Diárias",
    				value: /*row*/ ctx[11].diarias,
    				total: /*totais*/ ctx[2].diarias
    			},
    			$$inline: true
    		});

    	const realcombarra1 = new RealComBarra({
    			props: {
    				label: "Material de consumo",
    				value: /*row*/ ctx[11].materialDeConsumo,
    				total: /*totais*/ ctx[2].materialDeConsumo
    			},
    			$$inline: true
    		});

    	const realcombarra2 = new RealComBarra({
    			props: {
    				label: "Material permanente",
    				value: /*row*/ ctx[11].materialPermanente,
    				total: /*totais*/ ctx[2].materialPermanente
    			},
    			$$inline: true
    		});

    	const realcombarra3 = new RealComBarra({
    			props: {
    				label: "Obras",
    				value: /*row*/ ctx[11].obras,
    				total: /*totais*/ ctx[2].obras
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(realcombarra0.$$.fragment);
    			t2 = space();
    			create_component(realcombarra1.$$.fragment);
    			t3 = space();
    			create_component(realcombarra2.$$.fragment);
    			t4 = space();
    			create_component(realcombarra3.$$.fragment);
    			attr_dev(td, "data-label", "Município");
    			attr_dev(td, "class", "font-bold");
    			add_location(td, file$h, 87, 8, 2342);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t0);
    			insert_dev(target, t1, anchor);
    			mount_component(realcombarra0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(realcombarra1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(realcombarra2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(realcombarra3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*rows2*/ 1024) && t0_value !== (t0_value = /*row*/ ctx[11].municipio + "")) set_data_dev(t0, t0_value);
    			const realcombarra0_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra0_changes.value = /*row*/ ctx[11].diarias;
    			if (dirty & /*totais*/ 4) realcombarra0_changes.total = /*totais*/ ctx[2].diarias;
    			realcombarra0.$set(realcombarra0_changes);
    			const realcombarra1_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra1_changes.value = /*row*/ ctx[11].materialDeConsumo;
    			if (dirty & /*totais*/ 4) realcombarra1_changes.total = /*totais*/ ctx[2].materialDeConsumo;
    			realcombarra1.$set(realcombarra1_changes);
    			const realcombarra2_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra2_changes.value = /*row*/ ctx[11].materialPermanente;
    			if (dirty & /*totais*/ 4) realcombarra2_changes.total = /*totais*/ ctx[2].materialPermanente;
    			realcombarra2.$set(realcombarra2_changes);
    			const realcombarra3_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra3_changes.value = /*row*/ ctx[11].obras;
    			if (dirty & /*totais*/ 4) realcombarra3_changes.total = /*totais*/ ctx[2].obras;
    			realcombarra3.$set(realcombarra3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(realcombarra0.$$.fragment, local);
    			transition_in(realcombarra1.$$.fragment, local);
    			transition_in(realcombarra2.$$.fragment, local);
    			transition_in(realcombarra3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(realcombarra0.$$.fragment, local);
    			transition_out(realcombarra1.$$.fragment, local);
    			transition_out(realcombarra2.$$.fragment, local);
    			transition_out(realcombarra3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(realcombarra0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(realcombarra1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(realcombarra2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(realcombarra3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(87:6) <Row {index} on:click={() => onCellClick(row)}>",
    		ctx
    	});

    	return block;
    }

    // (86:4) {#each rows2 as row, index (row)}
    function create_each_block$5(key_1, ctx) {
    	let first;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[9](/*row*/ ctx[11], ...args);
    	}

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[13],
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*rows2*/ 1024) row_changes.index = /*index*/ ctx[13];

    			if (dirty & /*$$scope, rows2, totais*/ 17412) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(86:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (104:4) <Row>
    function create_default_slot_1$4(ctx) {
    	let td;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let current;

    	const total0 = new Total({
    			props: {
    				label: "Diárias",
    				total: /*totais*/ ctx[2].diarias
    			},
    			$$inline: true
    		});

    	const total1 = new Total({
    			props: {
    				label: "Material de consumo",
    				total: /*totais*/ ctx[2].materialDeConsumo
    			},
    			$$inline: true
    		});

    	const total2 = new Total({
    			props: {
    				label: "Material permanente",
    				total: /*totais*/ ctx[2].materialPermanente
    			},
    			$$inline: true
    		});

    	const total3 = new Total({
    			props: {
    				label: "Obras",
    				total: /*totais*/ ctx[2].obras
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			td.textContent = "Totais";
    			t1 = space();
    			create_component(total0.$$.fragment);
    			t2 = space();
    			create_component(total1.$$.fragment);
    			t3 = space();
    			create_component(total2.$$.fragment);
    			t4 = space();
    			create_component(total3.$$.fragment);
    			attr_dev(td, "data-label", "Total");
    			add_location(td, file$h, 104, 6, 2952);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(total0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(total1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(total2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(total3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const total0_changes = {};
    			if (dirty & /*totais*/ 4) total0_changes.total = /*totais*/ ctx[2].diarias;
    			total0.$set(total0_changes);
    			const total1_changes = {};
    			if (dirty & /*totais*/ 4) total1_changes.total = /*totais*/ ctx[2].materialDeConsumo;
    			total1.$set(total1_changes);
    			const total2_changes = {};
    			if (dirty & /*totais*/ 4) total2_changes.total = /*totais*/ ctx[2].materialPermanente;
    			total2.$set(total2_changes);
    			const total3_changes = {};
    			if (dirty & /*totais*/ 4) total3_changes.total = /*totais*/ ctx[2].obras;
    			total3.$set(total3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(total0.$$.fragment, local);
    			transition_in(total1.$$.fragment, local);
    			transition_in(total2.$$.fragment, local);
    			transition_in(total3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(total0.$$.fragment, local);
    			transition_out(total1.$$.fragment, local);
    			transition_out(total2.$$.fragment, local);
    			transition_out(total3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(total0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(total1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(total2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(total3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(104:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (113:2) <span slot="bottom" />
    function create_bottom_slot$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "bottom");
    			add_location(span, file$h, 112, 2, 3281);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_bottom_slot$2.name,
    		type: "slot",
    		source: "(113:2) <span slot=\\\"bottom\\\" />",
    		ctx
    	});

    	return block;
    }

    // (60:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$5(ctx) {
    	let t0;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let t2;
    	let current;
    	let each_value = /*rows2*/ ctx[10];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[11];
    	validate_each_keys(ctx, each_value, get_each_context$5, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$5(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
    	}

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(row.$$.fragment);
    			t2 = space();
    			add_location(tbody, file$h, 84, 2, 2231);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t1);
    			mount_component(row, tbody, null);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, onCellClick, totais*/ 1028) {
    				const each_value = /*rows2*/ ctx[10];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$5, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$5, t1, get_each_context$5);
    				check_outros();
    			}

    			const row_changes = {};

    			if (dirty & /*$$scope, totais*/ 16388) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(row);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(60:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let t;
    	let current;

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[0],
    				page: /*page*/ ctx[3],
    				pageSize: /*pageSize*/ ctx[4],
    				rows: /*rows*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$5,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					bottom: [
    						create_bottom_slot$2,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					head: [
    						create_head_slot$3,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(table.$$.fragment);
    			document.title = "Despesas em destaque";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const table_changes = {};
    			if (dirty & /*loading*/ 1) table_changes.loading = /*loading*/ ctx[0];
    			if (dirty & /*rows*/ 2) table_changes.rows = /*rows*/ ctx[1];

    			if (dirty & /*$$scope, totais, rows2*/ 17412) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onCellClick$2(row) {
    	
    } //alert(JSON.stringify(row));

    function instance$i($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(7, $params = $$value));
    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 100;
    	let totais = {};

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		$$invalidate(0, loading = true);

    		const res = await axios$1.post(api.getApiUrl("DWControleSocial"), [
    			{
    				run: "Municipio.Indicador.DespesasEmDestaque",
    				args: [ano]
    			}
    		]);

    		const data = res.data[0].value;

    		$$invalidate(2, totais = {
    			diarias: data.reduce((a, b) => a + b.diarias, 0),
    			materialDeConsumo: data.reduce((a, b) => a + b.materialDeConsumo, 0),
    			materialPermanente: data.reduce((a, b) => a + b.materialPermanente, 0),
    			obras: data.reduce((a, b) => a + b.obras, 0)
    		});

    		$$invalidate(1, rows = res.data[0].value);
    		$$invalidate(0, loading = false);
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortString(rows, dir, key));
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortNumber(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Despesas_em_destaque> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Despesas_em_destaque", $$slots, []);
    	const click_handler = row => onCellClick$2();

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		sortNumber,
    		sortString,
    		RealComBarra,
    		Total,
    		loading,
    		rows,
    		page,
    		pageSize,
    		totais,
    		refresh,
    		onCellClick: onCellClick$2,
    		onSortString,
    		onSortNumber,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(3, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(4, pageSize = $$props.pageSize);
    		if ("totais" in $$props) $$invalidate(2, totais = $$props.totais);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 128) {
    			 refresh($params);
    		}
    	};

    	return [
    		loading,
    		rows,
    		totais,
    		page,
    		pageSize,
    		onSortString,
    		onSortNumber,
    		$params,
    		refresh,
    		click_handler
    	];
    }

    class Despesas_em_destaque extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Despesas_em_destaque",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* node_modules\fa-svelte\src\Icon.svelte generated by Svelte v3.22.3 */

    const file$i = "node_modules\\fa-svelte\\src\\Icon.svelte";

    function create_fragment$j(ctx) {
    	let svg;
    	let path_1;
    	let svg_class_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path_1 = svg_element("path");
    			attr_dev(path_1, "fill", "currentColor");
    			attr_dev(path_1, "d", /*path*/ ctx[0]);
    			add_location(path_1, file$i, 7, 2, 129);
    			attr_dev(svg, "aria-hidden", "true");
    			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*classes*/ ctx[1]) + " svelte-p8vizn"));
    			attr_dev(svg, "role", "img");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[2]);
    			add_location(svg, file$i, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path_1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*path*/ 1) {
    				attr_dev(path_1, "d", /*path*/ ctx[0]);
    			}

    			if (dirty & /*classes*/ 2 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*classes*/ ctx[1]) + " svelte-p8vizn"))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (dirty & /*viewBox*/ 4) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { icon } = $$props;
    	let path = [];
    	let classes = "";
    	let viewBox = "";
    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Icon", $$slots, []);

    	$$self.$set = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("icon" in $$new_props) $$invalidate(3, icon = $$new_props.icon);
    	};

    	$$self.$capture_state = () => ({ icon, path, classes, viewBox });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    		if ("icon" in $$props) $$invalidate(3, icon = $$new_props.icon);
    		if ("path" in $$props) $$invalidate(0, path = $$new_props.path);
    		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
    		if ("viewBox" in $$props) $$invalidate(2, viewBox = $$new_props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*icon*/ 8) {
    			 $$invalidate(2, viewBox = "0 0 " + icon.icon[0] + " " + icon.icon[1]);
    		}

    		 $$invalidate(1, classes = "fa-svelte " + ($$props.class ? $$props.class : ""));

    		if ($$self.$$.dirty & /*icon*/ 8) {
    			 $$invalidate(0, path = icon.icon[4]);
    		}
    	};

    	$$props = exclude_internal_props($$props);
    	return [path, classes, viewBox, icon];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, { icon: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*icon*/ ctx[3] === undefined && !("icon" in props)) {
    			console.warn("<Icon> was created without expected prop 'icon'");
    		}
    	}

    	get icon() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var faThumbsDown = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'far';
    var iconName = 'thumbs-down';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f165';
    var svgPathData = 'M466.27 225.31c4.674-22.647.864-44.538-8.99-62.99 2.958-23.868-4.021-48.565-17.34-66.99C438.986 39.423 404.117 0 327 0c-7 0-15 .01-22.22.01C201.195.01 168.997 40 128 40h-10.845c-5.64-4.975-13.042-8-21.155-8H32C14.327 32 0 46.327 0 64v240c0 17.673 14.327 32 32 32h64c11.842 0 22.175-6.438 27.708-16h7.052c19.146 16.953 46.013 60.653 68.76 83.4 13.667 13.667 10.153 108.6 71.76 108.6 57.58 0 95.27-31.936 95.27-104.73 0-18.41-3.93-33.73-8.85-46.54h36.48c48.602 0 85.82-41.565 85.82-85.58 0-19.15-4.96-34.99-13.73-49.84zM64 296c-13.255 0-24-10.745-24-24s10.745-24 24-24 24 10.745 24 24-10.745 24-24 24zm330.18 16.73H290.19c0 37.82 28.36 55.37 28.36 94.54 0 23.75 0 56.73-47.27 56.73-18.91-18.91-9.46-66.18-37.82-94.54C206.9 342.89 167.28 272 138.92 272H128V85.83c53.611 0 100.001-37.82 171.64-37.82h37.82c35.512 0 60.82 17.12 53.12 65.9 15.2 8.16 26.5 36.44 13.94 57.57 21.581 20.384 18.699 51.065 5.21 65.62 9.45 0 22.36 18.91 22.27 37.81-.09 18.91-16.71 37.82-37.82 37.82z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faThumbsDown = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faThumbsDown);
    var faThumbsDown_1 = faThumbsDown.definition;
    var faThumbsDown_2 = faThumbsDown.faThumbsDown;
    var faThumbsDown_3 = faThumbsDown.prefix;
    var faThumbsDown_4 = faThumbsDown.iconName;
    var faThumbsDown_5 = faThumbsDown.width;
    var faThumbsDown_6 = faThumbsDown.height;
    var faThumbsDown_7 = faThumbsDown.ligatures;
    var faThumbsDown_8 = faThumbsDown.unicode;
    var faThumbsDown_9 = faThumbsDown.svgPathData;

    var faThumbsUp = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'far';
    var iconName = 'thumbs-up';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f164';
    var svgPathData = 'M466.27 286.69C475.04 271.84 480 256 480 236.85c0-44.015-37.218-85.58-85.82-85.58H357.7c4.92-12.81 8.85-28.13 8.85-46.54C366.55 31.936 328.86 0 271.28 0c-61.607 0-58.093 94.933-71.76 108.6-22.747 22.747-49.615 66.447-68.76 83.4H32c-17.673 0-32 14.327-32 32v240c0 17.673 14.327 32 32 32h64c14.893 0 27.408-10.174 30.978-23.95 44.509 1.001 75.06 39.94 177.802 39.94 7.22 0 15.22.01 22.22.01 77.117 0 111.986-39.423 112.94-95.33 13.319-18.425 20.299-43.122 17.34-66.99 9.854-18.452 13.664-40.343 8.99-62.99zm-61.75 53.83c12.56 21.13 1.26 49.41-13.94 57.57 7.7 48.78-17.608 65.9-53.12 65.9h-37.82c-71.639 0-118.029-37.82-171.64-37.82V240h10.92c28.36 0 67.98-70.89 94.54-97.46 28.36-28.36 18.91-75.63 37.82-94.54 47.27 0 47.27 32.98 47.27 56.73 0 39.17-28.36 56.72-28.36 94.54h103.99c21.11 0 37.73 18.91 37.82 37.82.09 18.9-12.82 37.81-22.27 37.81 13.489 14.555 16.371 45.236-5.21 65.62zM88 432c0 13.255-10.745 24-24 24s-24-10.745-24-24 10.745-24 24-24 24 10.745 24 24z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faThumbsUp = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faThumbsUp);
    var faThumbsUp_1 = faThumbsUp.definition;
    var faThumbsUp_2 = faThumbsUp.faThumbsUp;
    var faThumbsUp_3 = faThumbsUp.prefix;
    var faThumbsUp_4 = faThumbsUp.iconName;
    var faThumbsUp_5 = faThumbsUp.width;
    var faThumbsUp_6 = faThumbsUp.height;
    var faThumbsUp_7 = faThumbsUp.ligatures;
    var faThumbsUp_8 = faThumbsUp.unicode;
    var faThumbsUp_9 = faThumbsUp.svgPathData;

    /* src\pages\municipio\[ano]\indicadores\_components\AlertaLimiteConstitucionalSaudeEEducacao.svelte generated by Svelte v3.22.3 */
    const file$j = "src\\pages\\municipio\\[ano]\\indicadores\\_components\\AlertaLimiteConstitucionalSaudeEEducacao.svelte";

    // (14:0) {:else}
    function create_else_block$3(ctx) {
    	let span;
    	let span_title_value;
    	let current;

    	const icon = new Icon({
    			props: { icon: faThumbsDown_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "class", "text-red-800");
    			attr_dev(span, "title", span_title_value = `Ultrapassou o limite máximo ${/*config*/ ctx[1].limite}%`);
    			add_location(span, file$j, 14, 2, 435);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*config*/ 2 && span_title_value !== (span_title_value = `Ultrapassou o limite máximo ${/*config*/ ctx[1].limite}%`)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(14:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (10:0) {#if value >= config.limite}
    function create_if_block$8(ctx) {
    	let span;
    	let span_title_value;
    	let current;

    	const icon = new Icon({
    			props: { icon: faThumbsUp_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "class", "text-blue-800");
    			attr_dev(span, "title", span_title_value = `Obedeceu o limite de ${/*config*/ ctx[1].limite}%`);
    			add_location(span, file$j, 10, 2, 302);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*config*/ 2 && span_title_value !== (span_title_value = `Obedeceu o limite de ${/*config*/ ctx[1].limite}%`)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(10:0) {#if value >= config.limite}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*value*/ ctx[0] >= /*config*/ ctx[1].limite) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { value } = $$props;
    	let { config = {} } = $$props;
    	const writable_props = ["value", "config"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AlertaLimiteConstitucionalSaudeEEducacao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("AlertaLimiteConstitucionalSaudeEEducacao", $$slots, []);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("config" in $$props) $$invalidate(1, config = $$props.config);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		faThumbsDown: faThumbsDown_2,
    		faThumbsUp: faThumbsUp_2,
    		value,
    		config
    	});

    	$$self.$inject_state = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("config" in $$props) $$invalidate(1, config = $$props.config);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, config];
    }

    class AlertaLimiteConstitucionalSaudeEEducacao extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { value: 0, config: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AlertaLimiteConstitucionalSaudeEEducacao",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console.warn("<AlertaLimiteConstitucionalSaudeEEducacao> was created without expected prop 'value'");
    		}
    	}

    	get value() {
    		throw new Error("<AlertaLimiteConstitucionalSaudeEEducacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<AlertaLimiteConstitucionalSaudeEEducacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get config() {
    		throw new Error("<AlertaLimiteConstitucionalSaudeEEducacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set config(value) {
    		throw new Error("<AlertaLimiteConstitucionalSaudeEEducacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\educacao\index.svelte generated by Svelte v3.22.3 */
    const file$k = "src\\pages\\municipio\\[ano]\\indicadores\\educacao\\index.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    // (67:2) <thead slot="head">
    function create_head_slot$4(ctx) {
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let t1;
    	let th1;
    	let t2;
    	let t3;
    	let th2;
    	let t4;
    	let t5;
    	let th3;
    	let t6;
    	let t7;
    	let th4;
    	let t8;
    	let current;

    	const sort0 = new Sort({
    			props: { key: "municipio" },
    			$$inline: true
    		});

    	sort0.$on("sort", /*onSortString*/ ctx[6]);

    	const sort1 = new Sort({
    			props: { key: "aplicacao" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortNumber*/ ctx[7]);

    	const sort2 = new Sort({
    			props: { key: "quantidadeAlunos" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortNumber*/ ctx[7]);

    	const sort3 = new Sort({
    			props: { key: "aplicacaoPorAluno" },
    			$$inline: true
    		});

    	sort3.$on("sort", /*onSortNumber*/ ctx[7]);

    	const sort4 = new Sort({
    			props: { key: "limiteConstitucional" },
    			$$inline: true
    		});

    	sort4.$on("sort", /*onSortNumber*/ ctx[7]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text("Municípios\r\n        ");
    			create_component(sort0.$$.fragment);
    			t1 = space();
    			th1 = element("th");
    			t2 = text("Aplicação total\r\n        ");
    			create_component(sort1.$$.fragment);
    			t3 = space();
    			th2 = element("th");
    			t4 = text("Alunos\r\n        ");
    			create_component(sort2.$$.fragment);
    			t5 = space();
    			th3 = element("th");
    			t6 = text("Por aluno\r\n        ");
    			create_component(sort3.$$.fragment);
    			t7 = space();
    			th4 = element("th");
    			t8 = text("Limite constitucional\r\n        ");
    			create_component(sort4.$$.fragment);
    			add_location(th0, file$k, 68, 6, 1900);
    			add_location(th1, file$k, 72, 6, 2002);
    			add_location(th2, file$k, 76, 6, 2109);
    			add_location(th3, file$k, 80, 6, 2214);
    			add_location(th4, file$k, 84, 6, 2323);
    			add_location(tr, file$k, 67, 4, 1888);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$k, 66, 2, 1863);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			mount_component(sort0, th0, null);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			mount_component(sort1, th1, null);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			mount_component(sort2, th2, null);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			mount_component(sort3, th3, null);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			mount_component(sort4, th4, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			transition_in(sort3.$$.fragment, local);
    			transition_in(sort4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			transition_out(sort3.$$.fragment, local);
    			transition_out(sort4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    			destroy_component(sort3);
    			destroy_component(sort4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot$4.name,
    		type: "slot",
    		source: "(67:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (108:8) <PercentualComBarra            label="Limite constitucional"            isPositivo={v => v >= configLimiteConstitucional.limite}            value={row.limiteConstitucional}>
    function create_default_slot_3(ctx) {
    	let current;

    	const limiteconstitucional = new AlertaLimiteConstitucionalSaudeEEducacao({
    			props: {
    				config: /*configLimiteConstitucional*/ ctx[3],
    				value: /*row*/ ctx[13].limiteConstitucional
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(limiteconstitucional.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(limiteconstitucional, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const limiteconstitucional_changes = {};
    			if (dirty & /*rows2*/ 4096) limiteconstitucional_changes.value = /*row*/ ctx[13].limiteConstitucional;
    			limiteconstitucional.$set(limiteconstitucional_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(limiteconstitucional.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(limiteconstitucional.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(limiteconstitucional, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(108:8) <PercentualComBarra            label=\\\"Limite constitucional\\\"            isPositivo={v => v >= configLimiteConstitucional.limite}            value={row.limiteConstitucional}>",
    		ctx
    	});

    	return block;
    }

    // (93:6) <Row {index} on:click={() => onCellClick(row)}>
    function create_default_slot_2$3(ctx) {
    	let td0;
    	let t0_value = /*row*/ ctx[13].municipio + "";
    	let t0;
    	let t1;
    	let t2;
    	let td1;
    	let t3_value = /*row*/ ctx[13].quantidadeAlunos + "";
    	let t3;
    	let t4;
    	let td1_title_value;
    	let t5;
    	let t6;
    	let current;

    	const realcombarra0 = new RealComBarra({
    			props: {
    				label: "Aplicação total",
    				value: /*row*/ ctx[13].aplicacao,
    				total: /*totais*/ ctx[2].aplicacao
    			},
    			$$inline: true
    		});

    	const barra = new Barra({
    			props: {
    				value: /*row*/ ctx[13].quantidadeAlunos * 100 / /*totais*/ ctx[2].quantidadeAlunos
    			},
    			$$inline: true
    		});

    	const realcombarra1 = new RealComBarra({
    			props: {
    				label: "Por aluno",
    				value: /*row*/ ctx[13].aplicacaoPorAluno,
    				total: /*totais*/ ctx[2].aplicacaoPorAluno
    			},
    			$$inline: true
    		});

    	const percentualcombarra = new PercentualComBarra({
    			props: {
    				label: "Limite constitucional",
    				isPositivo: /*func*/ ctx[10],
    				value: /*row*/ ctx[13].limiteConstitucional,
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(realcombarra0.$$.fragment);
    			t2 = space();
    			td1 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			create_component(barra.$$.fragment);
    			t5 = space();
    			create_component(realcombarra1.$$.fragment);
    			t6 = space();
    			create_component(percentualcombarra.$$.fragment);
    			attr_dev(td0, "data-label", "Município");
    			attr_dev(td0, "class", "font-bold");
    			add_location(td0, file$k, 93, 8, 2577);
    			attr_dev(td1, "data-label", "Alunos");
    			attr_dev(td1, "class", "text-right");
    			attr_dev(td1, "title", td1_title_value = /*row*/ ctx[13].quantidadeAlunos);
    			add_location(td1, file$k, 98, 8, 2782);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td0, anchor);
    			append_dev(td0, t0);
    			insert_dev(target, t1, anchor);
    			mount_component(realcombarra0, target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, td1, anchor);
    			append_dev(td1, t3);
    			append_dev(td1, t4);
    			mount_component(barra, td1, null);
    			insert_dev(target, t5, anchor);
    			mount_component(realcombarra1, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(percentualcombarra, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*rows2*/ 4096) && t0_value !== (t0_value = /*row*/ ctx[13].municipio + "")) set_data_dev(t0, t0_value);
    			const realcombarra0_changes = {};
    			if (dirty & /*rows2*/ 4096) realcombarra0_changes.value = /*row*/ ctx[13].aplicacao;
    			if (dirty & /*totais*/ 4) realcombarra0_changes.total = /*totais*/ ctx[2].aplicacao;
    			realcombarra0.$set(realcombarra0_changes);
    			if ((!current || dirty & /*rows2*/ 4096) && t3_value !== (t3_value = /*row*/ ctx[13].quantidadeAlunos + "")) set_data_dev(t3, t3_value);
    			const barra_changes = {};
    			if (dirty & /*rows2, totais*/ 4100) barra_changes.value = /*row*/ ctx[13].quantidadeAlunos * 100 / /*totais*/ ctx[2].quantidadeAlunos;
    			barra.$set(barra_changes);

    			if (!current || dirty & /*rows2*/ 4096 && td1_title_value !== (td1_title_value = /*row*/ ctx[13].quantidadeAlunos)) {
    				attr_dev(td1, "title", td1_title_value);
    			}

    			const realcombarra1_changes = {};
    			if (dirty & /*rows2*/ 4096) realcombarra1_changes.value = /*row*/ ctx[13].aplicacaoPorAluno;
    			if (dirty & /*totais*/ 4) realcombarra1_changes.total = /*totais*/ ctx[2].aplicacaoPorAluno;
    			realcombarra1.$set(realcombarra1_changes);
    			const percentualcombarra_changes = {};
    			if (dirty & /*rows2*/ 4096) percentualcombarra_changes.value = /*row*/ ctx[13].limiteConstitucional;

    			if (dirty & /*$$scope, rows2*/ 69632) {
    				percentualcombarra_changes.$$scope = { dirty, ctx };
    			}

    			percentualcombarra.$set(percentualcombarra_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(realcombarra0.$$.fragment, local);
    			transition_in(barra.$$.fragment, local);
    			transition_in(realcombarra1.$$.fragment, local);
    			transition_in(percentualcombarra.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(realcombarra0.$$.fragment, local);
    			transition_out(barra.$$.fragment, local);
    			transition_out(realcombarra1.$$.fragment, local);
    			transition_out(percentualcombarra.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td0);
    			if (detaching) detach_dev(t1);
    			destroy_component(realcombarra0, detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(td1);
    			destroy_component(barra);
    			if (detaching) detach_dev(t5);
    			destroy_component(realcombarra1, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(percentualcombarra, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(93:6) <Row {index} on:click={() => onCellClick(row)}>",
    		ctx
    	});

    	return block;
    }

    // (92:4) {#each rows2 as row, index (row)}
    function create_each_block$6(key_1, ctx) {
    	let first;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[11](/*row*/ ctx[13], ...args);
    	}

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[15],
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*rows2*/ 4096) row_changes.index = /*index*/ ctx[15];

    			if (dirty & /*$$scope, rows2, totais*/ 69636) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(92:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (118:4) <Row>
    function create_default_slot_1$5(ctx) {
    	let td;
    	let t1;
    	let t2;
    	let t3;
    	let current;

    	const total0 = new Total({
    			props: {
    				label: "Aplicação total",
    				total: /*totais*/ ctx[2].aplicacao
    			},
    			$$inline: true
    		});

    	const total1 = new Total({
    			props: {
    				label: "Alunos",
    				total: /*totais*/ ctx[2].quantidadeAlunos
    			},
    			$$inline: true
    		});

    	const total2 = new Total({
    			props: {
    				label: "Por aluno",
    				total: /*totais*/ ctx[2].aplicacaoPorAluno
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			td.textContent = "Totais";
    			t1 = space();
    			create_component(total0.$$.fragment);
    			t2 = space();
    			create_component(total1.$$.fragment);
    			t3 = space();
    			create_component(total2.$$.fragment);
    			attr_dev(td, "data-label", "Total");
    			add_location(td, file$k, 118, 6, 3531);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(total0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(total1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(total2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const total0_changes = {};
    			if (dirty & /*totais*/ 4) total0_changes.total = /*totais*/ ctx[2].aplicacao;
    			total0.$set(total0_changes);
    			const total1_changes = {};
    			if (dirty & /*totais*/ 4) total1_changes.total = /*totais*/ ctx[2].quantidadeAlunos;
    			total1.$set(total1_changes);
    			const total2_changes = {};
    			if (dirty & /*totais*/ 4) total2_changes.total = /*totais*/ ctx[2].aplicacaoPorAluno;
    			total2.$set(total2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(total0.$$.fragment, local);
    			transition_in(total1.$$.fragment, local);
    			transition_in(total2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(total0.$$.fragment, local);
    			transition_out(total1.$$.fragment, local);
    			transition_out(total2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(total0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(total1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(total2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(118:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (126:2) <span slot="bottom" />
    function create_bottom_slot$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "bottom");
    			add_location(span, file$k, 125, 2, 3793);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_bottom_slot$3.name,
    		type: "slot",
    		source: "(126:2) <span slot=\\\"bottom\\\" />",
    		ctx
    	});

    	return block;
    }

    // (66:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$6(ctx) {
    	let t0;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let t2;
    	let current;
    	let each_value = /*rows2*/ ctx[12];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[13];
    	validate_each_keys(ctx, each_value, get_each_context$6, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$6(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
    	}

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(row.$$.fragment);
    			t2 = space();
    			add_location(tbody, file$k, 90, 2, 2466);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t1);
    			mount_component(row, tbody, null);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, onCellClick, configLimiteConstitucional, totais*/ 4108) {
    				const each_value = /*rows2*/ ctx[12];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$6, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$6, t1, get_each_context$6);
    				check_outros();
    			}

    			const row_changes = {};

    			if (dirty & /*$$scope, totais*/ 65540) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(row);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(66:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let t;
    	let current;

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[0],
    				page: /*page*/ ctx[4],
    				pageSize: /*pageSize*/ ctx[5],
    				rows: /*rows*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$6,
    						({ rows: rows2 }) => ({ 12: rows2 }),
    						({ rows: rows2 }) => rows2 ? 4096 : 0
    					],
    					bottom: [
    						create_bottom_slot$3,
    						({ rows: rows2 }) => ({ 12: rows2 }),
    						({ rows: rows2 }) => rows2 ? 4096 : 0
    					],
    					head: [
    						create_head_slot$4,
    						({ rows: rows2 }) => ({ 12: rows2 }),
    						({ rows: rows2 }) => rows2 ? 4096 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(table.$$.fragment);
    			document.title = "Educação";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const table_changes = {};
    			if (dirty & /*loading*/ 1) table_changes.loading = /*loading*/ ctx[0];
    			if (dirty & /*rows*/ 2) table_changes.rows = /*rows*/ ctx[1];

    			if (dirty & /*$$scope, totais, rows2*/ 69636) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onCellClick$3(row) {
    	
    } //alert(JSON.stringify(row));

    function instance$l($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(8, $params = $$value));
    	const configLimiteConstitucional = { limite: 25 };
    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 100;
    	let totais = {};

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		$$invalidate(0, loading = true);

    		const res = await axios$1.post(api.getApiUrl("ControleSocial"), [
    			{
    				run: "Municipio.Indicador.Educacao",
    				args: [ano]
    			}
    		]);

    		const data = res.data[0].value;

    		$$invalidate(2, totais = {
    			aplicacao: data.reduce((a, b) => a + b.aplicacao, 0),
    			quantidadeAlunos: data.reduce((a, b) => a + b.quantidadeAlunos, 0),
    			aplicacaoPorAluno: data.reduce((a, b) => a + b.aplicacaoPorAluno, 0)
    		});

    		$$invalidate(1, rows = res.data[0].value);
    		$$invalidate(0, loading = false);
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortString(rows, dir, key));
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortNumber(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Educacao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Educacao", $$slots, []);
    	const func = v => v >= configLimiteConstitucional.limite;
    	const click_handler = row => onCellClick$3();

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		sortNumber,
    		sortString,
    		Total,
    		Barra,
    		RealComBarra,
    		PercentualComBarra,
    		LimiteConstitucional: AlertaLimiteConstitucionalSaudeEEducacao,
    		configLimiteConstitucional,
    		loading,
    		rows,
    		page,
    		pageSize,
    		totais,
    		refresh,
    		onCellClick: onCellClick$3,
    		onSortString,
    		onSortNumber,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(4, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(5, pageSize = $$props.pageSize);
    		if ("totais" in $$props) $$invalidate(2, totais = $$props.totais);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 256) {
    			 refresh($params);
    		}
    	};

    	return [
    		loading,
    		rows,
    		totais,
    		configLimiteConstitucional,
    		page,
    		pageSize,
    		onSortString,
    		onSortNumber,
    		$params,
    		refresh,
    		func,
    		click_handler
    	];
    }

    class Educacao extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Educacao",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\educacao-fundeb\index.svelte generated by Svelte v3.22.3 */
    const file$l = "src\\pages\\municipio\\[ano]\\indicadores\\educacao-fundeb\\index.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (62:2) <thead slot="head">
    function create_head_slot$5(ctx) {
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let t1;
    	let th1;
    	let t2;
    	let t3;
    	let th2;
    	let t4;
    	let t5;
    	let th3;
    	let t6;
    	let t7;
    	let th4;
    	let t8;
    	let t9;
    	let th5;
    	let t10;
    	let current;

    	const sort0 = new Sort({
    			props: { key: "municipio" },
    			$$inline: true
    		});

    	sort0.$on("sort", /*onSortString*/ ctx[5]);

    	const sort1 = new Sort({
    			props: { key: "quantidadeAlunos" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort2 = new Sort({
    			props: { key: "destinado" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort3 = new Sort({
    			props: { key: "recebido" },
    			$$inline: true
    		});

    	sort3.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort4 = new Sort({
    			props: { key: "destinadoXRecebido" },
    			$$inline: true
    		});

    	sort4.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort5 = new Sort({
    			props: { key: "aplicacaoMagisterio" },
    			$$inline: true
    		});

    	sort5.$on("sort", /*onSortNumber*/ ctx[6]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text("Municípios\r\n        ");
    			create_component(sort0.$$.fragment);
    			t1 = space();
    			th1 = element("th");
    			t2 = text("Alunos\r\n        ");
    			create_component(sort1.$$.fragment);
    			t3 = space();
    			th2 = element("th");
    			t4 = text("Destinado\r\n        ");
    			create_component(sort2.$$.fragment);
    			t5 = space();
    			th3 = element("th");
    			t6 = text("Recebido\r\n        ");
    			create_component(sort3.$$.fragment);
    			t7 = space();
    			th4 = element("th");
    			t8 = text("Destinado X Recebido\r\n        ");
    			create_component(sort4.$$.fragment);
    			t9 = space();
    			th5 = element("th");
    			t10 = text("Aplicação no Magistério\r\n        ");
    			create_component(sort5.$$.fragment);
    			add_location(th0, file$l, 63, 6, 1728);
    			add_location(th1, file$l, 67, 6, 1830);
    			add_location(th2, file$l, 71, 6, 1935);
    			add_location(th3, file$l, 75, 6, 2036);
    			add_location(th4, file$l, 79, 6, 2135);
    			add_location(th5, file$l, 83, 6, 2256);
    			add_location(tr, file$l, 62, 4, 1716);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$l, 61, 2, 1691);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			mount_component(sort0, th0, null);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			mount_component(sort1, th1, null);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			mount_component(sort2, th2, null);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			mount_component(sort3, th3, null);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			mount_component(sort4, th4, null);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(th5, t10);
    			mount_component(sort5, th5, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			transition_in(sort3.$$.fragment, local);
    			transition_in(sort4.$$.fragment, local);
    			transition_in(sort5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			transition_out(sort3.$$.fragment, local);
    			transition_out(sort4.$$.fragment, local);
    			transition_out(sort5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    			destroy_component(sort3);
    			destroy_component(sort4);
    			destroy_component(sort5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot$5.name,
    		type: "slot",
    		source: "(62:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (92:6) <Row {index} on:click={() => onCellClick(row)}>
    function create_default_slot_2$4(ctx) {
    	let td0;
    	let t0_value = /*row*/ ctx[11].municipio + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*row*/ ctx[11].quantidadeAlunos + "";
    	let t2;
    	let t3;
    	let td1_title_value;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let current;

    	const barra = new Barra({
    			props: {
    				value: /*row*/ ctx[11].quantidadeAlunos * 100 / /*totais*/ ctx[2].quantidadeAlunos
    			},
    			$$inline: true
    		});

    	const realcombarra0 = new RealComBarra({
    			props: {
    				label: "Destinado",
    				value: /*row*/ ctx[11].destinado,
    				total: /*totais*/ ctx[2].destinado
    			},
    			$$inline: true
    		});

    	const realcombarra1 = new RealComBarra({
    			props: {
    				label: "Recebido",
    				value: /*row*/ ctx[11].recebido,
    				total: /*totais*/ ctx[2].recebido
    			},
    			$$inline: true
    		});

    	const percentualcombarra0 = new PercentualComBarra({
    			props: {
    				label: "Destinado X Recebido",
    				value: /*row*/ ctx[11].destinadoXRecebido
    			},
    			$$inline: true
    		});

    	const percentualcombarra1 = new PercentualComBarra({
    			props: {
    				label: "Aplicação no Magistério",
    				value: /*row*/ ctx[11].aplicacaoMagisterio
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			create_component(barra.$$.fragment);
    			t4 = space();
    			create_component(realcombarra0.$$.fragment);
    			t5 = space();
    			create_component(realcombarra1.$$.fragment);
    			t6 = space();
    			create_component(percentualcombarra0.$$.fragment);
    			t7 = space();
    			create_component(percentualcombarra1.$$.fragment);
    			attr_dev(td0, "data-label", "Município");
    			attr_dev(td0, "class", "font-bold");
    			add_location(td0, file$l, 92, 8, 2511);
    			attr_dev(td1, "data-label", "Alunos");
    			attr_dev(td1, "class", "text-right");
    			attr_dev(td1, "title", td1_title_value = /*row*/ ctx[11].quantidadeAlunos);
    			add_location(td1, file$l, 93, 8, 2586);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td0, anchor);
    			append_dev(td0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, td1, anchor);
    			append_dev(td1, t2);
    			append_dev(td1, t3);
    			mount_component(barra, td1, null);
    			insert_dev(target, t4, anchor);
    			mount_component(realcombarra0, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(realcombarra1, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(percentualcombarra0, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(percentualcombarra1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*rows2*/ 1024) && t0_value !== (t0_value = /*row*/ ctx[11].municipio + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*rows2*/ 1024) && t2_value !== (t2_value = /*row*/ ctx[11].quantidadeAlunos + "")) set_data_dev(t2, t2_value);
    			const barra_changes = {};
    			if (dirty & /*rows2, totais*/ 1028) barra_changes.value = /*row*/ ctx[11].quantidadeAlunos * 100 / /*totais*/ ctx[2].quantidadeAlunos;
    			barra.$set(barra_changes);

    			if (!current || dirty & /*rows2*/ 1024 && td1_title_value !== (td1_title_value = /*row*/ ctx[11].quantidadeAlunos)) {
    				attr_dev(td1, "title", td1_title_value);
    			}

    			const realcombarra0_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra0_changes.value = /*row*/ ctx[11].destinado;
    			if (dirty & /*totais*/ 4) realcombarra0_changes.total = /*totais*/ ctx[2].destinado;
    			realcombarra0.$set(realcombarra0_changes);
    			const realcombarra1_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra1_changes.value = /*row*/ ctx[11].recebido;
    			if (dirty & /*totais*/ 4) realcombarra1_changes.total = /*totais*/ ctx[2].recebido;
    			realcombarra1.$set(realcombarra1_changes);
    			const percentualcombarra0_changes = {};
    			if (dirty & /*rows2*/ 1024) percentualcombarra0_changes.value = /*row*/ ctx[11].destinadoXRecebido;
    			percentualcombarra0.$set(percentualcombarra0_changes);
    			const percentualcombarra1_changes = {};
    			if (dirty & /*rows2*/ 1024) percentualcombarra1_changes.value = /*row*/ ctx[11].aplicacaoMagisterio;
    			percentualcombarra1.$set(percentualcombarra1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(barra.$$.fragment, local);
    			transition_in(realcombarra0.$$.fragment, local);
    			transition_in(realcombarra1.$$.fragment, local);
    			transition_in(percentualcombarra0.$$.fragment, local);
    			transition_in(percentualcombarra1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(barra.$$.fragment, local);
    			transition_out(realcombarra0.$$.fragment, local);
    			transition_out(realcombarra1.$$.fragment, local);
    			transition_out(percentualcombarra0.$$.fragment, local);
    			transition_out(percentualcombarra1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(td1);
    			destroy_component(barra);
    			if (detaching) detach_dev(t4);
    			destroy_component(realcombarra0, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(realcombarra1, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(percentualcombarra0, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(percentualcombarra1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(92:6) <Row {index} on:click={() => onCellClick(row)}>",
    		ctx
    	});

    	return block;
    }

    // (91:4) {#each rows2 as row, index (row)}
    function create_each_block$7(key_1, ctx) {
    	let first;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[9](/*row*/ ctx[11], ...args);
    	}

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[13],
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*rows2*/ 1024) row_changes.index = /*index*/ ctx[13];

    			if (dirty & /*$$scope, rows2, totais*/ 17412) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(91:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (115:4) <Row>
    function create_default_slot_1$6(ctx) {
    	let td;
    	let t1;
    	let t2;
    	let t3;
    	let current;

    	const total0 = new Total({
    			props: {
    				label: "Alunos",
    				total: /*totais*/ ctx[2].quantidadeAlunos
    			},
    			$$inline: true
    		});

    	const total1 = new Total({
    			props: {
    				label: "Destinado",
    				total: /*totais*/ ctx[2].destinado
    			},
    			$$inline: true
    		});

    	const total2 = new Total({
    			props: {
    				label: "Recebido",
    				total: /*totais*/ ctx[2].recebido
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			td.textContent = "Totais";
    			t1 = space();
    			create_component(total0.$$.fragment);
    			t2 = space();
    			create_component(total1.$$.fragment);
    			t3 = space();
    			create_component(total2.$$.fragment);
    			attr_dev(td, "data-label", "Total");
    			add_location(td, file$l, 115, 6, 3327);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(total0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(total1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(total2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const total0_changes = {};
    			if (dirty & /*totais*/ 4) total0_changes.total = /*totais*/ ctx[2].quantidadeAlunos;
    			total0.$set(total0_changes);
    			const total1_changes = {};
    			if (dirty & /*totais*/ 4) total1_changes.total = /*totais*/ ctx[2].destinado;
    			total1.$set(total1_changes);
    			const total2_changes = {};
    			if (dirty & /*totais*/ 4) total2_changes.total = /*totais*/ ctx[2].recebido;
    			total2.$set(total2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(total0.$$.fragment, local);
    			transition_in(total1.$$.fragment, local);
    			transition_in(total2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(total0.$$.fragment, local);
    			transition_out(total1.$$.fragment, local);
    			transition_out(total2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(total0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(total1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(total2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(115:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (123:2) <span slot="bottom" />
    function create_bottom_slot$4(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "bottom");
    			add_location(span, file$l, 122, 2, 3573);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_bottom_slot$4.name,
    		type: "slot",
    		source: "(123:2) <span slot=\\\"bottom\\\" />",
    		ctx
    	});

    	return block;
    }

    // (61:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$7(ctx) {
    	let t0;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let t2;
    	let current;
    	let each_value = /*rows2*/ ctx[10];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[11];
    	validate_each_keys(ctx, each_value, get_each_context$7, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$7(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$7(key, child_ctx));
    	}

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(row.$$.fragment);
    			t2 = space();
    			add_location(tbody, file$l, 89, 2, 2400);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t1);
    			mount_component(row, tbody, null);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, onCellClick, totais*/ 1028) {
    				const each_value = /*rows2*/ ctx[10];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$7, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$7, t1, get_each_context$7);
    				check_outros();
    			}

    			const row_changes = {};

    			if (dirty & /*$$scope, totais*/ 16388) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(row);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(61:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let t;
    	let current;

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[0],
    				page: /*page*/ ctx[3],
    				pageSize: /*pageSize*/ ctx[4],
    				rows: /*rows*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$7,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					bottom: [
    						create_bottom_slot$4,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					head: [
    						create_head_slot$5,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(table.$$.fragment);
    			document.title = "Educação FUNDEB";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const table_changes = {};
    			if (dirty & /*loading*/ 1) table_changes.loading = /*loading*/ ctx[0];
    			if (dirty & /*rows*/ 2) table_changes.rows = /*rows*/ ctx[1];

    			if (dirty & /*$$scope, totais, rows2*/ 17412) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onCellClick$4(row) {
    	
    } //alert(JSON.stringify(row));

    function instance$m($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(7, $params = $$value));
    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 100;
    	let totais = {};

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		$$invalidate(0, loading = true);

    		const res = await axios$1.post(api.getApiUrl("ControleSocial"), [
    			{
    				run: "Municipio.Indicador.EducacaoFUNDEB",
    				args: [ano]
    			}
    		]);

    		const data = res.data[0].value;

    		$$invalidate(2, totais = {
    			quantidadeAlunos: data.reduce((a, b) => a + b.quantidadeAlunos, 0),
    			destinado: data.reduce((a, b) => a + b.recebido, 0),
    			recebido: data.reduce((a, b) => a + b.recebido, 0)
    		});

    		$$invalidate(1, rows = res.data[0].value);
    		$$invalidate(0, loading = false);
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortString(rows, dir, key));
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortNumber(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Educacao_fundeb> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Educacao_fundeb", $$slots, []);
    	const click_handler = row => onCellClick$4();

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		sortNumber,
    		sortString,
    		Total,
    		Barra,
    		RealComBarra,
    		PercentualComBarra,
    		loading,
    		rows,
    		page,
    		pageSize,
    		totais,
    		refresh,
    		onCellClick: onCellClick$4,
    		onSortString,
    		onSortNumber,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(3, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(4, pageSize = $$props.pageSize);
    		if ("totais" in $$props) $$invalidate(2, totais = $$props.totais);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 128) {
    			 refresh($params);
    		}
    	};

    	return [
    		loading,
    		rows,
    		totais,
    		page,
    		pageSize,
    		onSortString,
    		onSortNumber,
    		$params,
    		refresh,
    		click_handler
    	];
    }

    class Educacao_fundeb extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Educacao_fundeb",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\_components\IEGMComBarra.svelte generated by Svelte v3.22.3 */
    const file$m = "src\\pages\\municipio\\[ano]\\indicadores\\_components\\IEGMComBarra.svelte";

    function create_fragment$n(ctx) {
    	let td;
    	let t0;
    	let t1;
    	let t2;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const barra = new Barra({
    			props: {
    				value: getPercentual(/*value*/ ctx[1]),
    				isPositivo: /*isPositivo*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			t1 = text(/*formatted*/ ctx[3]);
    			t2 = space();
    			create_component(barra.$$.fragment);
    			attr_dev(td, "data-label", /*label*/ ctx[0]);
    			attr_dev(td, "class", "text-right");
    			attr_dev(td, "title", /*formatted*/ ctx[3]);
    			add_location(td, file$m, 39, 0, 651);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);

    			if (default_slot) {
    				default_slot.m(td, null);
    			}

    			append_dev(td, t0);
    			append_dev(td, t1);
    			append_dev(td, t2);
    			mount_component(barra, td, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[4], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null));
    				}
    			}

    			if (!current || dirty & /*formatted*/ 8) set_data_dev(t1, /*formatted*/ ctx[3]);
    			const barra_changes = {};
    			if (dirty & /*value*/ 2) barra_changes.value = getPercentual(/*value*/ ctx[1]);
    			if (dirty & /*isPositivo*/ 4) barra_changes.isPositivo = /*isPositivo*/ ctx[2];
    			barra.$set(barra_changes);

    			if (!current || dirty & /*label*/ 1) {
    				attr_dev(td, "data-label", /*label*/ ctx[0]);
    			}

    			if (!current || dirty & /*formatted*/ 8) {
    				attr_dev(td, "title", /*formatted*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(barra.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(barra.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (default_slot) default_slot.d(detaching);
    			destroy_component(barra);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getPercentual(value) {
    	if (!value) {
    		value = 6;
    	}

    	value = 6 - value;
    	return value * 100 / 5;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { value } = $$props;
    	let { isPositivo = v => v >= 0 } = $$props;
    	let formatted = "";
    	const writable_props = ["label", "value", "isPositivo"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IEGMComBarra> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("IEGMComBarra", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("isPositivo" in $$props) $$invalidate(2, isPositivo = $$props.isPositivo);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Barra,
    		label,
    		value,
    		isPositivo,
    		formatted,
    		getPercentual
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("isPositivo" in $$props) $$invalidate(2, isPositivo = $$props.isPositivo);
    		if ("formatted" in $$props) $$invalidate(3, formatted = $$props.formatted);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 2) {
    			 switch (value) {
    				case 1:
    					$$invalidate(3, formatted = "A");
    					break;
    				case 2:
    					$$invalidate(3, formatted = "B+");
    					break;
    				case 3:
    					$$invalidate(3, formatted = "B");
    					break;
    				case 4:
    					$$invalidate(3, formatted = "C+");
    					break;
    				case 5:
    					$$invalidate(3, formatted = "C");
    					break;
    				default:
    					$$invalidate(3, formatted = "?");
    					break;
    			}
    		}
    	};

    	return [label, value, isPositivo, formatted, $$scope, $$slots];
    }

    class IEGMComBarra extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { label: 0, value: 1, isPositivo: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IEGMComBarra",
    			options,
    			id: create_fragment$n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
    			console.warn("<IEGMComBarra> was created without expected prop 'label'");
    		}

    		if (/*value*/ ctx[1] === undefined && !("value" in props)) {
    			console.warn("<IEGMComBarra> was created without expected prop 'value'");
    		}
    	}

    	get label() {
    		throw new Error("<IEGMComBarra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<IEGMComBarra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<IEGMComBarra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<IEGMComBarra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isPositivo() {
    		throw new Error("<IEGMComBarra>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isPositivo(value) {
    		throw new Error("<IEGMComBarra>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\iegm\index.svelte generated by Svelte v3.22.3 */
    const file$n = "src\\pages\\municipio\\[ano]\\indicadores\\iegm\\index.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (53:2) <thead slot="head">
    function create_head_slot$6(ctx) {
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let t1;
    	let th1;
    	let t2;
    	let t3;
    	let th2;
    	let t4;
    	let t5;
    	let th3;
    	let t6;
    	let t7;
    	let th4;
    	let t8;
    	let t9;
    	let th5;
    	let t10;
    	let t11;
    	let th6;
    	let t12;
    	let t13;
    	let th7;
    	let t14;
    	let t15;
    	let th8;
    	let t16;
    	let current;

    	const sort0 = new Sort({
    			props: { key: "municipio" },
    			$$inline: true
    		});

    	sort0.$on("sort", /*onSortString*/ ctx[4]);

    	const sort1 = new Sort({
    			props: { key: "municipal" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortNumber*/ ctx[5]);

    	const sort2 = new Sort({
    			props: { key: "educacao" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortNumber*/ ctx[5]);
    	const sort3 = new Sort({ props: { key: "saude" }, $$inline: true });
    	sort3.$on("sort", /*onSortNumber*/ ctx[5]);

    	const sort4 = new Sort({
    			props: { key: "planejamento" },
    			$$inline: true
    		});

    	sort4.$on("sort", /*onSortNumber*/ ctx[5]);
    	const sort5 = new Sort({ props: { key: "fiscal" }, $$inline: true });
    	sort5.$on("sort", /*onSortNumber*/ ctx[5]);

    	const sort6 = new Sort({
    			props: { key: "meioAmbiente" },
    			$$inline: true
    		});

    	sort6.$on("sort", /*onSortNumber*/ ctx[5]);

    	const sort7 = new Sort({
    			props: { key: "seguranca" },
    			$$inline: true
    		});

    	sort7.$on("sort", /*onSortNumber*/ ctx[5]);

    	const sort8 = new Sort({
    			props: { key: "tecnologiaDaInformacao" },
    			$$inline: true
    		});

    	sort8.$on("sort", /*onSortNumber*/ ctx[5]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text("Municípios\r\n        ");
    			create_component(sort0.$$.fragment);
    			t1 = space();
    			th1 = element("th");
    			t2 = text("Municipal\r\n        ");
    			create_component(sort1.$$.fragment);
    			t3 = space();
    			th2 = element("th");
    			t4 = text("Educação\r\n        ");
    			create_component(sort2.$$.fragment);
    			t5 = space();
    			th3 = element("th");
    			t6 = text("Saúde\r\n        ");
    			create_component(sort3.$$.fragment);
    			t7 = space();
    			th4 = element("th");
    			t8 = text("Planejamento\r\n        ");
    			create_component(sort4.$$.fragment);
    			t9 = space();
    			th5 = element("th");
    			t10 = text("Fiscal\r\n        ");
    			create_component(sort5.$$.fragment);
    			t11 = space();
    			th6 = element("th");
    			t12 = text("Meio ambiente\r\n        ");
    			create_component(sort6.$$.fragment);
    			t13 = space();
    			th7 = element("th");
    			t14 = text("Segurança\r\n        ");
    			create_component(sort7.$$.fragment);
    			t15 = space();
    			th8 = element("th");
    			t16 = text("Tecnologia da Informação\r\n        ");
    			create_component(sort8.$$.fragment);
    			add_location(th0, file$n, 54, 6, 1357);
    			add_location(th1, file$n, 58, 6, 1459);
    			add_location(th2, file$n, 62, 6, 1560);
    			add_location(th3, file$n, 66, 6, 1659);
    			add_location(th4, file$n, 70, 6, 1752);
    			add_location(th5, file$n, 74, 6, 1859);
    			add_location(th6, file$n, 78, 6, 1954);
    			add_location(th7, file$n, 82, 6, 2062);
    			add_location(th8, file$n, 86, 6, 2163);
    			add_location(tr, file$n, 53, 4, 1345);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$n, 52, 2, 1320);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			mount_component(sort0, th0, null);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			mount_component(sort1, th1, null);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			mount_component(sort2, th2, null);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			mount_component(sort3, th3, null);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			mount_component(sort4, th4, null);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(th5, t10);
    			mount_component(sort5, th5, null);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(th6, t12);
    			mount_component(sort6, th6, null);
    			append_dev(tr, t13);
    			append_dev(tr, th7);
    			append_dev(th7, t14);
    			mount_component(sort7, th7, null);
    			append_dev(tr, t15);
    			append_dev(tr, th8);
    			append_dev(th8, t16);
    			mount_component(sort8, th8, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			transition_in(sort3.$$.fragment, local);
    			transition_in(sort4.$$.fragment, local);
    			transition_in(sort5.$$.fragment, local);
    			transition_in(sort6.$$.fragment, local);
    			transition_in(sort7.$$.fragment, local);
    			transition_in(sort8.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			transition_out(sort3.$$.fragment, local);
    			transition_out(sort4.$$.fragment, local);
    			transition_out(sort5.$$.fragment, local);
    			transition_out(sort6.$$.fragment, local);
    			transition_out(sort7.$$.fragment, local);
    			transition_out(sort8.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    			destroy_component(sort3);
    			destroy_component(sort4);
    			destroy_component(sort5);
    			destroy_component(sort6);
    			destroy_component(sort7);
    			destroy_component(sort8);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot$6.name,
    		type: "slot",
    		source: "(53:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (95:6) <Row {index} on:click={() => onCellClick(row)}>
    function create_default_slot_1$7(ctx) {
    	let td;
    	let t0_value = /*row*/ ctx[10].municipio + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let current;

    	const iegmcombarra0 = new IEGMComBarra({
    			props: {
    				label: "Municipal",
    				value: /*row*/ ctx[10].municipal
    			},
    			$$inline: true
    		});

    	const iegmcombarra1 = new IEGMComBarra({
    			props: {
    				label: "Educação",
    				value: /*row*/ ctx[10].educacao
    			},
    			$$inline: true
    		});

    	const iegmcombarra2 = new IEGMComBarra({
    			props: {
    				label: "Saúde",
    				value: /*row*/ ctx[10].saude
    			},
    			$$inline: true
    		});

    	const iegmcombarra3 = new IEGMComBarra({
    			props: {
    				label: "Planejamento",
    				value: /*row*/ ctx[10].planejamento
    			},
    			$$inline: true
    		});

    	const iegmcombarra4 = new IEGMComBarra({
    			props: {
    				label: "Fiscal",
    				value: /*row*/ ctx[10].fiscal
    			},
    			$$inline: true
    		});

    	const iegmcombarra5 = new IEGMComBarra({
    			props: {
    				label: "Meio ambiente",
    				value: /*row*/ ctx[10].meioAmbiente
    			},
    			$$inline: true
    		});

    	const iegmcombarra6 = new IEGMComBarra({
    			props: {
    				label: "Segurança",
    				value: /*row*/ ctx[10].seguranca
    			},
    			$$inline: true
    		});

    	const iegmcombarra7 = new IEGMComBarra({
    			props: {
    				label: "Tecnologia da Informação",
    				value: /*row*/ ctx[10].tecnologiaDaInformacao
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(iegmcombarra0.$$.fragment);
    			t2 = space();
    			create_component(iegmcombarra1.$$.fragment);
    			t3 = space();
    			create_component(iegmcombarra2.$$.fragment);
    			t4 = space();
    			create_component(iegmcombarra3.$$.fragment);
    			t5 = space();
    			create_component(iegmcombarra4.$$.fragment);
    			t6 = space();
    			create_component(iegmcombarra5.$$.fragment);
    			t7 = space();
    			create_component(iegmcombarra6.$$.fragment);
    			t8 = space();
    			create_component(iegmcombarra7.$$.fragment);
    			t9 = space();
    			attr_dev(td, "data-label", "Município");
    			attr_dev(td, "class", "font-bold");
    			add_location(td, file$n, 95, 8, 2422);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t0);
    			insert_dev(target, t1, anchor);
    			mount_component(iegmcombarra0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(iegmcombarra1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(iegmcombarra2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(iegmcombarra3, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(iegmcombarra4, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(iegmcombarra5, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(iegmcombarra6, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(iegmcombarra7, target, anchor);
    			insert_dev(target, t9, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*rows2*/ 512) && t0_value !== (t0_value = /*row*/ ctx[10].municipio + "")) set_data_dev(t0, t0_value);
    			const iegmcombarra0_changes = {};
    			if (dirty & /*rows2*/ 512) iegmcombarra0_changes.value = /*row*/ ctx[10].municipal;
    			iegmcombarra0.$set(iegmcombarra0_changes);
    			const iegmcombarra1_changes = {};
    			if (dirty & /*rows2*/ 512) iegmcombarra1_changes.value = /*row*/ ctx[10].educacao;
    			iegmcombarra1.$set(iegmcombarra1_changes);
    			const iegmcombarra2_changes = {};
    			if (dirty & /*rows2*/ 512) iegmcombarra2_changes.value = /*row*/ ctx[10].saude;
    			iegmcombarra2.$set(iegmcombarra2_changes);
    			const iegmcombarra3_changes = {};
    			if (dirty & /*rows2*/ 512) iegmcombarra3_changes.value = /*row*/ ctx[10].planejamento;
    			iegmcombarra3.$set(iegmcombarra3_changes);
    			const iegmcombarra4_changes = {};
    			if (dirty & /*rows2*/ 512) iegmcombarra4_changes.value = /*row*/ ctx[10].fiscal;
    			iegmcombarra4.$set(iegmcombarra4_changes);
    			const iegmcombarra5_changes = {};
    			if (dirty & /*rows2*/ 512) iegmcombarra5_changes.value = /*row*/ ctx[10].meioAmbiente;
    			iegmcombarra5.$set(iegmcombarra5_changes);
    			const iegmcombarra6_changes = {};
    			if (dirty & /*rows2*/ 512) iegmcombarra6_changes.value = /*row*/ ctx[10].seguranca;
    			iegmcombarra6.$set(iegmcombarra6_changes);
    			const iegmcombarra7_changes = {};
    			if (dirty & /*rows2*/ 512) iegmcombarra7_changes.value = /*row*/ ctx[10].tecnologiaDaInformacao;
    			iegmcombarra7.$set(iegmcombarra7_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iegmcombarra0.$$.fragment, local);
    			transition_in(iegmcombarra1.$$.fragment, local);
    			transition_in(iegmcombarra2.$$.fragment, local);
    			transition_in(iegmcombarra3.$$.fragment, local);
    			transition_in(iegmcombarra4.$$.fragment, local);
    			transition_in(iegmcombarra5.$$.fragment, local);
    			transition_in(iegmcombarra6.$$.fragment, local);
    			transition_in(iegmcombarra7.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iegmcombarra0.$$.fragment, local);
    			transition_out(iegmcombarra1.$$.fragment, local);
    			transition_out(iegmcombarra2.$$.fragment, local);
    			transition_out(iegmcombarra3.$$.fragment, local);
    			transition_out(iegmcombarra4.$$.fragment, local);
    			transition_out(iegmcombarra5.$$.fragment, local);
    			transition_out(iegmcombarra6.$$.fragment, local);
    			transition_out(iegmcombarra7.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(iegmcombarra0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(iegmcombarra1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(iegmcombarra2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(iegmcombarra3, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(iegmcombarra4, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(iegmcombarra5, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(iegmcombarra6, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(iegmcombarra7, detaching);
    			if (detaching) detach_dev(t9);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(95:6) <Row {index} on:click={() => onCellClick(row)}>",
    		ctx
    	});

    	return block;
    }

    // (94:4) {#each rows2 as row, index (row)}
    function create_each_block$8(key_1, ctx) {
    	let first;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[8](/*row*/ ctx[10], ...args);
    	}

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[12],
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*rows2*/ 512) row_changes.index = /*index*/ ctx[12];

    			if (dirty & /*$$scope, rows2*/ 8704) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(94:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (111:2) <span slot="bottom" />
    function create_bottom_slot$5(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "bottom");
    			add_location(span, file$n, 110, 2, 3107);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_bottom_slot$5.name,
    		type: "slot",
    		source: "(111:2) <span slot=\\\"bottom\\\" />",
    		ctx
    	});

    	return block;
    }

    // (52:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$8(ctx) {
    	let t0;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let current;
    	let each_value = /*rows2*/ ctx[9];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[10];
    	validate_each_keys(ctx, each_value, get_each_context$8, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$8(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			t0 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(tbody, file$n, 92, 2, 2311);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, onCellClick*/ 512) {
    				const each_value = /*rows2*/ ctx[9];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$8, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$8, null, get_each_context$8);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(52:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let t;
    	let current;

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[0],
    				page: /*page*/ ctx[2],
    				pageSize: /*pageSize*/ ctx[3],
    				rows: /*rows*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$8,
    						({ rows: rows2 }) => ({ 9: rows2 }),
    						({ rows: rows2 }) => rows2 ? 512 : 0
    					],
    					bottom: [
    						create_bottom_slot$5,
    						({ rows: rows2 }) => ({ 9: rows2 }),
    						({ rows: rows2 }) => rows2 ? 512 : 0
    					],
    					head: [
    						create_head_slot$6,
    						({ rows: rows2 }) => ({ 9: rows2 }),
    						({ rows: rows2 }) => rows2 ? 512 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(table.$$.fragment);
    			document.title = "IEGM";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const table_changes = {};
    			if (dirty & /*loading*/ 1) table_changes.loading = /*loading*/ ctx[0];
    			if (dirty & /*rows*/ 2) table_changes.rows = /*rows*/ ctx[1];

    			if (dirty & /*$$scope, rows2*/ 8704) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onCellClick$5(row) {
    	
    } //alert(JSON.stringify(row));

    function instance$o($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(6, $params = $$value));
    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 100;

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		$$invalidate(0, loading = true);

    		//checar se o ano é valido, senão redirecionar para o ano correto
    		const res = await axios$1.post(api.getApiUrl("ControleSocial"), [
    			{
    				run: "Municipio.Indicador.IEGM",
    				args: [ano]
    			}
    		]);

    		const data = res.data[0].value;
    		$$invalidate(1, rows = res.data[0].value);
    		$$invalidate(0, loading = false);
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortString(rows, dir, key));
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortNumber(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Iegm> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Iegm", $$slots, []);
    	const click_handler = row => onCellClick$5();

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		sortNumber,
    		sortString,
    		IEGMComBarra,
    		loading,
    		rows,
    		page,
    		pageSize,
    		refresh,
    		onCellClick: onCellClick$5,
    		onSortString,
    		onSortNumber,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(2, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(3, pageSize = $$props.pageSize);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 64) {
    			 refresh($params);
    		}
    	};

    	return [
    		loading,
    		rows,
    		page,
    		pageSize,
    		onSortString,
    		onSortNumber,
    		$params,
    		refresh,
    		click_handler
    	];
    }

    class Iegm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Iegm",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    var faHandPaper = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'far';
    var iconName = 'hand-paper';
    var width = 448;
    var height = 512;
    var ligatures = [];
    var unicode = 'f256';
    var svgPathData = 'M372.57 112.641v-10.825c0-43.612-40.52-76.691-83.039-65.546-25.629-49.5-94.09-47.45-117.982.747C130.269 26.456 89.144 57.945 89.144 102v126.13c-19.953-7.427-43.308-5.068-62.083 8.871-29.355 21.796-35.794 63.333-14.55 93.153L132.48 498.569a32 32 0 0 0 26.062 13.432h222.897c14.904 0 27.835-10.289 31.182-24.813l30.184-130.958A203.637 203.637 0 0 0 448 310.564V179c0-40.62-35.523-71.992-75.43-66.359zm27.427 197.922c0 11.731-1.334 23.469-3.965 34.886L368.707 464h-201.92L51.591 302.303c-14.439-20.27 15.023-42.776 29.394-22.605l27.128 38.079c8.995 12.626 29.031 6.287 29.031-9.283V102c0-25.645 36.571-24.81 36.571.691V256c0 8.837 7.163 16 16 16h6.856c8.837 0 16-7.163 16-16V67c0-25.663 36.571-24.81 36.571.691V256c0 8.837 7.163 16 16 16h6.856c8.837 0 16-7.163 16-16V101.125c0-25.672 36.57-24.81 36.57.691V256c0 8.837 7.163 16 16 16h6.857c8.837 0 16-7.163 16-16v-76.309c0-26.242 36.57-25.64 36.57-.691v131.563z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faHandPaper = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faHandPaper);
    var faHandPaper_1 = faHandPaper.definition;
    var faHandPaper_2 = faHandPaper.faHandPaper;
    var faHandPaper_3 = faHandPaper.prefix;
    var faHandPaper_4 = faHandPaper.iconName;
    var faHandPaper_5 = faHandPaper.width;
    var faHandPaper_6 = faHandPaper.height;
    var faHandPaper_7 = faHandPaper.ligatures;
    var faHandPaper_8 = faHandPaper.unicode;
    var faHandPaper_9 = faHandPaper.svgPathData;

    /* src\pages\municipio\[ano]\indicadores\_components\AlertaLimiteConstitucionalPessoal.svelte generated by Svelte v3.22.3 */
    const file$o = "src\\pages\\municipio\\[ano]\\indicadores\\_components\\AlertaLimiteConstitucionalPessoal.svelte";

    // (29:0) {:else}
    function create_else_block$4(ctx) {
    	let span;
    	let span_title_value;
    	let current;

    	const icon = new Icon({
    			props: { icon: faThumbsUp_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "class", "text-blue-800");
    			attr_dev(span, "title", span_title_value = `Obedeceu o limite de ${/*config*/ ctx[1].limite}%`);
    			add_location(span, file$o, 29, 2, 929);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*config*/ 2 && span_title_value !== (span_title_value = `Obedeceu o limite de ${/*config*/ ctx[1].limite}%`)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(29:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:38) 
    function create_if_block_2$1(ctx) {
    	let span;
    	let span_title_value;
    	let current;

    	const icon = new Icon({
    			props: { icon: faHandPaper_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "class", "text-yellow-400");
    			attr_dev(span, "title", span_title_value = `Ultrapassou o limite de alerta ${/*config*/ ctx[1].limiteAlerta}%`);
    			add_location(span, file$o, 23, 2, 767);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*config*/ 2 && span_title_value !== (span_title_value = `Ultrapassou o limite de alerta ${/*config*/ ctx[1].limiteAlerta}%`)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(23:38) ",
    		ctx
    	});

    	return block;
    }

    // (17:42) 
    function create_if_block_1$6(ctx) {
    	let span;
    	let span_title_value;
    	let current;

    	const icon = new Icon({
    			props: { icon: faHandPaper_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "class", "text-orange-500");
    			attr_dev(span, "title", span_title_value = `Ultrapassou o limite prudencial ${/*config*/ ctx[1].limitePrudencial}%`);
    			add_location(span, file$o, 17, 2, 569);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*config*/ 2 && span_title_value !== (span_title_value = `Ultrapassou o limite prudencial ${/*config*/ ctx[1].limitePrudencial}%`)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(17:42) ",
    		ctx
    	});

    	return block;
    }

    // (11:0) {#if value > config.limite}
    function create_if_block$9(ctx) {
    	let span;
    	let span_title_value;
    	let current;

    	const icon = new Icon({
    			props: { icon: faThumbsDown_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "class", "text-red-800");
    			attr_dev(span, "title", span_title_value = `Ultrapassou o limite máximo ${/*config*/ ctx[1].limite}%`);
    			add_location(span, file$o, 11, 2, 383);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*config*/ 2 && span_title_value !== (span_title_value = `Ultrapassou o limite máximo ${/*config*/ ctx[1].limite}%`)) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(11:0) {#if value > config.limite}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$9, create_if_block_1$6, create_if_block_2$1, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*value*/ ctx[0] > /*config*/ ctx[1].limite) return 0;
    		if (/*value*/ ctx[0] > /*config*/ ctx[1].limitePrudencial) return 1;
    		if (/*value*/ ctx[0] > /*config*/ ctx[1].limiteAlerta) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { value } = $$props;
    	let { config = {} } = $$props;
    	const writable_props = ["value", "config"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AlertaLimiteConstitucionalPessoal> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("AlertaLimiteConstitucionalPessoal", $$slots, []);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("config" in $$props) $$invalidate(1, config = $$props.config);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		faThumbsDown: faThumbsDown_2,
    		faThumbsUp: faThumbsUp_2,
    		faHandPaper: faHandPaper_2,
    		value,
    		config
    	});

    	$$self.$inject_state = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("config" in $$props) $$invalidate(1, config = $$props.config);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, config];
    }

    class AlertaLimiteConstitucionalPessoal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { value: 0, config: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AlertaLimiteConstitucionalPessoal",
    			options,
    			id: create_fragment$p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console.warn("<AlertaLimiteConstitucionalPessoal> was created without expected prop 'value'");
    		}
    	}

    	get value() {
    		throw new Error("<AlertaLimiteConstitucionalPessoal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<AlertaLimiteConstitucionalPessoal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get config() {
    		throw new Error("<AlertaLimiteConstitucionalPessoal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set config(value) {
    		throw new Error("<AlertaLimiteConstitucionalPessoal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\pessoal\index.svelte generated by Svelte v3.22.3 */
    const file$p = "src\\pages\\municipio\\[ano]\\indicadores\\pessoal\\index.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    // (92:2) <thead slot="head">
    function create_head_slot$7(ctx) {
    	let thead;
    	let tr0;
    	let th0;
    	let t0;
    	let th1;
    	let t2;
    	let th2;
    	let t4;
    	let th3;
    	let t6;
    	let tr1;
    	let th4;
    	let t7;
    	let t8;
    	let th5;
    	let t9;
    	let t10;
    	let th6;
    	let t11;
    	let t12;
    	let th7;
    	let t13;
    	let t14;
    	let th8;
    	let t15;
    	let t16;
    	let th9;
    	let t17;
    	let t18;
    	let th10;
    	let t19;
    	let t20;
    	let th11;
    	let t21;
    	let t22;
    	let th12;
    	let t23;
    	let t24;
    	let th13;
    	let t25;
    	let current;

    	const sort0 = new Sort({
    			props: { key: "municipio" },
    			$$inline: true
    		});

    	sort0.$on("sort", /*onSortString*/ ctx[8]);

    	const sort1 = new Sort({
    			props: { key: "despesaConsolidada" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortNumber*/ ctx[9]);

    	const sort2 = new Sort({
    			props: { key: "despesaConsolidadaPerCapita" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortNumber*/ ctx[9]);

    	const sort3 = new Sort({
    			props: {
    				key: "despesaConsolidadaLimiteConstitucional"
    			},
    			$$inline: true
    		});

    	sort3.$on("sort", /*onSortNumber*/ ctx[9]);

    	const sort4 = new Sort({
    			props: { key: "despesaExecutivo" },
    			$$inline: true
    		});

    	sort4.$on("sort", /*onSortNumber*/ ctx[9]);

    	const sort5 = new Sort({
    			props: { key: "despesaExecutivoPerCapita" },
    			$$inline: true
    		});

    	sort5.$on("sort", /*onSortNumber*/ ctx[9]);

    	const sort6 = new Sort({
    			props: {
    				key: "despesaExecutivoLimiteConstitucional"
    			},
    			$$inline: true
    		});

    	sort6.$on("sort", /*onSortNumber*/ ctx[9]);

    	const sort7 = new Sort({
    			props: { key: "despesaLegislativo" },
    			$$inline: true
    		});

    	sort7.$on("sort", /*onSortNumber*/ ctx[9]);

    	const sort8 = new Sort({
    			props: { key: "despesaLegislativoPerCapita" },
    			$$inline: true
    		});

    	sort8.$on("sort", /*onSortNumber*/ ctx[9]);

    	const sort9 = new Sort({
    			props: {
    				key: "despesaLegislativoLimiteConstitucional"
    			},
    			$$inline: true
    		});

    	sort9.$on("sort", /*onSortNumber*/ ctx[9]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			t0 = space();
    			th1 = element("th");
    			th1.textContent = "Consolidada";
    			t2 = space();
    			th2 = element("th");
    			th2.textContent = "Executivo";
    			t4 = space();
    			th3 = element("th");
    			th3.textContent = "Legislativo";
    			t6 = space();
    			tr1 = element("tr");
    			th4 = element("th");
    			t7 = text("Municípios\r\n        ");
    			create_component(sort0.$$.fragment);
    			t8 = space();
    			th5 = element("th");
    			t9 = text("Despesa\r\n        ");
    			create_component(sort1.$$.fragment);
    			t10 = space();
    			th6 = element("th");
    			t11 = text("Per capita\r\n        ");
    			create_component(sort2.$$.fragment);
    			t12 = space();
    			th7 = element("th");
    			t13 = text("LRF\r\n        ");
    			create_component(sort3.$$.fragment);
    			t14 = space();
    			th8 = element("th");
    			t15 = text("Despesa\r\n        ");
    			create_component(sort4.$$.fragment);
    			t16 = space();
    			th9 = element("th");
    			t17 = text("Per capita\r\n        ");
    			create_component(sort5.$$.fragment);
    			t18 = space();
    			th10 = element("th");
    			t19 = text("LRF\r\n        ");
    			create_component(sort6.$$.fragment);
    			t20 = space();
    			th11 = element("th");
    			t21 = text("Despesa\r\n        ");
    			create_component(sort7.$$.fragment);
    			t22 = space();
    			th12 = element("th");
    			t23 = text("Per capita\r\n        ");
    			create_component(sort8.$$.fragment);
    			t24 = space();
    			th13 = element("th");
    			t25 = text("LRF\r\n        ");
    			create_component(sort9.$$.fragment);
    			attr_dev(th0, "class", "text-center border-0 border-b border-dashed border-gray-300");
    			attr_dev(th0, "colspan", "1");
    			attr_dev(th0, "rowspan", "1");
    			add_location(th0, file$p, 93, 6, 2565);
    			attr_dev(th1, "class", "text-center border-0 border-b border-dashed border-gray-300");
    			attr_dev(th1, "colspan", "3");
    			attr_dev(th1, "title", "Despesas Pessoais");
    			attr_dev(th1, "rowspan", "1");
    			add_location(th1, file$p, 97, 6, 2698);
    			attr_dev(th2, "class", "text-center border border-t-0 border-dashed border-gray-300");
    			attr_dev(th2, "colspan", "3");
    			attr_dev(th2, "title", "Despesas com Executivo");
    			attr_dev(th2, "rowspan", "1");
    			add_location(th2, file$p, 104, 6, 2898);
    			attr_dev(th3, "class", "text-center border-0 border-b border-dashed border-gray-300");
    			attr_dev(th3, "colspan", "3");
    			attr_dev(th3, "title", "Despesas com Legislativo");
    			attr_dev(th3, "rowspan", "1");
    			add_location(th3, file$p, 111, 6, 3101);
    			attr_dev(tr0, "role", "row");
    			attr_dev(tr0, "class", "h-10");
    			add_location(tr0, file$p, 92, 4, 2529);
    			add_location(th4, file$p, 120, 6, 3329);
    			add_location(th5, file$p, 124, 6, 3431);
    			add_location(th6, file$p, 128, 6, 3539);
    			add_location(th7, file$p, 132, 6, 3659);
    			add_location(th8, file$p, 138, 6, 3805);
    			add_location(th9, file$p, 142, 6, 3911);
    			add_location(th10, file$p, 146, 6, 4029);
    			add_location(th11, file$p, 152, 6, 4173);
    			add_location(th12, file$p, 156, 6, 4281);
    			add_location(th13, file$p, 160, 6, 4401);
    			add_location(tr1, file$p, 119, 4, 3317);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$p, 91, 2, 2504);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t0);
    			append_dev(tr0, th1);
    			append_dev(tr0, t2);
    			append_dev(tr0, th2);
    			append_dev(tr0, t4);
    			append_dev(tr0, th3);
    			append_dev(thead, t6);
    			append_dev(thead, tr1);
    			append_dev(tr1, th4);
    			append_dev(th4, t7);
    			mount_component(sort0, th4, null);
    			append_dev(tr1, t8);
    			append_dev(tr1, th5);
    			append_dev(th5, t9);
    			mount_component(sort1, th5, null);
    			append_dev(tr1, t10);
    			append_dev(tr1, th6);
    			append_dev(th6, t11);
    			mount_component(sort2, th6, null);
    			append_dev(tr1, t12);
    			append_dev(tr1, th7);
    			append_dev(th7, t13);
    			mount_component(sort3, th7, null);
    			append_dev(tr1, t14);
    			append_dev(tr1, th8);
    			append_dev(th8, t15);
    			mount_component(sort4, th8, null);
    			append_dev(tr1, t16);
    			append_dev(tr1, th9);
    			append_dev(th9, t17);
    			mount_component(sort5, th9, null);
    			append_dev(tr1, t18);
    			append_dev(tr1, th10);
    			append_dev(th10, t19);
    			mount_component(sort6, th10, null);
    			append_dev(tr1, t20);
    			append_dev(tr1, th11);
    			append_dev(th11, t21);
    			mount_component(sort7, th11, null);
    			append_dev(tr1, t22);
    			append_dev(tr1, th12);
    			append_dev(th12, t23);
    			mount_component(sort8, th12, null);
    			append_dev(tr1, t24);
    			append_dev(tr1, th13);
    			append_dev(th13, t25);
    			mount_component(sort9, th13, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			transition_in(sort3.$$.fragment, local);
    			transition_in(sort4.$$.fragment, local);
    			transition_in(sort5.$$.fragment, local);
    			transition_in(sort6.$$.fragment, local);
    			transition_in(sort7.$$.fragment, local);
    			transition_in(sort8.$$.fragment, local);
    			transition_in(sort9.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			transition_out(sort3.$$.fragment, local);
    			transition_out(sort4.$$.fragment, local);
    			transition_out(sort5.$$.fragment, local);
    			transition_out(sort6.$$.fragment, local);
    			transition_out(sort7.$$.fragment, local);
    			transition_out(sort8.$$.fragment, local);
    			transition_out(sort9.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    			destroy_component(sort3);
    			destroy_component(sort4);
    			destroy_component(sort5);
    			destroy_component(sort6);
    			destroy_component(sort7);
    			destroy_component(sort8);
    			destroy_component(sort9);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot$7.name,
    		type: "slot",
    		source: "(92:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (181:8) <PercentualComBarra            label="Limite constitucional"            isPositivo={v => v < configLimiteConstitucionalConsolidado.limite}            value={row.despesaConsolidadaLimiteConstitucional}>
    function create_default_slot_5(ctx) {
    	let current;

    	const limiteconstitucional = new AlertaLimiteConstitucionalPessoal({
    			props: {
    				config: /*configLimiteConstitucionalConsolidado*/ ctx[3],
    				value: /*row*/ ctx[17].despesaConsolidadaLimiteConstitucional
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(limiteconstitucional.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(limiteconstitucional, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const limiteconstitucional_changes = {};
    			if (dirty & /*rows2*/ 65536) limiteconstitucional_changes.value = /*row*/ ctx[17].despesaConsolidadaLimiteConstitucional;
    			limiteconstitucional.$set(limiteconstitucional_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(limiteconstitucional.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(limiteconstitucional.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(limiteconstitucional, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(181:8) <PercentualComBarra            label=\\\"Limite constitucional\\\"            isPositivo={v => v < configLimiteConstitucionalConsolidado.limite}            value={row.despesaConsolidadaLimiteConstitucional}>",
    		ctx
    	});

    	return block;
    }

    // (197:8) <PercentualComBarra            label="Limite constitucional"            isPositivo={v => v < configLimiteConstitucionalExecutivo.limite}            value={row.despesaExecutivoLimiteConstitucional}>
    function create_default_slot_4(ctx) {
    	let current;

    	const limiteconstitucional = new AlertaLimiteConstitucionalPessoal({
    			props: {
    				config: /*configLimiteConstitucionalExecutivo*/ ctx[4],
    				value: /*row*/ ctx[17].despesaExecutivoLimiteConstitucional
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(limiteconstitucional.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(limiteconstitucional, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const limiteconstitucional_changes = {};
    			if (dirty & /*rows2*/ 65536) limiteconstitucional_changes.value = /*row*/ ctx[17].despesaExecutivoLimiteConstitucional;
    			limiteconstitucional.$set(limiteconstitucional_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(limiteconstitucional.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(limiteconstitucional.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(limiteconstitucional, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(197:8) <PercentualComBarra            label=\\\"Limite constitucional\\\"            isPositivo={v => v < configLimiteConstitucionalExecutivo.limite}            value={row.despesaExecutivoLimiteConstitucional}>",
    		ctx
    	});

    	return block;
    }

    // (213:8) <PercentualComBarra            label="Limite constitucional"            isPositivo={v => v < configLimiteConstitucionalLegislativo.limite}            value={row.despesaLegislativoLimiteConstitucional}>
    function create_default_slot_3$1(ctx) {
    	let current;

    	const limiteconstitucional = new AlertaLimiteConstitucionalPessoal({
    			props: {
    				config: /*configLimiteConstitucionalLegislativo*/ ctx[5],
    				value: /*row*/ ctx[17].despesaLegislativoLimiteConstitucional
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(limiteconstitucional.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(limiteconstitucional, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const limiteconstitucional_changes = {};
    			if (dirty & /*rows2*/ 65536) limiteconstitucional_changes.value = /*row*/ ctx[17].despesaLegislativoLimiteConstitucional;
    			limiteconstitucional.$set(limiteconstitucional_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(limiteconstitucional.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(limiteconstitucional.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(limiteconstitucional, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(213:8) <PercentualComBarra            label=\\\"Limite constitucional\\\"            isPositivo={v => v < configLimiteConstitucionalLegislativo.limite}            value={row.despesaLegislativoLimiteConstitucional}>",
    		ctx
    	});

    	return block;
    }

    // (171:6) <Row {index} on:click={() => onCellClick(row)}>
    function create_default_slot_2$5(ctx) {
    	let td;
    	let t0_value = /*row*/ ctx[17].municipio + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let current;

    	const realcombarra0 = new RealComBarra({
    			props: {
    				label: "Despesa",
    				value: /*row*/ ctx[17].despesaConsolidada,
    				total: /*totais*/ ctx[2].despesaConsolidada
    			},
    			$$inline: true
    		});

    	const realcombarra1 = new RealComBarra({
    			props: {
    				label: "Per capita",
    				value: /*row*/ ctx[17].despesaConsolidadaPerCapita,
    				total: /*totais*/ ctx[2].despesaConsolidadaPerCapita
    			},
    			$$inline: true
    		});

    	const percentualcombarra0 = new PercentualComBarra({
    			props: {
    				label: "Limite constitucional",
    				isPositivo: /*func*/ ctx[12],
    				value: /*row*/ ctx[17].despesaConsolidadaLimiteConstitucional,
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const realcombarra2 = new RealComBarra({
    			props: {
    				label: "Despesa",
    				value: /*row*/ ctx[17].despesaExecutivo,
    				total: /*totais*/ ctx[2].despesaExecutivo
    			},
    			$$inline: true
    		});

    	const realcombarra3 = new RealComBarra({
    			props: {
    				label: "Per capita",
    				value: /*row*/ ctx[17].despesaExecutivoPerCapita,
    				total: /*totais*/ ctx[2].despesaExecutivoPerCapita
    			},
    			$$inline: true
    		});

    	const percentualcombarra1 = new PercentualComBarra({
    			props: {
    				label: "Limite constitucional",
    				isPositivo: /*func_1*/ ctx[13],
    				value: /*row*/ ctx[17].despesaExecutivoLimiteConstitucional,
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const realcombarra4 = new RealComBarra({
    			props: {
    				label: "Despesa",
    				value: /*row*/ ctx[17].despesaLegislativo,
    				total: /*totais*/ ctx[2].despesaLegislativo
    			},
    			$$inline: true
    		});

    	const realcombarra5 = new RealComBarra({
    			props: {
    				label: "Per capita",
    				value: /*row*/ ctx[17].despesaLegislativoPerCapita,
    				total: /*totais*/ ctx[2].despesaLegislativoPerCapita
    			},
    			$$inline: true
    		});

    	const percentualcombarra2 = new PercentualComBarra({
    			props: {
    				label: "Limite constitucional",
    				isPositivo: /*func_2*/ ctx[14],
    				value: /*row*/ ctx[17].despesaLegislativoLimiteConstitucional,
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(realcombarra0.$$.fragment);
    			t2 = space();
    			create_component(realcombarra1.$$.fragment);
    			t3 = space();
    			create_component(percentualcombarra0.$$.fragment);
    			t4 = space();
    			create_component(realcombarra2.$$.fragment);
    			t5 = space();
    			create_component(realcombarra3.$$.fragment);
    			t6 = space();
    			create_component(percentualcombarra1.$$.fragment);
    			t7 = space();
    			create_component(realcombarra4.$$.fragment);
    			t8 = space();
    			create_component(realcombarra5.$$.fragment);
    			t9 = space();
    			create_component(percentualcombarra2.$$.fragment);
    			attr_dev(td, "data-label", "Município");
    			attr_dev(td, "class", "font-bold");
    			add_location(td, file$p, 171, 8, 4677);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t0);
    			insert_dev(target, t1, anchor);
    			mount_component(realcombarra0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(realcombarra1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(percentualcombarra0, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(realcombarra2, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(realcombarra3, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(percentualcombarra1, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(realcombarra4, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(realcombarra5, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(percentualcombarra2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*rows2*/ 65536) && t0_value !== (t0_value = /*row*/ ctx[17].municipio + "")) set_data_dev(t0, t0_value);
    			const realcombarra0_changes = {};
    			if (dirty & /*rows2*/ 65536) realcombarra0_changes.value = /*row*/ ctx[17].despesaConsolidada;
    			if (dirty & /*totais*/ 4) realcombarra0_changes.total = /*totais*/ ctx[2].despesaConsolidada;
    			realcombarra0.$set(realcombarra0_changes);
    			const realcombarra1_changes = {};
    			if (dirty & /*rows2*/ 65536) realcombarra1_changes.value = /*row*/ ctx[17].despesaConsolidadaPerCapita;
    			if (dirty & /*totais*/ 4) realcombarra1_changes.total = /*totais*/ ctx[2].despesaConsolidadaPerCapita;
    			realcombarra1.$set(realcombarra1_changes);
    			const percentualcombarra0_changes = {};
    			if (dirty & /*rows2*/ 65536) percentualcombarra0_changes.value = /*row*/ ctx[17].despesaConsolidadaLimiteConstitucional;

    			if (dirty & /*$$scope, rows2*/ 1114112) {
    				percentualcombarra0_changes.$$scope = { dirty, ctx };
    			}

    			percentualcombarra0.$set(percentualcombarra0_changes);
    			const realcombarra2_changes = {};
    			if (dirty & /*rows2*/ 65536) realcombarra2_changes.value = /*row*/ ctx[17].despesaExecutivo;
    			if (dirty & /*totais*/ 4) realcombarra2_changes.total = /*totais*/ ctx[2].despesaExecutivo;
    			realcombarra2.$set(realcombarra2_changes);
    			const realcombarra3_changes = {};
    			if (dirty & /*rows2*/ 65536) realcombarra3_changes.value = /*row*/ ctx[17].despesaExecutivoPerCapita;
    			if (dirty & /*totais*/ 4) realcombarra3_changes.total = /*totais*/ ctx[2].despesaExecutivoPerCapita;
    			realcombarra3.$set(realcombarra3_changes);
    			const percentualcombarra1_changes = {};
    			if (dirty & /*rows2*/ 65536) percentualcombarra1_changes.value = /*row*/ ctx[17].despesaExecutivoLimiteConstitucional;

    			if (dirty & /*$$scope, rows2*/ 1114112) {
    				percentualcombarra1_changes.$$scope = { dirty, ctx };
    			}

    			percentualcombarra1.$set(percentualcombarra1_changes);
    			const realcombarra4_changes = {};
    			if (dirty & /*rows2*/ 65536) realcombarra4_changes.value = /*row*/ ctx[17].despesaLegislativo;
    			if (dirty & /*totais*/ 4) realcombarra4_changes.total = /*totais*/ ctx[2].despesaLegislativo;
    			realcombarra4.$set(realcombarra4_changes);
    			const realcombarra5_changes = {};
    			if (dirty & /*rows2*/ 65536) realcombarra5_changes.value = /*row*/ ctx[17].despesaLegislativoPerCapita;
    			if (dirty & /*totais*/ 4) realcombarra5_changes.total = /*totais*/ ctx[2].despesaLegislativoPerCapita;
    			realcombarra5.$set(realcombarra5_changes);
    			const percentualcombarra2_changes = {};
    			if (dirty & /*rows2*/ 65536) percentualcombarra2_changes.value = /*row*/ ctx[17].despesaLegislativoLimiteConstitucional;

    			if (dirty & /*$$scope, rows2*/ 1114112) {
    				percentualcombarra2_changes.$$scope = { dirty, ctx };
    			}

    			percentualcombarra2.$set(percentualcombarra2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(realcombarra0.$$.fragment, local);
    			transition_in(realcombarra1.$$.fragment, local);
    			transition_in(percentualcombarra0.$$.fragment, local);
    			transition_in(realcombarra2.$$.fragment, local);
    			transition_in(realcombarra3.$$.fragment, local);
    			transition_in(percentualcombarra1.$$.fragment, local);
    			transition_in(realcombarra4.$$.fragment, local);
    			transition_in(realcombarra5.$$.fragment, local);
    			transition_in(percentualcombarra2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(realcombarra0.$$.fragment, local);
    			transition_out(realcombarra1.$$.fragment, local);
    			transition_out(percentualcombarra0.$$.fragment, local);
    			transition_out(realcombarra2.$$.fragment, local);
    			transition_out(realcombarra3.$$.fragment, local);
    			transition_out(percentualcombarra1.$$.fragment, local);
    			transition_out(realcombarra4.$$.fragment, local);
    			transition_out(realcombarra5.$$.fragment, local);
    			transition_out(percentualcombarra2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(realcombarra0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(realcombarra1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(percentualcombarra0, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(realcombarra2, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(realcombarra3, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(percentualcombarra1, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(realcombarra4, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(realcombarra5, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(percentualcombarra2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(171:6) <Row {index} on:click={() => onCellClick(row)}>",
    		ctx
    	});

    	return block;
    }

    // (170:4) {#each rows2 as row, index (row)}
    function create_each_block$9(key_1, ctx) {
    	let first;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[15](/*row*/ ctx[17], ...args);
    	}

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[19],
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*rows2*/ 65536) row_changes.index = /*index*/ ctx[19];

    			if (dirty & /*$$scope, rows2, totais*/ 1114116) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(170:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (223:4) <Row>
    function create_default_slot_1$8(ctx) {
    	let td0;
    	let t1;
    	let t2;
    	let t3;
    	let td1;
    	let t4;
    	let t5;
    	let t6;
    	let td2;
    	let t7;
    	let t8;
    	let t9;
    	let td3;
    	let current;

    	const total0 = new Total({
    			props: {
    				label: "Despesa",
    				total: /*totais*/ ctx[2].despesaConsolidada
    			},
    			$$inline: true
    		});

    	const total1 = new Total({
    			props: {
    				label: "Per capita",
    				total: /*totais*/ ctx[2].despesaConsolidadaPerCapita
    			},
    			$$inline: true
    		});

    	const total2 = new Total({
    			props: {
    				label: "Despesa",
    				total: /*totais*/ ctx[2].despesaExecutivo
    			},
    			$$inline: true
    		});

    	const total3 = new Total({
    			props: {
    				label: "Per capita",
    				total: /*totais*/ ctx[2].despesaExecutivoPerCapita
    			},
    			$$inline: true
    		});

    	const total4 = new Total({
    			props: {
    				label: "Despesa",
    				total: /*totais*/ ctx[2].despesaLegislativo
    			},
    			$$inline: true
    		});

    	const total5 = new Total({
    			props: {
    				label: "Per capita",
    				total: /*totais*/ ctx[2].despesaLegislativoPerCapita
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td0 = element("td");
    			td0.textContent = "Totais";
    			t1 = space();
    			create_component(total0.$$.fragment);
    			t2 = space();
    			create_component(total1.$$.fragment);
    			t3 = space();
    			td1 = element("td");
    			t4 = space();
    			create_component(total2.$$.fragment);
    			t5 = space();
    			create_component(total3.$$.fragment);
    			t6 = space();
    			td2 = element("td");
    			t7 = space();
    			create_component(total4.$$.fragment);
    			t8 = space();
    			create_component(total5.$$.fragment);
    			t9 = space();
    			td3 = element("td");
    			attr_dev(td0, "data-label", "Total");
    			add_location(td0, file$p, 223, 6, 6881);
    			add_location(td1, file$p, 226, 6, 7069);
    			add_location(td2, file$p, 229, 6, 7225);
    			add_location(td3, file$p, 232, 6, 7385);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td0, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(total0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(total1, target, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, td1, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(total2, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(total3, target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, td2, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(total4, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(total5, target, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, td3, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const total0_changes = {};
    			if (dirty & /*totais*/ 4) total0_changes.total = /*totais*/ ctx[2].despesaConsolidada;
    			total0.$set(total0_changes);
    			const total1_changes = {};
    			if (dirty & /*totais*/ 4) total1_changes.total = /*totais*/ ctx[2].despesaConsolidadaPerCapita;
    			total1.$set(total1_changes);
    			const total2_changes = {};
    			if (dirty & /*totais*/ 4) total2_changes.total = /*totais*/ ctx[2].despesaExecutivo;
    			total2.$set(total2_changes);
    			const total3_changes = {};
    			if (dirty & /*totais*/ 4) total3_changes.total = /*totais*/ ctx[2].despesaExecutivoPerCapita;
    			total3.$set(total3_changes);
    			const total4_changes = {};
    			if (dirty & /*totais*/ 4) total4_changes.total = /*totais*/ ctx[2].despesaLegislativo;
    			total4.$set(total4_changes);
    			const total5_changes = {};
    			if (dirty & /*totais*/ 4) total5_changes.total = /*totais*/ ctx[2].despesaLegislativoPerCapita;
    			total5.$set(total5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(total0.$$.fragment, local);
    			transition_in(total1.$$.fragment, local);
    			transition_in(total2.$$.fragment, local);
    			transition_in(total3.$$.fragment, local);
    			transition_in(total4.$$.fragment, local);
    			transition_in(total5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(total0.$$.fragment, local);
    			transition_out(total1.$$.fragment, local);
    			transition_out(total2.$$.fragment, local);
    			transition_out(total3.$$.fragment, local);
    			transition_out(total4.$$.fragment, local);
    			transition_out(total5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td0);
    			if (detaching) detach_dev(t1);
    			destroy_component(total0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(total1, detaching);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(td1);
    			if (detaching) detach_dev(t4);
    			destroy_component(total2, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(total3, detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(td2);
    			if (detaching) detach_dev(t7);
    			destroy_component(total4, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(total5, detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(td3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(223:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (237:2) <span slot="bottom" />
    function create_bottom_slot$6(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "bottom");
    			add_location(span, file$p, 236, 2, 7421);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_bottom_slot$6.name,
    		type: "slot",
    		source: "(237:2) <span slot=\\\"bottom\\\" />",
    		ctx
    	});

    	return block;
    }

    // (91:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$9(ctx) {
    	let t0;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let t2;
    	let current;
    	let each_value = /*rows2*/ ctx[16];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[17];
    	validate_each_keys(ctx, each_value, get_each_context$9, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$9(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
    	}

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(row.$$.fragment);
    			t2 = space();
    			add_location(tbody, file$p, 168, 2, 4566);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t1);
    			mount_component(row, tbody, null);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, onCellClick, configLimiteConstitucionalLegislativo, totais, configLimiteConstitucionalExecutivo, configLimiteConstitucionalConsolidado*/ 65596) {
    				const each_value = /*rows2*/ ctx[16];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$9, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$9, t1, get_each_context$9);
    				check_outros();
    			}

    			const row_changes = {};

    			if (dirty & /*$$scope, totais*/ 1048580) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(row);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(91:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let t;
    	let current;

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[0],
    				page: /*page*/ ctx[6],
    				pageSize: /*pageSize*/ ctx[7],
    				rows: /*rows*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$9,
    						({ rows: rows2 }) => ({ 16: rows2 }),
    						({ rows: rows2 }) => rows2 ? 65536 : 0
    					],
    					bottom: [
    						create_bottom_slot$6,
    						({ rows: rows2 }) => ({ 16: rows2 }),
    						({ rows: rows2 }) => rows2 ? 65536 : 0
    					],
    					head: [
    						create_head_slot$7,
    						({ rows: rows2 }) => ({ 16: rows2 }),
    						({ rows: rows2 }) => rows2 ? 65536 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(table.$$.fragment);
    			document.title = "Pessoal";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const table_changes = {};
    			if (dirty & /*loading*/ 1) table_changes.loading = /*loading*/ ctx[0];
    			if (dirty & /*rows*/ 2) table_changes.rows = /*rows*/ ctx[1];

    			if (dirty & /*$$scope, totais, rows2*/ 1114116) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onCellClick$6(row) {
    	
    } //alert(JSON.stringify(row));

    function instance$q($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(10, $params = $$value));

    	const configLimiteConstitucionalConsolidado = {
    		limite: 60,
    		limitePrudencial: 57,
    		limiteAlerta: 54
    	};

    	const configLimiteConstitucionalExecutivo = {
    		limite: 54,
    		limitePrudencial: 51.3,
    		limiteAlerta: 48.6
    	};

    	const configLimiteConstitucionalLegislativo = {
    		limite: 6,
    		limitePrudencial: 5.7,
    		limiteAlerta: 5.4
    	};

    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 100;
    	let totais = {};

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		$$invalidate(0, loading = true);

    		const res = await axios$1.post(api.getApiUrl("ControleSocial"), [
    			{
    				run: "Municipio.Indicador.Pessoal",
    				args: [ano]
    			}
    		]);

    		const data = res.data[0].value;

    		$$invalidate(2, totais = {
    			despesaConsolidada: data.reduce((a, b) => a + b.despesaConsolidada, 0),
    			despesaConsolidadaPerCapita: data.reduce((a, b) => a + b.despesaConsolidadaPerCapita, 0),
    			despesaExecutivo: data.reduce((a, b) => a + b.despesaExecutivo, 0),
    			despesaExecutivoPerCapita: data.reduce((a, b) => a + b.despesaExecutivoPerCapita, 0),
    			despesaLegislativo: data.reduce((a, b) => a + b.despesaLegislativo, 0),
    			despesaLegislativoPerCapita: data.reduce((a, b) => a + b.despesaLegislativoPerCapita, 0)
    		});

    		$$invalidate(1, rows = res.data[0].value);
    		$$invalidate(0, loading = false);
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortString(rows, dir, key));
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortNumber(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Pessoal> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Pessoal", $$slots, []);
    	const func = v => v < configLimiteConstitucionalConsolidado.limite;
    	const func_1 = v => v < configLimiteConstitucionalExecutivo.limite;
    	const func_2 = v => v < configLimiteConstitucionalLegislativo.limite;
    	const click_handler = row => onCellClick$6();

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		sortNumber,
    		sortString,
    		RealComBarra,
    		PercentualComBarra,
    		Total,
    		LimiteConstitucional: AlertaLimiteConstitucionalPessoal,
    		configLimiteConstitucionalConsolidado,
    		configLimiteConstitucionalExecutivo,
    		configLimiteConstitucionalLegislativo,
    		loading,
    		rows,
    		page,
    		pageSize,
    		totais,
    		refresh,
    		onCellClick: onCellClick$6,
    		onSortString,
    		onSortNumber,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(6, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(7, pageSize = $$props.pageSize);
    		if ("totais" in $$props) $$invalidate(2, totais = $$props.totais);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 1024) {
    			 refresh($params);
    		}
    	};

    	return [
    		loading,
    		rows,
    		totais,
    		configLimiteConstitucionalConsolidado,
    		configLimiteConstitucionalExecutivo,
    		configLimiteConstitucionalLegislativo,
    		page,
    		pageSize,
    		onSortString,
    		onSortNumber,
    		$params,
    		refresh,
    		func,
    		func_1,
    		func_2,
    		click_handler
    	];
    }

    class Pessoal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pessoal",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\receitas\index.svelte generated by Svelte v3.22.3 */
    const file$q = "src\\pages\\municipio\\[ano]\\indicadores\\receitas\\index.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (62:2) <thead slot="head">
    function create_head_slot$8(ctx) {
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t4;
    	let t5;
    	let th3;
    	let t6;
    	let t7;
    	let th4;
    	let t8;
    	let t9;
    	let th5;
    	let t10;
    	let current;

    	const sort0 = new Sort({
    			props: { key: "municipio" },
    			$$inline: true
    		});

    	sort0.$on("sort", /*onSortString*/ ctx[5]);

    	const sort1 = new Sort({
    			props: { key: "prevista" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort2 = new Sort({
    			props: { key: "arrecadada" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort3 = new Sort({
    			props: { key: "perCapita" },
    			$$inline: true
    		});

    	sort3.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort4 = new Sort({
    			props: { key: "desempenho" },
    			$$inline: true
    		});

    	sort4.$on("sort", /*onSortNumber*/ ctx[6]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text("Municípios\r\n        ");
    			create_component(sort0.$$.fragment);
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Mês";
    			t3 = space();
    			th2 = element("th");
    			t4 = text("Prevista\r\n        ");
    			create_component(sort1.$$.fragment);
    			t5 = space();
    			th3 = element("th");
    			t6 = text("Arrecadada\r\n        ");
    			create_component(sort2.$$.fragment);
    			t7 = space();
    			th4 = element("th");
    			t8 = text("Per capita\r\n        ");
    			create_component(sort3.$$.fragment);
    			t9 = space();
    			th5 = element("th");
    			t10 = text("Desempenho\r\n        ");
    			create_component(sort4.$$.fragment);
    			add_location(th0, file$q, 63, 6, 1721);
    			set_style(th1, "width", "20px");
    			add_location(th1, file$q, 67, 6, 1823);
    			add_location(th2, file$q, 68, 6, 1863);
    			add_location(th3, file$q, 72, 6, 1962);
    			add_location(th4, file$q, 76, 6, 2065);
    			add_location(th5, file$q, 80, 6, 2167);
    			add_location(tr, file$q, 62, 4, 1709);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$q, 61, 2, 1684);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			mount_component(sort0, th0, null);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			mount_component(sort1, th2, null);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			mount_component(sort2, th3, null);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			mount_component(sort3, th4, null);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(th5, t10);
    			mount_component(sort4, th5, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			transition_in(sort3.$$.fragment, local);
    			transition_in(sort4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			transition_out(sort3.$$.fragment, local);
    			transition_out(sort4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    			destroy_component(sort3);
    			destroy_component(sort4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot$8.name,
    		type: "slot",
    		source: "(62:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (89:6) <Row {index} on:click={() => onCellClick(row)}>
    function create_default_slot_2$6(ctx) {
    	let td0;
    	let t0_value = /*row*/ ctx[11].municipio + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = mesesAbreviados[/*row*/ ctx[11].mes - 1] + "";
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let current;

    	const realcombarra0 = new RealComBarra({
    			props: {
    				label: "Prevista",
    				value: /*row*/ ctx[11].prevista,
    				total: /*totais*/ ctx[2].prevista
    			},
    			$$inline: true
    		});

    	const realcombarra1 = new RealComBarra({
    			props: {
    				label: "Arrecadada",
    				value: /*row*/ ctx[11].arrecadada,
    				total: /*totais*/ ctx[2].arrecadada
    			},
    			$$inline: true
    		});

    	const realcombarra2 = new RealComBarra({
    			props: {
    				label: "Per capita",
    				value: /*row*/ ctx[11].perCapita,
    				total: /*totais*/ ctx[2].perCapita
    			},
    			$$inline: true
    		});

    	const percentualcombarra = new PercentualComBarra({
    			props: {
    				label: "Desempenho",
    				value: /*row*/ ctx[11].desempenho
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			create_component(realcombarra0.$$.fragment);
    			t4 = space();
    			create_component(realcombarra1.$$.fragment);
    			t5 = space();
    			create_component(realcombarra2.$$.fragment);
    			t6 = space();
    			create_component(percentualcombarra.$$.fragment);
    			attr_dev(td0, "data-label", "Município");
    			attr_dev(td0, "class", "font-bold");
    			add_location(td0, file$q, 89, 8, 2400);
    			attr_dev(td1, "class", "text-center");
    			add_location(td1, file$q, 90, 8, 2475);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td0, anchor);
    			append_dev(td0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, td1, anchor);
    			append_dev(td1, t2);
    			insert_dev(target, t3, anchor);
    			mount_component(realcombarra0, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(realcombarra1, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(realcombarra2, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(percentualcombarra, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*rows2*/ 1024) && t0_value !== (t0_value = /*row*/ ctx[11].municipio + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*rows2*/ 1024) && t2_value !== (t2_value = mesesAbreviados[/*row*/ ctx[11].mes - 1] + "")) set_data_dev(t2, t2_value);
    			const realcombarra0_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra0_changes.value = /*row*/ ctx[11].prevista;
    			if (dirty & /*totais*/ 4) realcombarra0_changes.total = /*totais*/ ctx[2].prevista;
    			realcombarra0.$set(realcombarra0_changes);
    			const realcombarra1_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra1_changes.value = /*row*/ ctx[11].arrecadada;
    			if (dirty & /*totais*/ 4) realcombarra1_changes.total = /*totais*/ ctx[2].arrecadada;
    			realcombarra1.$set(realcombarra1_changes);
    			const realcombarra2_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra2_changes.value = /*row*/ ctx[11].perCapita;
    			if (dirty & /*totais*/ 4) realcombarra2_changes.total = /*totais*/ ctx[2].perCapita;
    			realcombarra2.$set(realcombarra2_changes);
    			const percentualcombarra_changes = {};
    			if (dirty & /*rows2*/ 1024) percentualcombarra_changes.value = /*row*/ ctx[11].desempenho;
    			percentualcombarra.$set(percentualcombarra_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(realcombarra0.$$.fragment, local);
    			transition_in(realcombarra1.$$.fragment, local);
    			transition_in(realcombarra2.$$.fragment, local);
    			transition_in(percentualcombarra.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(realcombarra0.$$.fragment, local);
    			transition_out(realcombarra1.$$.fragment, local);
    			transition_out(realcombarra2.$$.fragment, local);
    			transition_out(percentualcombarra.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(td1);
    			if (detaching) detach_dev(t3);
    			destroy_component(realcombarra0, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(realcombarra1, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(realcombarra2, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(percentualcombarra, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(89:6) <Row {index} on:click={() => onCellClick(row)}>",
    		ctx
    	});

    	return block;
    }

    // (88:4) {#each rows2 as row, index (row)}
    function create_each_block$a(key_1, ctx) {
    	let first;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[9](/*row*/ ctx[11], ...args);
    	}

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[13],
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*rows2*/ 1024) row_changes.index = /*index*/ ctx[13];

    			if (dirty & /*$$scope, rows2, totais*/ 17412) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(88:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (107:4) <Row>
    function create_default_slot_1$9(ctx) {
    	let td;
    	let t1;
    	let t2;
    	let t3;
    	let current;

    	const total0 = new Total({
    			props: {
    				label: "Prevista",
    				total: /*totais*/ ctx[2].prevista
    			},
    			$$inline: true
    		});

    	const total1 = new Total({
    			props: {
    				label: "Arrecadada",
    				total: /*totais*/ ctx[2].arrecadada
    			},
    			$$inline: true
    		});

    	const total2 = new Total({
    			props: {
    				label: "Per capita",
    				total: /*totais*/ ctx[2].perCapita
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			td.textContent = "Totais";
    			t1 = space();
    			create_component(total0.$$.fragment);
    			t2 = space();
    			create_component(total1.$$.fragment);
    			t3 = space();
    			create_component(total2.$$.fragment);
    			attr_dev(td, "data-label", "Total");
    			add_location(td, file$q, 107, 6, 3027);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(total0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(total1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(total2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const total0_changes = {};
    			if (dirty & /*totais*/ 4) total0_changes.total = /*totais*/ ctx[2].prevista;
    			total0.$set(total0_changes);
    			const total1_changes = {};
    			if (dirty & /*totais*/ 4) total1_changes.total = /*totais*/ ctx[2].arrecadada;
    			total1.$set(total1_changes);
    			const total2_changes = {};
    			if (dirty & /*totais*/ 4) total2_changes.total = /*totais*/ ctx[2].perCapita;
    			total2.$set(total2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(total0.$$.fragment, local);
    			transition_in(total1.$$.fragment, local);
    			transition_in(total2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(total0.$$.fragment, local);
    			transition_out(total1.$$.fragment, local);
    			transition_out(total2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(total0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(total1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(total2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(107:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (115:2) <span slot="bottom" />
    function create_bottom_slot$7(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "bottom");
    			add_location(span, file$q, 114, 2, 3272);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_bottom_slot$7.name,
    		type: "slot",
    		source: "(115:2) <span slot=\\\"bottom\\\" />",
    		ctx
    	});

    	return block;
    }

    // (61:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$a(ctx) {
    	let t0;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let t2;
    	let current;
    	let each_value = /*rows2*/ ctx[10];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[11];
    	validate_each_keys(ctx, each_value, get_each_context$a, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$a(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
    	}

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(row.$$.fragment);
    			t2 = space();
    			add_location(tbody, file$q, 86, 2, 2289);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t1);
    			mount_component(row, tbody, null);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, onCellClick, totais, mesesAbreviados*/ 1028) {
    				const each_value = /*rows2*/ ctx[10];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$a, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$a, t1, get_each_context$a);
    				check_outros();
    			}

    			const row_changes = {};

    			if (dirty & /*$$scope, totais*/ 16388) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(row);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(61:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let t;
    	let current;

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[0],
    				page: /*page*/ ctx[3],
    				pageSize: /*pageSize*/ ctx[4],
    				rows: /*rows*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$a,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					bottom: [
    						create_bottom_slot$7,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					head: [
    						create_head_slot$8,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(table.$$.fragment);
    			document.title = "Receitas";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const table_changes = {};
    			if (dirty & /*loading*/ 1) table_changes.loading = /*loading*/ ctx[0];
    			if (dirty & /*rows*/ 2) table_changes.rows = /*rows*/ ctx[1];

    			if (dirty & /*$$scope, totais, rows2*/ 17412) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onCellClick$7(row) {
    	
    } //alert(JSON.stringify(row));

    function instance$r($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(7, $params = $$value));
    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 100;
    	let totais = {};

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		$$invalidate(0, loading = true);

    		const res = await axios$1.post(api.getApiUrl("DWControleSocial"), [
    			{
    				run: "Municipio.Indicador.Receitas",
    				args: [ano]
    			}
    		]);

    		const data = res.data[0].value;

    		$$invalidate(2, totais = {
    			arrecadada: data.reduce((a, b) => a + b.arrecadada, 0),
    			perCapita: data.reduce((a, b) => a + b.perCapita, 0),
    			prevista: data.reduce((a, b) => a + b.prevista, 0)
    		});

    		$$invalidate(1, rows = res.data[0].value);
    		$$invalidate(0, loading = false);
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortString(rows, dir, key));
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortNumber(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Receitas> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Receitas", $$slots, []);
    	const click_handler = row => onCellClick$7();

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		mesesAbreviados,
    		sortNumber,
    		sortString,
    		RealComBarra,
    		PercentualComBarra,
    		Total,
    		loading,
    		rows,
    		page,
    		pageSize,
    		totais,
    		refresh,
    		onCellClick: onCellClick$7,
    		onSortString,
    		onSortNumber,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(3, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(4, pageSize = $$props.pageSize);
    		if ("totais" in $$props) $$invalidate(2, totais = $$props.totais);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 128) {
    			 refresh($params);
    		}
    	};

    	return [
    		loading,
    		rows,
    		totais,
    		page,
    		pageSize,
    		onSortString,
    		onSortNumber,
    		$params,
    		refresh,
    		click_handler
    	];
    }

    class Receitas extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Receitas",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\receitas-em-destaque\index.svelte generated by Svelte v3.22.3 */
    const file$r = "src\\pages\\municipio\\[ano]\\indicadores\\receitas-em-destaque\\index.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (65:2) <thead slot="head">
    function create_head_slot$9(ctx) {
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let t1;
    	let th1;
    	let t2;
    	let t3;
    	let th2;
    	let t4;
    	let t5;
    	let th3;
    	let t6;
    	let t7;
    	let th4;
    	let t8;
    	let t9;
    	let th5;
    	let t10;
    	let t11;
    	let th6;
    	let t12;
    	let t13;
    	let th7;
    	let t14;
    	let t15;
    	let th8;
    	let t16;
    	let current;

    	const sort0 = new Sort({
    			props: { key: "municipio" },
    			$$inline: true
    		});

    	sort0.$on("sort", /*onSortString*/ ctx[5]);

    	const sort1 = new Sort({
    			props: { key: "conveniosDaUniao" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortNumber*/ ctx[6]);

    	const sort2 = new Sort({
    			props: { key: "conveniosDoEstado" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortNumber*/ ctx[6]);
    	const sort3 = new Sort({ props: { key: "fpm" }, $$inline: true });
    	sort3.$on("sort", /*onSortNumber*/ ctx[6]);
    	const sort4 = new Sort({ props: { key: "icms" }, $$inline: true });
    	sort4.$on("sort", /*onSortNumber*/ ctx[6]);
    	const sort5 = new Sort({ props: { key: "iptu" }, $$inline: true });
    	sort5.$on("sort", /*onSortNumber*/ ctx[6]);
    	const sort6 = new Sort({ props: { key: "ipva" }, $$inline: true });
    	sort6.$on("sort", /*onSortNumber*/ ctx[6]);
    	const sort7 = new Sort({ props: { key: "iss" }, $$inline: true });
    	sort7.$on("sort", /*onSortNumber*/ ctx[6]);
    	const sort8 = new Sort({ props: { key: "itbi" }, $$inline: true });
    	sort8.$on("sort", /*onSortNumber*/ ctx[6]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text("Municípios\r\n        ");
    			create_component(sort0.$$.fragment);
    			t1 = space();
    			th1 = element("th");
    			t2 = text("Convênios da União\r\n        ");
    			create_component(sort1.$$.fragment);
    			t3 = space();
    			th2 = element("th");
    			t4 = text("Convênios do Estado\r\n        ");
    			create_component(sort2.$$.fragment);
    			t5 = space();
    			th3 = element("th");
    			t6 = text("FPM\r\n        ");
    			create_component(sort3.$$.fragment);
    			t7 = space();
    			th4 = element("th");
    			t8 = text("ICMS\r\n        ");
    			create_component(sort4.$$.fragment);
    			t9 = space();
    			th5 = element("th");
    			t10 = text("IPTU\r\n        ");
    			create_component(sort5.$$.fragment);
    			t11 = space();
    			th6 = element("th");
    			t12 = text("IPVA\r\n        ");
    			create_component(sort6.$$.fragment);
    			t13 = space();
    			th7 = element("th");
    			t14 = text("ISS\r\n        ");
    			create_component(sort7.$$.fragment);
    			t15 = space();
    			th8 = element("th");
    			t16 = text("ITBI\r\n        ");
    			create_component(sort8.$$.fragment);
    			add_location(th0, file$r, 66, 6, 1869);
    			add_location(th1, file$r, 70, 6, 1971);
    			add_location(th2, file$r, 74, 6, 2088);
    			add_location(th3, file$r, 78, 6, 2207);
    			add_location(th4, file$r, 82, 6, 2296);
    			add_location(th5, file$r, 86, 6, 2387);
    			add_location(th6, file$r, 90, 6, 2478);
    			add_location(th7, file$r, 94, 6, 2569);
    			add_location(th8, file$r, 98, 6, 2658);
    			add_location(tr, file$r, 65, 4, 1857);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$r, 64, 2, 1832);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			mount_component(sort0, th0, null);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			mount_component(sort1, th1, null);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			mount_component(sort2, th2, null);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			mount_component(sort3, th3, null);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			mount_component(sort4, th4, null);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(th5, t10);
    			mount_component(sort5, th5, null);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(th6, t12);
    			mount_component(sort6, th6, null);
    			append_dev(tr, t13);
    			append_dev(tr, th7);
    			append_dev(th7, t14);
    			mount_component(sort7, th7, null);
    			append_dev(tr, t15);
    			append_dev(tr, th8);
    			append_dev(th8, t16);
    			mount_component(sort8, th8, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			transition_in(sort3.$$.fragment, local);
    			transition_in(sort4.$$.fragment, local);
    			transition_in(sort5.$$.fragment, local);
    			transition_in(sort6.$$.fragment, local);
    			transition_in(sort7.$$.fragment, local);
    			transition_in(sort8.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			transition_out(sort3.$$.fragment, local);
    			transition_out(sort4.$$.fragment, local);
    			transition_out(sort5.$$.fragment, local);
    			transition_out(sort6.$$.fragment, local);
    			transition_out(sort7.$$.fragment, local);
    			transition_out(sort8.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    			destroy_component(sort3);
    			destroy_component(sort4);
    			destroy_component(sort5);
    			destroy_component(sort6);
    			destroy_component(sort7);
    			destroy_component(sort8);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot$9.name,
    		type: "slot",
    		source: "(65:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:6) <Row {index} on:click={() => onCellClick(row)}>
    function create_default_slot_2$7(ctx) {
    	let td;
    	let t0_value = /*row*/ ctx[11].municipio + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let current;

    	const realcombarra0 = new RealComBarra({
    			props: {
    				label: "Convênios da União",
    				value: /*row*/ ctx[11].conveniosDaUniao,
    				total: /*totais*/ ctx[2].conveniosDaUniao
    			},
    			$$inline: true
    		});

    	const realcombarra1 = new RealComBarra({
    			props: {
    				label: "Convênios do Estado",
    				value: /*row*/ ctx[11].conveniosDoEstado,
    				total: /*totais*/ ctx[2].conveniosDoEstado
    			},
    			$$inline: true
    		});

    	const realcombarra2 = new RealComBarra({
    			props: {
    				label: "FPM",
    				value: /*row*/ ctx[11].fpm,
    				total: /*totais*/ ctx[2].fpm
    			},
    			$$inline: true
    		});

    	const realcombarra3 = new RealComBarra({
    			props: {
    				label: "ICMS",
    				value: /*row*/ ctx[11].icms,
    				total: /*totais*/ ctx[2].icms
    			},
    			$$inline: true
    		});

    	const realcombarra4 = new RealComBarra({
    			props: {
    				label: "IPTU",
    				value: /*row*/ ctx[11].iptu,
    				total: /*totais*/ ctx[2].iptu
    			},
    			$$inline: true
    		});

    	const realcombarra5 = new RealComBarra({
    			props: {
    				label: "IPVA",
    				value: /*row*/ ctx[11].ipva,
    				total: /*totais*/ ctx[2].ipva
    			},
    			$$inline: true
    		});

    	const realcombarra6 = new RealComBarra({
    			props: {
    				label: "ISS",
    				value: /*row*/ ctx[11].iss,
    				total: /*totais*/ ctx[2].iss
    			},
    			$$inline: true
    		});

    	const realcombarra7 = new RealComBarra({
    			props: {
    				label: "ITBI",
    				value: /*row*/ ctx[11].itbi,
    				total: /*totais*/ ctx[2].itbi
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(realcombarra0.$$.fragment);
    			t2 = space();
    			create_component(realcombarra1.$$.fragment);
    			t3 = space();
    			create_component(realcombarra2.$$.fragment);
    			t4 = space();
    			create_component(realcombarra3.$$.fragment);
    			t5 = space();
    			create_component(realcombarra4.$$.fragment);
    			t6 = space();
    			create_component(realcombarra5.$$.fragment);
    			t7 = space();
    			create_component(realcombarra6.$$.fragment);
    			t8 = space();
    			create_component(realcombarra7.$$.fragment);
    			attr_dev(td, "data-label", "Município");
    			attr_dev(td, "class", "font-bold");
    			add_location(td, file$r, 107, 8, 2879);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t0);
    			insert_dev(target, t1, anchor);
    			mount_component(realcombarra0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(realcombarra1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(realcombarra2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(realcombarra3, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(realcombarra4, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(realcombarra5, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(realcombarra6, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(realcombarra7, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*rows2*/ 1024) && t0_value !== (t0_value = /*row*/ ctx[11].municipio + "")) set_data_dev(t0, t0_value);
    			const realcombarra0_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra0_changes.value = /*row*/ ctx[11].conveniosDaUniao;
    			if (dirty & /*totais*/ 4) realcombarra0_changes.total = /*totais*/ ctx[2].conveniosDaUniao;
    			realcombarra0.$set(realcombarra0_changes);
    			const realcombarra1_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra1_changes.value = /*row*/ ctx[11].conveniosDoEstado;
    			if (dirty & /*totais*/ 4) realcombarra1_changes.total = /*totais*/ ctx[2].conveniosDoEstado;
    			realcombarra1.$set(realcombarra1_changes);
    			const realcombarra2_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra2_changes.value = /*row*/ ctx[11].fpm;
    			if (dirty & /*totais*/ 4) realcombarra2_changes.total = /*totais*/ ctx[2].fpm;
    			realcombarra2.$set(realcombarra2_changes);
    			const realcombarra3_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra3_changes.value = /*row*/ ctx[11].icms;
    			if (dirty & /*totais*/ 4) realcombarra3_changes.total = /*totais*/ ctx[2].icms;
    			realcombarra3.$set(realcombarra3_changes);
    			const realcombarra4_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra4_changes.value = /*row*/ ctx[11].iptu;
    			if (dirty & /*totais*/ 4) realcombarra4_changes.total = /*totais*/ ctx[2].iptu;
    			realcombarra4.$set(realcombarra4_changes);
    			const realcombarra5_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra5_changes.value = /*row*/ ctx[11].ipva;
    			if (dirty & /*totais*/ 4) realcombarra5_changes.total = /*totais*/ ctx[2].ipva;
    			realcombarra5.$set(realcombarra5_changes);
    			const realcombarra6_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra6_changes.value = /*row*/ ctx[11].iss;
    			if (dirty & /*totais*/ 4) realcombarra6_changes.total = /*totais*/ ctx[2].iss;
    			realcombarra6.$set(realcombarra6_changes);
    			const realcombarra7_changes = {};
    			if (dirty & /*rows2*/ 1024) realcombarra7_changes.value = /*row*/ ctx[11].itbi;
    			if (dirty & /*totais*/ 4) realcombarra7_changes.total = /*totais*/ ctx[2].itbi;
    			realcombarra7.$set(realcombarra7_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(realcombarra0.$$.fragment, local);
    			transition_in(realcombarra1.$$.fragment, local);
    			transition_in(realcombarra2.$$.fragment, local);
    			transition_in(realcombarra3.$$.fragment, local);
    			transition_in(realcombarra4.$$.fragment, local);
    			transition_in(realcombarra5.$$.fragment, local);
    			transition_in(realcombarra6.$$.fragment, local);
    			transition_in(realcombarra7.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(realcombarra0.$$.fragment, local);
    			transition_out(realcombarra1.$$.fragment, local);
    			transition_out(realcombarra2.$$.fragment, local);
    			transition_out(realcombarra3.$$.fragment, local);
    			transition_out(realcombarra4.$$.fragment, local);
    			transition_out(realcombarra5.$$.fragment, local);
    			transition_out(realcombarra6.$$.fragment, local);
    			transition_out(realcombarra7.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(realcombarra0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(realcombarra1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(realcombarra2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(realcombarra3, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(realcombarra4, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(realcombarra5, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(realcombarra6, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(realcombarra7, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(107:6) <Row {index} on:click={() => onCellClick(row)}>",
    		ctx
    	});

    	return block;
    }

    // (106:4) {#each rows2 as row, index (row)}
    function create_each_block$b(key_1, ctx) {
    	let first;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[9](/*row*/ ctx[11], ...args);
    	}

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[13],
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*rows2*/ 1024) row_changes.index = /*index*/ ctx[13];

    			if (dirty & /*$$scope, rows2, totais*/ 17412) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(106:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (125:4) <Row>
    function create_default_slot_1$a(ctx) {
    	let td;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let current;

    	const total0 = new Total({
    			props: {
    				label: "Convênios da União",
    				total: /*totais*/ ctx[2].conveniosDaUniao
    			},
    			$$inline: true
    		});

    	const total1 = new Total({
    			props: {
    				label: "Convênios do Estado",
    				total: /*totais*/ ctx[2].conveniosDoEstado
    			},
    			$$inline: true
    		});

    	const total2 = new Total({
    			props: {
    				label: "FPM",
    				total: /*totais*/ ctx[2].fpm
    			},
    			$$inline: true
    		});

    	const total3 = new Total({
    			props: {
    				label: "ICMS",
    				total: /*totais*/ ctx[2].icms
    			},
    			$$inline: true
    		});

    	const total4 = new Total({
    			props: {
    				label: "IPTU",
    				total: /*totais*/ ctx[2].iptu
    			},
    			$$inline: true
    		});

    	const total5 = new Total({
    			props: {
    				label: "IPVA",
    				total: /*totais*/ ctx[2].ipva
    			},
    			$$inline: true
    		});

    	const total6 = new Total({
    			props: {
    				label: "ISS",
    				total: /*totais*/ ctx[2].iss
    			},
    			$$inline: true
    		});

    	const total7 = new Total({
    			props: {
    				label: "ITBI",
    				total: /*totais*/ ctx[2].itbi
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			td.textContent = "Totais";
    			t1 = space();
    			create_component(total0.$$.fragment);
    			t2 = space();
    			create_component(total1.$$.fragment);
    			t3 = space();
    			create_component(total2.$$.fragment);
    			t4 = space();
    			create_component(total3.$$.fragment);
    			t5 = space();
    			create_component(total4.$$.fragment);
    			t6 = space();
    			create_component(total5.$$.fragment);
    			t7 = space();
    			create_component(total6.$$.fragment);
    			t8 = space();
    			create_component(total7.$$.fragment);
    			attr_dev(td, "data-label", "Total");
    			add_location(td, file$r, 125, 6, 3737);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(total0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(total1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(total2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(total3, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(total4, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(total5, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(total6, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(total7, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const total0_changes = {};
    			if (dirty & /*totais*/ 4) total0_changes.total = /*totais*/ ctx[2].conveniosDaUniao;
    			total0.$set(total0_changes);
    			const total1_changes = {};
    			if (dirty & /*totais*/ 4) total1_changes.total = /*totais*/ ctx[2].conveniosDoEstado;
    			total1.$set(total1_changes);
    			const total2_changes = {};
    			if (dirty & /*totais*/ 4) total2_changes.total = /*totais*/ ctx[2].fpm;
    			total2.$set(total2_changes);
    			const total3_changes = {};
    			if (dirty & /*totais*/ 4) total3_changes.total = /*totais*/ ctx[2].icms;
    			total3.$set(total3_changes);
    			const total4_changes = {};
    			if (dirty & /*totais*/ 4) total4_changes.total = /*totais*/ ctx[2].iptu;
    			total4.$set(total4_changes);
    			const total5_changes = {};
    			if (dirty & /*totais*/ 4) total5_changes.total = /*totais*/ ctx[2].ipva;
    			total5.$set(total5_changes);
    			const total6_changes = {};
    			if (dirty & /*totais*/ 4) total6_changes.total = /*totais*/ ctx[2].iss;
    			total6.$set(total6_changes);
    			const total7_changes = {};
    			if (dirty & /*totais*/ 4) total7_changes.total = /*totais*/ ctx[2].itbi;
    			total7.$set(total7_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(total0.$$.fragment, local);
    			transition_in(total1.$$.fragment, local);
    			transition_in(total2.$$.fragment, local);
    			transition_in(total3.$$.fragment, local);
    			transition_in(total4.$$.fragment, local);
    			transition_in(total5.$$.fragment, local);
    			transition_in(total6.$$.fragment, local);
    			transition_in(total7.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(total0.$$.fragment, local);
    			transition_out(total1.$$.fragment, local);
    			transition_out(total2.$$.fragment, local);
    			transition_out(total3.$$.fragment, local);
    			transition_out(total4.$$.fragment, local);
    			transition_out(total5.$$.fragment, local);
    			transition_out(total6.$$.fragment, local);
    			transition_out(total7.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(total0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(total1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(total2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(total3, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(total4, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(total5, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(total6, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(total7, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(125:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (138:2) <span slot="bottom" />
    function create_bottom_slot$8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "bottom");
    			add_location(span, file$r, 137, 2, 4251);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_bottom_slot$8.name,
    		type: "slot",
    		source: "(138:2) <span slot=\\\"bottom\\\" />",
    		ctx
    	});

    	return block;
    }

    // (64:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$b(ctx) {
    	let t0;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let t2;
    	let current;
    	let each_value = /*rows2*/ ctx[10];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[11];
    	validate_each_keys(ctx, each_value, get_each_context$b, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$b(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$b(key, child_ctx));
    	}

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(row.$$.fragment);
    			t2 = space();
    			add_location(tbody, file$r, 104, 2, 2768);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t1);
    			mount_component(row, tbody, null);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, onCellClick, totais*/ 1028) {
    				const each_value = /*rows2*/ ctx[10];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$b, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$b, t1, get_each_context$b);
    				check_outros();
    			}

    			const row_changes = {};

    			if (dirty & /*$$scope, totais*/ 16388) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(row);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(64:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let t;
    	let current;

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[0],
    				page: /*page*/ ctx[3],
    				pageSize: /*pageSize*/ ctx[4],
    				rows: /*rows*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$b,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					bottom: [
    						create_bottom_slot$8,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					],
    					head: [
    						create_head_slot$9,
    						({ rows: rows2 }) => ({ 10: rows2 }),
    						({ rows: rows2 }) => rows2 ? 1024 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(table.$$.fragment);
    			document.title = "Receitas em destaque";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const table_changes = {};
    			if (dirty & /*loading*/ 1) table_changes.loading = /*loading*/ ctx[0];
    			if (dirty & /*rows*/ 2) table_changes.rows = /*rows*/ ctx[1];

    			if (dirty & /*$$scope, totais, rows2*/ 17412) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onCellClick$8(row) {
    	
    } //alert(JSON.stringify(row));

    function instance$s($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(7, $params = $$value));
    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 100;
    	let totais = {};

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		$$invalidate(0, loading = true);

    		const res = await axios$1.post(api.getApiUrl("DWControleSocial"), [
    			{
    				run: "Municipio.Indicador.ReceitasEmDestaque",
    				args: [ano]
    			}
    		]);

    		const data = res.data[0].value;

    		$$invalidate(2, totais = {
    			conveniosDaUniao: data.reduce((a, b) => a + b.conveniosDaUniao, 0),
    			conveniosDoEstado: data.reduce((a, b) => a + b.conveniosDoEstado, 0),
    			fpm: data.reduce((a, b) => a + b.fpm, 0),
    			icms: data.reduce((a, b) => a + b.icms, 0),
    			iptu: data.reduce((a, b) => a + b.iptu, 0),
    			ipva: data.reduce((a, b) => a + b.ipva, 0),
    			iss: data.reduce((a, b) => a + b.iss, 0),
    			itbi: data.reduce((a, b) => a + b.itbi, 0)
    		});

    		$$invalidate(1, rows = res.data[0].value);
    		$$invalidate(0, loading = false);
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortString(rows, dir, key));
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortNumber(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Receitas_em_destaque> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Receitas_em_destaque", $$slots, []);
    	const click_handler = row => onCellClick$8();

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		sortNumber,
    		sortString,
    		RealComBarra,
    		Total,
    		loading,
    		rows,
    		page,
    		pageSize,
    		totais,
    		refresh,
    		onCellClick: onCellClick$8,
    		onSortString,
    		onSortNumber,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(3, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(4, pageSize = $$props.pageSize);
    		if ("totais" in $$props) $$invalidate(2, totais = $$props.totais);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 128) {
    			 refresh($params);
    		}
    	};

    	return [
    		loading,
    		rows,
    		totais,
    		page,
    		pageSize,
    		onSortString,
    		onSortNumber,
    		$params,
    		refresh,
    		click_handler
    	];
    }

    class Receitas_em_destaque extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Receitas_em_destaque",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\indicadores\saude\index.svelte generated by Svelte v3.22.3 */
    const file$s = "src\\pages\\municipio\\[ano]\\indicadores\\saude\\index.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    // (67:2) <thead slot="head">
    function create_head_slot$a(ctx) {
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let t1;
    	let th1;
    	let t2;
    	let t3;
    	let th2;
    	let t4;
    	let t5;
    	let th3;
    	let t6;
    	let t7;
    	let th4;
    	let t8;
    	let current;

    	const sort0 = new Sort({
    			props: { key: "municipio" },
    			$$inline: true
    		});

    	sort0.$on("sort", /*onSortString*/ ctx[6]);

    	const sort1 = new Sort({
    			props: { key: "aplicacao" },
    			$$inline: true
    		});

    	sort1.$on("sort", /*onSortNumber*/ ctx[7]);

    	const sort2 = new Sort({
    			props: { key: "quantidadeAlunos" },
    			$$inline: true
    		});

    	sort2.$on("sort", /*onSortNumber*/ ctx[7]);

    	const sort3 = new Sort({
    			props: { key: "aplicacaoPorAluno" },
    			$$inline: true
    		});

    	sort3.$on("sort", /*onSortNumber*/ ctx[7]);

    	const sort4 = new Sort({
    			props: { key: "limiteConstitucional" },
    			$$inline: true
    		});

    	sort4.$on("sort", /*onSortNumber*/ ctx[7]);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text("Municípios\r\n        ");
    			create_component(sort0.$$.fragment);
    			t1 = space();
    			th1 = element("th");
    			t2 = text("Aplicação total\r\n        ");
    			create_component(sort1.$$.fragment);
    			t3 = space();
    			th2 = element("th");
    			t4 = text("Alunos\r\n        ");
    			create_component(sort2.$$.fragment);
    			t5 = space();
    			th3 = element("th");
    			t6 = text("Por aluno\r\n        ");
    			create_component(sort3.$$.fragment);
    			t7 = space();
    			th4 = element("th");
    			t8 = text("Limite constitucional\r\n        ");
    			create_component(sort4.$$.fragment);
    			add_location(th0, file$s, 68, 6, 1894);
    			add_location(th1, file$s, 72, 6, 1996);
    			add_location(th2, file$s, 76, 6, 2103);
    			add_location(th3, file$s, 80, 6, 2208);
    			add_location(th4, file$s, 84, 6, 2317);
    			add_location(tr, file$s, 67, 4, 1882);
    			attr_dev(thead, "slot", "head");
    			add_location(thead, file$s, 66, 2, 1857);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			mount_component(sort0, th0, null);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			mount_component(sort1, th1, null);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			mount_component(sort2, th2, null);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			mount_component(sort3, th3, null);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			mount_component(sort4, th4, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sort0.$$.fragment, local);
    			transition_in(sort1.$$.fragment, local);
    			transition_in(sort2.$$.fragment, local);
    			transition_in(sort3.$$.fragment, local);
    			transition_in(sort4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sort0.$$.fragment, local);
    			transition_out(sort1.$$.fragment, local);
    			transition_out(sort2.$$.fragment, local);
    			transition_out(sort3.$$.fragment, local);
    			transition_out(sort4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			destroy_component(sort0);
    			destroy_component(sort1);
    			destroy_component(sort2);
    			destroy_component(sort3);
    			destroy_component(sort4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_head_slot$a.name,
    		type: "slot",
    		source: "(67:2) <thead slot=\\\"head\\\">",
    		ctx
    	});

    	return block;
    }

    // (108:8) <PercentualComBarra            label="Limite constitucional"            isPositivo={v => v >= configLimiteConstitucional.limite}            value={row.limiteConstitucional}>
    function create_default_slot_3$2(ctx) {
    	let current;

    	const limiteconstitucional = new AlertaLimiteConstitucionalSaudeEEducacao({
    			props: {
    				config: /*configLimiteConstitucional*/ ctx[3],
    				value: /*row*/ ctx[13].limiteConstitucional
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(limiteconstitucional.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(limiteconstitucional, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const limiteconstitucional_changes = {};
    			if (dirty & /*rows2*/ 4096) limiteconstitucional_changes.value = /*row*/ ctx[13].limiteConstitucional;
    			limiteconstitucional.$set(limiteconstitucional_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(limiteconstitucional.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(limiteconstitucional.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(limiteconstitucional, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(108:8) <PercentualComBarra            label=\\\"Limite constitucional\\\"            isPositivo={v => v >= configLimiteConstitucional.limite}            value={row.limiteConstitucional}>",
    		ctx
    	});

    	return block;
    }

    // (93:6) <Row {index} on:click={() => onCellClick(row)}>
    function create_default_slot_2$8(ctx) {
    	let td0;
    	let t0_value = /*row*/ ctx[13].municipio + "";
    	let t0;
    	let t1;
    	let t2;
    	let td1;
    	let t3_value = /*row*/ ctx[13].quantidadeAlunos + "";
    	let t3;
    	let t4;
    	let td1_title_value;
    	let t5;
    	let t6;
    	let current;

    	const realcombarra0 = new RealComBarra({
    			props: {
    				label: "Aplicação total",
    				value: /*row*/ ctx[13].aplicacao,
    				total: /*totais*/ ctx[2].aplicacao
    			},
    			$$inline: true
    		});

    	const barra = new Barra({
    			props: {
    				value: /*row*/ ctx[13].quantidadeAlunos * 100 / /*totais*/ ctx[2].quantidadeAlunos
    			},
    			$$inline: true
    		});

    	const realcombarra1 = new RealComBarra({
    			props: {
    				label: "Por aluno",
    				value: /*row*/ ctx[13].aplicacaoPorAluno,
    				total: /*totais*/ ctx[2].aplicacaoPorAluno
    			},
    			$$inline: true
    		});

    	const percentualcombarra = new PercentualComBarra({
    			props: {
    				label: "Limite constitucional",
    				isPositivo: /*func*/ ctx[10],
    				value: /*row*/ ctx[13].limiteConstitucional,
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(realcombarra0.$$.fragment);
    			t2 = space();
    			td1 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			create_component(barra.$$.fragment);
    			t5 = space();
    			create_component(realcombarra1.$$.fragment);
    			t6 = space();
    			create_component(percentualcombarra.$$.fragment);
    			attr_dev(td0, "data-label", "Município");
    			attr_dev(td0, "class", "font-bold");
    			add_location(td0, file$s, 93, 8, 2571);
    			attr_dev(td1, "data-label", "Alunos");
    			attr_dev(td1, "class", "text-right");
    			attr_dev(td1, "title", td1_title_value = /*row*/ ctx[13].quantidadeAlunos);
    			add_location(td1, file$s, 98, 8, 2776);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td0, anchor);
    			append_dev(td0, t0);
    			insert_dev(target, t1, anchor);
    			mount_component(realcombarra0, target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, td1, anchor);
    			append_dev(td1, t3);
    			append_dev(td1, t4);
    			mount_component(barra, td1, null);
    			insert_dev(target, t5, anchor);
    			mount_component(realcombarra1, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(percentualcombarra, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*rows2*/ 4096) && t0_value !== (t0_value = /*row*/ ctx[13].municipio + "")) set_data_dev(t0, t0_value);
    			const realcombarra0_changes = {};
    			if (dirty & /*rows2*/ 4096) realcombarra0_changes.value = /*row*/ ctx[13].aplicacao;
    			if (dirty & /*totais*/ 4) realcombarra0_changes.total = /*totais*/ ctx[2].aplicacao;
    			realcombarra0.$set(realcombarra0_changes);
    			if ((!current || dirty & /*rows2*/ 4096) && t3_value !== (t3_value = /*row*/ ctx[13].quantidadeAlunos + "")) set_data_dev(t3, t3_value);
    			const barra_changes = {};
    			if (dirty & /*rows2, totais*/ 4100) barra_changes.value = /*row*/ ctx[13].quantidadeAlunos * 100 / /*totais*/ ctx[2].quantidadeAlunos;
    			barra.$set(barra_changes);

    			if (!current || dirty & /*rows2*/ 4096 && td1_title_value !== (td1_title_value = /*row*/ ctx[13].quantidadeAlunos)) {
    				attr_dev(td1, "title", td1_title_value);
    			}

    			const realcombarra1_changes = {};
    			if (dirty & /*rows2*/ 4096) realcombarra1_changes.value = /*row*/ ctx[13].aplicacaoPorAluno;
    			if (dirty & /*totais*/ 4) realcombarra1_changes.total = /*totais*/ ctx[2].aplicacaoPorAluno;
    			realcombarra1.$set(realcombarra1_changes);
    			const percentualcombarra_changes = {};
    			if (dirty & /*rows2*/ 4096) percentualcombarra_changes.value = /*row*/ ctx[13].limiteConstitucional;

    			if (dirty & /*$$scope, rows2*/ 69632) {
    				percentualcombarra_changes.$$scope = { dirty, ctx };
    			}

    			percentualcombarra.$set(percentualcombarra_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(realcombarra0.$$.fragment, local);
    			transition_in(barra.$$.fragment, local);
    			transition_in(realcombarra1.$$.fragment, local);
    			transition_in(percentualcombarra.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(realcombarra0.$$.fragment, local);
    			transition_out(barra.$$.fragment, local);
    			transition_out(realcombarra1.$$.fragment, local);
    			transition_out(percentualcombarra.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td0);
    			if (detaching) detach_dev(t1);
    			destroy_component(realcombarra0, detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(td1);
    			destroy_component(barra);
    			if (detaching) detach_dev(t5);
    			destroy_component(realcombarra1, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(percentualcombarra, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(93:6) <Row {index} on:click={() => onCellClick(row)}>",
    		ctx
    	});

    	return block;
    }

    // (92:4) {#each rows2 as row, index (row)}
    function create_each_block$c(key_1, ctx) {
    	let first;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[11](/*row*/ ctx[13], ...args);
    	}

    	const row = new Row({
    			props: {
    				index: /*index*/ ctx[15],
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*rows2*/ 4096) row_changes.index = /*index*/ ctx[15];

    			if (dirty & /*$$scope, rows2, totais*/ 69636) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(92:4) {#each rows2 as row, index (row)}",
    		ctx
    	});

    	return block;
    }

    // (118:4) <Row>
    function create_default_slot_1$b(ctx) {
    	let td;
    	let t1;
    	let t2;
    	let t3;
    	let current;

    	const total0 = new Total({
    			props: {
    				label: "Aplicação total",
    				total: /*totais*/ ctx[2].aplicacao
    			},
    			$$inline: true
    		});

    	const total1 = new Total({
    			props: {
    				label: "Alunos",
    				total: /*totais*/ ctx[2].quantidadeAlunos
    			},
    			$$inline: true
    		});

    	const total2 = new Total({
    			props: {
    				label: "Por aluno",
    				total: /*totais*/ ctx[2].aplicacaoPorAluno
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			td = element("td");
    			td.textContent = "Totais";
    			t1 = space();
    			create_component(total0.$$.fragment);
    			t2 = space();
    			create_component(total1.$$.fragment);
    			t3 = space();
    			create_component(total2.$$.fragment);
    			attr_dev(td, "data-label", "Total");
    			add_location(td, file$s, 118, 6, 3525);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(total0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(total1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(total2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const total0_changes = {};
    			if (dirty & /*totais*/ 4) total0_changes.total = /*totais*/ ctx[2].aplicacao;
    			total0.$set(total0_changes);
    			const total1_changes = {};
    			if (dirty & /*totais*/ 4) total1_changes.total = /*totais*/ ctx[2].quantidadeAlunos;
    			total1.$set(total1_changes);
    			const total2_changes = {};
    			if (dirty & /*totais*/ 4) total2_changes.total = /*totais*/ ctx[2].aplicacaoPorAluno;
    			total2.$set(total2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(total0.$$.fragment, local);
    			transition_in(total1.$$.fragment, local);
    			transition_in(total2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(total0.$$.fragment, local);
    			transition_out(total1.$$.fragment, local);
    			transition_out(total2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (detaching) detach_dev(t1);
    			destroy_component(total0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(total1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(total2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(118:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (126:2) <span slot="bottom" />
    function create_bottom_slot$9(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "bottom");
    			add_location(span, file$s, 125, 2, 3787);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_bottom_slot$9.name,
    		type: "slot",
    		source: "(126:2) <span slot=\\\"bottom\\\" />",
    		ctx
    	});

    	return block;
    }

    // (66:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>
    function create_default_slot$c(ctx) {
    	let t0;
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let t2;
    	let current;
    	let each_value = /*rows2*/ ctx[12];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[13];
    	validate_each_keys(ctx, each_value, get_each_context$c, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$c(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$c(key, child_ctx));
    	}

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(row.$$.fragment);
    			t2 = space();
    			add_location(tbody, file$s, 90, 2, 2460);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t1);
    			mount_component(row, tbody, null);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rows2, onCellClick, configLimiteConstitucional, totais*/ 4108) {
    				const each_value = /*rows2*/ ctx[12];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$c, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$c, t1, get_each_context$c);
    				check_outros();
    			}

    			const row_changes = {};

    			if (dirty & /*$$scope, totais*/ 65540) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(row);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(66:0) <Table {loading} {page} {pageSize} {rows} let:rows={rows2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let t;
    	let current;

    	const table = new Src({
    			props: {
    				loading: /*loading*/ ctx[0],
    				page: /*page*/ ctx[4],
    				pageSize: /*pageSize*/ ctx[5],
    				rows: /*rows*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$c,
    						({ rows: rows2 }) => ({ 12: rows2 }),
    						({ rows: rows2 }) => rows2 ? 4096 : 0
    					],
    					bottom: [
    						create_bottom_slot$9,
    						({ rows: rows2 }) => ({ 12: rows2 }),
    						({ rows: rows2 }) => rows2 ? 4096 : 0
    					],
    					head: [
    						create_head_slot$a,
    						({ rows: rows2 }) => ({ 12: rows2 }),
    						({ rows: rows2 }) => rows2 ? 4096 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(table.$$.fragment);
    			document.title = "Saúde";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const table_changes = {};
    			if (dirty & /*loading*/ 1) table_changes.loading = /*loading*/ ctx[0];
    			if (dirty & /*rows*/ 2) table_changes.rows = /*rows*/ ctx[1];

    			if (dirty & /*$$scope, totais, rows2*/ 69636) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onCellClick$9(row) {
    	
    } //alert(JSON.stringify(row));

    function instance$t($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(8, $params = $$value));
    	const configLimiteConstitucional = { limite: 15 };
    	let loading = true;
    	let rows = [];
    	let page = 0; //first page
    	let pageSize = 100;
    	let totais = {};

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		$$invalidate(0, loading = true);

    		const res = await axios$1.post(api.getApiUrl("ControleSocial"), [
    			{
    				run: "Municipio.Indicador.Saude",
    				args: [ano]
    			}
    		]);

    		const data = res.data[0].value;

    		$$invalidate(2, totais = {
    			aplicacao: data.reduce((a, b) => a + b.aplicacao, 0),
    			quantidadeAlunos: data.reduce((a, b) => a + b.quantidadeAlunos, 0),
    			aplicacaoPorAluno: data.reduce((a, b) => a + b.aplicacaoPorAluno, 0)
    		});

    		$$invalidate(1, rows = res.data[0].value);
    		$$invalidate(0, loading = false);
    	}

    	function onSortString({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortString(rows, dir, key));
    	}

    	function onSortNumber({ detail: { dir, key } }) {
    		$$invalidate(1, rows = sortNumber(rows, dir, key));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Saude> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Saude", $$slots, []);
    	const func = v => v >= configLimiteConstitucional.limite;
    	const click_handler = row => onCellClick$9();

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		Table: Src,
    		Pagination,
    		Row,
    		Search,
    		Sort,
    		api,
    		sortNumber,
    		sortString,
    		Total,
    		Barra,
    		RealComBarra,
    		PercentualComBarra,
    		LimiteConstitucional: AlertaLimiteConstitucionalSaudeEEducacao,
    		configLimiteConstitucional,
    		loading,
    		rows,
    		page,
    		pageSize,
    		totais,
    		refresh,
    		onCellClick: onCellClick$9,
    		onSortString,
    		onSortNumber,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("page" in $$props) $$invalidate(4, page = $$props.page);
    		if ("pageSize" in $$props) $$invalidate(5, pageSize = $$props.pageSize);
    		if ("totais" in $$props) $$invalidate(2, totais = $$props.totais);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 256) {
    			 refresh($params);
    		}
    	};

    	return [
    		loading,
    		rows,
    		totais,
    		configLimiteConstitucional,
    		page,
    		pageSize,
    		onSortString,
    		onSortNumber,
    		$params,
    		refresh,
    		func,
    		click_handler
    	];
    }

    class Saude extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Saude",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    const settings = {
    	municipios: {
    		get: value => {
    			const data = [
    				{ value: "001", label: "Afonso Cláudio" },
    				{ value: "002", label: "Água Doce do Norte" },
    				{ value: "003", label: "Águia Branca" },
    				{ value: "004", label: "Alegre" },
    				{ value: "005", label: "Alfredo Chaves" },
    				{ value: "006", label: "Alto Rio Novo" },
    				{ value: "007", label: "Anchieta" },
    				{ value: "008", label: "Apiacá" },
    				{ value: "009", label: "Aracruz" },
    				{ value: "010", label: "Atílio Vivácqua" },
    				{ value: "011", label: "Baixo Guandu" },
    				{ value: "012", label: "Barra de São Francisco" },
    				{ value: "013", label: "Boa Esperança" },
    				{ value: "014", label: "Bom Jesus do Norte" },
    				{ value: "015", label: "Brejetuba" },
    				{ value: "016", label: "Cachoeiro de Itapemirim" },
    				{ value: "017", label: "Cariacica" },
    				{ value: "018", label: "Castelo" },
    				{ value: "019", label: "Colatina" },
    				{ value: "020", label: "Conceição da Barra" },
    				{ value: "021", label: "Conceição do Castelo" },
    				{ value: "501", label: "Consórcio do Estado do Espírito Santo" },
    				{ value: "022", label: "Divino de São Lourenço" },
    				{ value: "023", label: "Domingos Martins" },
    				{ value: "024", label: "Dores do Rio Preto" },
    				{ value: "025", label: "Ecoporanga" },
    				{ value: "026", label: "Fundão" },
    				{ value: "078", label: "Governador Lindenberg" },
    				{ value: "027", label: "Guaçuí" },
    				{ value: "028", label: "Guarapari" },
    				{ value: "029", label: "Ibatiba" },
    				{ value: "030", label: "Ibiraçu" },
    				{ value: "031", label: "Ibitirama" },
    				{ value: "032", label: "Iconha" },
    				{ value: "033", label: "Irupi" },
    				{ value: "034", label: "Itaguaçu" },
    				{ value: "035", label: "Itapemirim" },
    				{ value: "036", label: "Itarana" },
    				{ value: "037", label: "Iúna" },
    				{ value: "038", label: "Jaguaré" },
    				{ value: "039", label: "Jerônimo Monteiro" },
    				{ value: "040", label: "João Neiva" },
    				{ value: "041", label: "Laranja da Terra" },
    				{ value: "042", label: "Linhares" },
    				{ value: "043", label: "Mantenópolis" },
    				{ value: "044", label: "Marataízes" },
    				{ value: "045", label: "Marechal Floriano" },
    				{ value: "046", label: "Marilândia" },
    				{ value: "047", label: "Mimoso do Sul" },
    				{ value: "048", label: "Montanha" },
    				{ value: "049", label: "Mucurici" },
    				{ value: "050", label: "Muniz Freire" },
    				{ value: "051", label: "Muqui" },
    				{ value: "052", label: "Nova Venécia" },
    				{ value: "053", label: "Pancas" },
    				{ value: "054", label: "Pedro Canário" },
    				{ value: "055", label: "Pinheiros" },
    				{ value: "056", label: "Piúma" },
    				{ value: "057", label: "Ponto Belo" },
    				{ value: "058", label: "Presidente Kennedy" },
    				{ value: "059", label: "Rio Bananal" },
    				{ value: "060", label: "Rio Novo do Sul" },
    				{ value: "061", label: "Santa Leopoldina" },
    				{ value: "062", label: "Santa Maria de Jetibá" },
    				{ value: "063", label: "Santa Teresa" },
    				{ value: "064", label: "São Domingos do Norte" },
    				{ value: "065", label: "São Gabriel da Palha" },
    				{ value: "066", label: "São José do Calçado" },
    				{ value: "067", label: "São Mateus" },
    				{ value: "068", label: "São Roque do Canaã" },
    				{ value: "069", label: "Serra" },
    				{ value: "070", label: "Sooretama" },
    				{ value: "071", label: "Vargem Alta" },
    				{ value: "072", label: "Venda Nova do Imigrante" },
    				{ value: "073", label: "Viana" },
    				{ value: "074", label: "Vila Pavão" },
    				{ value: "075", label: "Vila Valério" },
    				{ value: "076", label: "Vila Velha" },
    				{ value: "077", label: "Vitória" }
    			];

    			select(data, value);
    			return data;
    		}
    	},
    	ano: { get: segment => { } },
    	anos: {
    		get: (value, segment) => {
    			let data = [];

    			if (segment === "iegm") {
    				data = [
    					{ label: "2017", value: 2017 },
    					{ label: "2016", value: 2016 },
    					{ label: "2015", value: 2015 }
    				];
    			} else {
    				data = [
    					{ label: "2020", value: 2020 },
    					{ label: "2019", value: 2019 },
    					{ label: "2018", value: 2018 },
    					{ label: "2017", value: 2017 },
    					// { label: "2016", value: 2016 },
    					// { label: "2015", value: 2015 },
    					// { label: "2014", value: 2014 },
    					// { label: "2013", value: 2013 }
    				];
    			}

    			select(data, value);
    			return data;
    		}
    	}
    };

    function select(data, value) {
    	for (let i = 0; i < data.length; i++) {
    		if (data[i].value === value) {
    			data[i].selected = true;
    		}
    	}
    }

    /* src\components\Breadcrumb\Breadcrumb.svelte generated by Svelte v3.22.3 */

    const file$t = "src\\components\\Breadcrumb\\Breadcrumb.svelte";
    const get_right_slot_changes = dirty => ({});
    const get_right_slot_context = ctx => ({});
    const get_text_slot_changes = dirty => ({});
    const get_text_slot_context = ctx => ({});

    function create_fragment$u(ctx) {
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let span2;
    	let current;
    	const text_slot_template = /*$$slots*/ ctx[1].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[0], get_text_slot_context);
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);
    	const right_slot_template = /*$$slots*/ ctx[1].right;
    	const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[0], get_right_slot_context);

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			if (text_slot) text_slot.c();
    			t0 = space();
    			span1 = element("span");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			span2 = element("span");
    			if (right_slot) right_slot.c();
    			attr_dev(span0, "class", "flex justify-start");
    			add_location(span0, file$t, 0, 0, 0);
    			attr_dev(span1, "class", "flex justify-center");
    			add_location(span1, file$t, 3, 0, 68);
    			attr_dev(span2, "class", "flex justify-end");
    			add_location(span2, file$t, 6, 0, 125);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);

    			if (text_slot) {
    				text_slot.m(span0, null);
    			}

    			insert_dev(target, t0, anchor);
    			insert_dev(target, span1, anchor);

    			if (default_slot) {
    				default_slot.m(span1, null);
    			}

    			insert_dev(target, t1, anchor);
    			insert_dev(target, span2, anchor);

    			if (right_slot) {
    				right_slot.m(span2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (text_slot) {
    				if (text_slot.p && dirty & /*$$scope*/ 1) {
    					text_slot.p(get_slot_context(text_slot_template, ctx, /*$$scope*/ ctx[0], get_text_slot_context), get_slot_changes(text_slot_template, /*$$scope*/ ctx[0], dirty, get_text_slot_changes));
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[0], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null));
    				}
    			}

    			if (right_slot) {
    				if (right_slot.p && dirty & /*$$scope*/ 1) {
    					right_slot.p(get_slot_context(right_slot_template, ctx, /*$$scope*/ ctx[0], get_right_slot_context), get_slot_changes(right_slot_template, /*$$scope*/ ctx[0], dirty, get_right_slot_changes));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			transition_in(default_slot, local);
    			transition_in(right_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			transition_out(default_slot, local);
    			transition_out(right_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (text_slot) text_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span1);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span2);
    			if (right_slot) right_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Breadcrumb> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Breadcrumb", $$slots, ['text','default','right']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class Breadcrumb extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Breadcrumb",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src\components\Form\Dropdown\Lista.svelte generated by Svelte v3.22.3 */
    const file$u = "src\\components\\Form\\Dropdown\\Lista.svelte";
    const get_default_slot_changes$1 = dirty => ({ items: dirty & /*filtered*/ 4 });
    const get_default_slot_context$1 = ctx => ({ items: /*filtered*/ ctx[2] });

    // (198:2) {#if visible}
    function create_if_block$a(ctx) {
    	let div3;
    	let div0;
    	let input;
    	let t0;
    	let div1;
    	let ul;
    	let t1;
    	let div2;
    	let t2_value = /*labels*/ ctx[0].close + "";
    	let t2;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[16].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], get_default_slot_context$1);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			div1 = element("div");
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			div2 = element("div");
    			t2 = text(t2_value);
    			attr_dev(input, "class", "border-2 rounded h-8 w-full px-2");
    			add_location(input, file$u, 202, 8, 4252);
    			attr_dev(div0, "class", "w-full p-2");
    			add_location(div0, file$u, 201, 6, 4218);
    			attr_dev(ul, "class", "list-reset pb-24 md:pb-0");
    			add_location(ul, file$u, 209, 8, 4478);
    			attr_dev(div1, "class", "list overflow-y-auto h-full");
    			add_location(div1, file$u, 208, 6, 4397);
    			attr_dev(div2, "class", "fixed bottom-0 md:hidden bg-white w-full text-center\r\n        hover:bg-gray-200 h-12 cursor-pointer border-t border-gray-300");
    			set_style(div2, "line-height", "3rem");
    			add_location(div2, file$u, 214, 6, 4591);
    			attr_dev(div3, "class", "container rounded shadow z-10 bg-white w-full h-full fixed left-0\r\n      z-50");
    			add_location(div3, file$u, 198, 4, 4112);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, input);
    			/*input_binding*/ ctx[17](input);
    			set_input_value(input, /*text*/ ctx[5]);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			append_dev(div1, ul);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			/*div1_binding*/ ctx[19](div1);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, t2);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(input, "input", /*input_input_handler*/ ctx[18]),
    				listen_dev(div2, "click", /*close*/ ctx[1], false, false, false)
    			];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 32 && input.value !== /*text*/ ctx[5]) {
    				set_input_value(input, /*text*/ ctx[5]);
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, filtered*/ 32772) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], get_default_slot_context$1), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, get_default_slot_changes$1));
    				}
    			}

    			if ((!current || dirty & /*labels*/ 1) && t2_value !== (t2_value = /*labels*/ ctx[0].close + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			/*input_binding*/ ctx[17](null);
    			if (default_slot) default_slot.d(detaching);
    			/*div1_binding*/ ctx[19](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(198:2) {#if visible}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let div1;
    	let div0;
    	let span;
    	let t0;
    	let t1;
    	let current;
    	let dispose;
    	let if_block = /*visible*/ ctx[7] && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span = element("span");
    			t0 = text(/*label*/ ctx[4]);
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(span, "class", "float-left label svelte-jah42h");
    			add_location(span, file$u, 183, 4, 3637);
    			attr_dev(div0, "class", "appearance-none w-full bg-white border border-gray-200\r\n    hover:border-gray-300 rounded shadow focus:outline-none focus:shadow-outline\r\n    p-1 md:px-2 float-left cursor-pointer");
    			add_location(div0, file$u, 178, 2, 3401);
    			attr_dev(div1, "class", "relative float-left w-full dropdown svelte-jah42h");
    			add_location(div1, file$u, 177, 0, 3348);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span);
    			append_dev(span, t0);
    			append_dev(div1, t1);
    			if (if_block) if_block.m(div1, null);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(window, "keyup", onKeyupWindow, false, false, false),
    				listen_dev(window, "click", onClickWindow, false, false, false),
    				listen_dev(div0, "click", /*onClickDropdown*/ ctx[8], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*label*/ 16) set_data_dev(t0, /*label*/ ctx[4]);

    			if (/*visible*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*visible*/ 128) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const allowVisible = writable(true);

    function closeAllDropdowns() {
    	allowVisible.set(false);
    	allowVisible.set(true);
    }

    function onClickWindow(e) {
    	closeAllDropdowns();
    }

    function onKeyupWindow(e) {
    	const esc = 27;

    	if (e.which === esc) {
    		closeAllDropdowns();
    	}
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { multiple = false } = $$props;
    	let { items = [] } = $$props;
    	let { labels = { close: "Fechar" } } = $$props;
    	let _selecteds;
    	let filtered = [];
    	let itemsContainerRef;
    	let label = "";
    	let text = "";
    	let textRef;
    	let visible = false;
    	let lastScrollTop = 0;

    	allowVisible.subscribe(a => {
    		if (!a) {
    			close();
    		}
    	});

    	function close() {
    		if (itemsContainerRef) {
    			lastScrollTop = itemsContainerRef.scrollTop;
    		}

    		$$invalidate(7, visible = false);
    		$$invalidate(5, text = "");
    	}

    	async function onClickDropdown(e) {
    		e.stopPropagation();

    		if (!visible) {
    			closeAllDropdowns();
    			$$invalidate(7, visible = true);
    			await tick();
    			textRef.focus();
    			itemsContainerRef.scrollTo(0, lastScrollTop);
    		} else {
    			close();
    		}
    	}

    	function onChange() {
    		close();
    	}

    	function select(item) {
    		onChange();

    		if (!multiple) {
    			$$invalidate(9, items = items.map(m => {
    				m.selected = false;
    				return m;
    			}));
    		}

    		item.selected = true;
    	}

    	const writable_props = ["multiple", "items", "labels"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Lista> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Lista", $$slots, ['default']);

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(6, textRef = $$value);
    		});
    	}

    	function input_input_handler() {
    		text = this.value;
    		$$invalidate(5, text);
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(3, itemsContainerRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("multiple" in $$props) $$invalidate(10, multiple = $$props.multiple);
    		if ("items" in $$props) $$invalidate(9, items = $$props.items);
    		if ("labels" in $$props) $$invalidate(0, labels = $$props.labels);
    		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		allowVisible,
    		closeAllDropdowns,
    		tick,
    		multiple,
    		items,
    		labels,
    		_selecteds,
    		filtered,
    		itemsContainerRef,
    		label,
    		text,
    		textRef,
    		visible,
    		lastScrollTop,
    		close,
    		onClickDropdown,
    		onChange,
    		select,
    		onClickWindow,
    		onKeyupWindow
    	});

    	$$self.$inject_state = $$props => {
    		if ("multiple" in $$props) $$invalidate(10, multiple = $$props.multiple);
    		if ("items" in $$props) $$invalidate(9, items = $$props.items);
    		if ("labels" in $$props) $$invalidate(0, labels = $$props.labels);
    		if ("_selecteds" in $$props) $$invalidate(12, _selecteds = $$props._selecteds);
    		if ("filtered" in $$props) $$invalidate(2, filtered = $$props.filtered);
    		if ("itemsContainerRef" in $$props) $$invalidate(3, itemsContainerRef = $$props.itemsContainerRef);
    		if ("label" in $$props) $$invalidate(4, label = $$props.label);
    		if ("text" in $$props) $$invalidate(5, text = $$props.text);
    		if ("textRef" in $$props) $$invalidate(6, textRef = $$props.textRef);
    		if ("visible" in $$props) $$invalidate(7, visible = $$props.visible);
    		if ("lastScrollTop" in $$props) lastScrollTop = $$props.lastScrollTop;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*items, _selecteds*/ 4608) {
    			 {
    				$$invalidate(12, _selecteds = items.filter(i => i.selected));

    				if (_selecteds.length === 0) {
    					onChange();

    					if (items.length === 0) {
    						$$invalidate(2, filtered = []);
    						$$invalidate(4, label = "");
    					} else {
    						const _items = items.slice(0);
    						_items[0].selected = true;
    						$$invalidate(2, filtered = _items);
    						$$invalidate(4, label = _items[0].label);
    					}
    				} else {
    					onChange();
    					$$invalidate(2, filtered = items.slice(0));
    					$$invalidate(4, label = _selecteds.map(i => i.label).join(", "));
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*text, items*/ 544) {
    			 if (text.length === 0) {
    				$$invalidate(2, filtered = items.slice(0));
    			} else {
    				const _text = text.toLocaleLowerCase();
    				$$invalidate(2, filtered = items.filter(i => i.label.toLocaleLowerCase().indexOf(text) > -1 || i.value.toLocaleLowerCase().indexOf(text) > -1 && i.visible !== false));
    			}
    		}
    	};

    	return [
    		labels,
    		close,
    		filtered,
    		itemsContainerRef,
    		label,
    		text,
    		textRef,
    		visible,
    		onClickDropdown,
    		items,
    		multiple,
    		select,
    		_selecteds,
    		lastScrollTop,
    		onChange,
    		$$scope,
    		$$slots,
    		input_binding,
    		input_input_handler,
    		div1_binding
    	];
    }

    class Lista extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
    			multiple: 10,
    			items: 9,
    			labels: 0,
    			close: 1,
    			select: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lista",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get multiple() {
    		throw new Error("<Lista>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<Lista>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<Lista>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Lista>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labels() {
    		throw new Error("<Lista>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labels(value) {
    		throw new Error("<Lista>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		return this.$$.ctx[1];
    	}

    	set close(value) {
    		throw new Error("<Lista>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get select() {
    		return this.$$.ctx[11];
    	}

    	set select(value) {
    		throw new Error("<Lista>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Icons\Gear.svelte generated by Svelte v3.22.3 */

    const file$v = "src\\components\\Icons\\Gear.svelte";

    function create_fragment$w(ctx) {
    	let span;
    	let svg;
    	let path;
    	let t;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			span = element("span");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(path, "d", "M24\r\n      13.616v-3.232l-2.869-1.02c-.198-.687-.472-1.342-.811-1.955l1.308-2.751-2.285-2.285-2.751\r\n      1.307c-.613-.339-1.269-.613-1.955-.811l-1.021-2.869h-3.232l-1.021\r\n      2.869c-.686.198-1.342.471-1.955.811l-2.751-1.308-2.285 2.285 1.308\r\n      2.752c-.339.613-.614 1.268-.811 1.955l-2.869 1.02v3.232l2.869\r\n      1.02c.197.687.472 1.342.811 1.955l-1.308 2.751 2.285 2.286\r\n      2.751-1.308c.613.339 1.269.613 1.955.811l1.021\r\n      2.869h3.232l1.021-2.869c.687-.198 1.342-.472 1.955-.811l2.751 1.308\r\n      2.285-2.286-1.308-2.751c.339-.613.613-1.268.811-1.955l2.869-1.02zm-12\r\n      2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z");
    			add_location(path, file$v, 7, 4, 204);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "class", "fill-current w-full");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$v, 1, 2, 62);
    			attr_dev(span, "class", "relative cursor-pointer hover:text-gray-700");
    			add_location(span, file$v, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, svg);
    			append_dev(svg, path);
    			append_dev(span, t);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[0], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Gear> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Gear", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class Gear extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Gear",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    var menu = [
      {
        label: "Composição da Receita Arrecadada",
        title: "Composição da Receita Arrecadada",
        path: "composicao-receita-arrecadada"
      },
      {
        label: "Despesas",
        title: "Despesas",
        path: "despesas"
      },
      {
        label: "Despesas em destaque",
        title: "Despesas em destaque",
        path: "despesas-em-destaque"
      },
      {
        label: "Educação",
        title: "Educação",
        path: "educacao"
      },
      {
        label: "Educação FUNDEB",
        title: "Educação FUNDEB",
        path: "educacao-fundeb"
      },
      {
        label: "IEGM",
        title: "Índice de Efetividade da Gestão Municipal",
        path: "iegm"
      },
      {
        label: "Pessoal",
        title: "Pessoal",
        path: "pessoal"
      },
      {
        label: "Receitas",
        title: "Receitas",
        path: "receitas"
      },
      {
        label: "Receitas em destaque",
        title: "Receitas em destaque",
        path: "receitas-em-destaque"
      },
      {
        label: "Saúde",
        title: "Saúde",
        path: "saude"
      }
    ];

    const menus = writable([]);

    function updateMenu(items, segments, count = 1) {
      let _menus = [];
      const _segment = segments.slice(0, count).join("/");

      const _menu = items.map(m => {
        m.selected = m.path === _segment;

        if (m.selected && m.children) {
          let _children = updateMenu(m.children, segments, count + 1);
          _menus = _menus.concat(_children);
        }

        return m;
      });

      _menus = [_menu].concat(_menus);
      return _menus;
    }

    /* src\pages\municipio\[ano]\indicadores\_layout.svelte generated by Svelte v3.22.3 */
    const file$w = "src\\pages\\municipio\\[ano]\\indicadores\\_layout.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (66:14) <Link href={`/municipio/${ano}/indicadores/${item.path}`}>
    function create_default_slot_4$1(ctx) {
    	let html_tag;
    	let raw_value = /*item*/ ctx[8].label + "";

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(raw_value, null);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(target, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items*/ 128 && raw_value !== (raw_value = /*item*/ ctx[8].label + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(66:14) <Link href={`/municipio/${ano}/indicadores/${item.path}`}>",
    		ctx
    	});

    	return block;
    }

    // (64:10) {#each items as item}
    function create_each_block_2(ctx) {
    	let li;
    	let current;

    	const link = new Link({
    			props: {
    				href: `/municipio/${/*ano*/ ctx[0]}/indicadores/${/*item*/ ctx[8].path}`,
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			toggle_class(li, "active", /*item*/ ctx[8].selected);
    			add_location(li, file$w, 64, 12, 1741);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*ano, items*/ 129) link_changes.href = `/municipio/${/*ano*/ ctx[0]}/indicadores/${/*item*/ ctx[8].path}`;

    			if (dirty & /*$$scope, items*/ 192) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);

    			if (dirty & /*items*/ 128) {
    				toggle_class(li, "active", /*item*/ ctx[8].selected);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(64:10) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    // (63:8) <DropdownLista items={menu} let:items>
    function create_default_slot_3$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*items*/ ctx[7];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items, ano*/ 129) {
    				each_value_2 = /*items*/ ctx[7];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(63:8) <DropdownLista items={menu} let:items>",
    		ctx
    	});

    	return block;
    }

    // (61:4) {#each $menuStore as menu}
    function create_each_block_1$2(ctx) {
    	let span;
    	let current;

    	const dropdownlista = new Lista({
    			props: {
    				items: /*menu*/ ctx[11],
    				$$slots: {
    					default: [
    						create_default_slot_3$3,
    						({ items }) => ({ 7: items }),
    						({ items }) => items ? 128 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(dropdownlista.$$.fragment);
    			attr_dev(span, "class", "w-1/2 mx-1");
    			add_location(span, file$w, 61, 6, 1621);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(dropdownlista, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownlista_changes = {};
    			if (dirty & /*$menuStore*/ 4) dropdownlista_changes.items = /*menu*/ ctx[11];

    			if (dirty & /*$$scope, items, ano*/ 193) {
    				dropdownlista_changes.$$scope = { dirty, ctx };
    			}

    			dropdownlista.$set(dropdownlista_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownlista.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownlista.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(dropdownlista);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(61:4) {#each $menuStore as menu}",
    		ctx
    	});

    	return block;
    }

    // (78:12) <Link href={`/municipio/${item.value}/indicadores/${segments}`}>
    function create_default_slot_2$9(ctx) {
    	let html_tag;
    	let raw_value = /*item*/ ctx[8].label + "";

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(raw_value, null);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(target, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items*/ 128 && raw_value !== (raw_value = /*item*/ ctx[8].label + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(78:12) <Link href={`/municipio/${item.value}/indicadores/${segments}`}>",
    		ctx
    	});

    	return block;
    }

    // (76:8) {#each items as item}
    function create_each_block$d(ctx) {
    	let li;
    	let t;
    	let current;

    	const link = new Link({
    			props: {
    				href: `/municipio/${/*item*/ ctx[8].value}/indicadores/${/*segments*/ ctx[1]}`,
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			t = space();
    			toggle_class(li, "active", /*item*/ ctx[8].selected);
    			add_location(li, file$w, 76, 10, 2147);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*items, segments*/ 130) link_changes.href = `/municipio/${/*item*/ ctx[8].value}/indicadores/${/*segments*/ ctx[1]}`;

    			if (dirty & /*$$scope, items*/ 192) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);

    			if (dirty & /*items*/ 128) {
    				toggle_class(li, "active", /*item*/ ctx[8].selected);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(76:8) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    // (75:6) <DropdownLista items={settings.anos.get(ano, segments)} let:items>
    function create_default_slot_1$c(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*items*/ ctx[7];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items, segments*/ 130) {
    				each_value = /*items*/ ctx[7];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(75:6) <DropdownLista items={settings.anos.get(ano, segments)} let:items>",
    		ctx
    	});

    	return block;
    }

    // (60:2) <Breadcrumb>
    function create_default_slot$d(ctx) {
    	let t0;
    	let span0;
    	let t1;
    	let span1;
    	let current;
    	let each_value_1 = /*$menuStore*/ ctx[2];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const dropdownlista = new Lista({
    			props: {
    				items: settings.anos.get(/*ano*/ ctx[0], /*segments*/ ctx[1]),
    				$$slots: {
    					default: [
    						create_default_slot_1$c,
    						({ items }) => ({ 7: items }),
    						({ items }) => items ? 128 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const gear = new Gear({ $$inline: true });

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			span0 = element("span");
    			create_component(dropdownlista.$$.fragment);
    			t1 = space();
    			span1 = element("span");
    			create_component(gear.$$.fragment);
    			attr_dev(span0, "class", "w-1/2 mx-1");
    			add_location(span0, file$w, 73, 4, 2005);
    			attr_dev(span1, "class", "text-lg ml-1 self-center");
    			set_style(span1, "width", "40px");
    			add_location(span1, file$w, 84, 4, 2390);
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			insert_dev(target, span0, anchor);
    			mount_component(dropdownlista, span0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, span1, anchor);
    			mount_component(gear, span1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$menuStore, items, ano*/ 133) {
    				each_value_1 = /*$menuStore*/ ctx[2];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t0.parentNode, t0);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const dropdownlista_changes = {};
    			if (dirty & /*ano, segments*/ 3) dropdownlista_changes.items = settings.anos.get(/*ano*/ ctx[0], /*segments*/ ctx[1]);

    			if (dirty & /*$$scope, items, segments*/ 194) {
    				dropdownlista_changes.$$scope = { dirty, ctx };
    			}

    			dropdownlista.$set(dropdownlista_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(dropdownlista.$$.fragment, local);
    			transition_in(gear.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(dropdownlista.$$.fragment, local);
    			transition_out(gear.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span0);
    			destroy_component(dropdownlista);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span1);
    			destroy_component(gear);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(60:2) <Breadcrumb>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let div0;
    	let t;
    	let div1;
    	let current;

    	const breadcrumb = new Breadcrumb({
    			props: {
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const default_slot_template = /*$$slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(breadcrumb.$$.fragment);
    			t = space();
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "breadcrumb fixed w-full h-12 pt-2 px-2 bg-white z-40");
    			add_location(div0, file$w, 58, 0, 1499);
    			attr_dev(div1, "class", "container svelte-klrkh5");
    			add_location(div1, file$w, 90, 0, 2507);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(breadcrumb, div0, null);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const breadcrumb_changes = {};

    			if (dirty & /*$$scope, ano, segments, $menuStore*/ 71) {
    				breadcrumb_changes.$$scope = { dirty, ctx };
    			}

    			breadcrumb.$set(breadcrumb_changes);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 64) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[6], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(breadcrumb.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(breadcrumb.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(breadcrumb);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let $route;
    	let $menuStore;
    	validate_store(route, "route");
    	component_subscribe($$self, route, $$value => $$invalidate(3, $route = $$value));
    	validate_store(menus, "menuStore");
    	component_subscribe($$self, menus, $$value => $$invalidate(2, $menuStore = $$value));
    	let ano;
    	let segments;

    	function refresh({ params, path }) {
    		const _segments = path.replace("/municipio/:ano/indicadores/", "").split("/");
    		$$invalidate(0, ano = parseInt(params.ano));

    		$$invalidate(1, segments = (_segments[_segments.length - 1].toLowerCase() === "index"
    		? _segments.slice(0, _segments.length - 1)
    		: _segments).join("/"));

    		menus.set(updateMenu(menu, _segments));
    		window.scrollTo(0, 0);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layout> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Layout", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		route,
    		settings,
    		Breadcrumb,
    		DropdownLista: Lista,
    		Link,
    		Gear,
    		menu,
    		menuStore: menus,
    		updateMenu,
    		ano,
    		segments,
    		refresh,
    		$route,
    		$menuStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("ano" in $$props) $$invalidate(0, ano = $$props.ano);
    		if ("segments" in $$props) $$invalidate(1, segments = $$props.segments);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$route*/ 8) {
    			 refresh($route);
    		}
    	};

    	return [ano, segments, $menuStore, $route, refresh, $$slots, $$scope];
    }

    class Layout$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Layout",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\despesas\destino-do-dinheiro\index.svelte generated by Svelte v3.22.3 */

    function create_fragment$y(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("teste");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Destino_do_dinheiro> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Destino_do_dinheiro", $$slots, []);
    	return [];
    }

    class Destino_do_dinheiro extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Destino_do_dinheiro",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    var faTimesCircle = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'times-circle';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f057';
    var svgPathData = 'M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faTimesCircle = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faTimesCircle);
    var faTimesCircle_1 = faTimesCircle.definition;
    var faTimesCircle_2 = faTimesCircle.faTimesCircle;
    var faTimesCircle_3 = faTimesCircle.prefix;
    var faTimesCircle_4 = faTimesCircle.iconName;
    var faTimesCircle_5 = faTimesCircle.width;
    var faTimesCircle_6 = faTimesCircle.height;
    var faTimesCircle_7 = faTimesCircle.ligatures;
    var faTimesCircle_8 = faTimesCircle.unicode;
    var faTimesCircle_9 = faTimesCircle.svgPathData;

    /* src\components\Navigation\Modal.svelte generated by Svelte v3.22.3 */
    const file$x = "src\\components\\Navigation\\Modal.svelte";
    const get_header_slot_changes = dirty => ({});
    const get_header_slot_context = ctx => ({});

    // (84:0) {#if visible}
    function create_if_block$b(ctx) {
    	let div0;
    	let t0;
    	let div5;
    	let div4;
    	let div1;
    	let span;
    	let t1;
    	let t2;
    	let div3;
    	let div2;
    	let div5_class_value;
    	let current;
    	let dispose;

    	const icon = new Icon({
    			props: { icon: faTimesCircle_2 },
    			$$inline: true
    		});

    	const header_slot_template = /*$$slots*/ ctx[8].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[7], get_header_slot_context);
    	const default_slot_template = /*$$slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			span = element("span");
    			create_component(icon.$$.fragment);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			t2 = space();
    			div3 = element("div");
    			div2 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "modal-background svelte-1dv5lln");
    			add_location(div0, file$x, 84, 2, 1517);
    			attr_dev(span, "class", "absolute cursor-pointer text-red-700 text-xl");
    			set_style(span, "top", "-.50em");
    			set_style(span, "right", ".25em");
    			add_location(span, file$x, 93, 8, 1721);
    			attr_dev(div1, "class", "header svelte-1dv5lln");
    			add_location(div1, file$x, 92, 6, 1691);
    			attr_dev(div2, "class", "px-5");
    			add_location(div2, file$x, 103, 8, 2004);
    			attr_dev(div3, "class", "body svelte-1dv5lln");
    			add_location(div3, file$x, 102, 6, 1976);
    			attr_dev(div4, "class", "relative");
    			add_location(div4, file$x, 91, 4, 1661);
    			attr_dev(div5, "class", div5_class_value = "" + (null_to_empty(/*$$props*/ ctx[4].class) + " svelte-1dv5lln"));
    			attr_dev(div5, "tabindex", "0");
    			toggle_class(div5, "modal", true);
    			add_location(div5, file$x, 86, 2, 1555);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, span);
    			mount_component(icon, span, null);
    			append_dev(div1, t1);

    			if (header_slot) {
    				header_slot.m(div1, null);
    			}

    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, div2);

    			if (default_slot) {
    				default_slot.m(div2, null);
    			}

    			/*div5_binding*/ ctx[9](div5);
    			current = true;
    			if (remount) dispose();
    			dispose = listen_dev(span, "click", /*close*/ ctx[0], false, false, false);
    		},
    		p: function update(ctx, dirty) {
    			if (header_slot) {
    				if (header_slot.p && dirty & /*$$scope*/ 128) {
    					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[7], get_header_slot_context), get_slot_changes(header_slot_template, /*$$scope*/ ctx[7], dirty, get_header_slot_changes));
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[7], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null));
    				}
    			}

    			if (!current || dirty & /*$$props*/ 16 && div5_class_value !== (div5_class_value = "" + (null_to_empty(/*$$props*/ ctx[4].class) + " svelte-1dv5lln"))) {
    				attr_dev(div5, "class", div5_class_value);
    			}

    			if (dirty & /*$$props*/ 16) {
    				toggle_class(div5, "modal", true);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			transition_in(header_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			transition_out(header_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div5);
    			destroy_component(icon);
    			if (header_slot) header_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			/*div5_binding*/ ctx[9](null);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(84:0) {#if visible}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let if_block_anchor;
    	let current;
    	let dispose;
    	let if_block = /*visible*/ ctx[1] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) dispose();
    			dispose = listen_dev(window, "keydown", /*handleKeydown*/ ctx[3], false, false, false);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*visible*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*visible*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const esc = 27;

    function instance$z($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	let visible = false;
    	let modalRef = null;

    	function handleKeydown(event) {
    		if (event.target === modalRef && event.which === esc) {
    			close();
    		}
    	}

    	async function show() {
    		$$invalidate(1, visible = true);
    	}

    	async function close() {
    		dispatch("close");
    		await tick();
    		$$invalidate(1, visible = false);
    	}

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Modal", $$slots, ['header','default']);

    	function div5_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(2, modalRef = $$value);
    		});
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		tick,
    		Icon,
    		faTimesCircle: faTimesCircle_2,
    		dispatch,
    		esc,
    		visible,
    		modalRef,
    		handleKeydown,
    		show,
    		close
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    		if ("visible" in $$props) $$invalidate(1, visible = $$new_props.visible);
    		if ("modalRef" in $$props) $$invalidate(2, modalRef = $$new_props.modalRef);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*modalRef*/ 4) {
    			 if (modalRef) {
    				modalRef.focus();
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		close,
    		visible,
    		modalRef,
    		handleKeydown,
    		$$props,
    		show,
    		dispatch,
    		$$scope,
    		$$slots,
    		div5_binding
    	];
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { show: 5, close: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get show() {
    		return this.$$.ctx[5];
    	}

    	set show(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		return this.$$.ctx[0];
    	}

    	set close(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var faExclamationCircle = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'exclamation-circle';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f06a';
    var svgPathData = 'M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faExclamationCircle = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faExclamationCircle);
    var faExclamationCircle_1 = faExclamationCircle.definition;
    var faExclamationCircle_2 = faExclamationCircle.faExclamationCircle;
    var faExclamationCircle_3 = faExclamationCircle.prefix;
    var faExclamationCircle_4 = faExclamationCircle.iconName;
    var faExclamationCircle_5 = faExclamationCircle.width;
    var faExclamationCircle_6 = faExclamationCircle.height;
    var faExclamationCircle_7 = faExclamationCircle.ligatures;
    var faExclamationCircle_8 = faExclamationCircle.unicode;
    var faExclamationCircle_9 = faExclamationCircle.svgPathData;

    var faCheckCircle = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'check-circle';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f058';
    var svgPathData = 'M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faCheckCircle = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faCheckCircle);
    var faCheckCircle_1 = faCheckCircle.definition;
    var faCheckCircle_2 = faCheckCircle.faCheckCircle;
    var faCheckCircle_3 = faCheckCircle.prefix;
    var faCheckCircle_4 = faCheckCircle.iconName;
    var faCheckCircle_5 = faCheckCircle.width;
    var faCheckCircle_6 = faCheckCircle.height;
    var faCheckCircle_7 = faCheckCircle.ligatures;
    var faCheckCircle_8 = faCheckCircle.unicode;
    var faCheckCircle_9 = faCheckCircle.svgPathData;

    var faHistory = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'history';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f1da';
    var svgPathData = 'M504 255.531c.253 136.64-111.18 248.372-247.82 248.468-59.015.042-113.223-20.53-155.822-54.911-11.077-8.94-11.905-25.541-1.839-35.607l11.267-11.267c8.609-8.609 22.353-9.551 31.891-1.984C173.062 425.135 212.781 440 256 440c101.705 0 184-82.311 184-184 0-101.705-82.311-184-184-184-48.814 0-93.149 18.969-126.068 49.932l50.754 50.754c10.08 10.08 2.941 27.314-11.313 27.314H24c-8.837 0-16-7.163-16-16V38.627c0-14.254 17.234-21.393 27.314-11.314l49.372 49.372C129.209 34.136 189.552 8 256 8c136.81 0 247.747 110.78 248 247.531zm-180.912 78.784l9.823-12.63c8.138-10.463 6.253-25.542-4.21-33.679L288 256.349V152c0-13.255-10.745-24-24-24h-16c-13.255 0-24 10.745-24 24v135.651l65.409 50.874c10.463 8.137 25.541 6.253 33.679-4.21z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faHistory = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faHistory);
    var faHistory_1 = faHistory.definition;
    var faHistory_2 = faHistory.faHistory;
    var faHistory_3 = faHistory.prefix;
    var faHistory_4 = faHistory.iconName;
    var faHistory_5 = faHistory.width;
    var faHistory_6 = faHistory.height;
    var faHistory_7 = faHistory.ligatures;
    var faHistory_8 = faHistory.unicode;
    var faHistory_9 = faHistory.svgPathData;

    /* src\pages\municipio\[ano]\[municipio]\[ug]\_components\PrestacaoContaMensal.svelte generated by Svelte v3.22.3 */
    const file$y = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\_components\\PrestacaoContaMensal.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	child_ctx[14] = i;
    	return child_ctx;
    }

    // (108:0) {:else}
    function create_else_block$5(ctx) {
    	let span;
    	let t;
    	let div;
    	let current;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*possuiMesObrigatorio*/ ctx[1] || /*ultimoSemOmissao*/ ctx[6]) return create_if_block_5;
    		return create_else_block_3;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	let modal_props = {
    		$$slots: {
    			default: [create_default_slot$e],
    			header: [create_header_slot]
    		},
    		$$scope: { ctx }
    	};

    	const modal = new Modal({ props: modal_props, $$inline: true });
    	/*modal_binding*/ ctx[11](modal);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			t = space();
    			div = element("div");
    			create_component(modal.$$.fragment);
    			attr_dev(span, "class", "cursor-pointer text-blue-800");
    			add_location(span, file$y, 108, 2, 2804);
    			attr_dev(div, "class", "modal-container svelte-odtq20");
    			add_location(div, file$y, 118, 2, 3107);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, span, anchor);
    			if_block.m(span, null);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(modal, div, null);
    			current = true;
    			if (remount) dispose();
    			dispose = listen_dev(span, "click", /*click_handler*/ ctx[10], false, false, false);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}

    			const modal_changes = {};

    			if (dirty & /*$$scope, ultimoItem, omissoes, items*/ 32824) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_block.d();
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			/*modal_binding*/ ctx[11](null);
    			destroy_component(modal);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(108:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (106:0) {#if loading}
    function create_if_block$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Carregando dados da prestação de contas...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(106:0) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (113:4) {:else}
    function create_else_block_3(ctx) {
    	let b;
    	let t1;

    	const block = {
    		c: function create() {
    			b = element("b");
    			b.textContent = "Não";
    			t1 = text("\r\n      há mês obrigatórios ainda");
    			add_location(b, file$y, 113, 6, 3036);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, b, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(b);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(113:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (110:4) {#if possuiMesObrigatorio || ultimoSemOmissao}
    function create_if_block_5(ctx) {
    	let t0;
    	let b;
    	let t1_value = /*ultimoSemOmissao*/ ctx[6].nomeMes.toUpperCase() + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Dados acumulados até\r\n      ");
    			b = element("b");
    			t1 = text(t1_value);
    			add_location(b, file$y, 111, 6, 2968);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, b, anchor);
    			append_dev(b, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ultimoSemOmissao*/ 64 && t1_value !== (t1_value = /*ultimoSemOmissao*/ ctx[6].nomeMes.toUpperCase() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(b);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(110:4) {#if possuiMesObrigatorio || ultimoSemOmissao}",
    		ctx
    	});

    	return block;
    }

    // (121:6) <span slot="header">
    function create_header_slot(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Situação do envio de remessas ao TCE-ES";
    			attr_dev(span, "slot", "header");
    			add_location(span, file$y, 120, 6, 3178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot.name,
    		type: "slot",
    		source: "(121:6) <span slot=\\\"header\\\">",
    		ctx
    	});

    	return block;
    }

    // (140:14) {:else}
    function create_else_block_2(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faHistory_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "class", "text-gray-600 rotate-x");
    			add_location(span, file$y, 140, 16, 4034);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(140:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (136:39) 
    function create_if_block_4(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faExclamationCircle_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "class", "text-red-800");
    			add_location(span, file$y, 136, 16, 3886);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(136:39) ",
    		ctx
    	});

    	return block;
    }

    // (132:38) 
    function create_if_block_3$1(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faCheckCircle_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "class", "text-yellow-600");
    			add_location(span, file$y, 132, 16, 3723);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(132:38) ",
    		ctx
    	});

    	return block;
    }

    // (128:14) {#if item.emDia}
    function create_if_block_2$2(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faCheckCircle_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "class", "text-green-600");
    			add_location(span, file$y, 128, 16, 3562);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(128:14) {#if item.emDia}",
    		ctx
    	});

    	return block;
    }

    // (125:8) {#each items as item, index}
    function create_each_block$e(ctx) {
    	let div1;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let t1_value = /*item*/ ctx[12].nomeMesAbreviado + "";
    	let t1;
    	let t2;
    	let div1_title_value;
    	let current;
    	const if_block_creators = [create_if_block_2$2, create_if_block_3$1, create_if_block_4, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*item*/ ctx[12].emDia) return 0;
    		if (/*item*/ ctx[12].emAtraso) return 1;
    		if (/*item*/ ctx[12].emOmissao) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(div0, "class", "bg-gray-400 text-center p-3 border rounded");
    			add_location(div0, file$y, 126, 12, 3456);
    			attr_dev(div1, "class", "w-1/3 px-2 py-1");
    			attr_dev(div1, "title", div1_title_value = /*getTooltip*/ ctx[7](/*item*/ ctx[12]));
    			add_location(div1, file$y, 125, 10, 3388);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div1, t2);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, t0);
    			}

    			if ((!current || dirty & /*items*/ 8) && t1_value !== (t1_value = /*item*/ ctx[12].nomeMesAbreviado + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*items*/ 8 && div1_title_value !== (div1_title_value = /*getTooltip*/ ctx[7](/*item*/ ctx[12]))) {
    				attr_dev(div1, "title", div1_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(125:8) {#each items as item, index}",
    		ctx
    	});

    	return block;
    }

    // (164:6) {:else}
    function create_else_block_1$1(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*ultimoItem*/ ctx[5].ano + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Para o exercício de ");
    			t1 = text(t1_value);
    			t2 = text(" não há remessas pendentes de\r\n          dados de PCM junto ao TCE-ES.");
    			attr_dev(p, "class", "mt-2");
    			add_location(p, file$y, 164, 8, 4690);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ultimoItem*/ 32 && t1_value !== (t1_value = /*ultimoItem*/ ctx[5].ano + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(164:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (151:6) {#if omissoes.length > 0}
    function create_if_block_1$7(ctx) {
    	let p0;
    	let t0;
    	let t1_value = /*ultimoItem*/ ctx[5].ano + "";
    	let t1;
    	let t2;
    	let b0;
    	let t3_value = /*omissoes*/ ctx[4].join(", ") + "";
    	let t3;
    	let t4;
    	let t5;
    	let p1;
    	let b1;
    	let t6;
    	let t7_value = dateFormat(/*ultimoItem*/ ctx[5].dataLimite, "extenso") + "";
    	let t7;
    	let t8;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			t0 = text("Para o exercício de ");
    			t1 = text(t1_value);
    			t2 = text(" estão pendentes as remessas de\r\n          dados de PCM referentes a\r\n          ");
    			b0 = element("b");
    			t3 = text(t3_value);
    			t4 = text("\r\n          .");
    			t5 = space();
    			p1 = element("p");
    			b1 = element("b");
    			t6 = text("O prazo se encerrou em ");
    			t7 = text(t7_value);
    			t8 = text(".");
    			add_location(b0, file$y, 154, 10, 4459);
    			attr_dev(p0, "class", "mt-2");
    			add_location(p0, file$y, 151, 8, 4315);
    			add_location(b1, file$y, 159, 10, 4554);
    			attr_dev(p1, "class", "mt-2");
    			add_location(p1, file$y, 158, 8, 4526);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t0);
    			append_dev(p0, t1);
    			append_dev(p0, t2);
    			append_dev(p0, b0);
    			append_dev(b0, t3);
    			append_dev(p0, t4);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, b1);
    			append_dev(b1, t6);
    			append_dev(b1, t7);
    			append_dev(b1, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ultimoItem*/ 32 && t1_value !== (t1_value = /*ultimoItem*/ ctx[5].ano + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*omissoes*/ 16 && t3_value !== (t3_value = /*omissoes*/ ctx[4].join(", ") + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*ultimoItem*/ 32 && t7_value !== (t7_value = dateFormat(/*ultimoItem*/ ctx[5].dataLimite, "extenso") + "")) set_data_dev(t7, t7_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(p1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(151:6) {#if omissoes.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (120:4) <Modal bind:this={modalRef}>
    function create_default_slot$e(ctx) {
    	let t0;
    	let hr;
    	let t1;
    	let div;
    	let t2;
    	let if_block_anchor;
    	let current;
    	let each_value = /*items*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	function select_block_type_3(ctx, dirty) {
    		if (/*omissoes*/ ctx[4].length > 0) return create_if_block_1$7;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type_3(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			hr = element("hr");
    			t1 = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(hr, "class", "mb-3");
    			add_location(hr, file$y, 121, 6, 3252);
    			attr_dev(div, "class", "w-full px-4 py-2 bg-gray-200 flex flex-wrap");
    			add_location(div, file$y, 123, 6, 3281);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			insert_dev(target, t2, anchor);
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*getTooltip, items, faCheckCircle, faExclamationCircle, faHistory*/ 136) {
    				each_value = /*items*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t2);
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(120:4) <Modal bind:this={modalRef}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$c, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let loading = true;
    	let possuiMesObrigatorio = false;
    	let modalRef;
    	let items;
    	let omissoes;
    	let ultimoItem;
    	let ultimoSemOmissao;

    	function refresh(model) {
    		var hoje = new Date();
    		hoje.setHours(0, 0, 0, 0);
    		$$invalidate(3, items = []);
    		$$invalidate(4, omissoes = []);
    		$$invalidate(5, ultimoItem = undefined);
    		$$invalidate(6, ultimoSemOmissao = undefined);

    		if (!model) {
    			return;
    		}

    		$$invalidate(0, loading = false);

    		for (let i = 0; i < 12; i++) {
    			let item = { mes: i + 1 };

    			if (model.value[i]) {
    				item = { ...model.value[i] };

    				if (item.dataLimite) {
    					item.dataLimite = new Date(item.dataLimite);

    					if (item.emOmissao) {
    						item.emOmissao = true;
    						omissoes.push(meses[i].toLocaleLowerCase());
    					} else {
    						item.dataHomologacao = new Date(item.dataHomologacao);

    						if (!item.emTempo) {
    							$$invalidate(6, ultimoSemOmissao = item);
    						}
    					}

    					$$invalidate(5, ultimoItem = item);
    				}
    			}

    			item.nomeMes = meses[i];
    			item.nomeMesAbreviado = mesesAbreviados[i];
    			items.push(item);
    		}

    		$$invalidate(1, possuiMesObrigatorio = new Date() >= items[0].dataLimite);

    		//para causar revalidação das variáveis
    		$$invalidate(3, items);

    		$$invalidate(4, omissoes);
    	}

    	function getTooltip(item) {
    		if (item.emDia) {
    			return `Remessa recebida em dia (Data limite: ${dateFormat(item.dataLimite, "d/m/Y")}, Data da entrega: ${dateFormat(item.dataHomologacao, "d/m/Y")})`;
    		} else if (item.emAtraso) {
    			return `Remessa recebida com atraso (Data limite: ${dateFormat(item.dataLimite, "d/m/Y")}, Data da entrega: ${dateFormat(item.dataHomologacao, "d/m/Y")})`;
    		} else if (item.emOmissao) {
    			return `Remessa ainda não foi entregue  (Data limite: ${dateFormat(item.dataLimite, "d/m/Y")})`;
    		} else {
    			return `Remessa ainda não obrigatória (Data limite: ${dateFormat(item.dataLimite, "d/m/Y")})`;
    		}
    	}

    	const writable_props = ["model"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PrestacaoContaMensal> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("PrestacaoContaMensal", $$slots, []);
    	const click_handler = () => modalRef.show();

    	function modal_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(2, modalRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(8, model = $$props.model);
    	};

    	$$self.$capture_state = () => ({
    		Modal,
    		Icon,
    		faExclamationCircle: faExclamationCircle_2,
    		faCheckCircle: faCheckCircle_2,
    		faHistory: faHistory_2,
    		date: dateFormat,
    		meses,
    		mesesAbreviados,
    		model,
    		loading,
    		possuiMesObrigatorio,
    		modalRef,
    		items,
    		omissoes,
    		ultimoItem,
    		ultimoSemOmissao,
    		refresh,
    		getTooltip
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(8, model = $$props.model);
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    		if ("possuiMesObrigatorio" in $$props) $$invalidate(1, possuiMesObrigatorio = $$props.possuiMesObrigatorio);
    		if ("modalRef" in $$props) $$invalidate(2, modalRef = $$props.modalRef);
    		if ("items" in $$props) $$invalidate(3, items = $$props.items);
    		if ("omissoes" in $$props) $$invalidate(4, omissoes = $$props.omissoes);
    		if ("ultimoItem" in $$props) $$invalidate(5, ultimoItem = $$props.ultimoItem);
    		if ("ultimoSemOmissao" in $$props) $$invalidate(6, ultimoSemOmissao = $$props.ultimoSemOmissao);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*model*/ 256) {
    			 refresh(model);
    		}
    	};

    	return [
    		loading,
    		possuiMesObrigatorio,
    		modalRef,
    		items,
    		omissoes,
    		ultimoItem,
    		ultimoSemOmissao,
    		getTooltip,
    		model,
    		refresh,
    		click_handler,
    		modal_binding
    	];
    }

    class PrestacaoContaMensal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { model: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PrestacaoContaMensal",
    			options,
    			id: create_fragment$A.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[8] === undefined && !("model" in props)) {
    			console.warn("<PrestacaoContaMensal> was created without expected prop 'model'");
    		}
    	}

    	get model() {
    		throw new Error("<PrestacaoContaMensal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<PrestacaoContaMensal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var faInfoCircle = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'info-circle';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f05a';
    var svgPathData = 'M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faInfoCircle = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faInfoCircle);
    var faInfoCircle_1 = faInfoCircle.definition;
    var faInfoCircle_2 = faInfoCircle.faInfoCircle;
    var faInfoCircle_3 = faInfoCircle.prefix;
    var faInfoCircle_4 = faInfoCircle.iconName;
    var faInfoCircle_5 = faInfoCircle.width;
    var faInfoCircle_6 = faInfoCircle.height;
    var faInfoCircle_7 = faInfoCircle.ligatures;
    var faInfoCircle_8 = faInfoCircle.unicode;
    var faInfoCircle_9 = faInfoCircle.svgPathData;

    function fade(node, { delay = 0, duration = 400, easing = identity }) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    /* src\components\Navigation\Tooltip.svelte generated by Svelte v3.22.3 */
    const file$z = "src\\components\\Navigation\\Tooltip.svelte";
    const get_icon_slot_changes = dirty => ({});
    const get_icon_slot_context = ctx => ({});

    // (56:22) i
    function fallback_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("i");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(56:22) i",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let span2;
    	let span0;
    	let t;
    	let span1;
    	let span1_style_value;
    	let span1_transition;
    	let current;
    	const icon_slot_template = /*$$slots*/ ctx[8].icon;
    	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[7], get_icon_slot_context);
    	const icon_slot_or_fallback = icon_slot || fallback_block$1(ctx);
    	const default_slot_template = /*$$slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			span2 = element("span");
    			span0 = element("span");
    			if (icon_slot_or_fallback) icon_slot_or_fallback.c();
    			t = space();
    			span1 = element("span");
    			if (default_slot) default_slot.c();
    			attr_dev(span0, "class", "text-center w-full float-left");
    			add_location(span0, file$z, 54, 2, 975);
    			attr_dev(span1, "class", "tooltip z-40 svelte-1d1li35");
    			attr_dev(span1, "style", span1_style_value = `width:${/*width*/ ctx[0]}vw;`);
    			toggle_class(span1, "inverse-x", /*inverseX*/ ctx[2]);
    			toggle_class(span1, "hidden", !/*visible*/ ctx[1]);
    			add_location(span1, file$z, 57, 2, 1066);
    			attr_dev(span2, "class", "relative w-full float-left");
    			add_location(span2, file$z, 53, 0, 930);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span2, anchor);
    			append_dev(span2, span0);

    			if (icon_slot_or_fallback) {
    				icon_slot_or_fallback.m(span0, null);
    			}

    			append_dev(span2, t);
    			append_dev(span2, span1);

    			if (default_slot) {
    				default_slot.m(span1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (icon_slot) {
    				if (icon_slot.p && dirty & /*$$scope*/ 128) {
    					icon_slot.p(get_slot_context(icon_slot_template, ctx, /*$$scope*/ ctx[7], get_icon_slot_context), get_slot_changes(icon_slot_template, /*$$scope*/ ctx[7], dirty, get_icon_slot_changes));
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[7], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null));
    				}
    			}

    			if (!current || dirty & /*width*/ 1 && span1_style_value !== (span1_style_value = `width:${/*width*/ ctx[0]}vw;`)) {
    				attr_dev(span1, "style", span1_style_value);
    			}

    			if (dirty & /*inverseX*/ 4) {
    				toggle_class(span1, "inverse-x", /*inverseX*/ ctx[2]);
    			}

    			if (dirty & /*visible*/ 2) {
    				toggle_class(span1, "hidden", !/*visible*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_slot_or_fallback, local);
    			transition_in(default_slot, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!span1_transition) span1_transition = create_bidirectional_transition(span1, fade, { duration: 150 }, true);
    					span1_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_slot_or_fallback, local);
    			transition_out(default_slot, local);

    			if (local) {
    				if (!span1_transition) span1_transition = create_bidirectional_transition(span1, fade, { duration: 150 }, false);
    				span1_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span2);
    			if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && span1_transition) span1_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let visible = false;
    	let hideTimer;
    	let inverseX = false;
    	let { width = 40 } = $$props;
    	let { hideTimeout = 250 } = $$props;

    	function show(e) {
    		clearTimeout(hideTimer);

    		if (visible) {
    			return;
    		}

    		const widthPx = width / 100 * e.view.innerWidth;
    		const diff = e.x + widthPx - e.view.innerWidth;

    		if (diff > 0) {
    			$$invalidate(2, inverseX = true);
    		}

    		$$invalidate(1, visible = true);
    	}

    	function hide(e) {
    		hideTimer = setTimeout(
    			() => {
    				$$invalidate(2, inverseX = false);
    				$$invalidate(1, visible = false);
    			},
    			hideTimeout
    		);
    	}

    	const writable_props = ["width", "hideTimeout"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tooltip> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Tooltip", $$slots, ['icon','default']);

    	$$self.$set = $$props => {
    		if ("width" in $$props) $$invalidate(0, width = $$props.width);
    		if ("hideTimeout" in $$props) $$invalidate(3, hideTimeout = $$props.hideTimeout);
    		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		visible,
    		hideTimer,
    		inverseX,
    		width,
    		hideTimeout,
    		show,
    		hide
    	});

    	$$self.$inject_state = $$props => {
    		if ("visible" in $$props) $$invalidate(1, visible = $$props.visible);
    		if ("hideTimer" in $$props) hideTimer = $$props.hideTimer;
    		if ("inverseX" in $$props) $$invalidate(2, inverseX = $$props.inverseX);
    		if ("width" in $$props) $$invalidate(0, width = $$props.width);
    		if ("hideTimeout" in $$props) $$invalidate(3, hideTimeout = $$props.hideTimeout);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, visible, inverseX, hideTimeout, show, hide, hideTimer, $$scope, $$slots];
    }

    class Tooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
    			width: 0,
    			hideTimeout: 3,
    			show: 4,
    			hide: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tooltip",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get width() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideTimeout() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideTimeout(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get show() {
    		return this.$$.ctx[4];
    	}

    	set show(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hide() {
    		return this.$$.ctx[5];
    	}

    	set hide(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Widget\Widget.svelte generated by Svelte v3.22.3 */
    const file$A = "src\\components\\Widget\\Widget.svelte";
    const get_tooltip_slot_changes = dirty => ({});
    const get_tooltip_slot_context = ctx => ({});
    const get_title_slot_changes = dirty => ({});
    const get_title_slot_context = ctx => ({});

    // (30:10) <span slot="icon" class="text-gray-400 hover:text-gray-700 pr-2">
    function create_icon_slot(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faInfoCircle_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			attr_dev(span, "class", "text-gray-400 hover:text-gray-700 pr-2");
    			add_location(span, file$A, 29, 10, 862);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot.name,
    		type: "slot",
    		source: "(30:10) <span slot=\\\"icon\\\" class=\\\"text-gray-400 hover:text-gray-700 pr-2\\\">",
    		ctx
    	});

    	return block;
    }

    // (29:8) <Tooltip bind:this={tooltip}>
    function create_default_slot$f(ctx) {
    	let t;
    	let span;
    	let current;
    	const tooltip_slot_template = /*$$slots*/ ctx[4].tooltip;
    	const tooltip_slot = create_slot(tooltip_slot_template, ctx, /*$$scope*/ ctx[6], get_tooltip_slot_context);

    	const block = {
    		c: function create() {
    			t = space();
    			span = element("span");
    			if (tooltip_slot) tooltip_slot.c();
    			attr_dev(span, "class", "leading-none");
    			add_location(span, file$A, 32, 10, 1000);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, span, anchor);

    			if (tooltip_slot) {
    				tooltip_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (tooltip_slot) {
    				if (tooltip_slot.p && dirty & /*$$scope*/ 64) {
    					tooltip_slot.p(get_slot_context(tooltip_slot_template, ctx, /*$$scope*/ ctx[6], get_tooltip_slot_context), get_slot_changes(tooltip_slot_template, /*$$scope*/ ctx[6], dirty, get_tooltip_slot_changes));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(span);
    			if (tooltip_slot) tooltip_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(29:8) <Tooltip bind:this={tooltip}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let div2;
    	let div0;
    	let span1;
    	let p;
    	let t0;
    	let span0;
    	let t1;
    	let div1;
    	let current;
    	let dispose;
    	const title_slot_template = /*$$slots*/ ctx[4].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[6], get_title_slot_context);

    	let tooltip_1_props = {
    		$$slots: {
    			default: [create_default_slot$f],
    			icon: [create_icon_slot]
    		},
    		$$scope: { ctx }
    	};

    	const tooltip_1 = new Tooltip({ props: tooltip_1_props, $$inline: true });
    	/*tooltip_1_binding*/ ctx[5](tooltip_1);
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			span1 = element("span");
    			p = element("p");
    			if (title_slot) title_slot.c();
    			t0 = space();
    			span0 = element("span");
    			create_component(tooltip_1.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(p, "class", "w-full font-semibold");
    			add_location(p, file$A, 20, 6, 577);
    			attr_dev(span0, "class", "absolute top-0 right-0");
    			toggle_class(span0, "hidden", /*noTooltip*/ ctx[0]);
    			add_location(span0, file$A, 23, 6, 660);
    			attr_dev(span1, "class", "w-full relative border-b pl-2 leading-loose");
    			add_location(span1, file$A, 19, 4, 511);
    			attr_dev(div0, "class", "bg-gray-100 flex justify-between text-sm");
    			add_location(div0, file$A, 18, 2, 451);
    			attr_dev(div1, "class", "bg-white p-2 md:p-1");
    			add_location(div1, file$A, 39, 2, 1145);
    			attr_dev(div2, "class", "float-left rounded w-full");
    			set_style(div2, "border", "1px solid #f0f0f0");
    			add_location(div2, file$A, 17, 0, 374);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, span1);
    			append_dev(span1, p);

    			if (title_slot) {
    				title_slot.m(p, null);
    			}

    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			mount_component(tooltip_1, span0, null);
    			append_dev(div2, t1);
    			append_dev(div2, div1);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(span0, "mouseover", /*showTooltip*/ ctx[2], false, false, false),
    				listen_dev(span0, "mouseout", /*hideTooltip*/ ctx[3], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (title_slot) {
    				if (title_slot.p && dirty & /*$$scope*/ 64) {
    					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[6], get_title_slot_context), get_slot_changes(title_slot_template, /*$$scope*/ ctx[6], dirty, get_title_slot_changes));
    				}
    			}

    			const tooltip_1_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				tooltip_1_changes.$$scope = { dirty, ctx };
    			}

    			tooltip_1.$set(tooltip_1_changes);

    			if (dirty & /*noTooltip*/ 1) {
    				toggle_class(span0, "hidden", /*noTooltip*/ ctx[0]);
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 64) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[6], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			transition_in(tooltip_1.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			transition_out(tooltip_1.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (title_slot) title_slot.d(detaching);
    			/*tooltip_1_binding*/ ctx[5](null);
    			destroy_component(tooltip_1);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { noTooltip = false } = $$props;
    	let tooltip;

    	function showTooltip(e) {
    		tooltip.show(e);
    	}

    	function hideTooltip(e) {
    		tooltip.hide(e);
    	}

    	const writable_props = ["noTooltip"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Widget> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Widget", $$slots, ['title','tooltip','default']);

    	function tooltip_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(1, tooltip = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("noTooltip" in $$props) $$invalidate(0, noTooltip = $$props.noTooltip);
    		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		faInfoCircle: faInfoCircle_2,
    		Tooltip,
    		noTooltip,
    		tooltip,
    		showTooltip,
    		hideTooltip
    	});

    	$$self.$inject_state = $$props => {
    		if ("noTooltip" in $$props) $$invalidate(0, noTooltip = $$props.noTooltip);
    		if ("tooltip" in $$props) $$invalidate(1, tooltip = $$props.tooltip);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		noTooltip,
    		tooltip,
    		showTooltip,
    		hideTooltip,
    		$$slots,
    		tooltip_1_binding,
    		$$scope
    	];
    }

    class Widget extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { noTooltip: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Widget",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get noTooltip() {
    		throw new Error("<Widget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noTooltip(value) {
    		throw new Error("<Widget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Navigation\Loading.svelte generated by Svelte v3.22.3 */

    function create_fragment$D(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Carregando...");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Loading> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Loading", $$slots, []);
    	return [];
    }

    class Loading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loading",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    /* src\components\Drawer\Drawer.svelte generated by Svelte v3.22.3 */
    const file$B = "src\\components\\Drawer\\Drawer.svelte";

    function create_fragment$E(ctx) {
    	let div;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "Drawer navbar w-full lg:w-1/6 mt-16 fixed overflow-x-auto bg-gray-700\r\n  top-0 pb-5 svelte-uy546y");
    			toggle_class(div, "navbar-open", /*$visible*/ ctx[0]);
    			toggle_class(div, "navbar-close", !/*$visible*/ ctx[0]);
    			add_location(div, file$B, 53, 0, 919);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(window, "keyup", onKeyupWindow$1, false, false, false),
    				listen_dev(window, "click", onClickWindow$1, false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[1], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null));
    				}
    			}

    			if (dirty & /*$visible*/ 1) {
    				toggle_class(div, "navbar-open", /*$visible*/ ctx[0]);
    			}

    			if (dirty & /*$visible*/ 1) {
    				toggle_class(div, "navbar-close", !/*$visible*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const visible = writable(false);

    function toggleDrawer() {
    	visible.update(d => !d);
    }

    function showDrawer() {
    	visible.update(d => true);
    }

    function hideDrawer() {
    	visible.update(d => false);
    }

    function onClickWindow$1(e) {
    	hideDrawer();
    }

    function onKeyupWindow$1(e) {
    	const esc = 27;

    	if (e.which === esc) {
    		hideDrawer();
    	}
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let $visible,
    		$$unsubscribe_visible = noop;

    	validate_store(visible, "visible");
    	component_subscribe($$self, visible, $$value => $$invalidate(0, $visible = $$value));
    	$$self.$$.on_destroy.push(() => $$unsubscribe_visible());
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Drawer> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Drawer", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		visible,
    		toggleDrawer,
    		showDrawer,
    		hideDrawer,
    		Link,
    		onClickWindow: onClickWindow$1,
    		onKeyupWindow: onKeyupWindow$1,
    		$visible
    	});

    	return [$visible, $$scope, $$slots];
    }

    class Drawer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Drawer",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /**
     * zrender: 生成唯一id
     *
     * @author errorrik (errorrik@gmail.com)
     */
    var idStart = 0x0907;

    function _default$1() {
      return idStart++;
    }

    var guid = _default$1;

    /**
     * echarts设备环境识别
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author firede[firede@firede.us]
     * @desc thanks zepto.
     */

    /* global wx */
    var env = {};

    if (typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function') {
      // In Weixin Application
      env = {
        browser: {},
        os: {},
        node: false,
        wxa: true,
        // Weixin Application
        canvasSupported: true,
        svgSupported: false,
        touchEventsSupported: true,
        domSupported: false
      };
    } else if (typeof document === 'undefined' && typeof self !== 'undefined') {
      // In worker
      env = {
        browser: {},
        os: {},
        node: false,
        worker: true,
        canvasSupported: true,
        domSupported: false
      };
    } else if (typeof navigator === 'undefined') {
      // In node
      env = {
        browser: {},
        os: {},
        node: true,
        worker: false,
        // Assume canvas is supported
        canvasSupported: true,
        svgSupported: true,
        domSupported: false
      };
    } else {
      env = detect(navigator.userAgent);
    }

    var _default$2 = env; // Zepto.js
    // (c) 2010-2013 Thomas Fuchs
    // Zepto.js may be freely distributed under the MIT license.

    function detect(ua) {
      var os = {};
      var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
      // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
      // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
      // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
      // var touchpad = webos && ua.match(/TouchPad/);
      // var kindle = ua.match(/Kindle\/([\d.]+)/);
      // var silk = ua.match(/Silk\/([\d._]+)/);
      // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
      // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
      // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
      // var playbook = ua.match(/PlayBook/);
      // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);

      var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
      // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;

      var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
      || ua.match(/Trident\/.+?rv:(([\d.]+))/);
      var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+

      var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
      // - discern (more) between multiple browsers on android
      // - decide if kindle fire in silk mode is android or not
      // - Firefox on Android doesn't specify the Android version
      // - possibly devide in os, device and browser hashes
      // if (browser.webkit = !!webkit) browser.version = webkit[1];
      // if (android) os.android = true, os.version = android[2];
      // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
      // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
      // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
      // if (webos) os.webos = true, os.version = webos[2];
      // if (touchpad) os.touchpad = true;
      // if (blackberry) os.blackberry = true, os.version = blackberry[2];
      // if (bb10) os.bb10 = true, os.version = bb10[2];
      // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
      // if (playbook) browser.playbook = true;
      // if (kindle) os.kindle = true, os.version = kindle[1];
      // if (silk) browser.silk = true, browser.version = silk[1];
      // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
      // if (chrome) browser.chrome = true, browser.version = chrome[1];

      if (firefox) {
        browser.firefox = true;
        browser.version = firefox[1];
      } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
      // if (webview) browser.webview = true;


      if (ie) {
        browser.ie = true;
        browser.version = ie[1];
      }

      if (edge) {
        browser.edge = true;
        browser.version = edge[1];
      } // It is difficult to detect WeChat in Win Phone precisely, because ua can
      // not be set on win phone. So we do not consider Win Phone.


      if (weChat) {
        browser.weChat = true;
      } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
      //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
      // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
      //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
      //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));


      return {
        browser: browser,
        os: os,
        node: false,
        // 原生canvas支持，改极端点了
        // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
        canvasSupported: !!document.createElement('canvas').getContext,
        svgSupported: typeof SVGRect !== 'undefined',
        // works on most browsers
        // IE10/11 does not support touch event, and MS Edge supports them but not by
        // default, so we dont check navigator.maxTouchPoints for them here.
        touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
        // <http://caniuse.com/#search=pointer%20event>.
        pointerEventsSupported: // (1) Firefox supports pointer but not by default, only MS browsers are reliable on pointer
        // events currently. So we dont use that on other browsers unless tested sufficiently.
        // For example, in iOS 13 Mobile Chromium 78, if the touching behavior starts page
        // scroll, the `pointermove` event can not be fired any more. That will break some
        // features like "pan horizontally to move something and pan vertically to page scroll".
        // The horizontal pan probably be interrupted by the casually triggered page scroll.
        // (2) Although IE 10 supports pointer event, it use old style and is different from the
        // standard. So we exclude that. (IE 10 is hardly used on touch device)
        'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 11),
        // passiveSupported: detectPassiveSupport()
        domSupported: typeof document !== 'undefined'
      };
    } // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
    // function detectPassiveSupport() {
    //     // Test via a getter in the options object to see if the passive property is accessed
    //     var supportsPassive = false;
    //     try {
    //         var opts = Object.defineProperty({}, 'passive', {
    //             get: function() {
    //                 supportsPassive = true;
    //             }
    //         });
    //         window.addEventListener('testPassive', function() {}, opts);
    //     } catch (e) {
    //     }
    //     return supportsPassive;
    // }


    var env_1 = _default$2;

    /**
     * @module zrender/core/util
     */
    // 用于处理merge时无法遍历Date等对象的问题
    var BUILTIN_OBJECT = {
      '[object Function]': 1,
      '[object RegExp]': 1,
      '[object Date]': 1,
      '[object Error]': 1,
      '[object CanvasGradient]': 1,
      '[object CanvasPattern]': 1,
      // For node-canvas
      '[object Image]': 1,
      '[object Canvas]': 1
    };
    var TYPED_ARRAY = {
      '[object Int8Array]': 1,
      '[object Uint8Array]': 1,
      '[object Uint8ClampedArray]': 1,
      '[object Int16Array]': 1,
      '[object Uint16Array]': 1,
      '[object Int32Array]': 1,
      '[object Uint32Array]': 1,
      '[object Float32Array]': 1,
      '[object Float64Array]': 1
    };
    var objToString = Object.prototype.toString;
    var arrayProto = Array.prototype;
    var nativeForEach = arrayProto.forEach;
    var nativeFilter = arrayProto.filter;
    var nativeSlice = arrayProto.slice;
    var nativeMap = arrayProto.map;
    var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.

    var methods = {};

    function $override(name, fn) {
      // Clear ctx instance for different environment
      if (name === 'createCanvas') {
        _ctx = null;
      }

      methods[name] = fn;
    }
    /**
     * Those data types can be cloned:
     *     Plain object, Array, TypedArray, number, string, null, undefined.
     * Those data types will be assgined using the orginal data:
     *     BUILTIN_OBJECT
     * Instance of user defined class will be cloned to a plain object, without
     * properties in prototype.
     * Other data types is not supported (not sure what will happen).
     *
     * Caution: do not support clone Date, for performance consideration.
     * (There might be a large number of date in `series.data`).
     * So date should not be modified in and out of echarts.
     *
     * @param {*} source
     * @return {*} new
     */


    function clone$1(source) {
      if (source == null || typeof source !== 'object') {
        return source;
      }

      var result = source;
      var typeStr = objToString.call(source);

      if (typeStr === '[object Array]') {
        if (!isPrimitive(source)) {
          result = [];

          for (var i = 0, len = source.length; i < len; i++) {
            result[i] = clone$1(source[i]);
          }
        }
      } else if (TYPED_ARRAY[typeStr]) {
        if (!isPrimitive(source)) {
          var Ctor = source.constructor;

          if (source.constructor.from) {
            result = Ctor.from(source);
          } else {
            result = new Ctor(source.length);

            for (var i = 0, len = source.length; i < len; i++) {
              result[i] = clone$1(source[i]);
            }
          }
        }
      } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
        result = {};

        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            result[key] = clone$1(source[key]);
          }
        }
      }

      return result;
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} target
     * @param {*} source
     * @param {boolean} [overwrite=false]
     */


    function merge$1(target, source, overwrite) {
      // We should escapse that source is string
      // and enter for ... in ...
      if (!isObject$1(source) || !isObject$1(target)) {
        return overwrite ? clone$1(source) : target;
      }

      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          var targetProp = target[key];
          var sourceProp = source[key];

          if (isObject$1(sourceProp) && isObject$1(targetProp) && !isArray$1(sourceProp) && !isArray$1(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
            // 如果需要递归覆盖，就递归调用merge
            merge$1(targetProp, sourceProp, overwrite);
          } else if (overwrite || !(key in target)) {
            // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
            // NOTE，在 target[key] 不存在的时候也是直接覆盖
            target[key] = clone$1(source[key]);
          }
        }
      }

      return target;
    }
    /**
     * @param {Array} targetAndSources The first item is target, and the rests are source.
     * @param {boolean} [overwrite=false]
     * @return {*} target
     */


    function mergeAll(targetAndSources, overwrite) {
      var result = targetAndSources[0];

      for (var i = 1, len = targetAndSources.length; i < len; i++) {
        result = merge$1(result, targetAndSources[i], overwrite);
      }

      return result;
    }
    /**
     * @param {*} target
     * @param {*} source
     * @memberOf module:zrender/core/util
     */


    function extend$1(target, source) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          target[key] = source[key];
        }
      }

      return target;
    }
    /**
     * @param {*} target
     * @param {*} source
     * @param {boolean} [overlay=false]
     * @memberOf module:zrender/core/util
     */


    function defaults$1(target, source, overlay) {
      for (var key in source) {
        if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
          target[key] = source[key];
        }
      }

      return target;
    }

    var createCanvas = function () {
      return methods.createCanvas();
    };

    methods.createCanvas = function () {
      return document.createElement('canvas');
    }; // FIXME


    var _ctx;

    function getContext$1() {
      if (!_ctx) {
        // Use util.createCanvas instead of createCanvas
        // because createCanvas may be overwritten in different environment
        _ctx = createCanvas().getContext('2d');
      }

      return _ctx;
    }
    /**
     * 查询数组中元素的index
     * @memberOf module:zrender/core/util
     */


    function indexOf(array, value) {
      if (array) {
        if (array.indexOf) {
          return array.indexOf(value);
        }

        for (var i = 0, len = array.length; i < len; i++) {
          if (array[i] === value) {
            return i;
          }
        }
      }

      return -1;
    }
    /**
     * 构造类继承关系
     *
     * @memberOf module:zrender/core/util
     * @param {Function} clazz 源类
     * @param {Function} baseClazz 基类
     */


    function inherits(clazz, baseClazz) {
      var clazzPrototype = clazz.prototype;

      function F() {}

      F.prototype = baseClazz.prototype;
      clazz.prototype = new F();

      for (var prop in clazzPrototype) {
        if (clazzPrototype.hasOwnProperty(prop)) {
          clazz.prototype[prop] = clazzPrototype[prop];
        }
      }

      clazz.prototype.constructor = clazz;
      clazz.superClass = baseClazz;
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {Object|Function} target
     * @param {Object|Function} sorce
     * @param {boolean} overlay
     */


    function mixin(target, source, overlay) {
      target = 'prototype' in target ? target.prototype : target;
      source = 'prototype' in source ? source.prototype : source;
      defaults$1(target, source, overlay);
    }
    /**
     * Consider typed array.
     * @param {Array|TypedArray} data
     */


    function isArrayLike(data) {
      if (!data) {
        return;
      }

      if (typeof data === 'string') {
        return false;
      }

      return typeof data.length === 'number';
    }
    /**
     * 数组或对象遍历
     * @memberOf module:zrender/core/util
     * @param {Object|Array} obj
     * @param {Function} cb
     * @param {*} [context]
     */


    function each(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }

      if (obj.forEach && obj.forEach === nativeForEach) {
        obj.forEach(cb, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, len = obj.length; i < len; i++) {
          cb.call(context, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            cb.call(context, obj[key], key, obj);
          }
        }
      }
    }
    /**
     * 数组映射
     * @memberOf module:zrender/core/util
     * @param {Array} obj
     * @param {Function} cb
     * @param {*} [context]
     * @return {Array}
     */


    function map(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }

      if (obj.map && obj.map === nativeMap) {
        return obj.map(cb, context);
      } else {
        var result = [];

        for (var i = 0, len = obj.length; i < len; i++) {
          result.push(cb.call(context, obj[i], i, obj));
        }

        return result;
      }
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {Array} obj
     * @param {Function} cb
     * @param {Object} [memo]
     * @param {*} [context]
     * @return {Array}
     */


    function reduce(obj, cb, memo, context) {
      if (!(obj && cb)) {
        return;
      }

      if (obj.reduce && obj.reduce === nativeReduce) {
        return obj.reduce(cb, memo, context);
      } else {
        for (var i = 0, len = obj.length; i < len; i++) {
          memo = cb.call(context, memo, obj[i], i, obj);
        }

        return memo;
      }
    }
    /**
     * 数组过滤
     * @memberOf module:zrender/core/util
     * @param {Array} obj
     * @param {Function} cb
     * @param {*} [context]
     * @return {Array}
     */


    function filter(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }

      if (obj.filter && obj.filter === nativeFilter) {
        return obj.filter(cb, context);
      } else {
        var result = [];

        for (var i = 0, len = obj.length; i < len; i++) {
          if (cb.call(context, obj[i], i, obj)) {
            result.push(obj[i]);
          }
        }

        return result;
      }
    }
    /**
     * 数组项查找
     * @memberOf module:zrender/core/util
     * @param {Array} obj
     * @param {Function} cb
     * @param {*} [context]
     * @return {*}
     */


    function find(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }

      for (var i = 0, len = obj.length; i < len; i++) {
        if (cb.call(context, obj[i], i, obj)) {
          return obj[i];
        }
      }
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {Function} func
     * @param {*} context
     * @return {Function}
     */


    function bind$1(func, context) {
      var args = nativeSlice.call(arguments, 2);
      return function () {
        return func.apply(context, args.concat(nativeSlice.call(arguments)));
      };
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {Function} func
     * @return {Function}
     */


    function curry(func) {
      var args = nativeSlice.call(arguments, 1);
      return function () {
        return func.apply(this, args.concat(nativeSlice.call(arguments)));
      };
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */


    function isArray$1(value) {
      return objToString.call(value) === '[object Array]';
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */


    function isFunction$1(value) {
      return typeof value === 'function';
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */


    function isString$1(value) {
      return objToString.call(value) === '[object String]';
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */


    function isObject$1(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return type === 'function' || !!value && type === 'object';
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */


    function isBuiltInObject(value) {
      return !!BUILTIN_OBJECT[objToString.call(value)];
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */


    function isTypedArray(value) {
      return !!TYPED_ARRAY[objToString.call(value)];
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */


    function isDom(value) {
      return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
    }
    /**
     * Whether is exactly NaN. Notice isNaN('a') returns true.
     * @param {*} value
     * @return {boolean}
     */


    function eqNaN(value) {
      /* eslint-disable-next-line no-self-compare */
      return value !== value;
    }
    /**
     * If value1 is not null, then return value1, otherwise judget rest of values.
     * Low performance.
     * @memberOf module:zrender/core/util
     * @return {*} Final value
     */


    function retrieve(values) {
      for (var i = 0, len = arguments.length; i < len; i++) {
        if (arguments[i] != null) {
          return arguments[i];
        }
      }
    }

    function retrieve2(value0, value1) {
      return value0 != null ? value0 : value1;
    }

    function retrieve3(value0, value1, value2) {
      return value0 != null ? value0 : value1 != null ? value1 : value2;
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {Array} arr
     * @param {number} startIndex
     * @param {number} endIndex
     * @return {Array}
     */


    function slice() {
      return Function.call.apply(nativeSlice, arguments);
    }
    /**
     * Normalize css liked array configuration
     * e.g.
     *  3 => [3, 3, 3, 3]
     *  [4, 2] => [4, 2, 4, 2]
     *  [4, 3, 2] => [4, 3, 2, 3]
     * @param {number|Array.<number>} val
     * @return {Array.<number>}
     */


    function normalizeCssArray(val) {
      if (typeof val === 'number') {
        return [val, val, val, val];
      }

      var len = val.length;

      if (len === 2) {
        // vertical | horizontal
        return [val[0], val[1], val[0], val[1]];
      } else if (len === 3) {
        // top | horizontal | bottom
        return [val[0], val[1], val[2], val[1]];
      }

      return val;
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {boolean} condition
     * @param {string} message
     */


    function assert(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {string} str string to be trimed
     * @return {string} trimed string
     */


    function trim$1(str) {
      if (str == null) {
        return null;
      } else if (typeof str.trim === 'function') {
        return str.trim();
      } else {
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
      }
    }

    var primitiveKey = '__ec_primitive__';
    /**
     * Set an object as primitive to be ignored traversing children in clone or merge
     */

    function setAsPrimitive(obj) {
      obj[primitiveKey] = true;
    }

    function isPrimitive(obj) {
      return obj[primitiveKey];
    }
    /**
     * @constructor
     * @param {Object} obj Only apply `ownProperty`.
     */


    function HashMap(obj) {
      var isArr = isArray$1(obj); // Key should not be set on this, otherwise
      // methods get/set/... may be overrided.

      this.data = {};
      var thisMap = this;
      obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);

      function visit(value, key) {
        isArr ? thisMap.set(value, key) : thisMap.set(key, value);
      }
    }

    HashMap.prototype = {
      constructor: HashMap,
      // Do not provide `has` method to avoid defining what is `has`.
      // (We usually treat `null` and `undefined` as the same, different
      // from ES6 Map).
      get: function (key) {
        return this.data.hasOwnProperty(key) ? this.data[key] : null;
      },
      set: function (key, value) {
        // Comparing with invocation chaining, `return value` is more commonly
        // used in this case: `var someVal = map.set('a', genVal());`
        return this.data[key] = value;
      },
      // Although util.each can be performed on this hashMap directly, user
      // should not use the exposed keys, who are prefixed.
      each: function (cb, context) {
        context !== void 0 && (cb = bind$1(cb, context));
        /* eslint-disable guard-for-in */

        for (var key in this.data) {
          this.data.hasOwnProperty(key) && cb(this.data[key], key);
        }
        /* eslint-enable guard-for-in */

      },
      // Do not use this method if performance sensitive.
      removeKey: function (key) {
        delete this.data[key];
      }
    };

    function createHashMap(obj) {
      return new HashMap(obj);
    }

    function concatArray(a, b) {
      var newArray = new a.constructor(a.length + b.length);

      for (var i = 0; i < a.length; i++) {
        newArray[i] = a[i];
      }

      var offset = a.length;

      for (i = 0; i < b.length; i++) {
        newArray[i + offset] = b[i];
      }

      return newArray;
    }

    function noop$1() {}

    var $override_1 = $override;
    var clone_1 = clone$1;
    var merge_1 = merge$1;
    var mergeAll_1 = mergeAll;
    var extend_1 = extend$1;
    var defaults_1$1 = defaults$1;
    var createCanvas_1 = createCanvas;
    var getContext_1 = getContext$1;
    var indexOf_1 = indexOf;
    var inherits_1 = inherits;
    var mixin_1 = mixin;
    var isArrayLike_1 = isArrayLike;
    var each_1 = each;
    var map_1 = map;
    var reduce_1 = reduce;
    var filter_1 = filter;
    var find_1 = find;
    var bind_1 = bind$1;
    var curry_1 = curry;
    var isArray_1 = isArray$1;
    var isFunction_1 = isFunction$1;
    var isString_1 = isString$1;
    var isObject_1 = isObject$1;
    var isBuiltInObject_1 = isBuiltInObject;
    var isTypedArray_1 = isTypedArray;
    var isDom_1 = isDom;
    var eqNaN_1 = eqNaN;
    var retrieve_1 = retrieve;
    var retrieve2_1 = retrieve2;
    var retrieve3_1 = retrieve3;
    var slice_1 = slice;
    var normalizeCssArray_1 = normalizeCssArray;
    var assert_1 = assert;
    var trim_1 = trim$1;
    var setAsPrimitive_1 = setAsPrimitive;
    var isPrimitive_1 = isPrimitive;
    var createHashMap_1 = createHashMap;
    var concatArray_1 = concatArray;
    var noop_1 = noop$1;

    var util = {
    	$override: $override_1,
    	clone: clone_1,
    	merge: merge_1,
    	mergeAll: mergeAll_1,
    	extend: extend_1,
    	defaults: defaults_1$1,
    	createCanvas: createCanvas_1,
    	getContext: getContext_1,
    	indexOf: indexOf_1,
    	inherits: inherits_1,
    	mixin: mixin_1,
    	isArrayLike: isArrayLike_1,
    	each: each_1,
    	map: map_1,
    	reduce: reduce_1,
    	filter: filter_1,
    	find: find_1,
    	bind: bind_1,
    	curry: curry_1,
    	isArray: isArray_1,
    	isFunction: isFunction_1,
    	isString: isString_1,
    	isObject: isObject_1,
    	isBuiltInObject: isBuiltInObject_1,
    	isTypedArray: isTypedArray_1,
    	isDom: isDom_1,
    	eqNaN: eqNaN_1,
    	retrieve: retrieve_1,
    	retrieve2: retrieve2_1,
    	retrieve3: retrieve3_1,
    	slice: slice_1,
    	normalizeCssArray: normalizeCssArray_1,
    	assert: assert_1,
    	trim: trim_1,
    	setAsPrimitive: setAsPrimitive_1,
    	isPrimitive: isPrimitive_1,
    	createHashMap: createHashMap_1,
    	concatArray: concatArray_1,
    	noop: noop_1
    };

    /* global Float32Array */
    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
    /**
     * 创建一个向量
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @return {Vector2}
     */

    function create$1(x, y) {
      var out = new ArrayCtor(2);

      if (x == null) {
        x = 0;
      }

      if (y == null) {
        y = 0;
      }

      out[0] = x;
      out[1] = y;
      return out;
    }
    /**
     * 复制向量数据
     * @param {Vector2} out
     * @param {Vector2} v
     * @return {Vector2}
     */


    function copy(out, v) {
      out[0] = v[0];
      out[1] = v[1];
      return out;
    }
    /**
     * 克隆一个向量
     * @param {Vector2} v
     * @return {Vector2}
     */


    function clone$2(v) {
      var out = new ArrayCtor(2);
      out[0] = v[0];
      out[1] = v[1];
      return out;
    }
    /**
     * 设置向量的两个项
     * @param {Vector2} out
     * @param {number} a
     * @param {number} b
     * @return {Vector2} 结果
     */


    function set(out, a, b) {
      out[0] = a;
      out[1] = b;
      return out;
    }
    /**
     * 向量相加
     * @param {Vector2} out
     * @param {Vector2} v1
     * @param {Vector2} v2
     */


    function add(out, v1, v2) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      return out;
    }
    /**
     * 向量缩放后相加
     * @param {Vector2} out
     * @param {Vector2} v1
     * @param {Vector2} v2
     * @param {number} a
     */


    function scaleAndAdd(out, v1, v2, a) {
      out[0] = v1[0] + v2[0] * a;
      out[1] = v1[1] + v2[1] * a;
      return out;
    }
    /**
     * 向量相减
     * @param {Vector2} out
     * @param {Vector2} v1
     * @param {Vector2} v2
     */


    function sub(out, v1, v2) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      return out;
    }
    /**
     * 向量长度
     * @param {Vector2} v
     * @return {number}
     */


    function len(v) {
      return Math.sqrt(lenSquare(v));
    }

    var length = len; // jshint ignore:line

    /**
     * 向量长度平方
     * @param {Vector2} v
     * @return {number}
     */

    function lenSquare(v) {
      return v[0] * v[0] + v[1] * v[1];
    }

    var lengthSquare = lenSquare;
    /**
     * 向量乘法
     * @param {Vector2} out
     * @param {Vector2} v1
     * @param {Vector2} v2
     */

    function mul(out, v1, v2) {
      out[0] = v1[0] * v2[0];
      out[1] = v1[1] * v2[1];
      return out;
    }
    /**
     * 向量除法
     * @param {Vector2} out
     * @param {Vector2} v1
     * @param {Vector2} v2
     */


    function div(out, v1, v2) {
      out[0] = v1[0] / v2[0];
      out[1] = v1[1] / v2[1];
      return out;
    }
    /**
     * 向量点乘
     * @param {Vector2} v1
     * @param {Vector2} v2
     * @return {number}
     */


    function dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    /**
     * 向量缩放
     * @param {Vector2} out
     * @param {Vector2} v
     * @param {number} s
     */


    function scale(out, v, s) {
      out[0] = v[0] * s;
      out[1] = v[1] * s;
      return out;
    }
    /**
     * 向量归一化
     * @param {Vector2} out
     * @param {Vector2} v
     */


    function normalize(out, v) {
      var d = len(v);

      if (d === 0) {
        out[0] = 0;
        out[1] = 0;
      } else {
        out[0] = v[0] / d;
        out[1] = v[1] / d;
      }

      return out;
    }
    /**
     * 计算向量间距离
     * @param {Vector2} v1
     * @param {Vector2} v2
     * @return {number}
     */


    function distance(v1, v2) {
      return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
    }

    var dist = distance;
    /**
     * 向量距离平方
     * @param {Vector2} v1
     * @param {Vector2} v2
     * @return {number}
     */

    function distanceSquare(v1, v2) {
      return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
    }

    var distSquare = distanceSquare;
    /**
     * 求负向量
     * @param {Vector2} out
     * @param {Vector2} v
     */

    function negate(out, v) {
      out[0] = -v[0];
      out[1] = -v[1];
      return out;
    }
    /**
     * 插值两个点
     * @param {Vector2} out
     * @param {Vector2} v1
     * @param {Vector2} v2
     * @param {number} t
     */


    function lerp(out, v1, v2, t) {
      out[0] = v1[0] + t * (v2[0] - v1[0]);
      out[1] = v1[1] + t * (v2[1] - v1[1]);
      return out;
    }
    /**
     * 矩阵左乘向量
     * @param {Vector2} out
     * @param {Vector2} v
     * @param {Vector2} m
     */


    function applyTransform(out, v, m) {
      var x = v[0];
      var y = v[1];
      out[0] = m[0] * x + m[2] * y + m[4];
      out[1] = m[1] * x + m[3] * y + m[5];
      return out;
    }
    /**
     * 求两个向量最小值
     * @param  {Vector2} out
     * @param  {Vector2} v1
     * @param  {Vector2} v2
     */


    function min(out, v1, v2) {
      out[0] = Math.min(v1[0], v2[0]);
      out[1] = Math.min(v1[1], v2[1]);
      return out;
    }
    /**
     * 求两个向量最大值
     * @param  {Vector2} out
     * @param  {Vector2} v1
     * @param  {Vector2} v2
     */


    function max(out, v1, v2) {
      out[0] = Math.max(v1[0], v2[0]);
      out[1] = Math.max(v1[1], v2[1]);
      return out;
    }

    var create_1 = create$1;
    var copy_1 = copy;
    var clone_1$1 = clone$2;
    var set_1 = set;
    var add_1 = add;
    var scaleAndAdd_1 = scaleAndAdd;
    var sub_1 = sub;
    var len_1 = len;
    var length_1 = length;
    var lenSquare_1 = lenSquare;
    var lengthSquare_1 = lengthSquare;
    var mul_1 = mul;
    var div_1 = div;
    var dot_1 = dot;
    var scale_1 = scale;
    var normalize_1 = normalize;
    var distance_1 = distance;
    var dist_1 = dist;
    var distanceSquare_1 = distanceSquare;
    var distSquare_1 = distSquare;
    var negate_1 = negate;
    var lerp_1 = lerp;
    var applyTransform_1 = applyTransform;
    var min_1 = min;
    var max_1 = max;

    var vector = {
    	create: create_1,
    	copy: copy_1,
    	clone: clone_1$1,
    	set: set_1,
    	add: add_1,
    	scaleAndAdd: scaleAndAdd_1,
    	sub: sub_1,
    	len: len_1,
    	length: length_1,
    	lenSquare: lenSquare_1,
    	lengthSquare: lengthSquare_1,
    	mul: mul_1,
    	div: div_1,
    	dot: dot_1,
    	scale: scale_1,
    	normalize: normalize_1,
    	distance: distance_1,
    	dist: dist_1,
    	distanceSquare: distanceSquare_1,
    	distSquare: distSquare_1,
    	negate: negate_1,
    	lerp: lerp_1,
    	applyTransform: applyTransform_1,
    	min: min_1,
    	max: max_1
    };

    // TODO Draggable for group
    // FIXME Draggable on element which has parent rotation or scale
    function Draggable() {
      this.on('mousedown', this._dragStart, this);
      this.on('mousemove', this._drag, this);
      this.on('mouseup', this._dragEnd, this); // `mosuemove` and `mouseup` can be continue to fire when dragging.
      // See [Drag outside] in `Handler.js`. So we do not need to trigger
      // `_dragEnd` when globalout. That would brings better user experience.
      // this.on('globalout', this._dragEnd, this);
      // this._dropTarget = null;
      // this._draggingTarget = null;
      // this._x = 0;
      // this._y = 0;
    }

    Draggable.prototype = {
      constructor: Draggable,
      _dragStart: function (e) {
        var draggingTarget = e.target; // Find if there is draggable in the ancestor

        while (draggingTarget && !draggingTarget.draggable) {
          draggingTarget = draggingTarget.parent;
        }

        if (draggingTarget) {
          this._draggingTarget = draggingTarget;
          draggingTarget.dragging = true;
          this._x = e.offsetX;
          this._y = e.offsetY;
          this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
        }
      },
      _drag: function (e) {
        var draggingTarget = this._draggingTarget;

        if (draggingTarget) {
          var x = e.offsetX;
          var y = e.offsetY;
          var dx = x - this._x;
          var dy = y - this._y;
          this._x = x;
          this._y = y;
          draggingTarget.drift(dx, dy, e);
          this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
          var dropTarget = this.findHover(x, y, draggingTarget).target;
          var lastDropTarget = this._dropTarget;
          this._dropTarget = dropTarget;

          if (draggingTarget !== dropTarget) {
            if (lastDropTarget && dropTarget !== lastDropTarget) {
              this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
            }

            if (dropTarget && dropTarget !== lastDropTarget) {
              this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
            }
          }
        }
      },
      _dragEnd: function (e) {
        var draggingTarget = this._draggingTarget;

        if (draggingTarget) {
          draggingTarget.dragging = false;
        }

        this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);

        if (this._dropTarget) {
          this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
        }

        this._draggingTarget = null;
        this._dropTarget = null;
      }
    };

    function param(target, e) {
      return {
        target: target,
        topTarget: e && e.topTarget
      };
    }

    var _default$3 = Draggable;
    var Draggable_1 = _default$3;

    /**
     * Event Mixin
     * @module zrender/mixin/Eventful
     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
     *         pissang (https://www.github.com/pissang)
     */
    var arrySlice = Array.prototype.slice;
    /**
     * Event dispatcher.
     *
     * @alias module:zrender/mixin/Eventful
     * @constructor
     * @param {Object} [eventProcessor] The object eventProcessor is the scope when
     *        `eventProcessor.xxx` called.
     * @param {Function} [eventProcessor.normalizeQuery]
     *        param: {string|Object} Raw query.
     *        return: {string|Object} Normalized query.
     * @param {Function} [eventProcessor.filter] Event will be dispatched only
     *        if it returns `true`.
     *        param: {string} eventType
     *        param: {string|Object} query
     *        return: {boolean}
     * @param {Function} [eventProcessor.afterTrigger] Called after all handlers called.
     *        param: {string} eventType
     */

    var Eventful = function (eventProcessor) {
      this._$handlers = {};
      this._$eventProcessor = eventProcessor;
    };

    Eventful.prototype = {
      constructor: Eventful,

      /**
       * The handler can only be triggered once, then removed.
       *
       * @param {string} event The event name.
       * @param {string|Object} [query] Condition used on event filter.
       * @param {Function} handler The event handler.
       * @param {Object} context
       */
      one: function (event, query, handler, context) {
        return on(this, event, query, handler, context, true);
      },

      /**
       * Bind a handler.
       *
       * @param {string} event The event name.
       * @param {string|Object} [query] Condition used on event filter.
       * @param {Function} handler The event handler.
       * @param {Object} [context]
       */
      on: function (event, query, handler, context) {
        return on(this, event, query, handler, context, false);
      },

      /**
       * Whether any handler has bound.
       *
       * @param  {string}  event
       * @return {boolean}
       */
      isSilent: function (event) {
        var _h = this._$handlers;
        return !_h[event] || !_h[event].length;
      },

      /**
       * Unbind a event.
       *
       * @param {string} [event] The event name.
       *        If no `event` input, "off" all listeners.
       * @param {Function} [handler] The event handler.
       *        If no `handler` input, "off" all listeners of the `event`.
       */
      off: function (event, handler) {
        var _h = this._$handlers;

        if (!event) {
          this._$handlers = {};
          return this;
        }

        if (handler) {
          if (_h[event]) {
            var newList = [];

            for (var i = 0, l = _h[event].length; i < l; i++) {
              if (_h[event][i].h !== handler) {
                newList.push(_h[event][i]);
              }
            }

            _h[event] = newList;
          }

          if (_h[event] && _h[event].length === 0) {
            delete _h[event];
          }
        } else {
          delete _h[event];
        }

        return this;
      },

      /**
       * Dispatch a event.
       *
       * @param {string} type The event name.
       */
      trigger: function (type) {
        var _h = this._$handlers[type];
        var eventProcessor = this._$eventProcessor;

        if (_h) {
          var args = arguments;
          var argLen = args.length;

          if (argLen > 3) {
            args = arrySlice.call(args, 1);
          }

          var len = _h.length;

          for (var i = 0; i < len;) {
            var hItem = _h[i];

            if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
              i++;
              continue;
            } // Optimize advise from backbone


            switch (argLen) {
              case 1:
                hItem.h.call(hItem.ctx);
                break;

              case 2:
                hItem.h.call(hItem.ctx, args[1]);
                break;

              case 3:
                hItem.h.call(hItem.ctx, args[1], args[2]);
                break;

              default:
                // have more than 2 given arguments
                hItem.h.apply(hItem.ctx, args);
                break;
            }

            if (hItem.one) {
              _h.splice(i, 1);

              len--;
            } else {
              i++;
            }
          }
        }

        eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
        return this;
      },

      /**
       * Dispatch a event with context, which is specified at the last parameter.
       *
       * @param {string} type The event name.
       */
      triggerWithContext: function (type) {
        var _h = this._$handlers[type];
        var eventProcessor = this._$eventProcessor;

        if (_h) {
          var args = arguments;
          var argLen = args.length;

          if (argLen > 4) {
            args = arrySlice.call(args, 1, args.length - 1);
          }

          var ctx = args[args.length - 1];
          var len = _h.length;

          for (var i = 0; i < len;) {
            var hItem = _h[i];

            if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
              i++;
              continue;
            } // Optimize advise from backbone


            switch (argLen) {
              case 1:
                hItem.h.call(ctx);
                break;

              case 2:
                hItem.h.call(ctx, args[1]);
                break;

              case 3:
                hItem.h.call(ctx, args[1], args[2]);
                break;

              default:
                // have more than 2 given arguments
                hItem.h.apply(ctx, args);
                break;
            }

            if (hItem.one) {
              _h.splice(i, 1);

              len--;
            } else {
              i++;
            }
          }
        }

        eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
        return this;
      }
    };

    function normalizeQuery(host, query) {
      var eventProcessor = host._$eventProcessor;

      if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
        query = eventProcessor.normalizeQuery(query);
      }

      return query;
    }

    function on(eventful, event, query, handler, context, isOnce) {
      var _h = eventful._$handlers;

      if (typeof query === 'function') {
        context = handler;
        handler = query;
        query = null;
      }

      if (!handler || !event) {
        return eventful;
      }

      query = normalizeQuery(eventful, query);

      if (!_h[event]) {
        _h[event] = [];
      }

      for (var i = 0; i < _h[event].length; i++) {
        if (_h[event][i].h === handler) {
          return eventful;
        }
      }

      var wrap = {
        h: handler,
        one: isOnce,
        query: query,
        ctx: context || eventful,
        // FIXME
        // Do not publish this feature util it is proved that it makes sense.
        callAtLast: handler.zrEventfulCallAtLast
      };
      var lastIndex = _h[event].length - 1;
      var lastWrap = _h[event][lastIndex];
      lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
      return eventful;
    } // ----------------------
    // The events in zrender
    // ----------------------

    /**
     * @event module:zrender/mixin/Eventful#onclick
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#onmouseover
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#onmouseout
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#onmousemove
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#onmousewheel
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#onmousedown
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#onmouseup
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#ondrag
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#ondragstart
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#ondragend
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#ondragenter
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#ondragleave
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#ondragover
     * @type {Function}
     * @default null
     */

    /**
     * @event module:zrender/mixin/Eventful#ondrop
     * @type {Function}
     * @default null
     */


    var _default$4 = Eventful;
    var Eventful_1 = _default$4;

    /**
     * The algoritm is learnt from
     * https://franklinta.com/2014/09/08/computing-css-matrix3d-transforms/
     * And we made some optimization for matrix inversion.
     * Other similar approaches:
     * "cv::getPerspectiveTransform", "Direct Linear Transformation".
     */
    var LN2 = Math.log(2);

    function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
      var cacheKey = rowMask + '-' + colMask;
      var fullRank = rows.length;

      if (detCache.hasOwnProperty(cacheKey)) {
        return detCache[cacheKey];
      }

      if (rank === 1) {
        // In this case the colMask must be like: `11101111`. We can find the place of `0`.
        var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
        return rows[rowStart][colStart];
      }

      var subRowMask = rowMask | 1 << rowStart;
      var subRowStart = rowStart + 1;

      while (rowMask & 1 << subRowStart) {
        subRowStart++;
      }

      var sum = 0;

      for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
        var colTag = 1 << j;

        if (!(colTag & colMask)) {
          sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] // det(subMatrix(0, j))
          * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
          colLocalIdx++;
        }
      }

      detCache[cacheKey] = sum;
      return sum;
    }
    /**
     * Usage:
     * ```js
     * var transformer = buildTransformer(
     *     [10, 44, 100, 44, 100, 300, 10, 300],
     *     [50, 54, 130, 14, 140, 330, 14, 220]
     * );
     * var out = [];
     * transformer && transformer([11, 33], out);
     * ```
     *
     * Notice: `buildTransformer` may take more than 10ms in some Android device.
     *
     * @param {Array.<number>} src source four points, [x0, y0, x1, y1, x2, y2, x3, y3]
     * @param {Array.<number>} dest destination four points, [x0, y0, x1, y1, x2, y2, x3, y3]
     * @return {Function} transformer If fail, return null/undefined.
     */


    function buildTransformer(src, dest) {
      var mA = [[src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]], [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]], [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]], [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]], [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]], [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]], [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]], [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]];
      var detCache = {};
      var det = determinant(mA, 8, 0, 0, 0, detCache);

      if (det === 0) {
        // can not make transformer when and only when
        // any three of the markers are collinear.
        return;
      } // `invert(mA) * dest`, that is, `adj(mA) / det * dest`.


      var vh = [];

      for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
          vh[j] == null && (vh[j] = 0);
          vh[j] += ((i + j) % 2 ? -1 : 1) * // det(subMatrix(i, j))
          determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
        }
      }

      return function (out, srcPointX, srcPointY) {
        var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
        out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
        out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
      };
    }

    var buildTransformer_1 = buildTransformer;

    var fourPointsTransform = {
    	buildTransformer: buildTransformer_1
    };

    var buildTransformer$1 = fourPointsTransform.buildTransformer;
    var EVENT_SAVED_PROP = '___zrEVENTSAVED';
    var _calcOut = [];
    /**
     * Transform "local coord" from `elFrom` to `elTarget`.
     * "local coord": the coord based on the input `el`. The origin point is at
     *     the position of "left: 0; top: 0;" in the `el`.
     *
     * Support when CSS transform is used.
     *
     * Having the `out` (that is, `[outX, outY]`), we can create an DOM element
     * and set the CSS style as "left: outX; top: outY;" and append it to `elTarge`
     * to locate the element.
     *
     * For example, this code below positions a child of `document.body` on the event
     * point, no matter whether `body` has `margin`/`paddin`/`transfrom`/... :
     * ```js
     * transformLocalCoord(out, container, document.body, event.offsetX, event.offsetY);
     * if (!eqNaN(out[0])) {
     *     // Then locate the tip element on the event point.
     *     var tipEl = document.createElement('div');
     *     tipEl.style.cssText = 'position: absolute; left:' + out[0] + ';top:' + out[1] + ';';
     *     document.body.appendChild(tipEl);
     * }
     * ```
     *
     * Notice: In some env this method is not supported. If called, `out` will be `[NaN, NaN]`.
     *
     * @param {Array.<number>} out [inX: number, inY: number] The output..
     *        If can not transform, `out` will not be modified but return `false`.
     * @param {HTMLElement} elFrom The `[inX, inY]` is based on elFrom.
     * @param {HTMLElement} elTarget The `out` is based on elTarget.
     * @param {number} inX
     * @param {number} inY
     * @return {boolean} Whether transform successfully.
     */

    function transformLocalCoord(out, elFrom, elTarget, inX, inY) {
      return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1]);
    }
    /**
     * Transform between a "viewport coord" and a "local coord".
     * "viewport coord": the coord based on the left-top corner of the viewport
     *     of the browser.
     * "local coord": the coord based on the input `el`. The origin point is at
     *     the position of "left: 0; top: 0;" in the `el`.
     *
     * Support the case when CSS transform is used on el.
     *
     * @param {Array.<number>} out [inX: number, inY: number] The output. If `inverse: false`,
     *        it represents "local coord", otherwise "vireport coord".
     *        If can not transform, `out` will not be modified but return `false`.
     * @param {HTMLElement} el The "local coord" is based on the `el`, see comment above.
     * @param {number} inX If `inverse: false`,
     *        it represents "vireport coord", otherwise "local coord".
     * @param {number} inY If `inverse: false`,
     *        it represents "vireport coord", otherwise "local coord".
     * @param {boolean} [inverse=false]
     *        `true`: from "viewport coord" to "local coord".
     *        `false`: from "local coord" to "viewport coord".
     * @return {boolean} Whether transform successfully.
     */


    function transformCoordWithViewport(out, el, inX, inY, inverse) {
      if (el.getBoundingClientRect && env_1.domSupported && !isCanvasEl(el)) {
        var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
        var markers = prepareCoordMarkers(el, saved);
        var transformer = preparePointerTransformer(markers, saved, inverse);

        if (transformer) {
          transformer(out, inX, inY);
          return true;
        }
      }

      return false;
    }

    function prepareCoordMarkers(el, saved) {
      var markers = saved.markers;

      if (markers) {
        return markers;
      }

      markers = saved.markers = [];
      var propLR = ['left', 'right'];
      var propTB = ['top', 'bottom'];

      for (var i = 0; i < 4; i++) {
        var marker = document.createElement('div');
        var stl = marker.style;
        var idxLR = i % 2;
        var idxTB = (i >> 1) % 2;
        stl.cssText = ['position: absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'user-select: none', 'width:0', 'height:0', // 'width: 5px',
        // 'height: 5px',
        propLR[idxLR] + ':0', propTB[idxTB] + ':0', propLR[1 - idxLR] + ':auto', propTB[1 - idxTB] + ':auto', ''].join('!important;');
        el.appendChild(marker);
        markers.push(marker);
      }

      return markers;
    }

    function preparePointerTransformer(markers, saved, inverse) {
      var transformerName = inverse ? 'invTrans' : 'trans';
      var transformer = saved[transformerName];
      var oldSrcCoords = saved.srcCoords;
      var oldCoordTheSame = true;
      var srcCoords = [];
      var destCoords = [];

      for (var i = 0; i < 4; i++) {
        var rect = markers[i].getBoundingClientRect();
        var ii = 2 * i;
        var x = rect.left;
        var y = rect.top;
        srcCoords.push(x, y);
        oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
        destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
      } // Cache to avoid time consuming of `buildTransformer`.


      return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer$1(destCoords, srcCoords) : buildTransformer$1(srcCoords, destCoords));
    }

    function isCanvasEl(el) {
      return el.nodeName.toUpperCase() === 'CANVAS';
    }

    var transformLocalCoord_1 = transformLocalCoord;
    var transformCoordWithViewport_1 = transformCoordWithViewport;
    var isCanvasEl_1 = isCanvasEl;

    var dom = {
    	transformLocalCoord: transformLocalCoord_1,
    	transformCoordWithViewport: transformCoordWithViewport_1,
    	isCanvasEl: isCanvasEl_1
    };

    var Dispatcher = Eventful_1;





    var isCanvasEl$1 = dom.isCanvasEl;
    var transformCoordWithViewport$1 = dom.transformCoordWithViewport;

    /**
     * Utilities for mouse or touch events.
     */
    var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
    var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
    var _calcOut$1 = [];
    /**
     * Get the `zrX` and `zrY`, which are relative to the top-left of
     * the input `el`.
     * CSS transform (2D & 3D) is supported.
     *
     * The strategy to fetch the coords:
     * + If `calculate` is not set as `true`, users of this method should
     * ensure that `el` is the same or the same size & location as `e.target`.
     * Otherwise the result coords are probably not expected. Because we
     * firstly try to get coords from e.offsetX/e.offsetY.
     * + If `calculate` is set as `true`, the input `el` can be any element
     * and we force to calculate the coords based on `el`.
     * + The input `el` should be positionable (not position:static).
     *
     * The force `calculate` can be used in case like:
     * When mousemove event triggered on ec tooltip, `e.target` is not `el`(zr painter.dom).
     *
     * @param {HTMLElement} el DOM element.
     * @param {Event} e Mouse event or touch event.
     * @param {Object} out Get `out.zrX` and `out.zrY` as the result.
     * @param {boolean} [calculate=false] Whether to force calculate
     *        the coordinates but not use ones provided by browser.
     */

    function clientToLocal(el, e, out, calculate) {
      out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
      // to the padding edge of the target element. The only browser using this convention
      // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
      // not support the properties.
      // (see http://www.jacklmoore.com/notes/mouse-position/)
      // In zr painter.dom, padding edge equals to border edge.

      if (calculate || !env_1.canvasSupported) {
        calculateZrXY(el, e, out);
      } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
      // ancestor element, so we should make sure el is positioned (e.g., not position:static).
      // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
      // zoom-factor, overflow / opacity layers, transforms ...)
      // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
      // <https://bugs.jquery.com/ticket/8523#comment:14>
      // BTW3, In ff, offsetX/offsetY is always 0.
      else if (env_1.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
          out.zrX = e.layerX;
          out.zrY = e.layerY;
        } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
        else if (e.offsetX != null) {
            out.zrX = e.offsetX;
            out.zrY = e.offsetY;
          } // For some other device, e.g., IOS safari.
          else {
              calculateZrXY(el, e, out);
            }

      return out;
    }

    function calculateZrXY(el, e, out) {
      // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect.
      if (env_1.domSupported && el.getBoundingClientRect) {
        var ex = e.clientX;
        var ey = e.clientY;

        if (isCanvasEl$1(el)) {
          // Original approach, which do not support CSS transform.
          // marker can not be locationed in a canvas container
          // (getBoundingClientRect is always 0). We do not support
          // that input a pre-created canvas to zr while using css
          // transform in iOS.
          var box = el.getBoundingClientRect();
          out.zrX = ex - box.left;
          out.zrY = ey - box.top;
          return;
        } else {
          if (transformCoordWithViewport$1(_calcOut$1, el, ex, ey)) {
            out.zrX = _calcOut$1[0];
            out.zrY = _calcOut$1[1];
            return;
          }
        }
      }

      out.zrX = out.zrY = 0;
    }
    /**
     * Find native event compat for legency IE.
     * Should be called at the begining of a native event listener.
     *
     * @param {Event} [e] Mouse event or touch event or pointer event.
     *        For lagency IE, we use `window.event` is used.
     * @return {Event} The native event.
     */


    function getNativeEvent(e) {
      return e || window.event;
    }
    /**
     * Normalize the coordinates of the input event.
     *
     * Get the `e.zrX` and `e.zrY`, which are relative to the top-left of
     * the input `el`.
     * Get `e.zrDelta` if using mouse wheel.
     * Get `e.which`, see the comment inside this function.
     *
     * Do not calculate repeatly if `zrX` and `zrY` already exist.
     *
     * Notice: see comments in `clientToLocal`. check the relationship
     * between the result coords and the parameters `el` and `calculate`.
     *
     * @param {HTMLElement} el DOM element.
     * @param {Event} [e] See `getNativeEvent`.
     * @param {boolean} [calculate=false] Whether to force calculate
     *        the coordinates but not use ones provided by browser.
     * @return {UIEvent} The normalized native UIEvent.
     */


    function normalizeEvent(el, e, calculate) {
      e = getNativeEvent(e);

      if (e.zrX != null) {
        return e;
      }

      var eventType = e.type;
      var isTouch = eventType && eventType.indexOf('touch') >= 0;

      if (!isTouch) {
        clientToLocal(el, e, e, calculate);
        e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
      } else {
        var touch = eventType !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
        touch && clientToLocal(el, touch, e, calculate);
      } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
      // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
      // If e.which has been defined, it may be readonly,
      // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which


      var button = e.button;

      if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
        e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
      } // [Caution]: `e.which` from browser is not always reliable. For example,
      // when press left button and `mousemove (pointermove)` in Edge, the `e.which`
      // is 65536 and the `e.button` is -1. But the `mouseup (pointerup)` and
      // `mousedown (pointerdown)` is the same as Chrome does.


      return e;
    }
    /**
     * @param {HTMLElement} el
     * @param {string} name
     * @param {Function} handler
     * @param {Object|boolean} opt If boolean, means `opt.capture`
     * @param {boolean} [opt.capture=false]
     * @param {boolean} [opt.passive=false]
     */


    function addEventListener$1(el, name, handler, opt) {
      if (isDomLevel2) {
        // Reproduct the console warning:
        // [Violation] Added non-passive event listener to a scroll-blocking <some> event.
        // Consider marking event handler as 'passive' to make the page more responsive.
        // Just set console log level: verbose in chrome dev tool.
        // then the warning log will be printed when addEventListener called.
        // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
        // We have not yet found a neat way to using passive. Because in zrender the dom event
        // listener delegate all of the upper events of element. Some of those events need
        // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.
        // Before passive can be adopted, these issues should be considered:
        // (1) Whether and how a zrender user specifies an event listener passive. And by default,
        // passive or not.
        // (2) How to tread that some zrender event listener is passive, and some is not. If
        // we use other way but not preventDefault of mousewheel and touchmove, browser
        // compatibility should be handled.
        // var opts = (env.passiveSupported && name === 'mousewheel')
        //     ? {passive: true}
        //     // By default, the third param of el.addEventListener is `capture: false`.
        //     : void 0;
        // el.addEventListener(name, handler /* , opts */);
        el.addEventListener(name, handler, opt);
      } else {
        // For simplicity, do not implement `setCapture` for IE9-.
        el.attachEvent('on' + name, handler);
      }
    }
    /**
     * Parameter are the same as `addEventListener`.
     *
     * Notice that if a listener is registered twice, one with capture and one without,
     * remove each one separately. Removal of a capturing listener does not affect a
     * non-capturing version of the same listener, and vice versa.
     */


    function removeEventListener$1(el, name, handler, opt) {
      if (isDomLevel2) {
        el.removeEventListener(name, handler, opt);
      } else {
        el.detachEvent('on' + name, handler);
      }
    }
    /**
     * preventDefault and stopPropagation.
     * Notice: do not use this method in zrender. It can only be
     * used by upper applications if necessary.
     *
     * @param {Event} e A mouse or touch event.
     */


    var stop = isDomLevel2 ? function (e) {
      e.preventDefault();
      e.stopPropagation();
      e.cancelBubble = true;
    } : function (e) {
      e.returnValue = false;
      e.cancelBubble = true;
    };
    /**
     * This method only works for mouseup and mousedown. The functionality is restricted
     * for fault tolerance, See the `e.which` compatibility above.
     *
     * @param {MouseEvent} e
     * @return {boolean}
     */

    function isMiddleOrRightButtonOnMouseUpDown(e) {
      return e.which === 2 || e.which === 3;
    }
    /**
     * To be removed.
     * @deprecated
     */


    function notLeftMouse(e) {
      // If e.which is undefined, considered as left mouse event.
      return e.which > 1;
    } // For backward compatibility


    var clientToLocal_1 = clientToLocal;
    var getNativeEvent_1 = getNativeEvent;
    var normalizeEvent_1 = normalizeEvent;
    var addEventListener_1 = addEventListener$1;
    var removeEventListener_1 = removeEventListener$1;
    var stop_1 = stop;
    var isMiddleOrRightButtonOnMouseUpDown_1 = isMiddleOrRightButtonOnMouseUpDown;
    var notLeftMouse_1 = notLeftMouse;

    var event = {
    	Dispatcher: Dispatcher,
    	clientToLocal: clientToLocal_1,
    	getNativeEvent: getNativeEvent_1,
    	normalizeEvent: normalizeEvent_1,
    	addEventListener: addEventListener_1,
    	removeEventListener: removeEventListener_1,
    	stop: stop_1,
    	isMiddleOrRightButtonOnMouseUpDown: isMiddleOrRightButtonOnMouseUpDown_1,
    	notLeftMouse: notLeftMouse_1
    };

    /**
     * Only implements needed gestures for mobile.
     */
    var GestureMgr = function () {
      /**
       * @private
       * @type {Array.<Object>}
       */
      this._track = [];
    };

    GestureMgr.prototype = {
      constructor: GestureMgr,
      recognize: function (event, target, root) {
        this._doTrack(event, target, root);

        return this._recognize(event);
      },
      clear: function () {
        this._track.length = 0;
        return this;
      },
      _doTrack: function (event$1, target, root) {
        var touches = event$1.touches;

        if (!touches) {
          return;
        }

        var trackItem = {
          points: [],
          touches: [],
          target: target,
          event: event$1
        };

        for (var i = 0, len = touches.length; i < len; i++) {
          var touch = touches[i];
          var pos = event.clientToLocal(root, touch, {});
          trackItem.points.push([pos.zrX, pos.zrY]);
          trackItem.touches.push(touch);
        }

        this._track.push(trackItem);
      },
      _recognize: function (event) {
        for (var eventName in recognizers) {
          if (recognizers.hasOwnProperty(eventName)) {
            var gestureInfo = recognizers[eventName](this._track, event);

            if (gestureInfo) {
              return gestureInfo;
            }
          }
        }
      }
    };

    function dist$1(pointPair) {
      var dx = pointPair[1][0] - pointPair[0][0];
      var dy = pointPair[1][1] - pointPair[0][1];
      return Math.sqrt(dx * dx + dy * dy);
    }

    function center(pointPair) {
      return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
    }

    var recognizers = {
      pinch: function (track, event) {
        var trackLen = track.length;

        if (!trackLen) {
          return;
        }

        var pinchEnd = (track[trackLen - 1] || {}).points;
        var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;

        if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
          var pinchScale = dist$1(pinchEnd) / dist$1(pinchPre);
          !isFinite(pinchScale) && (pinchScale = 1);
          event.pinchScale = pinchScale;
          var pinchCenter = center(pinchEnd);
          event.pinchX = pinchCenter[0];
          event.pinchY = pinchCenter[1];
          return {
            type: 'pinch',
            target: track[0].target,
            event: event
          };
        }
      } // Only pinch currently.

    };
    var _default$5 = GestureMgr;
    var GestureMgr_1 = _default$5;

    /**
     * [The interface between `Handler` and `HandlerProxy`]:
     *
     * The default `HandlerProxy` only support the common standard web environment
     * (e.g., standalone browser, headless browser, embed browser in mobild APP, ...).
     * But `HandlerProxy` can be replaced to support more non-standard environment
     * (e.g., mini app), or to support more feature that the default `HandlerProxy`
     * not provided (like echarts-gl did).
     * So the interface between `Handler` and `HandlerProxy` should be stable. Do not
     * make break changes util inevitable. The interface include the public methods
     * of `Handler` and the events listed in `handlerNames` below, by which `HandlerProxy`
     * drives `Handler`.
     */

    /**
     * [Drag outside]:
     *
     * That is, triggering `mousemove` and `mouseup` event when the pointer is out of the
     * zrender area when dragging. That is important for the improvement of the user experience
     * when dragging something near the boundary without being terminated unexpectedly.
     *
     * We originally consider to introduce new events like `pagemovemove` and `pagemouseup`
     * to resolve this issue. But some drawbacks of it is described in
     * https://github.com/ecomfe/zrender/pull/536#issuecomment-560286899
     *
     * Instead, we referenced the specifications:
     * https://www.w3.org/TR/touch-events/#the-touchmove-event
     * https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-mousemove
     * where the the mousemove/touchmove can be continue to fire if the user began a drag
     * operation and the pointer has left the boundary. (for the mouse event, browsers
     * only do it on `document` and when the pointer has left the boundary of the browser.)
     *
     * So the default `HandlerProxy` supports this feature similarly: if it is in the dragging
     * state (see `pointerCapture` in `HandlerProxy`), the `mousemove` and `mouseup` continue
     * to fire until release the pointer. That is implemented by listen to those event on
     * `document`.
     * If we implement some other `HandlerProxy` only for touch device, that would be easier.
     * The touch event support this feature by default.
     *
     * Note:
     * There might be some cases that the mouse event can not be
     * received on `document`. For example,
     * (A) `useCapture` is not supported and some user defined event listeners on the ancestor
     * of zr dom throw Error .
     * (B) `useCapture` is not supported Some user defined event listeners on the ancestor of
     * zr dom call `stopPropagation`.
     * In these cases, the `mousemove` event might be keep triggered event
     * if the mouse is released. We try to reduce the side-effect in those cases.
     * That is, do nothing (especially, `findHover`) in those cases. See `isOutsideBoundary`.
     *
     * Note:
     * If `HandlerProxy` listens to `document` with `useCapture`, `HandlerProxy` needs to
     * make sure `stopPropagation` and `preventDefault` doing nothing if and only if the event
     * target is not zrender dom. Becuase it is dangerous to enable users to call them in
     * `document` capture phase to prevent the propagation to any listener of the webpage.
     * But they are needed to work when the pointer inside the zrender dom.
     */
    var SILENT = 'silent';

    function makeEventPacket(eveType, targetInfo, event) {
      return {
        type: eveType,
        event: event,
        // target can only be an element that is not silent.
        target: targetInfo.target,
        // topTarget can be a silent element.
        topTarget: targetInfo.topTarget,
        cancelBubble: false,
        offsetX: event.zrX,
        offsetY: event.zrY,
        gestureEvent: event.gestureEvent,
        pinchX: event.pinchX,
        pinchY: event.pinchY,
        pinchScale: event.pinchScale,
        wheelDelta: event.zrDelta,
        zrByTouch: event.zrByTouch,
        which: event.which,
        stop: stopEvent
      };
    }

    function stopEvent() {
      event.stop(this.event);
    }

    function EmptyProxy() {}

    EmptyProxy.prototype.dispose = function () {};

    var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
    /**
     * @alias module:zrender/Handler
     * @constructor
     * @extends module:zrender/mixin/Eventful
     * @param {module:zrender/Storage} storage Storage instance.
     * @param {module:zrender/Painter} painter Painter instance.
     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
     */

    var Handler = function (storage, painter, proxy, painterRoot) {
      Eventful_1.call(this);
      this.storage = storage;
      this.painter = painter;
      this.painterRoot = painterRoot;
      proxy = proxy || new EmptyProxy();
      /**
       * Proxy of event. can be Dom, WebGLSurface, etc.
       */

      this.proxy = null;
      /**
       * {target, topTarget, x, y}
       * @private
       * @type {Object}
       */

      this._hovered = {};
      /**
       * @private
       * @type {Date}
       */

      this._lastTouchMoment;
      /**
       * @private
       * @type {number}
       */

      this._lastX;
      /**
       * @private
       * @type {number}
       */

      this._lastY;
      /**
       * @private
       * @type {module:zrender/core/GestureMgr}
       */

      this._gestureMgr;
      Draggable_1.call(this);
      this.setHandlerProxy(proxy);
    };

    Handler.prototype = {
      constructor: Handler,
      setHandlerProxy: function (proxy) {
        if (this.proxy) {
          this.proxy.dispose();
        }

        if (proxy) {
          util.each(handlerNames, function (name) {
            proxy.on && proxy.on(name, this[name], this);
          }, this); // Attach handler

          proxy.handler = this;
        }

        this.proxy = proxy;
      },
      mousemove: function (event) {
        var x = event.zrX;
        var y = event.zrY;
        var isOutside = isOutsideBoundary(this, x, y);
        var lastHovered = this._hovered;
        var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
        // (like 'setOption' or 'dispatchAction') in event handlers, we should find
        // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
        // See #6198.

        if (lastHoveredTarget && !lastHoveredTarget.__zr) {
          lastHovered = this.findHover(lastHovered.x, lastHovered.y);
          lastHoveredTarget = lastHovered.target;
        }

        var hovered = this._hovered = isOutside ? {
          x: x,
          y: y
        } : this.findHover(x, y);
        var hoveredTarget = hovered.target;
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element

        if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
          this.dispatchToElement(lastHovered, 'mouseout', event);
        } // Mouse moving on one element


        this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element

        if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
          this.dispatchToElement(hovered, 'mouseover', event);
        }
      },
      mouseout: function (event) {
        var eventControl = event.zrEventControl;
        var zrIsToLocalDOM = event.zrIsToLocalDOM;

        if (eventControl !== 'only_globalout') {
          this.dispatchToElement(this._hovered, 'mouseout', event);
        }

        if (eventControl !== 'no_globalout') {
          // FIXME: if the pointer moving from the extra doms to realy "outside",
          // the `globalout` should have been triggered. But currently not.
          !zrIsToLocalDOM && this.trigger('globalout', {
            type: 'globalout',
            event: event
          });
        }
      },

      /**
       * Resize
       */
      resize: function (event) {
        this._hovered = {};
      },

      /**
       * Dispatch event
       * @param {string} eventName
       * @param {event=} eventArgs
       */
      dispatch: function (eventName, eventArgs) {
        var handler = this[eventName];
        handler && handler.call(this, eventArgs);
      },

      /**
       * Dispose
       */
      dispose: function () {
        this.proxy.dispose();
        this.storage = this.proxy = this.painter = null;
      },

      /**
       * 设置默认的cursor style
       * @param {string} [cursorStyle='default'] 例如 crosshair
       */
      setCursorStyle: function (cursorStyle) {
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(cursorStyle);
      },

      /**
       * 事件分发代理
       *
       * @private
       * @param {Object} targetInfo {target, topTarget} 目标图形元素
       * @param {string} eventName 事件名称
       * @param {Object} event 事件对象
       */
      dispatchToElement: function (targetInfo, eventName, event) {
        targetInfo = targetInfo || {};
        var el = targetInfo.target;

        if (el && el.silent) {
          return;
        }

        var eventHandler = 'on' + eventName;
        var eventPacket = makeEventPacket(eventName, targetInfo, event);

        while (el) {
          el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
          el.trigger(eventName, eventPacket);
          el = el.parent;

          if (eventPacket.cancelBubble) {
            break;
          }
        }

        if (!eventPacket.cancelBubble) {
          // 冒泡到顶级 zrender 对象
          this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
          // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在

          this.painter && this.painter.eachOtherLayer(function (layer) {
            if (typeof layer[eventHandler] === 'function') {
              layer[eventHandler].call(layer, eventPacket);
            }

            if (layer.trigger) {
              layer.trigger(eventName, eventPacket);
            }
          });
        }
      },

      /**
       * @private
       * @param {number} x
       * @param {number} y
       * @param {module:zrender/graphic/Displayable} exclude
       * @return {model:zrender/Element}
       * @method
       */
      findHover: function (x, y, exclude) {
        var list = this.storage.getDisplayList();
        var out = {
          x: x,
          y: y
        };

        for (var i = list.length - 1; i >= 0; i--) {
          var hoverCheckResult;

          if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
          && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
            !out.topTarget && (out.topTarget = list[i]);

            if (hoverCheckResult !== SILENT) {
              out.target = list[i];
              break;
            }
          }
        }

        return out;
      },
      processGesture: function (event, stage) {
        if (!this._gestureMgr) {
          this._gestureMgr = new GestureMgr_1();
        }

        var gestureMgr = this._gestureMgr;
        stage === 'start' && gestureMgr.clear();
        var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
        stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.

        if (gestureInfo) {
          var type = gestureInfo.type;
          event.gestureEvent = type;
          this.dispatchToElement({
            target: gestureInfo.target
          }, type, gestureInfo.event);
        }
      }
    }; // Common handlers

    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
      Handler.prototype[name] = function (event) {
        var x = event.zrX;
        var y = event.zrY;
        var isOutside = isOutsideBoundary(this, x, y);
        var hovered;
        var hoveredTarget;

        if (name !== 'mouseup' || !isOutside) {
          // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
          hovered = this.findHover(x, y);
          hoveredTarget = hovered.target;
        }

        if (name === 'mousedown') {
          this._downEl = hoveredTarget;
          this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup

          this._upEl = hoveredTarget;
        } else if (name === 'mouseup') {
          this._upEl = hoveredTarget;
        } else if (name === 'click') {
          if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
          // including the case that `mousedown` - `mousemove` - `mouseup`,
          // which should be filtered, otherwise it will bring trouble to
          // pan and zoom.
          || !this._downPoint // Arbitrary value
          || vector.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
            return;
          }

          this._downPoint = null;
        }

        this.dispatchToElement(hovered, name, event);
      };
    });

    function isHover(displayable, x, y) {
      if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
        var el = displayable;
        var isSilent;

        while (el) {
          // If clipped by ancestor.
          // FIXME: If clipPath has neither stroke nor fill,
          // el.clipPath.contain(x, y) will always return false.
          if (el.clipPath && !el.clipPath.contain(x, y)) {
            return false;
          }

          if (el.silent) {
            isSilent = true;
          }

          el = el.parent;
        }

        return isSilent ? SILENT : true;
      }

      return false;
    }
    /**
     * See [Drag outside].
     */


    function isOutsideBoundary(handlerInstance, x, y) {
      var painter = handlerInstance.painter;
      return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
    }

    util.mixin(Handler, Eventful_1);
    util.mixin(Handler, Draggable_1);
    var _default$6 = Handler;
    var Handler_1 = _default$6;

    /**
     * 3x2矩阵操作类
     * @exports zrender/tool/matrix
     */

    /* global Float32Array */
    var ArrayCtor$1 = typeof Float32Array === 'undefined' ? Array : Float32Array;
    /**
     * Create a identity matrix.
     * @return {Float32Array|Array.<number>}
     */

    function create$2() {
      var out = new ArrayCtor$1(6);
      identity$1(out);
      return out;
    }
    /**
     * 设置矩阵为单位矩阵
     * @param {Float32Array|Array.<number>} out
     */


    function identity$1(out) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      out[4] = 0;
      out[5] = 0;
      return out;
    }
    /**
     * 复制矩阵
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} m
     */


    function copy$1(out, m) {
      out[0] = m[0];
      out[1] = m[1];
      out[2] = m[2];
      out[3] = m[3];
      out[4] = m[4];
      out[5] = m[5];
      return out;
    }
    /**
     * 矩阵相乘
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} m1
     * @param {Float32Array|Array.<number>} m2
     */


    function mul$1(out, m1, m2) {
      // Consider matrix.mul(m, m2, m);
      // where out is the same as m2.
      // So use temp variable to escape error.
      var out0 = m1[0] * m2[0] + m1[2] * m2[1];
      var out1 = m1[1] * m2[0] + m1[3] * m2[1];
      var out2 = m1[0] * m2[2] + m1[2] * m2[3];
      var out3 = m1[1] * m2[2] + m1[3] * m2[3];
      var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
      var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
      out[0] = out0;
      out[1] = out1;
      out[2] = out2;
      out[3] = out3;
      out[4] = out4;
      out[5] = out5;
      return out;
    }
    /**
     * 平移变换
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} a
     * @param {Float32Array|Array.<number>} v
     */


    function translate(out, a, v) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4] + v[0];
      out[5] = a[5] + v[1];
      return out;
    }
    /**
     * 旋转变换
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} a
     * @param {number} rad
     */


    function rotate(out, a, rad) {
      var aa = a[0];
      var ac = a[2];
      var atx = a[4];
      var ab = a[1];
      var ad = a[3];
      var aty = a[5];
      var st = Math.sin(rad);
      var ct = Math.cos(rad);
      out[0] = aa * ct + ab * st;
      out[1] = -aa * st + ab * ct;
      out[2] = ac * ct + ad * st;
      out[3] = -ac * st + ct * ad;
      out[4] = ct * atx + st * aty;
      out[5] = ct * aty - st * atx;
      return out;
    }
    /**
     * 缩放变换
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} a
     * @param {Float32Array|Array.<number>} v
     */


    function scale$1(out, a, v) {
      var vx = v[0];
      var vy = v[1];
      out[0] = a[0] * vx;
      out[1] = a[1] * vy;
      out[2] = a[2] * vx;
      out[3] = a[3] * vy;
      out[4] = a[4] * vx;
      out[5] = a[5] * vy;
      return out;
    }
    /**
     * 求逆矩阵
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} a
     */


    function invert(out, a) {
      var aa = a[0];
      var ac = a[2];
      var atx = a[4];
      var ab = a[1];
      var ad = a[3];
      var aty = a[5];
      var det = aa * ad - ab * ac;

      if (!det) {
        return null;
      }

      det = 1.0 / det;
      out[0] = ad * det;
      out[1] = -ab * det;
      out[2] = -ac * det;
      out[3] = aa * det;
      out[4] = (ac * aty - ad * atx) * det;
      out[5] = (ab * atx - aa * aty) * det;
      return out;
    }
    /**
     * Clone a new matrix.
     * @param {Float32Array|Array.<number>} a
     */


    function clone$3(a) {
      var b = create$2();
      copy$1(b, a);
      return b;
    }

    var create_1$1 = create$2;
    var identity_1 = identity$1;
    var copy_1$1 = copy$1;
    var mul_1$1 = mul$1;
    var translate_1 = translate;
    var rotate_1 = rotate;
    var scale_1$1 = scale$1;
    var invert_1 = invert;
    var clone_1$2 = clone$3;

    var matrix = {
    	create: create_1$1,
    	identity: identity_1,
    	copy: copy_1$1,
    	mul: mul_1$1,
    	translate: translate_1,
    	rotate: rotate_1,
    	scale: scale_1$1,
    	invert: invert_1,
    	clone: clone_1$2
    };

    /**
     * 提供变换扩展
     * @module zrender/mixin/Transformable
     * @author pissang (https://www.github.com/pissang)
     */
    var mIdentity = matrix.identity;
    var EPSILON = 5e-5;

    function isNotAroundZero(val) {
      return val > EPSILON || val < -EPSILON;
    }
    /**
     * @alias module:zrender/mixin/Transformable
     * @constructor
     */


    var Transformable = function (opts) {
      opts = opts || {}; // If there are no given position, rotation, scale

      if (!opts.position) {
        /**
         * 平移
         * @type {Array.<number>}
         * @default [0, 0]
         */
        this.position = [0, 0];
      }

      if (opts.rotation == null) {
        /**
         * 旋转
         * @type {Array.<number>}
         * @default 0
         */
        this.rotation = 0;
      }

      if (!opts.scale) {
        /**
         * 缩放
         * @type {Array.<number>}
         * @default [1, 1]
         */
        this.scale = [1, 1];
      }
      /**
       * 旋转和缩放的原点
       * @type {Array.<number>}
       * @default null
       */


      this.origin = this.origin || null;
    };

    var transformableProto = Transformable.prototype;
    transformableProto.transform = null;
    /**
     * 判断是否需要有坐标变换
     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
     */

    transformableProto.needLocalTransform = function () {
      return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
    };

    var scaleTmp = [];

    transformableProto.updateTransform = function () {
      var parent = this.parent;
      var parentHasTransform = parent && parent.transform;
      var needLocalTransform = this.needLocalTransform();
      var m = this.transform;

      if (!(needLocalTransform || parentHasTransform)) {
        m && mIdentity(m);
        return;
      }

      m = m || matrix.create();

      if (needLocalTransform) {
        this.getLocalTransform(m);
      } else {
        mIdentity(m);
      } // 应用父节点变换


      if (parentHasTransform) {
        if (needLocalTransform) {
          matrix.mul(m, parent.transform, m);
        } else {
          matrix.copy(m, parent.transform);
        }
      } // 保存这个变换矩阵


      this.transform = m;
      var globalScaleRatio = this.globalScaleRatio;

      if (globalScaleRatio != null && globalScaleRatio !== 1) {
        this.getGlobalScale(scaleTmp);
        var relX = scaleTmp[0] < 0 ? -1 : 1;
        var relY = scaleTmp[1] < 0 ? -1 : 1;
        var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
        var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
        m[0] *= sx;
        m[1] *= sx;
        m[2] *= sy;
        m[3] *= sy;
      }

      this.invTransform = this.invTransform || matrix.create();
      matrix.invert(this.invTransform, m);
    };

    transformableProto.getLocalTransform = function (m) {
      return Transformable.getLocalTransform(this, m);
    };
    /**
     * 将自己的transform应用到context上
     * @param {CanvasRenderingContext2D} ctx
     */


    transformableProto.setTransform = function (ctx) {
      var m = this.transform;
      var dpr = ctx.dpr || 1;

      if (m) {
        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
      } else {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    };

    transformableProto.restoreTransform = function (ctx) {
      var dpr = ctx.dpr || 1;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    var tmpTransform = [];
    var originTransform = matrix.create();

    transformableProto.setLocalTransform = function (m) {
      if (!m) {
        // TODO return or set identity?
        return;
      }

      var sx = m[0] * m[0] + m[1] * m[1];
      var sy = m[2] * m[2] + m[3] * m[3];
      var position = this.position;
      var scale = this.scale;

      if (isNotAroundZero(sx - 1)) {
        sx = Math.sqrt(sx);
      }

      if (isNotAroundZero(sy - 1)) {
        sy = Math.sqrt(sy);
      }

      if (m[0] < 0) {
        sx = -sx;
      }

      if (m[3] < 0) {
        sy = -sy;
      }

      position[0] = m[4];
      position[1] = m[5];
      scale[0] = sx;
      scale[1] = sy;
      this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
    };
    /**
     * 分解`transform`矩阵到`position`, `rotation`, `scale`
     */


    transformableProto.decomposeTransform = function () {
      if (!this.transform) {
        return;
      }

      var parent = this.parent;
      var m = this.transform;

      if (parent && parent.transform) {
        // Get local transform and decompose them to position, scale, rotation
        matrix.mul(tmpTransform, parent.invTransform, m);
        m = tmpTransform;
      }

      var origin = this.origin;

      if (origin && (origin[0] || origin[1])) {
        originTransform[4] = origin[0];
        originTransform[5] = origin[1];
        matrix.mul(tmpTransform, m, originTransform);
        tmpTransform[4] -= origin[0];
        tmpTransform[5] -= origin[1];
        m = tmpTransform;
      }

      this.setLocalTransform(m);
    };
    /**
     * Get global scale
     * @return {Array.<number>}
     */


    transformableProto.getGlobalScale = function (out) {
      var m = this.transform;
      out = out || [];

      if (!m) {
        out[0] = 1;
        out[1] = 1;
        return out;
      }

      out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
      out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);

      if (m[0] < 0) {
        out[0] = -out[0];
      }

      if (m[3] < 0) {
        out[1] = -out[1];
      }

      return out;
    };
    /**
     * 变换坐标位置到 shape 的局部坐标空间
     * @method
     * @param {number} x
     * @param {number} y
     * @return {Array.<number>}
     */


    transformableProto.transformCoordToLocal = function (x, y) {
      var v2 = [x, y];
      var invTransform = this.invTransform;

      if (invTransform) {
        vector.applyTransform(v2, v2, invTransform);
      }

      return v2;
    };
    /**
     * 变换局部坐标位置到全局坐标空间
     * @method
     * @param {number} x
     * @param {number} y
     * @return {Array.<number>}
     */


    transformableProto.transformCoordToGlobal = function (x, y) {
      var v2 = [x, y];
      var transform = this.transform;

      if (transform) {
        vector.applyTransform(v2, v2, transform);
      }

      return v2;
    };
    /**
     * @static
     * @param {Object} target
     * @param {Array.<number>} target.origin
     * @param {number} target.rotation
     * @param {Array.<number>} target.position
     * @param {Array.<number>} [m]
     */


    Transformable.getLocalTransform = function (target, m) {
      m = m || [];
      mIdentity(m);
      var origin = target.origin;
      var scale = target.scale || [1, 1];
      var rotation = target.rotation || 0;
      var position = target.position || [0, 0];

      if (origin) {
        // Translate to origin
        m[4] -= origin[0];
        m[5] -= origin[1];
      }

      matrix.scale(m, m, scale);

      if (rotation) {
        matrix.rotate(m, m, rotation);
      }

      if (origin) {
        // Translate back from origin
        m[4] += origin[0];
        m[5] += origin[1];
      }

      m[4] += position[0];
      m[5] += position[1];
      return m;
    };

    var _default$7 = Transformable;
    var Transformable_1 = _default$7;

    /**
     * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
     * @see http://sole.github.io/tween.js/examples/03_graphs.html
     * @exports zrender/animation/easing
     */
    var easing = {
      /**
      * @param {number} k
      * @return {number}
      */
      linear: function (k) {
        return k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quadraticIn: function (k) {
        return k * k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quadraticOut: function (k) {
        return k * (2 - k);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quadraticInOut: function (k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k;
        }

        return -0.5 * (--k * (k - 2) - 1);
      },
      // 三次方的缓动（t^3）

      /**
      * @param {number} k
      * @return {number}
      */
      cubicIn: function (k) {
        return k * k * k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      cubicOut: function (k) {
        return --k * k * k + 1;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      cubicInOut: function (k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k;
        }

        return 0.5 * ((k -= 2) * k * k + 2);
      },
      // 四次方的缓动（t^4）

      /**
      * @param {number} k
      * @return {number}
      */
      quarticIn: function (k) {
        return k * k * k * k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quarticOut: function (k) {
        return 1 - --k * k * k * k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quarticInOut: function (k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k;
        }

        return -0.5 * ((k -= 2) * k * k * k - 2);
      },
      // 五次方的缓动（t^5）

      /**
      * @param {number} k
      * @return {number}
      */
      quinticIn: function (k) {
        return k * k * k * k * k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quinticOut: function (k) {
        return --k * k * k * k * k + 1;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quinticInOut: function (k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k * k;
        }

        return 0.5 * ((k -= 2) * k * k * k * k + 2);
      },
      // 正弦曲线的缓动（sin(t)）

      /**
      * @param {number} k
      * @return {number}
      */
      sinusoidalIn: function (k) {
        return 1 - Math.cos(k * Math.PI / 2);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      sinusoidalOut: function (k) {
        return Math.sin(k * Math.PI / 2);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      sinusoidalInOut: function (k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      },
      // 指数曲线的缓动（2^t）

      /**
      * @param {number} k
      * @return {number}
      */
      exponentialIn: function (k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      exponentialOut: function (k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      exponentialInOut: function (k) {
        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if ((k *= 2) < 1) {
          return 0.5 * Math.pow(1024, k - 1);
        }

        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
      },
      // 圆形曲线的缓动（sqrt(1-t^2)）

      /**
      * @param {number} k
      * @return {number}
      */
      circularIn: function (k) {
        return 1 - Math.sqrt(1 - k * k);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      circularOut: function (k) {
        return Math.sqrt(1 - --k * k);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      circularInOut: function (k) {
        if ((k *= 2) < 1) {
          return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }

        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      },
      // 创建类似于弹簧在停止前来回振荡的动画

      /**
      * @param {number} k
      * @return {number}
      */
      elasticIn: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;

        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }

        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      },

      /**
      * @param {number} k
      * @return {number}
      */
      elasticOut: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;

        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }

        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      elasticInOut: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;

        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }

        if ((k *= 2) < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }

        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动

      /**
      * @param {number} k
      * @return {number}
      */
      backIn: function (k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      backOut: function (k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      backInOut: function (k) {
        var s = 1.70158 * 1.525;

        if ((k *= 2) < 1) {
          return 0.5 * (k * k * ((s + 1) * k - s));
        }

        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      },
      // 创建弹跳效果

      /**
      * @param {number} k
      * @return {number}
      */
      bounceIn: function (k) {
        return 1 - easing.bounceOut(1 - k);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      bounceOut: function (k) {
        if (k < 1 / 2.75) {
          return 7.5625 * k * k;
        } else if (k < 2 / 2.75) {
          return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
        } else if (k < 2.5 / 2.75) {
          return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
        } else {
          return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
        }
      },

      /**
      * @param {number} k
      * @return {number}
      */
      bounceInOut: function (k) {
        if (k < 0.5) {
          return easing.bounceIn(k * 2) * 0.5;
        }

        return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
      }
    };
    var _default$8 = easing;
    var easing_1 = _default$8;

    /**
     * 动画主控制器
     * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
     * @config life(1000) 动画时长
     * @config delay(0) 动画延迟时间
     * @config loop(true)
     * @config gap(0) 循环的间隔时间
     * @config onframe
     * @config easing(optional)
     * @config ondestroy(optional)
     * @config onrestart(optional)
     *
     * TODO pause
     */
    function Clip(options) {
      this._target = options.target; // 生命周期

      this._life = options.life || 1000; // 延时

      this._delay = options.delay || 0; // 开始时间
      // this._startTime = new Date().getTime() + this._delay;// 单位毫秒

      this._initialized = false; // 是否循环

      this.loop = options.loop == null ? false : options.loop;
      this.gap = options.gap || 0;
      this.easing = options.easing || 'Linear';
      this.onframe = options.onframe;
      this.ondestroy = options.ondestroy;
      this.onrestart = options.onrestart;
      this._pausedTime = 0;
      this._paused = false;
    }

    Clip.prototype = {
      constructor: Clip,
      step: function (globalTime, deltaTime) {
        // Set startTime on first step, or _startTime may has milleseconds different between clips
        // PENDING
        if (!this._initialized) {
          this._startTime = globalTime + this._delay;
          this._initialized = true;
        }

        if (this._paused) {
          this._pausedTime += deltaTime;
          return;
        }

        var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始

        if (percent < 0) {
          return;
        }

        percent = Math.min(percent, 1);
        var easing = this.easing;
        var easingFunc = typeof easing === 'string' ? easing_1[easing] : easing;
        var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
        this.fire('frame', schedule); // 结束

        if (percent === 1) {
          if (this.loop) {
            this.restart(globalTime); // 重新开始周期
            // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件

            return 'restart';
          } // 动画完成将这个控制器标识为待删除
          // 在Animation.update中进行批量删除


          this._needsRemove = true;
          return 'destroy';
        }

        return null;
      },
      restart: function (globalTime) {
        var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
        this._startTime = globalTime - remainder + this.gap;
        this._pausedTime = 0;
        this._needsRemove = false;
      },
      fire: function (eventType, arg) {
        eventType = 'on' + eventType;

        if (this[eventType]) {
          this[eventType](this._target, arg);
        }
      },
      pause: function () {
        this._paused = true;
      },
      resume: function () {
        this._paused = false;
      }
    };
    var _default$9 = Clip;
    var Clip_1 = _default$9;

    // Simple LRU cache use doubly linked list
    // @module zrender/core/LRU

    /**
     * Simple double linked list. Compared with array, it has O(1) remove operation.
     * @constructor
     */
    var LinkedList = function () {
      /**
       * @type {module:zrender/core/LRU~Entry}
       */
      this.head = null;
      /**
       * @type {module:zrender/core/LRU~Entry}
       */

      this.tail = null;
      this._len = 0;
    };

    var linkedListProto = LinkedList.prototype;
    /**
     * Insert a new value at the tail
     * @param  {} val
     * @return {module:zrender/core/LRU~Entry}
     */

    linkedListProto.insert = function (val) {
      var entry = new Entry(val);
      this.insertEntry(entry);
      return entry;
    };
    /**
     * Insert an entry at the tail
     * @param  {module:zrender/core/LRU~Entry} entry
     */


    linkedListProto.insertEntry = function (entry) {
      if (!this.head) {
        this.head = this.tail = entry;
      } else {
        this.tail.next = entry;
        entry.prev = this.tail;
        entry.next = null;
        this.tail = entry;
      }

      this._len++;
    };
    /**
     * Remove entry.
     * @param  {module:zrender/core/LRU~Entry} entry
     */


    linkedListProto.remove = function (entry) {
      var prev = entry.prev;
      var next = entry.next;

      if (prev) {
        prev.next = next;
      } else {
        // Is head
        this.head = next;
      }

      if (next) {
        next.prev = prev;
      } else {
        // Is tail
        this.tail = prev;
      }

      entry.next = entry.prev = null;
      this._len--;
    };
    /**
     * @return {number}
     */


    linkedListProto.len = function () {
      return this._len;
    };
    /**
     * Clear list
     */


    linkedListProto.clear = function () {
      this.head = this.tail = null;
      this._len = 0;
    };
    /**
     * @constructor
     * @param {} val
     */


    var Entry = function (val) {
      /**
       * @type {}
       */
      this.value = val;
      /**
       * @type {module:zrender/core/LRU~Entry}
       */

      this.next;
      /**
       * @type {module:zrender/core/LRU~Entry}
       */

      this.prev;
    };
    /**
     * LRU Cache
     * @constructor
     * @alias module:zrender/core/LRU
     */


    var LRU = function (maxSize) {
      this._list = new LinkedList();
      this._map = {};
      this._maxSize = maxSize || 10;
      this._lastRemovedEntry = null;
    };

    var LRUProto = LRU.prototype;
    /**
     * @param  {string} key
     * @param  {} value
     * @return {} Removed value
     */

    LRUProto.put = function (key, value) {
      var list = this._list;
      var map = this._map;
      var removed = null;

      if (map[key] == null) {
        var len = list.len(); // Reuse last removed entry

        var entry = this._lastRemovedEntry;

        if (len >= this._maxSize && len > 0) {
          // Remove the least recently used
          var leastUsedEntry = list.head;
          list.remove(leastUsedEntry);
          delete map[leastUsedEntry.key];
          removed = leastUsedEntry.value;
          this._lastRemovedEntry = leastUsedEntry;
        }

        if (entry) {
          entry.value = value;
        } else {
          entry = new Entry(value);
        }

        entry.key = key;
        list.insertEntry(entry);
        map[key] = entry;
      }

      return removed;
    };
    /**
     * @param  {string} key
     * @return {}
     */


    LRUProto.get = function (key) {
      var entry = this._map[key];
      var list = this._list;

      if (entry != null) {
        // Put the latest used entry in the tail
        if (entry !== list.tail) {
          list.remove(entry);
          list.insertEntry(entry);
        }

        return entry.value;
      }
    };
    /**
     * Clear the cache
     */


    LRUProto.clear = function () {
      this._list.clear();

      this._map = {};
    };

    var _default$a = LRU;
    var LRU_1 = _default$a;

    var kCSSColorTable = {
      'transparent': [0, 0, 0, 0],
      'aliceblue': [240, 248, 255, 1],
      'antiquewhite': [250, 235, 215, 1],
      'aqua': [0, 255, 255, 1],
      'aquamarine': [127, 255, 212, 1],
      'azure': [240, 255, 255, 1],
      'beige': [245, 245, 220, 1],
      'bisque': [255, 228, 196, 1],
      'black': [0, 0, 0, 1],
      'blanchedalmond': [255, 235, 205, 1],
      'blue': [0, 0, 255, 1],
      'blueviolet': [138, 43, 226, 1],
      'brown': [165, 42, 42, 1],
      'burlywood': [222, 184, 135, 1],
      'cadetblue': [95, 158, 160, 1],
      'chartreuse': [127, 255, 0, 1],
      'chocolate': [210, 105, 30, 1],
      'coral': [255, 127, 80, 1],
      'cornflowerblue': [100, 149, 237, 1],
      'cornsilk': [255, 248, 220, 1],
      'crimson': [220, 20, 60, 1],
      'cyan': [0, 255, 255, 1],
      'darkblue': [0, 0, 139, 1],
      'darkcyan': [0, 139, 139, 1],
      'darkgoldenrod': [184, 134, 11, 1],
      'darkgray': [169, 169, 169, 1],
      'darkgreen': [0, 100, 0, 1],
      'darkgrey': [169, 169, 169, 1],
      'darkkhaki': [189, 183, 107, 1],
      'darkmagenta': [139, 0, 139, 1],
      'darkolivegreen': [85, 107, 47, 1],
      'darkorange': [255, 140, 0, 1],
      'darkorchid': [153, 50, 204, 1],
      'darkred': [139, 0, 0, 1],
      'darksalmon': [233, 150, 122, 1],
      'darkseagreen': [143, 188, 143, 1],
      'darkslateblue': [72, 61, 139, 1],
      'darkslategray': [47, 79, 79, 1],
      'darkslategrey': [47, 79, 79, 1],
      'darkturquoise': [0, 206, 209, 1],
      'darkviolet': [148, 0, 211, 1],
      'deeppink': [255, 20, 147, 1],
      'deepskyblue': [0, 191, 255, 1],
      'dimgray': [105, 105, 105, 1],
      'dimgrey': [105, 105, 105, 1],
      'dodgerblue': [30, 144, 255, 1],
      'firebrick': [178, 34, 34, 1],
      'floralwhite': [255, 250, 240, 1],
      'forestgreen': [34, 139, 34, 1],
      'fuchsia': [255, 0, 255, 1],
      'gainsboro': [220, 220, 220, 1],
      'ghostwhite': [248, 248, 255, 1],
      'gold': [255, 215, 0, 1],
      'goldenrod': [218, 165, 32, 1],
      'gray': [128, 128, 128, 1],
      'green': [0, 128, 0, 1],
      'greenyellow': [173, 255, 47, 1],
      'grey': [128, 128, 128, 1],
      'honeydew': [240, 255, 240, 1],
      'hotpink': [255, 105, 180, 1],
      'indianred': [205, 92, 92, 1],
      'indigo': [75, 0, 130, 1],
      'ivory': [255, 255, 240, 1],
      'khaki': [240, 230, 140, 1],
      'lavender': [230, 230, 250, 1],
      'lavenderblush': [255, 240, 245, 1],
      'lawngreen': [124, 252, 0, 1],
      'lemonchiffon': [255, 250, 205, 1],
      'lightblue': [173, 216, 230, 1],
      'lightcoral': [240, 128, 128, 1],
      'lightcyan': [224, 255, 255, 1],
      'lightgoldenrodyellow': [250, 250, 210, 1],
      'lightgray': [211, 211, 211, 1],
      'lightgreen': [144, 238, 144, 1],
      'lightgrey': [211, 211, 211, 1],
      'lightpink': [255, 182, 193, 1],
      'lightsalmon': [255, 160, 122, 1],
      'lightseagreen': [32, 178, 170, 1],
      'lightskyblue': [135, 206, 250, 1],
      'lightslategray': [119, 136, 153, 1],
      'lightslategrey': [119, 136, 153, 1],
      'lightsteelblue': [176, 196, 222, 1],
      'lightyellow': [255, 255, 224, 1],
      'lime': [0, 255, 0, 1],
      'limegreen': [50, 205, 50, 1],
      'linen': [250, 240, 230, 1],
      'magenta': [255, 0, 255, 1],
      'maroon': [128, 0, 0, 1],
      'mediumaquamarine': [102, 205, 170, 1],
      'mediumblue': [0, 0, 205, 1],
      'mediumorchid': [186, 85, 211, 1],
      'mediumpurple': [147, 112, 219, 1],
      'mediumseagreen': [60, 179, 113, 1],
      'mediumslateblue': [123, 104, 238, 1],
      'mediumspringgreen': [0, 250, 154, 1],
      'mediumturquoise': [72, 209, 204, 1],
      'mediumvioletred': [199, 21, 133, 1],
      'midnightblue': [25, 25, 112, 1],
      'mintcream': [245, 255, 250, 1],
      'mistyrose': [255, 228, 225, 1],
      'moccasin': [255, 228, 181, 1],
      'navajowhite': [255, 222, 173, 1],
      'navy': [0, 0, 128, 1],
      'oldlace': [253, 245, 230, 1],
      'olive': [128, 128, 0, 1],
      'olivedrab': [107, 142, 35, 1],
      'orange': [255, 165, 0, 1],
      'orangered': [255, 69, 0, 1],
      'orchid': [218, 112, 214, 1],
      'palegoldenrod': [238, 232, 170, 1],
      'palegreen': [152, 251, 152, 1],
      'paleturquoise': [175, 238, 238, 1],
      'palevioletred': [219, 112, 147, 1],
      'papayawhip': [255, 239, 213, 1],
      'peachpuff': [255, 218, 185, 1],
      'peru': [205, 133, 63, 1],
      'pink': [255, 192, 203, 1],
      'plum': [221, 160, 221, 1],
      'powderblue': [176, 224, 230, 1],
      'purple': [128, 0, 128, 1],
      'red': [255, 0, 0, 1],
      'rosybrown': [188, 143, 143, 1],
      'royalblue': [65, 105, 225, 1],
      'saddlebrown': [139, 69, 19, 1],
      'salmon': [250, 128, 114, 1],
      'sandybrown': [244, 164, 96, 1],
      'seagreen': [46, 139, 87, 1],
      'seashell': [255, 245, 238, 1],
      'sienna': [160, 82, 45, 1],
      'silver': [192, 192, 192, 1],
      'skyblue': [135, 206, 235, 1],
      'slateblue': [106, 90, 205, 1],
      'slategray': [112, 128, 144, 1],
      'slategrey': [112, 128, 144, 1],
      'snow': [255, 250, 250, 1],
      'springgreen': [0, 255, 127, 1],
      'steelblue': [70, 130, 180, 1],
      'tan': [210, 180, 140, 1],
      'teal': [0, 128, 128, 1],
      'thistle': [216, 191, 216, 1],
      'tomato': [255, 99, 71, 1],
      'turquoise': [64, 224, 208, 1],
      'violet': [238, 130, 238, 1],
      'wheat': [245, 222, 179, 1],
      'white': [255, 255, 255, 1],
      'whitesmoke': [245, 245, 245, 1],
      'yellow': [255, 255, 0, 1],
      'yellowgreen': [154, 205, 50, 1]
    };

    function clampCssByte(i) {
      // Clamp to integer 0 .. 255.
      i = Math.round(i); // Seems to be what Chrome does (vs truncation).

      return i < 0 ? 0 : i > 255 ? 255 : i;
    }

    function clampCssAngle(i) {
      // Clamp to integer 0 .. 360.
      i = Math.round(i); // Seems to be what Chrome does (vs truncation).

      return i < 0 ? 0 : i > 360 ? 360 : i;
    }

    function clampCssFloat(f) {
      // Clamp to float 0.0 .. 1.0.
      return f < 0 ? 0 : f > 1 ? 1 : f;
    }

    function parseCssInt(str) {
      // int or percentage.
      if (str.length && str.charAt(str.length - 1) === '%') {
        return clampCssByte(parseFloat(str) / 100 * 255);
      }

      return clampCssByte(parseInt(str, 10));
    }

    function parseCssFloat(str) {
      // float or percentage.
      if (str.length && str.charAt(str.length - 1) === '%') {
        return clampCssFloat(parseFloat(str) / 100);
      }

      return clampCssFloat(parseFloat(str));
    }

    function cssHueToRgb(m1, m2, h) {
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }

      if (h * 6 < 1) {
        return m1 + (m2 - m1) * h * 6;
      }

      if (h * 2 < 1) {
        return m2;
      }

      if (h * 3 < 2) {
        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
      }

      return m1;
    }

    function lerpNumber(a, b, p) {
      return a + (b - a) * p;
    }

    function setRgba(out, r, g, b, a) {
      out[0] = r;
      out[1] = g;
      out[2] = b;
      out[3] = a;
      return out;
    }

    function copyRgba(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      return out;
    }

    var colorCache = new LRU_1(20);
    var lastRemovedArr = null;

    function putToCache(colorStr, rgbaArr) {
      // Reuse removed array
      if (lastRemovedArr) {
        copyRgba(lastRemovedArr, rgbaArr);
      }

      lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
    }
    /**
     * @param {string} colorStr
     * @param {Array.<number>} out
     * @return {Array.<number>}
     * @memberOf module:zrender/util/color
     */


    function parse(colorStr, rgbaArr) {
      if (!colorStr) {
        return;
      }

      rgbaArr = rgbaArr || [];
      var cached = colorCache.get(colorStr);

      if (cached) {
        return copyRgba(rgbaArr, cached);
      } // colorStr may be not string


      colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.

      var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

      if (str in kCSSColorTable) {
        copyRgba(rgbaArr, kCSSColorTable[str]);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      } // #abc and #abc123 syntax.


      if (str.charAt(0) === '#') {
        if (str.length === 4) {
          var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

          if (!(iv >= 0 && iv <= 0xfff)) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return; // Covers NaN.
          }

          setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        } else if (str.length === 7) {
          var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

          if (!(iv >= 0 && iv <= 0xffffff)) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return; // Covers NaN.
          }

          setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        }

        return;
      }

      var op = str.indexOf('(');
      var ep = str.indexOf(')');

      if (op !== -1 && ep + 1 === str.length) {
        var fname = str.substr(0, op);
        var params = str.substr(op + 1, ep - (op + 1)).split(',');
        var alpha = 1; // To allow case fallthrough.

        switch (fname) {
          case 'rgba':
            if (params.length !== 4) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }

            alpha = parseCssFloat(params.pop());
          // jshint ignore:line
          // Fall through.

          case 'rgb':
            if (params.length !== 3) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }

            setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;

          case 'hsla':
            if (params.length !== 4) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }

            params[3] = parseCssFloat(params[3]);
            hsla2rgba(params, rgbaArr);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;

          case 'hsl':
            if (params.length !== 3) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }

            hsla2rgba(params, rgbaArr);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;

          default:
            return;
        }
      }

      setRgba(rgbaArr, 0, 0, 0, 1);
      return;
    }
    /**
     * @param {Array.<number>} hsla
     * @param {Array.<number>} rgba
     * @return {Array.<number>} rgba
     */


    function hsla2rgba(hsla, rgba) {
      var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
      // NOTE(deanm): According to the CSS spec s/l should only be
      // percentages, but we don't bother and let float or percentage.

      var s = parseCssFloat(hsla[1]);
      var l = parseCssFloat(hsla[2]);
      var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
      var m1 = l * 2 - m2;
      rgba = rgba || [];
      setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);

      if (hsla.length === 4) {
        rgba[3] = hsla[3];
      }

      return rgba;
    }
    /**
     * @param {Array.<number>} rgba
     * @return {Array.<number>} hsla
     */


    function rgba2hsla(rgba) {
      if (!rgba) {
        return;
      } // RGB from 0 to 255


      var R = rgba[0] / 255;
      var G = rgba[1] / 255;
      var B = rgba[2] / 255;
      var vMin = Math.min(R, G, B); // Min. value of RGB

      var vMax = Math.max(R, G, B); // Max. value of RGB

      var delta = vMax - vMin; // Delta RGB value

      var L = (vMax + vMin) / 2;
      var H;
      var S; // HSL results from 0 to 1

      if (delta === 0) {
        H = 0;
        S = 0;
      } else {
        if (L < 0.5) {
          S = delta / (vMax + vMin);
        } else {
          S = delta / (2 - vMax - vMin);
        }

        var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
        var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
        var deltaB = ((vMax - B) / 6 + delta / 2) / delta;

        if (R === vMax) {
          H = deltaB - deltaG;
        } else if (G === vMax) {
          H = 1 / 3 + deltaR - deltaB;
        } else if (B === vMax) {
          H = 2 / 3 + deltaG - deltaR;
        }

        if (H < 0) {
          H += 1;
        }

        if (H > 1) {
          H -= 1;
        }
      }

      var hsla = [H * 360, S, L];

      if (rgba[3] != null) {
        hsla.push(rgba[3]);
      }

      return hsla;
    }
    /**
     * @param {string} color
     * @param {number} level
     * @return {string}
     * @memberOf module:zrender/util/color
     */


    function lift(color, level) {
      var colorArr = parse(color);

      if (colorArr) {
        for (var i = 0; i < 3; i++) {
          if (level < 0) {
            colorArr[i] = colorArr[i] * (1 - level) | 0;
          } else {
            colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
          }

          if (colorArr[i] > 255) {
            colorArr[i] = 255;
          } else if (color[i] < 0) {
            colorArr[i] = 0;
          }
        }

        return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
      }
    }
    /**
     * @param {string} color
     * @return {string}
     * @memberOf module:zrender/util/color
     */


    function toHex(color) {
      var colorArr = parse(color);

      if (colorArr) {
        return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
      }
    }
    /**
     * Map value to color. Faster than lerp methods because color is represented by rgba array.
     * @param {number} normalizedValue A float between 0 and 1.
     * @param {Array.<Array.<number>>} colors List of rgba color array
     * @param {Array.<number>} [out] Mapped gba color array
     * @return {Array.<number>} will be null/undefined if input illegal.
     */


    function fastLerp(normalizedValue, colors, out) {
      if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
        return;
      }

      out = out || [];
      var value = normalizedValue * (colors.length - 1);
      var leftIndex = Math.floor(value);
      var rightIndex = Math.ceil(value);
      var leftColor = colors[leftIndex];
      var rightColor = colors[rightIndex];
      var dv = value - leftIndex;
      out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
      out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
      out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
      out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
      return out;
    }
    /**
     * @deprecated
     */


    var fastMapToColor = fastLerp;
    /**
     * @param {number} normalizedValue A float between 0 and 1.
     * @param {Array.<string>} colors Color list.
     * @param {boolean=} fullOutput Default false.
     * @return {(string|Object)} Result color. If fullOutput,
     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
     * @memberOf module:zrender/util/color
     */

    function lerp$1(normalizedValue, colors, fullOutput) {
      if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
        return;
      }

      var value = normalizedValue * (colors.length - 1);
      var leftIndex = Math.floor(value);
      var rightIndex = Math.ceil(value);
      var leftColor = parse(colors[leftIndex]);
      var rightColor = parse(colors[rightIndex]);
      var dv = value - leftIndex;
      var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
      return fullOutput ? {
        color: color,
        leftIndex: leftIndex,
        rightIndex: rightIndex,
        value: value
      } : color;
    }
    /**
     * @deprecated
     */


    var mapToColor = lerp$1;
    /**
     * @param {string} color
     * @param {number=} h 0 ~ 360, ignore when null.
     * @param {number=} s 0 ~ 1, ignore when null.
     * @param {number=} l 0 ~ 1, ignore when null.
     * @return {string} Color string in rgba format.
     * @memberOf module:zrender/util/color
     */

    function modifyHSL(color, h, s, l) {
      color = parse(color);

      if (color) {
        color = rgba2hsla(color);
        h != null && (color[0] = clampCssAngle(h));
        s != null && (color[1] = parseCssFloat(s));
        l != null && (color[2] = parseCssFloat(l));
        return stringify(hsla2rgba(color), 'rgba');
      }
    }
    /**
     * @param {string} color
     * @param {number=} alpha 0 ~ 1
     * @return {string} Color string in rgba format.
     * @memberOf module:zrender/util/color
     */


    function modifyAlpha(color, alpha) {
      color = parse(color);

      if (color && alpha != null) {
        color[3] = clampCssFloat(alpha);
        return stringify(color, 'rgba');
      }
    }
    /**
     * @param {Array.<number>} arrColor like [12,33,44,0.4]
     * @param {string} type 'rgba', 'hsva', ...
     * @return {string} Result color. (If input illegal, return undefined).
     */


    function stringify(arrColor, type) {
      if (!arrColor || !arrColor.length) {
        return;
      }

      var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];

      if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
        colorStr += ',' + arrColor[3];
      }

      return type + '(' + colorStr + ')';
    }

    var parse_1 = parse;
    var lift_1 = lift;
    var toHex_1 = toHex;
    var fastLerp_1 = fastLerp;
    var fastMapToColor_1 = fastMapToColor;
    var lerp_1$1 = lerp$1;
    var mapToColor_1 = mapToColor;
    var modifyHSL_1 = modifyHSL;
    var modifyAlpha_1 = modifyAlpha;
    var stringify_1 = stringify;

    var color = {
    	parse: parse_1,
    	lift: lift_1,
    	toHex: toHex_1,
    	fastLerp: fastLerp_1,
    	fastMapToColor: fastMapToColor_1,
    	lerp: lerp_1$1,
    	mapToColor: mapToColor_1,
    	modifyHSL: modifyHSL_1,
    	modifyAlpha: modifyAlpha_1,
    	stringify: stringify_1
    };

    var isArrayLike$1 = util.isArrayLike;

    /**
     * @module echarts/animation/Animator
     */
    var arraySlice = Array.prototype.slice;

    function defaultGetter(target, key) {
      return target[key];
    }

    function defaultSetter(target, key, value) {
      target[key] = value;
    }
    /**
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} percent
     * @return {number}
     */


    function interpolateNumber(p0, p1, percent) {
      return (p1 - p0) * percent + p0;
    }
    /**
     * @param  {string} p0
     * @param  {string} p1
     * @param  {number} percent
     * @return {string}
     */


    function interpolateString(p0, p1, percent) {
      return percent > 0.5 ? p1 : p0;
    }
    /**
     * @param  {Array} p0
     * @param  {Array} p1
     * @param  {number} percent
     * @param  {Array} out
     * @param  {number} arrDim
     */


    function interpolateArray(p0, p1, percent, out, arrDim) {
      var len = p0.length;

      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          out[i] = interpolateNumber(p0[i], p1[i], percent);
        }
      } else {
        var len2 = len && p0[0].length;

        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
          }
        }
      }
    } // arr0 is source array, arr1 is target array.
    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1


    function fillArr(arr0, arr1, arrDim) {
      var arr0Len = arr0.length;
      var arr1Len = arr1.length;

      if (arr0Len !== arr1Len) {
        // FIXME Not work for TypedArray
        var isPreviousLarger = arr0Len > arr1Len;

        if (isPreviousLarger) {
          // Cut the previous
          arr0.length = arr1Len;
        } else {
          // Fill the previous
          for (var i = arr0Len; i < arr1Len; i++) {
            arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
          }
        }
      } // Handling NaN value


      var len2 = arr0[0] && arr0[0].length;

      for (var i = 0; i < arr0.length; i++) {
        if (arrDim === 1) {
          if (isNaN(arr0[i])) {
            arr0[i] = arr1[i];
          }
        } else {
          for (var j = 0; j < len2; j++) {
            if (isNaN(arr0[i][j])) {
              arr0[i][j] = arr1[i][j];
            }
          }
        }
      }
    }
    /**
     * @param  {Array} arr0
     * @param  {Array} arr1
     * @param  {number} arrDim
     * @return {boolean}
     */


    function isArraySame(arr0, arr1, arrDim) {
      if (arr0 === arr1) {
        return true;
      }

      var len = arr0.length;

      if (len !== arr1.length) {
        return false;
      }

      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          if (arr0[i] !== arr1[i]) {
            return false;
          }
        }
      } else {
        var len2 = arr0[0].length;

        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            if (arr0[i][j] !== arr1[i][j]) {
              return false;
            }
          }
        }
      }

      return true;
    }
    /**
     * Catmull Rom interpolate array
     * @param  {Array} p0
     * @param  {Array} p1
     * @param  {Array} p2
     * @param  {Array} p3
     * @param  {number} t
     * @param  {number} t2
     * @param  {number} t3
     * @param  {Array} out
     * @param  {number} arrDim
     */


    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
      var len = p0.length;

      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
        }
      } else {
        var len2 = p0[0].length;

        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
          }
        }
      }
    }
    /**
     * Catmull Rom interpolate number
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @param  {number} t2
     * @param  {number} t3
     * @return {number}
     */


    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }

    function cloneValue(value) {
      if (isArrayLike$1(value)) {
        var len = value.length;

        if (isArrayLike$1(value[0])) {
          var ret = [];

          for (var i = 0; i < len; i++) {
            ret.push(arraySlice.call(value[i]));
          }

          return ret;
        }

        return arraySlice.call(value);
      }

      return value;
    }

    function rgba2String(rgba) {
      rgba[0] = Math.floor(rgba[0]);
      rgba[1] = Math.floor(rgba[1]);
      rgba[2] = Math.floor(rgba[2]);
      return 'rgba(' + rgba.join(',') + ')';
    }

    function getArrayDim(keyframes) {
      var lastValue = keyframes[keyframes.length - 1].value;
      return isArrayLike$1(lastValue && lastValue[0]) ? 2 : 1;
    }

    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
      var getter = animator._getter;
      var setter = animator._setter;
      var useSpline = easing === 'spline';
      var trackLen = keyframes.length;

      if (!trackLen) {
        return;
      } // Guess data type


      var firstVal = keyframes[0].value;
      var isValueArray = isArrayLike$1(firstVal);
      var isValueColor = false;
      var isValueString = false; // For vertices morphing

      var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
      var trackMaxTime; // Sort keyframe as ascending

      keyframes.sort(function (a, b) {
        return a.time - b.time;
      });
      trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe

      var kfPercents = []; // Value of each keyframe

      var kfValues = [];
      var prevValue = keyframes[0].value;
      var isAllValueEqual = true;

      for (var i = 0; i < trackLen; i++) {
        kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string

        var value = keyframes[i].value; // Check if value is equal, deep check if value is array

        if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
          isAllValueEqual = false;
        }

        prevValue = value; // Try converting a string to a color array

        if (typeof value === 'string') {
          var colorArray = color.parse(value);

          if (colorArray) {
            value = colorArray;
            isValueColor = true;
          } else {
            isValueString = true;
          }
        }

        kfValues.push(value);
      }

      if (!forceAnimate && isAllValueEqual) {
        return;
      }

      var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value

      for (var i = 0; i < trackLen - 1; i++) {
        if (isValueArray) {
          fillArr(kfValues[i], lastValue, arrDim);
        } else {
          if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
            kfValues[i] = lastValue;
          }
        }
      }

      isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
      // animation playback is sequency

      var lastFrame = 0;
      var lastFramePercent = 0;
      var start;
      var w;
      var p0;
      var p1;
      var p2;
      var p3;

      if (isValueColor) {
        var rgba = [0, 0, 0, 0];
      }

      var onframe = function (target, percent) {
        // Find the range keyframes
        // kf1-----kf2---------current--------kf3
        // find kf2 and kf3 and do interpolation
        var frame; // In the easing function like elasticOut, percent may less than 0

        if (percent < 0) {
          frame = 0;
        } else if (percent < lastFramePercent) {
          // Start from next key
          // PENDING start from lastFrame ?
          start = Math.min(lastFrame + 1, trackLen - 1);

          for (frame = start; frame >= 0; frame--) {
            if (kfPercents[frame] <= percent) {
              break;
            }
          } // PENDING really need to do this ?


          frame = Math.min(frame, trackLen - 2);
        } else {
          for (frame = lastFrame; frame < trackLen; frame++) {
            if (kfPercents[frame] > percent) {
              break;
            }
          }

          frame = Math.min(frame - 1, trackLen - 2);
        }

        lastFrame = frame;
        lastFramePercent = percent;
        var range = kfPercents[frame + 1] - kfPercents[frame];

        if (range === 0) {
          return;
        } else {
          w = (percent - kfPercents[frame]) / range;
        }

        if (useSpline) {
          p1 = kfValues[frame];
          p0 = kfValues[frame === 0 ? frame : frame - 1];
          p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
          p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];

          if (isValueArray) {
            catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
          } else {
            var value;

            if (isValueColor) {
              value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
              value = rgba2String(rgba);
            } else if (isValueString) {
              // String is step(0.5)
              return interpolateString(p1, p2, w);
            } else {
              value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
            }

            setter(target, propName, value);
          }
        } else {
          if (isValueArray) {
            interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
          } else {
            var value;

            if (isValueColor) {
              interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
              value = rgba2String(rgba);
            } else if (isValueString) {
              // String is step(0.5)
              return interpolateString(kfValues[frame], kfValues[frame + 1], w);
            } else {
              value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
            }

            setter(target, propName, value);
          }
        }
      };

      var clip = new Clip_1({
        target: animator._target,
        life: trackMaxTime,
        loop: animator._loop,
        delay: animator._delay,
        onframe: onframe,
        ondestroy: oneTrackDone
      });

      if (easing && easing !== 'spline') {
        clip.easing = easing;
      }

      return clip;
    }
    /**
     * @alias module:zrender/animation/Animator
     * @constructor
     * @param {Object} target
     * @param {boolean} loop
     * @param {Function} getter
     * @param {Function} setter
     */


    var Animator = function (target, loop, getter, setter) {
      this._tracks = {};
      this._target = target;
      this._loop = loop || false;
      this._getter = getter || defaultGetter;
      this._setter = setter || defaultSetter;
      this._clipCount = 0;
      this._delay = 0;
      this._doneList = [];
      this._onframeList = [];
      this._clipList = [];
    };

    Animator.prototype = {
      /**
       * Set Animation keyframe
       * @param  {number} time 关键帧时间，单位是ms
       * @param  {Object} props 关键帧的属性值，key-value表示
       * @return {module:zrender/animation/Animator}
       */
      when: function (time
      /* ms */
      , props) {
        var tracks = this._tracks;

        for (var propName in props) {
          if (!props.hasOwnProperty(propName)) {
            continue;
          }

          if (!tracks[propName]) {
            tracks[propName] = []; // Invalid value

            var value = this._getter(this._target, propName);

            if (value == null) {
              // zrLog('Invalid property ' + propName);
              continue;
            } // If time is 0
            //  Then props is given initialize value
            // Else
            //  Initialize value from current prop value


            if (time !== 0) {
              tracks[propName].push({
                time: 0,
                value: cloneValue(value)
              });
            }
          }

          tracks[propName].push({
            time: time,
            value: props[propName]
          });
        }

        return this;
      },

      /**
       * 添加动画每一帧的回调函数
       * @param  {Function} callback
       * @return {module:zrender/animation/Animator}
       */
      during: function (callback) {
        this._onframeList.push(callback);

        return this;
      },
      pause: function () {
        for (var i = 0; i < this._clipList.length; i++) {
          this._clipList[i].pause();
        }

        this._paused = true;
      },
      resume: function () {
        for (var i = 0; i < this._clipList.length; i++) {
          this._clipList[i].resume();
        }

        this._paused = false;
      },
      isPaused: function () {
        return !!this._paused;
      },
      _doneCallback: function () {
        // Clear all tracks
        this._tracks = {}; // Clear all clips

        this._clipList.length = 0;
        var doneList = this._doneList;
        var len = doneList.length;

        for (var i = 0; i < len; i++) {
          doneList[i].call(this);
        }
      },

      /**
       * Start the animation
       * @param  {string|Function} [easing]
       *         动画缓动函数，详见{@link module:zrender/animation/easing}
       * @param  {boolean} forceAnimate
       * @return {module:zrender/animation/Animator}
       */
      start: function (easing, forceAnimate) {
        var self = this;
        var clipCount = 0;

        var oneTrackDone = function () {
          clipCount--;

          if (!clipCount) {
            self._doneCallback();
          }
        };

        var lastClip;

        for (var propName in this._tracks) {
          if (!this._tracks.hasOwnProperty(propName)) {
            continue;
          }

          var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);

          if (clip) {
            this._clipList.push(clip);

            clipCount++; // If start after added to animation

            if (this.animation) {
              this.animation.addClip(clip);
            }

            lastClip = clip;
          }
        } // Add during callback on the last clip


        if (lastClip) {
          var oldOnFrame = lastClip.onframe;

          lastClip.onframe = function (target, percent) {
            oldOnFrame(target, percent);

            for (var i = 0; i < self._onframeList.length; i++) {
              self._onframeList[i](target, percent);
            }
          };
        } // This optimization will help the case that in the upper application
        // the view may be refreshed frequently, where animation will be
        // called repeatly but nothing changed.


        if (!clipCount) {
          this._doneCallback();
        }

        return this;
      },

      /**
       * Stop animation
       * @param {boolean} forwardToLast If move to last frame before stop
       */
      stop: function (forwardToLast) {
        var clipList = this._clipList;
        var animation = this.animation;

        for (var i = 0; i < clipList.length; i++) {
          var clip = clipList[i];

          if (forwardToLast) {
            // Move to last frame before stop
            clip.onframe(this._target, 1);
          }

          animation && animation.removeClip(clip);
        }

        clipList.length = 0;
      },

      /**
       * Set when animation delay starts
       * @param  {number} time 单位ms
       * @return {module:zrender/animation/Animator}
       */
      delay: function (time) {
        this._delay = time;
        return this;
      },

      /**
       * Add callback for animation end
       * @param  {Function} cb
       * @return {module:zrender/animation/Animator}
       */
      done: function (cb) {
        if (cb) {
          this._doneList.push(cb);
        }

        return this;
      },

      /**
       * @return {Array.<module:zrender/animation/Clip>}
       */
      getClips: function () {
        return this._clipList;
      }
    };
    var _default$b = Animator;
    var Animator_1 = _default$b;

    var dpr = 1; // If in browser environment

    if (typeof window !== 'undefined') {
      dpr = Math.max(window.devicePixelRatio || 1, 1);
    }
    /**
     * config默认配置项
     * @exports zrender/config
     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
     */

    /**
     * Debug log mode:
     * 0: Do nothing, for release.
     * 1: console.error, for debug.
     */


    var debugMode = 0; // retina 屏幕优化

    var devicePixelRatio = dpr;
    var debugMode_1 = debugMode;
    var devicePixelRatio_1 = devicePixelRatio;

    var config = {
    	debugMode: debugMode_1,
    	devicePixelRatio: devicePixelRatio_1
    };

    var logError = function () {};

    var _default$c = logError;
    var log = _default$c;

    var isString$2 = util.isString;
    var isFunction$2 = util.isFunction;
    var isObject$2 = util.isObject;
    var isArrayLike$2 = util.isArrayLike;
    var indexOf$1 = util.indexOf;

    /**
     * @alias module:zrender/mixin/Animatable
     * @constructor
     */
    var Animatable = function () {
      /**
       * @type {Array.<module:zrender/animation/Animator>}
       * @readOnly
       */
      this.animators = [];
    };

    Animatable.prototype = {
      constructor: Animatable,

      /**
       * 动画
       *
       * @param {string} path The path to fetch value from object, like 'a.b.c'.
       * @param {boolean} [loop] Whether to loop animation.
       * @return {module:zrender/animation/Animator}
       * @example:
       *     el.animate('style', false)
       *         .when(1000, {x: 10} )
       *         .done(function(){ // Animation done })
       *         .start()
       */
      animate: function (path, loop) {
        var target;
        var animatingShape = false;
        var el = this;
        var zr = this.__zr;

        if (path) {
          var pathSplitted = path.split('.');
          var prop = el; // If animating shape

          animatingShape = pathSplitted[0] === 'shape';

          for (var i = 0, l = pathSplitted.length; i < l; i++) {
            if (!prop) {
              continue;
            }

            prop = prop[pathSplitted[i]];
          }

          if (prop) {
            target = prop;
          }
        } else {
          target = el;
        }

        if (!target) {
          log('Property "' + path + '" is not existed in element ' + el.id);
          return;
        }

        var animators = el.animators;
        var animator = new Animator_1(target, loop);
        animator.during(function (target) {
          el.dirty(animatingShape);
        }).done(function () {
          // FIXME Animator will not be removed if use `Animator#stop` to stop animation
          animators.splice(indexOf$1(animators, animator), 1);
        });
        animators.push(animator); // If animate after added to the zrender

        if (zr) {
          zr.animation.addAnimator(animator);
        }

        return animator;
      },

      /**
       * 停止动画
       * @param {boolean} forwardToLast If move to last frame before stop
       */
      stopAnimation: function (forwardToLast) {
        var animators = this.animators;
        var len = animators.length;

        for (var i = 0; i < len; i++) {
          animators[i].stop(forwardToLast);
        }

        animators.length = 0;
        return this;
      },

      /**
       * Caution: this method will stop previous animation.
       * So do not use this method to one element twice before
       * animation starts, unless you know what you are doing.
       * @param {Object} target
       * @param {number} [time=500] Time in ms
       * @param {string} [easing='linear']
       * @param {number} [delay=0]
       * @param {Function} [callback]
       * @param {Function} [forceAnimate] Prevent stop animation and callback
       *        immediently when target values are the same as current values.
       *
       * @example
       *  // Animate position
       *  el.animateTo({
       *      position: [10, 10]
       *  }, function () { // done })
       *
       *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
       *  el.animateTo({
       *      shape: {
       *          width: 500
       *      },
       *      style: {
       *          fill: 'red'
       *      }
       *      position: [10, 10]
       *  }, 100, 100, 'cubicOut', function () { // done })
       */
      // TODO Return animation key
      animateTo: function (target, time, delay, easing, callback, forceAnimate) {
        animateTo(this, target, time, delay, easing, callback, forceAnimate);
      },

      /**
       * Animate from the target state to current state.
       * The params and the return value are the same as `this.animateTo`.
       */
      animateFrom: function (target, time, delay, easing, callback, forceAnimate) {
        animateTo(this, target, time, delay, easing, callback, forceAnimate, true);
      }
    };

    function animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {
      // animateTo(target, time, easing, callback);
      if (isString$2(delay)) {
        callback = easing;
        easing = delay;
        delay = 0;
      } // animateTo(target, time, delay, callback);
      else if (isFunction$2(easing)) {
          callback = easing;
          easing = 'linear';
          delay = 0;
        } // animateTo(target, time, callback);
        else if (isFunction$2(delay)) {
            callback = delay;
            delay = 0;
          } // animateTo(target, callback)
          else if (isFunction$2(time)) {
              callback = time;
              time = 500;
            } // animateTo(target)
            else if (!time) {
                time = 500;
              } // Stop all previous animations


      animatable.stopAnimation();
      animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start
      // if there is nothing to animate

      var animators = animatable.animators.slice();
      var count = animators.length;

      function done() {
        count--;

        if (!count) {
          callback && callback();
        }
      } // No animators. This should be checked before animators[i].start(),
      // because 'done' may be executed immediately if no need to animate.


      if (!count) {
        callback && callback();
      } // Start after all animators created
      // Incase any animator is done immediately when all animation properties are not changed


      for (var i = 0; i < animators.length; i++) {
        animators[i].done(done).start(easing, forceAnimate);
      }
    }
    /**
     * @param {string} path=''
     * @param {Object} source=animatable
     * @param {Object} target
     * @param {number} [time=500]
     * @param {number} [delay=0]
     * @param {boolean} [reverse] If `true`, animate
     *        from the `target` to current state.
     *
     * @example
     *  // Animate position
     *  el._animateToShallow({
     *      position: [10, 10]
     *  })
     *
     *  // Animate shape, style and position in 100ms, delayed 100ms
     *  el._animateToShallow({
     *      shape: {
     *          width: 500
     *      },
     *      style: {
     *          fill: 'red'
     *      }
     *      position: [10, 10]
     *  }, 100, 100)
     */


    function animateToShallow(animatable, path, source, target, time, delay, reverse) {
      var objShallow = {};
      var propertyCount = 0;

      for (var name in target) {
        if (!target.hasOwnProperty(name)) {
          continue;
        }

        if (source[name] != null) {
          if (isObject$2(target[name]) && !isArrayLike$2(target[name])) {
            animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);
          } else {
            if (reverse) {
              objShallow[name] = source[name];
              setAttrByPath(animatable, path, name, target[name]);
            } else {
              objShallow[name] = target[name];
            }

            propertyCount++;
          }
        } else if (target[name] != null && !reverse) {
          setAttrByPath(animatable, path, name, target[name]);
        }
      }

      if (propertyCount > 0) {
        animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
      }
    }

    function setAttrByPath(el, path, name, value) {
      // Attr directly if not has property
      // FIXME, if some property not needed for element ?
      if (!path) {
        el.attr(name, value);
      } else {
        // Only support set shape or style
        var props = {};
        props[path] = {};
        props[path][name] = value;
        el.attr(props);
      }
    }

    var _default$d = Animatable;
    var Animatable_1 = _default$d;

    /**
     * @alias module:zrender/Element
     * @constructor
     * @extends {module:zrender/mixin/Animatable}
     * @extends {module:zrender/mixin/Transformable}
     * @extends {module:zrender/mixin/Eventful}
     */
    var Element = function (opts) {
      // jshint ignore:line
      Transformable_1.call(this, opts);
      Eventful_1.call(this, opts);
      Animatable_1.call(this, opts);
      /**
       * 画布元素ID
       * @type {string}
       */

      this.id = opts.id || guid();
    };

    Element.prototype = {
      /**
       * 元素类型
       * Element type
       * @type {string}
       */
      type: 'element',

      /**
       * 元素名字
       * Element name
       * @type {string}
       */
      name: '',

      /**
       * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
       * ZRender instance will be assigned when element is associated with zrender
       * @name module:/zrender/Element#__zr
       * @type {module:zrender/ZRender}
       */
      __zr: null,

      /**
       * 图形是否忽略，为true时忽略图形的绘制以及事件触发
       * If ignore drawing and events of the element object
       * @name module:/zrender/Element#ignore
       * @type {boolean}
       * @default false
       */
      ignore: false,

      /**
       * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
       * 该路径会继承被裁减对象的变换
       * @type {module:zrender/graphic/Path}
       * @see http://www.w3.org/TR/2dcontext/#clipping-region
       * @readOnly
       */
      clipPath: null,

      /**
       * 是否是 Group
       * @type {boolean}
       */
      isGroup: false,

      /**
       * Drift element
       * @param  {number} dx dx on the global space
       * @param  {number} dy dy on the global space
       */
      drift: function (dx, dy) {
        switch (this.draggable) {
          case 'horizontal':
            dy = 0;
            break;

          case 'vertical':
            dx = 0;
            break;
        }

        var m = this.transform;

        if (!m) {
          m = this.transform = [1, 0, 0, 1, 0, 0];
        }

        m[4] += dx;
        m[5] += dy;
        this.decomposeTransform();
        this.dirty(false);
      },

      /**
       * Hook before update
       */
      beforeUpdate: function () {},

      /**
       * Hook after update
       */
      afterUpdate: function () {},

      /**
       * Update each frame
       */
      update: function () {
        this.updateTransform();
      },

      /**
       * @param  {Function} cb
       * @param  {}   context
       */
      traverse: function (cb, context) {},

      /**
       * @protected
       */
      attrKV: function (key, value) {
        if (key === 'position' || key === 'scale' || key === 'origin') {
          // Copy the array
          if (value) {
            var target = this[key];

            if (!target) {
              target = this[key] = [];
            }

            target[0] = value[0];
            target[1] = value[1];
          }
        } else {
          this[key] = value;
        }
      },

      /**
       * Hide the element
       */
      hide: function () {
        this.ignore = true;
        this.__zr && this.__zr.refresh();
      },

      /**
       * Show the element
       */
      show: function () {
        this.ignore = false;
        this.__zr && this.__zr.refresh();
      },

      /**
       * @param {string|Object} key
       * @param {*} value
       */
      attr: function (key, value) {
        if (typeof key === 'string') {
          this.attrKV(key, value);
        } else if (util.isObject(key)) {
          for (var name in key) {
            if (key.hasOwnProperty(name)) {
              this.attrKV(name, key[name]);
            }
          }
        }

        this.dirty(false);
        return this;
      },

      /**
       * @param {module:zrender/graphic/Path} clipPath
       */
      setClipPath: function (clipPath) {
        var zr = this.__zr;

        if (zr) {
          clipPath.addSelfToZr(zr);
        } // Remove previous clip path


        if (this.clipPath && this.clipPath !== clipPath) {
          this.removeClipPath();
        }

        this.clipPath = clipPath;
        clipPath.__zr = zr;
        clipPath.__clipTarget = this;
        this.dirty(false);
      },

      /**
       */
      removeClipPath: function () {
        var clipPath = this.clipPath;

        if (clipPath) {
          if (clipPath.__zr) {
            clipPath.removeSelfFromZr(clipPath.__zr);
          }

          clipPath.__zr = null;
          clipPath.__clipTarget = null;
          this.clipPath = null;
          this.dirty(false);
        }
      },

      /**
       * Add self from zrender instance.
       * Not recursively because it will be invoked when element added to storage.
       * @param {module:zrender/ZRender} zr
       */
      addSelfToZr: function (zr) {
        this.__zr = zr; // 添加动画

        var animators = this.animators;

        if (animators) {
          for (var i = 0; i < animators.length; i++) {
            zr.animation.addAnimator(animators[i]);
          }
        }

        if (this.clipPath) {
          this.clipPath.addSelfToZr(zr);
        }
      },

      /**
       * Remove self from zrender instance.
       * Not recursively because it will be invoked when element added to storage.
       * @param {module:zrender/ZRender} zr
       */
      removeSelfFromZr: function (zr) {
        this.__zr = null; // 移除动画

        var animators = this.animators;

        if (animators) {
          for (var i = 0; i < animators.length; i++) {
            zr.animation.removeAnimator(animators[i]);
          }
        }

        if (this.clipPath) {
          this.clipPath.removeSelfFromZr(zr);
        }
      }
    };
    util.mixin(Element, Animatable_1);
    util.mixin(Element, Transformable_1);
    util.mixin(Element, Eventful_1);
    var _default$e = Element;
    var Element_1 = _default$e;

    /**
     * @module echarts/core/BoundingRect
     */
    var v2ApplyTransform = vector.applyTransform;
    var mathMin = Math.min;
    var mathMax = Math.max;
    /**
     * @alias module:echarts/core/BoundingRect
     */

    function BoundingRect(x, y, width, height) {
      if (width < 0) {
        x = x + width;
        width = -width;
      }

      if (height < 0) {
        y = y + height;
        height = -height;
      }
      /**
       * @type {number}
       */


      this.x = x;
      /**
       * @type {number}
       */

      this.y = y;
      /**
       * @type {number}
       */

      this.width = width;
      /**
       * @type {number}
       */

      this.height = height;
    }

    BoundingRect.prototype = {
      constructor: BoundingRect,

      /**
       * @param {module:echarts/core/BoundingRect} other
       */
      union: function (other) {
        var x = mathMin(other.x, this.x);
        var y = mathMin(other.y, this.y);
        this.width = mathMax(other.x + other.width, this.x + this.width) - x;
        this.height = mathMax(other.y + other.height, this.y + this.height) - y;
        this.x = x;
        this.y = y;
      },

      /**
       * @param {Array.<number>} m
       * @methods
       */
      applyTransform: function () {
        var lt = [];
        var rb = [];
        var lb = [];
        var rt = [];
        return function (m) {
          // In case usage like this
          // el.getBoundingRect().applyTransform(el.transform)
          // And element has no transform
          if (!m) {
            return;
          }

          lt[0] = lb[0] = this.x;
          lt[1] = rt[1] = this.y;
          rb[0] = rt[0] = this.x + this.width;
          rb[1] = lb[1] = this.y + this.height;
          v2ApplyTransform(lt, lt, m);
          v2ApplyTransform(rb, rb, m);
          v2ApplyTransform(lb, lb, m);
          v2ApplyTransform(rt, rt, m);
          this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
          this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
          var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
          var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
          this.width = maxX - this.x;
          this.height = maxY - this.y;
        };
      }(),

      /**
       * Calculate matrix of transforming from self to target rect
       * @param  {module:zrender/core/BoundingRect} b
       * @return {Array.<number>}
       */
      calculateTransform: function (b) {
        var a = this;
        var sx = b.width / a.width;
        var sy = b.height / a.height;
        var m = matrix.create(); // 矩阵右乘

        matrix.translate(m, m, [-a.x, -a.y]);
        matrix.scale(m, m, [sx, sy]);
        matrix.translate(m, m, [b.x, b.y]);
        return m;
      },

      /**
       * @param {(module:echarts/core/BoundingRect|Object)} b
       * @return {boolean}
       */
      intersect: function (b) {
        if (!b) {
          return false;
        }

        if (!(b instanceof BoundingRect)) {
          // Normalize negative width/height.
          b = BoundingRect.create(b);
        }

        var a = this;
        var ax0 = a.x;
        var ax1 = a.x + a.width;
        var ay0 = a.y;
        var ay1 = a.y + a.height;
        var bx0 = b.x;
        var bx1 = b.x + b.width;
        var by0 = b.y;
        var by1 = b.y + b.height;
        return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
      },
      contain: function (x, y) {
        var rect = this;
        return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
      },

      /**
       * @return {module:echarts/core/BoundingRect}
       */
      clone: function () {
        return new BoundingRect(this.x, this.y, this.width, this.height);
      },

      /**
       * Copy from another rect
       */
      copy: function (other) {
        this.x = other.x;
        this.y = other.y;
        this.width = other.width;
        this.height = other.height;
      },
      plain: function () {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height
        };
      }
    };
    /**
     * @param {Object|module:zrender/core/BoundingRect} rect
     * @param {number} rect.x
     * @param {number} rect.y
     * @param {number} rect.width
     * @param {number} rect.height
     * @return {module:zrender/core/BoundingRect}
     */

    BoundingRect.create = function (rect) {
      return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
    };

    var _default$f = BoundingRect;
    var BoundingRect_1 = _default$f;

    /**
     * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
     * @module zrender/graphic/Group
     * @example
     *     var Group = require('zrender/container/Group');
     *     var Circle = require('zrender/graphic/shape/Circle');
     *     var g = new Group();
     *     g.position[0] = 100;
     *     g.position[1] = 100;
     *     g.add(new Circle({
     *         style: {
     *             x: 100,
     *             y: 100,
     *             r: 20,
     *         }
     *     }));
     *     zr.add(g);
     */

    /**
     * @alias module:zrender/graphic/Group
     * @constructor
     * @extends module:zrender/mixin/Transformable
     * @extends module:zrender/mixin/Eventful
     */
    var Group = function (opts) {
      opts = opts || {};
      Element_1.call(this, opts);

      for (var key in opts) {
        if (opts.hasOwnProperty(key)) {
          this[key] = opts[key];
        }
      }

      this._children = [];
      this.__storage = null;
      this.__dirty = true;
    };

    Group.prototype = {
      constructor: Group,
      isGroup: true,

      /**
       * @type {string}
       */
      type: 'group',

      /**
       * 所有子孙元素是否响应鼠标事件
       * @name module:/zrender/container/Group#silent
       * @type {boolean}
       * @default false
       */
      silent: false,

      /**
       * @return {Array.<module:zrender/Element>}
       */
      children: function () {
        return this._children.slice();
      },

      /**
       * 获取指定 index 的儿子节点
       * @param  {number} idx
       * @return {module:zrender/Element}
       */
      childAt: function (idx) {
        return this._children[idx];
      },

      /**
       * 获取指定名字的儿子节点
       * @param  {string} name
       * @return {module:zrender/Element}
       */
      childOfName: function (name) {
        var children = this._children;

        for (var i = 0; i < children.length; i++) {
          if (children[i].name === name) {
            return children[i];
          }
        }
      },

      /**
       * @return {number}
       */
      childCount: function () {
        return this._children.length;
      },

      /**
       * 添加子节点到最后
       * @param {module:zrender/Element} child
       */
      add: function (child) {
        if (child && child !== this && child.parent !== this) {
          this._children.push(child);

          this._doAdd(child);
        }

        return this;
      },

      /**
       * 添加子节点在 nextSibling 之前
       * @param {module:zrender/Element} child
       * @param {module:zrender/Element} nextSibling
       */
      addBefore: function (child, nextSibling) {
        if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
          var children = this._children;
          var idx = children.indexOf(nextSibling);

          if (idx >= 0) {
            children.splice(idx, 0, child);

            this._doAdd(child);
          }
        }

        return this;
      },
      _doAdd: function (child) {
        if (child.parent) {
          child.parent.remove(child);
        }

        child.parent = this;
        var storage = this.__storage;
        var zr = this.__zr;

        if (storage && storage !== child.__storage) {
          storage.addToStorage(child);

          if (child instanceof Group) {
            child.addChildrenToStorage(storage);
          }
        }

        zr && zr.refresh();
      },

      /**
       * 移除子节点
       * @param {module:zrender/Element} child
       */
      remove: function (child) {
        var zr = this.__zr;
        var storage = this.__storage;
        var children = this._children;
        var idx = util.indexOf(children, child);

        if (idx < 0) {
          return this;
        }

        children.splice(idx, 1);
        child.parent = null;

        if (storage) {
          storage.delFromStorage(child);

          if (child instanceof Group) {
            child.delChildrenFromStorage(storage);
          }
        }

        zr && zr.refresh();
        return this;
      },

      /**
       * 移除所有子节点
       */
      removeAll: function () {
        var children = this._children;
        var storage = this.__storage;
        var child;
        var i;

        for (i = 0; i < children.length; i++) {
          child = children[i];

          if (storage) {
            storage.delFromStorage(child);

            if (child instanceof Group) {
              child.delChildrenFromStorage(storage);
            }
          }

          child.parent = null;
        }

        children.length = 0;
        return this;
      },

      /**
       * 遍历所有子节点
       * @param  {Function} cb
       * @param  {}   context
       */
      eachChild: function (cb, context) {
        var children = this._children;

        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          cb.call(context, child, i);
        }

        return this;
      },

      /**
       * 深度优先遍历所有子孙节点
       * @param  {Function} cb
       * @param  {}   context
       */
      traverse: function (cb, context) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          cb.call(context, child);

          if (child.type === 'group') {
            child.traverse(cb, context);
          }
        }

        return this;
      },
      addChildrenToStorage: function (storage) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          storage.addToStorage(child);

          if (child instanceof Group) {
            child.addChildrenToStorage(storage);
          }
        }
      },
      delChildrenFromStorage: function (storage) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          storage.delFromStorage(child);

          if (child instanceof Group) {
            child.delChildrenFromStorage(storage);
          }
        }
      },
      dirty: function () {
        this.__dirty = true;
        this.__zr && this.__zr.refresh();
        return this;
      },

      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getBoundingRect: function (includeChildren) {
        // TODO Caching
        var rect = null;
        var tmpRect = new BoundingRect_1(0, 0, 0, 0);
        var children = includeChildren || this._children;
        var tmpMat = [];

        for (var i = 0; i < children.length; i++) {
          var child = children[i];

          if (child.ignore || child.invisible) {
            continue;
          }

          var childRect = child.getBoundingRect();
          var transform = child.getLocalTransform(tmpMat); // TODO
          // The boundingRect cacluated by transforming original
          // rect may be bigger than the actual bundingRect when rotation
          // is used. (Consider a circle rotated aginst its center, where
          // the actual boundingRect should be the same as that not be
          // rotated.) But we can not find better approach to calculate
          // actual boundingRect yet, considering performance.

          if (transform) {
            tmpRect.copy(childRect);
            tmpRect.applyTransform(transform);
            rect = rect || tmpRect.clone();
            rect.union(tmpRect);
          } else {
            rect = rect || childRect.clone();
            rect.union(childRect);
          }
        }

        return rect || tmpRect;
      }
    };
    util.inherits(Group, Element_1);
    var _default$g = Group;
    var Group_1 = _default$g;

    // https://github.com/mziccard/node-timsort
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;

    function minRunLength(n) {
      var r = 0;

      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }

      return n + r;
    }

    function makeAscendingRun(array, lo, hi, compare) {
      var runHi = lo + 1;

      if (runHi === hi) {
        return 1;
      }

      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }

        reverseRun(array, lo, runHi);
      } else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }

      return runHi - lo;
    }

    function reverseRun(array, lo, hi) {
      hi--;

      while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }

    function binaryInsertionSort(array, lo, hi, start, compare) {
      if (start === lo) {
        start++;
      }

      for (; start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;
        var mid;

        while (left < right) {
          mid = left + right >>> 1;

          if (compare(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }

        var n = start - left;

        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];

          case 2:
            array[left + 2] = array[left + 1];

          case 1:
            array[left + 1] = array[left];
            break;

          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              n--;
            }

        }

        array[left] = pivot;
      }
    }

    function gallopLeft(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;

      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }

      lastOffset++;

      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }

      return offset;
    }

    function gallopRight(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;

      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
      }

      lastOffset++;

      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }

      return offset;
    }

    function TimSort(array, compare) {
      var minGallop = DEFAULT_MIN_GALLOPING;
      var length = 0;
      var runStart;
      var runLength;
      var stackSize = 0;
      length = array.length;

      var tmp = [];
      runStart = [];
      runLength = [];

      function pushRun(_runStart, _runLength) {
        runStart[stackSize] = _runStart;
        runLength[stackSize] = _runLength;
        stackSize += 1;
      }

      function mergeRuns() {
        while (stackSize > 1) {
          var n = stackSize - 2;

          if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
            if (runLength[n - 1] < runLength[n + 1]) {
              n--;
            }
          } else if (runLength[n] > runLength[n + 1]) {
            break;
          }

          mergeAt(n);
        }
      }

      function forceMergeRuns() {
        while (stackSize > 1) {
          var n = stackSize - 2;

          if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
            n--;
          }

          mergeAt(n);
        }
      }

      function mergeAt(i) {
        var start1 = runStart[i];
        var length1 = runLength[i];
        var start2 = runStart[i + 1];
        var length2 = runLength[i + 1];
        runLength[i] = length1 + length2;

        if (i === stackSize - 3) {
          runStart[i + 1] = runStart[i + 2];
          runLength[i + 1] = runLength[i + 2];
        }

        stackSize--;
        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;

        if (length1 === 0) {
          return;
        }

        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

        if (length2 === 0) {
          return;
        }

        if (length1 <= length2) {
          mergeLow(start1, length1, start2, length2);
        } else {
          mergeHigh(start1, length1, start2, length2);
        }
      }

      function mergeLow(start1, length1, start2, length2) {
        var i = 0;

        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
        }

        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;
        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }

          return;
        }

        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          array[dest + length2] = tmp[cursor1];
          return;
        }

        var _minGallop = minGallop;
        var count1;
        var count2;
        var exit;

        while (1) {
          count1 = 0;
          count2 = 0;
          exit = false;

          do {
            if (compare(array[cursor2], tmp[cursor1]) < 0) {
              array[dest++] = array[cursor2++];
              count2++;
              count1 = 0;

              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest++] = tmp[cursor1++];
              count1++;
              count2 = 0;

              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < _minGallop);

          if (exit) {
            break;
          }

          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
              }

              dest += count1;
              cursor1 += count1;
              length1 -= count1;

              if (length1 <= 1) {
                exit = true;
                break;
              }
            }

            array[dest++] = array[cursor2++];

            if (--length2 === 0) {
              exit = true;
              break;
            }

            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

            if (count2 !== 0) {
              for (i = 0; i < count2; i++) {
                array[dest + i] = array[cursor2 + i];
              }

              dest += count2;
              cursor2 += count2;
              length2 -= count2;

              if (length2 === 0) {
                exit = true;
                break;
              }
            }

            array[dest++] = tmp[cursor1++];

            if (--length1 === 1) {
              exit = true;
              break;
            }

            _minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

          if (exit) {
            break;
          }

          if (_minGallop < 0) {
            _minGallop = 0;
          }

          _minGallop += 2;
        }

        minGallop = _minGallop;
        minGallop < 1 && (minGallop = 1);

        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          array[dest + length2] = tmp[cursor1];
        } else if (length1 === 0) {
          throw new Error(); // throw new Error('mergeLow preconditions were not respected');
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
        }
      }

      function mergeHigh(start1, length1, start2, length2) {
        var i = 0;

        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
        }

        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;
        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);

          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }

          return;
        }

        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          array[dest] = tmp[cursor2];
          return;
        }

        var _minGallop = minGallop;

        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;

          do {
            if (compare(tmp[cursor2], array[cursor1]) < 0) {
              array[dest--] = array[cursor1--];
              count1++;
              count2 = 0;

              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest--] = tmp[cursor2--];
              count2++;
              count1 = 0;

              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < _minGallop);

          if (exit) {
            break;
          }

          do {
            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;

              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
              }

              if (length1 === 0) {
                exit = true;
                break;
              }
            }

            array[dest--] = tmp[cursor2--];

            if (--length2 === 1) {
              exit = true;
              break;
            }

            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

            if (count2 !== 0) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;

              for (i = 0; i < count2; i++) {
                array[customDest + i] = tmp[customCursor + i];
              }

              if (length2 <= 1) {
                exit = true;
                break;
              }
            }

            array[dest--] = array[cursor1--];

            if (--length1 === 0) {
              exit = true;
              break;
            }

            _minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

          if (exit) {
            break;
          }

          if (_minGallop < 0) {
            _minGallop = 0;
          }

          _minGallop += 2;
        }

        minGallop = _minGallop;

        if (minGallop < 1) {
          minGallop = 1;
        }

        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          array[dest] = tmp[cursor2];
        } else if (length2 === 0) {
          throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
        } else {
          customCursor = dest - (length2 - 1);

          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }
        }
      }

      this.mergeRuns = mergeRuns;
      this.forceMergeRuns = forceMergeRuns;
      this.pushRun = pushRun;
    }

    function sort(array, compare, lo, hi) {
      if (!lo) {
        lo = 0;
      }

      if (!hi) {
        hi = array.length;
      }

      var remaining = hi - lo;

      if (remaining < 2) {
        return;
      }

      var runLength = 0;

      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
      }

      var ts = new TimSort(array, compare);
      var minRun = minRunLength(remaining);

      do {
        runLength = makeAscendingRun(array, lo, hi, compare);

        if (runLength < minRun) {
          var force = remaining;

          if (force > minRun) {
            force = minRun;
          }

          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }

        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);

      ts.forceMergeRuns();
    }

    var timsort = sort;

    // Use timsort because in most case elements are partially sorted
    // https://jsfiddle.net/pissang/jr4x7mdm/8/
    function shapeCompareFunc(a, b) {
      if (a.zlevel === b.zlevel) {
        if (a.z === b.z) {
          // if (a.z2 === b.z2) {
          //     // FIXME Slow has renderidx compare
          //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
          //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
          //     return a.__renderidx - b.__renderidx;
          // }
          return a.z2 - b.z2;
        }

        return a.z - b.z;
      }

      return a.zlevel - b.zlevel;
    }
    /**
     * 内容仓库 (M)
     * @alias module:zrender/Storage
     * @constructor
     */


    var Storage = function () {
      // jshint ignore:line
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
    };

    Storage.prototype = {
      constructor: Storage,

      /**
       * @param  {Function} cb
       *
       */
      traverse: function (cb, context) {
        for (var i = 0; i < this._roots.length; i++) {
          this._roots[i].traverse(cb, context);
        }
      },

      /**
       * 返回所有图形的绘制队列
       * @param {boolean} [update=false] 是否在返回前更新该数组
       * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
       *
       * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
       * @return {Array.<module:zrender/graphic/Displayable>}
       */
      getDisplayList: function (update, includeIgnore) {
        includeIgnore = includeIgnore || false;

        if (update) {
          this.updateDisplayList(includeIgnore);
        }

        return this._displayList;
      },

      /**
       * 更新图形的绘制队列。
       * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
       * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
       * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
       */
      updateDisplayList: function (includeIgnore) {
        this._displayListLen = 0;
        var roots = this._roots;
        var displayList = this._displayList;

        for (var i = 0, len = roots.length; i < len; i++) {
          this._updateAndAddDisplayable(roots[i], null, includeIgnore);
        }

        displayList.length = this._displayListLen;
        env_1.canvasSupported && timsort(displayList, shapeCompareFunc);
      },
      _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
        if (el.ignore && !includeIgnore) {
          return;
        }

        el.beforeUpdate();

        if (el.__dirty) {
          el.update();
        }

        el.afterUpdate();
        var userSetClipPath = el.clipPath;

        if (userSetClipPath) {
          // FIXME 效率影响
          if (clipPaths) {
            clipPaths = clipPaths.slice();
          } else {
            clipPaths = [];
          }

          var currentClipPath = userSetClipPath;
          var parentClipPath = el; // Recursively add clip path

          while (currentClipPath) {
            // clipPath 的变换是基于使用这个 clipPath 的元素
            currentClipPath.parent = parentClipPath;
            currentClipPath.updateTransform();
            clipPaths.push(currentClipPath);
            parentClipPath = currentClipPath;
            currentClipPath = currentClipPath.clipPath;
          }
        }

        if (el.isGroup) {
          var children = el._children;

          for (var i = 0; i < children.length; i++) {
            var child = children[i]; // Force to mark as dirty if group is dirty
            // FIXME __dirtyPath ?

            if (el.__dirty) {
              child.__dirty = true;
            }

            this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
          } // Mark group clean here


          el.__dirty = false;
        } else {
          el.__clipPaths = clipPaths;
          this._displayList[this._displayListLen++] = el;
        }
      },

      /**
       * 添加图形(Shape)或者组(Group)到根节点
       * @param {module:zrender/Element} el
       */
      addRoot: function (el) {
        if (el.__storage === this) {
          return;
        }

        if (el instanceof Group_1) {
          el.addChildrenToStorage(this);
        }

        this.addToStorage(el);

        this._roots.push(el);
      },

      /**
       * 删除指定的图形(Shape)或者组(Group)
       * @param {string|Array.<string>} [el] 如果为空清空整个Storage
       */
      delRoot: function (el) {
        if (el == null) {
          // 不指定el清空
          for (var i = 0; i < this._roots.length; i++) {
            var root = this._roots[i];

            if (root instanceof Group_1) {
              root.delChildrenFromStorage(this);
            }
          }

          this._roots = [];
          this._displayList = [];
          this._displayListLen = 0;
          return;
        }

        if (el instanceof Array) {
          for (var i = 0, l = el.length; i < l; i++) {
            this.delRoot(el[i]);
          }

          return;
        }

        var idx = util.indexOf(this._roots, el);

        if (idx >= 0) {
          this.delFromStorage(el);

          this._roots.splice(idx, 1);

          if (el instanceof Group_1) {
            el.delChildrenFromStorage(this);
          }
        }
      },
      addToStorage: function (el) {
        if (el) {
          el.__storage = this;
          el.dirty(false);
        }

        return this;
      },
      delFromStorage: function (el) {
        if (el) {
          el.__storage = null;
        }

        return this;
      },

      /**
       * 清空并且释放Storage
       */
      dispose: function () {
        this._renderList = this._roots = null;
      },
      displayableSortFunc: shapeCompareFunc
    };
    var _default$h = Storage;
    var Storage_1 = _default$h;

    var SHADOW_PROPS = {
      'shadowBlur': 1,
      'shadowOffsetX': 1,
      'shadowOffsetY': 1,
      'textShadowBlur': 1,
      'textShadowOffsetX': 1,
      'textShadowOffsetY': 1,
      'textBoxShadowBlur': 1,
      'textBoxShadowOffsetX': 1,
      'textBoxShadowOffsetY': 1
    };

    function _default$i(ctx, propName, value) {
      if (SHADOW_PROPS.hasOwnProperty(propName)) {
        return value *= ctx.dpr;
      }

      return value;
    }

    var fixShadow = _default$i;

    var ContextCachedBy = {
      NONE: 0,
      STYLE_BIND: 1,
      PLAIN_TEXT: 2
    }; // Avoid confused with 0/false.

    var WILL_BE_RESTORED = 9;
    var ContextCachedBy_1 = ContextCachedBy;
    var WILL_BE_RESTORED_1 = WILL_BE_RESTORED;

    var constant = {
    	ContextCachedBy: ContextCachedBy_1,
    	WILL_BE_RESTORED: WILL_BE_RESTORED_1
    };

    var ContextCachedBy$1 = constant.ContextCachedBy;
    var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);

    var Style = function (opts) {
      this.extendFrom(opts, false);
    };

    function createLinearGradient(ctx, obj, rect) {
      var x = obj.x == null ? 0 : obj.x;
      var x2 = obj.x2 == null ? 1 : obj.x2;
      var y = obj.y == null ? 0 : obj.y;
      var y2 = obj.y2 == null ? 0 : obj.y2;

      if (!obj.global) {
        x = x * rect.width + rect.x;
        x2 = x2 * rect.width + rect.x;
        y = y * rect.height + rect.y;
        y2 = y2 * rect.height + rect.y;
      } // Fix NaN when rect is Infinity


      x = isNaN(x) ? 0 : x;
      x2 = isNaN(x2) ? 1 : x2;
      y = isNaN(y) ? 0 : y;
      y2 = isNaN(y2) ? 0 : y2;
      var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
      return canvasGradient;
    }

    function createRadialGradient(ctx, obj, rect) {
      var width = rect.width;
      var height = rect.height;
      var min = Math.min(width, height);
      var x = obj.x == null ? 0.5 : obj.x;
      var y = obj.y == null ? 0.5 : obj.y;
      var r = obj.r == null ? 0.5 : obj.r;

      if (!obj.global) {
        x = x * width + rect.x;
        y = y * height + rect.y;
        r = r * min;
      }

      var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
      return canvasGradient;
    }

    Style.prototype = {
      constructor: Style,

      /**
       * @type {string}
       */
      fill: '#000',

      /**
       * @type {string}
       */
      stroke: null,

      /**
       * @type {number}
       */
      opacity: 1,

      /**
       * @type {number}
       */
      fillOpacity: null,

      /**
       * @type {number}
       */
      strokeOpacity: null,

      /**
       * `true` is not supported.
       * `false`/`null`/`undefined` are the same.
       * `false` is used to remove lineDash in some
       * case that `null`/`undefined` can not be set.
       * (e.g., emphasis.lineStyle in echarts)
       * @type {Array.<number>|boolean}
       */
      lineDash: null,

      /**
       * @type {number}
       */
      lineDashOffset: 0,

      /**
       * @type {number}
       */
      shadowBlur: 0,

      /**
       * @type {number}
       */
      shadowOffsetX: 0,

      /**
       * @type {number}
       */
      shadowOffsetY: 0,

      /**
       * @type {number}
       */
      lineWidth: 1,

      /**
       * If stroke ignore scale
       * @type {Boolean}
       */
      strokeNoScale: false,
      // Bounding rect text configuration
      // Not affected by element transform

      /**
       * @type {string}
       */
      text: null,

      /**
       * If `fontSize` or `fontFamily` exists, `font` will be reset by
       * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
       * So do not visit it directly in upper application (like echarts),
       * but use `contain/text#makeFont` instead.
       * @type {string}
       */
      font: null,

      /**
       * The same as font. Use font please.
       * @deprecated
       * @type {string}
       */
      textFont: null,

      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * @type {string}
       */
      fontStyle: null,

      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * @type {string}
       */
      fontWeight: null,

      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * Should be 12 but not '12px'.
       * @type {number}
       */
      fontSize: null,

      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * @type {string}
       */
      fontFamily: null,

      /**
       * Reserved for special functinality, like 'hr'.
       * @type {string}
       */
      textTag: null,

      /**
       * @type {string}
       */
      textFill: '#000',

      /**
       * @type {string}
       */
      textStroke: null,

      /**
       * @type {number}
       */
      textWidth: null,

      /**
       * Only for textBackground.
       * @type {number}
       */
      textHeight: null,

      /**
       * textStroke may be set as some color as a default
       * value in upper applicaion, where the default value
       * of textStrokeWidth should be 0 to make sure that
       * user can choose to do not use text stroke.
       * @type {number}
       */
      textStrokeWidth: 0,

      /**
       * @type {number}
       */
      textLineHeight: null,

      /**
       * 'inside', 'left', 'right', 'top', 'bottom'
       * [x, y]
       * Based on x, y of rect.
       * @type {string|Array.<number>}
       * @default 'inside'
       */
      textPosition: 'inside',

      /**
       * If not specified, use the boundingRect of a `displayable`.
       * @type {Object}
       */
      textRect: null,

      /**
       * [x, y]
       * @type {Array.<number>}
       */
      textOffset: null,

      /**
       * @type {string}
       */
      textAlign: null,

      /**
       * @type {string}
       */
      textVerticalAlign: null,

      /**
       * @type {number}
       */
      textDistance: 5,

      /**
       * @type {string}
       */
      textShadowColor: 'transparent',

      /**
       * @type {number}
       */
      textShadowBlur: 0,

      /**
       * @type {number}
       */
      textShadowOffsetX: 0,

      /**
       * @type {number}
       */
      textShadowOffsetY: 0,

      /**
       * @type {string}
       */
      textBoxShadowColor: 'transparent',

      /**
       * @type {number}
       */
      textBoxShadowBlur: 0,

      /**
       * @type {number}
       */
      textBoxShadowOffsetX: 0,

      /**
       * @type {number}
       */
      textBoxShadowOffsetY: 0,

      /**
       * Whether transform text.
       * Only available in Path and Image element,
       * where the text is called as `RectText`.
       * @type {boolean}
       */
      transformText: false,

      /**
       * Text rotate around position of Path or Image.
       * The origin of the rotation can be specified by `textOrigin`.
       * Only available in Path and Image element,
       * where the text is called as `RectText`.
       */
      textRotation: 0,

      /**
       * Text origin of text rotation.
       * Useful in the case like label rotation of circular symbol.
       * Only available in Path and Image element, where the text is called
       * as `RectText` and the element is called as "host element".
       * The value can be:
       * + If specified as a coordinate like `[10, 40]`, it is the `[x, y]`
       * base on the left-top corner of the rect of its host element.
       * + If specified as a string `center`, it is the center of the rect of
       * its host element.
       * + By default, this origin is the `textPosition`.
       * @type {string|Array.<number>}
       */
      textOrigin: null,

      /**
       * @type {string}
       */
      textBackgroundColor: null,

      /**
       * @type {string}
       */
      textBorderColor: null,

      /**
       * @type {number}
       */
      textBorderWidth: 0,

      /**
       * @type {number}
       */
      textBorderRadius: 0,

      /**
       * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
       * @type {number|Array.<number>}
       */
      textPadding: null,

      /**
       * Text styles for rich text.
       * @type {Object}
       */
      rich: null,

      /**
       * {outerWidth, outerHeight, ellipsis, placeholder}
       * @type {Object}
       */
      truncate: null,

      /**
       * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
       * @type {string}
       */
      blend: null,

      /**
       * @param {CanvasRenderingContext2D} ctx
       */
      bind: function (ctx, el, prevEl) {
        var style = this;
        var prevStyle = prevEl && prevEl.style; // If no prevStyle, it means first draw.
        // Only apply cache if the last time cachced by this function.

        var notCheckCache = !prevStyle || ctx.__attrCachedBy !== ContextCachedBy$1.STYLE_BIND;
        ctx.__attrCachedBy = ContextCachedBy$1.STYLE_BIND;

        for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
          var prop = STYLE_COMMON_PROPS[i];
          var styleName = prop[0];

          if (notCheckCache || style[styleName] !== prevStyle[styleName]) {
            // FIXME Invalid property value will cause style leak from previous element.
            ctx[styleName] = fixShadow(ctx, styleName, style[styleName] || prop[1]);
          }
        }

        if (notCheckCache || style.fill !== prevStyle.fill) {
          ctx.fillStyle = style.fill;
        }

        if (notCheckCache || style.stroke !== prevStyle.stroke) {
          ctx.strokeStyle = style.stroke;
        }

        if (notCheckCache || style.opacity !== prevStyle.opacity) {
          ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
        }

        if (notCheckCache || style.blend !== prevStyle.blend) {
          ctx.globalCompositeOperation = style.blend || 'source-over';
        }

        if (this.hasStroke()) {
          var lineWidth = style.lineWidth;
          ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
        }
      },
      hasFill: function () {
        var fill = this.fill;
        return fill != null && fill !== 'none';
      },
      hasStroke: function () {
        var stroke = this.stroke;
        return stroke != null && stroke !== 'none' && this.lineWidth > 0;
      },

      /**
       * Extend from other style
       * @param {zrender/graphic/Style} otherStyle
       * @param {boolean} overwrite true: overwrirte any way.
       *                            false: overwrite only when !target.hasOwnProperty
       *                            others: overwrite when property is not null/undefined.
       */
      extendFrom: function (otherStyle, overwrite) {
        if (otherStyle) {
          for (var name in otherStyle) {
            if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
              this[name] = otherStyle[name];
            }
          }
        }
      },

      /**
       * Batch setting style with a given object
       * @param {Object|string} obj
       * @param {*} [obj]
       */
      set: function (obj, value) {
        if (typeof obj === 'string') {
          this[obj] = value;
        } else {
          this.extendFrom(obj, true);
        }
      },

      /**
       * Clone
       * @return {zrender/graphic/Style} [description]
       */
      clone: function () {
        var newStyle = new this.constructor();
        newStyle.extendFrom(this, true);
        return newStyle;
      },
      getGradient: function (ctx, obj, rect) {
        var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
        var canvasGradient = method(ctx, obj, rect);
        var colorStops = obj.colorStops;

        for (var i = 0; i < colorStops.length; i++) {
          canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
        }

        return canvasGradient;
      }
    };
    var styleProto = Style.prototype;

    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
      var prop = STYLE_COMMON_PROPS[i];

      if (!(prop[0] in styleProto)) {
        styleProto[prop[0]] = prop[1];
      }
    } // Provide for others


    Style.getGradient = styleProto.getGradient;
    var _default$j = Style;
    var Style_1 = _default$j;

    var Pattern = function (image, repeat) {
      // Should do nothing more in this constructor. Because gradient can be
      // declard by `color: {image: ...}`, where this constructor will not be called.
      this.image = image;
      this.repeat = repeat; // Can be cloned

      this.type = 'pattern';
    };

    Pattern.prototype.getCanvasPattern = function (ctx) {
      return ctx.createPattern(this.image, this.repeat || 'repeat');
    };

    var _default$k = Pattern;
    var Pattern_1 = _default$k;

    var devicePixelRatio$1 = config.devicePixelRatio;





    /**
     * @module zrender/Layer
     * @author pissang(https://www.github.com/pissang)
     */
    function returnFalse() {
      return false;
    }
    /**
     * 创建dom
     *
     * @inner
     * @param {string} id dom id 待用
     * @param {Painter} painter painter instance
     * @param {number} number
     */


    function createDom(id, painter, dpr) {
      var newDom = util.createCanvas();
      var width = painter.getWidth();
      var height = painter.getHeight();
      var newDomStyle = newDom.style;

      if (newDomStyle) {
        // In node or some other non-browser environment
        newDomStyle.position = 'absolute';
        newDomStyle.left = 0;
        newDomStyle.top = 0;
        newDomStyle.width = width + 'px';
        newDomStyle.height = height + 'px';
        newDom.setAttribute('data-zr-dom-id', id);
      }

      newDom.width = width * dpr;
      newDom.height = height * dpr;
      return newDom;
    }
    /**
     * @alias module:zrender/Layer
     * @constructor
     * @extends module:zrender/mixin/Transformable
     * @param {string} id
     * @param {module:zrender/Painter} painter
     * @param {number} [dpr]
     */


    var Layer = function (id, painter, dpr) {
      var dom;
      dpr = dpr || devicePixelRatio$1;

      if (typeof id === 'string') {
        dom = createDom(id, painter, dpr);
      } // Not using isDom because in node it will return false
      else if (util.isObject(id)) {
          dom = id;
          id = dom.id;
        }

      this.id = id;
      this.dom = dom;
      var domStyle = dom.style;

      if (domStyle) {
        // Not in node
        dom.onselectstart = returnFalse; // 避免页面选中的尴尬

        domStyle['-webkit-user-select'] = 'none';
        domStyle['user-select'] = 'none';
        domStyle['-webkit-touch-callout'] = 'none';
        domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
        domStyle['padding'] = 0; // eslint-disable-line dot-notation

        domStyle['margin'] = 0; // eslint-disable-line dot-notation

        domStyle['border-width'] = 0;
      }

      this.domBack = null;
      this.ctxBack = null;
      this.painter = painter;
      this.config = null; // Configs

      /**
       * 每次清空画布的颜色
       * @type {string}
       * @default 0
       */

      this.clearColor = 0;
      /**
       * 是否开启动态模糊
       * @type {boolean}
       * @default false
       */

      this.motionBlur = false;
      /**
       * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
       * @type {number}
       * @default 0.7
       */

      this.lastFrameAlpha = 0.7;
      /**
       * Layer dpr
       * @type {number}
       */

      this.dpr = dpr;
    };

    Layer.prototype = {
      constructor: Layer,
      __dirty: true,
      __used: false,
      __drawIndex: 0,
      __startIndex: 0,
      __endIndex: 0,
      incremental: false,
      getElementCount: function () {
        return this.__endIndex - this.__startIndex;
      },
      initContext: function () {
        this.ctx = this.dom.getContext('2d');
        this.ctx.dpr = this.dpr;
      },
      createBackBuffer: function () {
        var dpr = this.dpr;
        this.domBack = createDom('back-' + this.id, this.painter, dpr);
        this.ctxBack = this.domBack.getContext('2d');

        if (dpr !== 1) {
          this.ctxBack.scale(dpr, dpr);
        }
      },

      /**
       * @param  {number} width
       * @param  {number} height
       */
      resize: function (width, height) {
        var dpr = this.dpr;
        var dom = this.dom;
        var domStyle = dom.style;
        var domBack = this.domBack;

        if (domStyle) {
          domStyle.width = width + 'px';
          domStyle.height = height + 'px';
        }

        dom.width = width * dpr;
        dom.height = height * dpr;

        if (domBack) {
          domBack.width = width * dpr;
          domBack.height = height * dpr;

          if (dpr !== 1) {
            this.ctxBack.scale(dpr, dpr);
          }
        }
      },

      /**
       * 清空该层画布
       * @param {boolean} [clearAll]=false Clear all with out motion blur
       * @param {Color} [clearColor]
       */
      clear: function (clearAll, clearColor) {
        var dom = this.dom;
        var ctx = this.ctx;
        var width = dom.width;
        var height = dom.height;
        var clearColor = clearColor || this.clearColor;
        var haveMotionBLur = this.motionBlur && !clearAll;
        var lastFrameAlpha = this.lastFrameAlpha;
        var dpr = this.dpr;

        if (haveMotionBLur) {
          if (!this.domBack) {
            this.createBackBuffer();
          }

          this.ctxBack.globalCompositeOperation = 'copy';
          this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
        }

        ctx.clearRect(0, 0, width, height);

        if (clearColor && clearColor !== 'transparent') {
          var clearColorGradientOrPattern; // Gradient

          if (clearColor.colorStops) {
            // Cache canvas gradient
            clearColorGradientOrPattern = clearColor.__canvasGradient || Style_1.getGradient(ctx, clearColor, {
              x: 0,
              y: 0,
              width: width,
              height: height
            });
            clearColor.__canvasGradient = clearColorGradientOrPattern;
          } // Pattern
          else if (clearColor.image) {
              clearColorGradientOrPattern = Pattern_1.prototype.getCanvasPattern.call(clearColor, ctx);
            }

          ctx.save();
          ctx.fillStyle = clearColorGradientOrPattern || clearColor;
          ctx.fillRect(0, 0, width, height);
          ctx.restore();
        }

        if (haveMotionBLur) {
          var domBack = this.domBack;
          ctx.save();
          ctx.globalAlpha = lastFrameAlpha;
          ctx.drawImage(domBack, 0, 0, width, height);
          ctx.restore();
        }
      }
    };
    var _default$l = Layer;
    var Layer_1 = _default$l;

    var _default$m = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
    window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
      setTimeout(func, 16);
    };

    var requestAnimationFrame$1 = _default$m;

    var globalImageCache = new LRU_1(50);
    /**
     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
     */

    function findExistImage(newImageOrSrc) {
      if (typeof newImageOrSrc === 'string') {
        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        return cachedImgObj && cachedImgObj.image;
      } else {
        return newImageOrSrc;
      }
    }
    /**
     * Caution: User should cache loaded images, but not just count on LRU.
     * Consider if required images more than LRU size, will dead loop occur?
     *
     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
     * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
     * @param {module:zrender/Element} [hostEl] For calling `dirty`.
     * @param {Function} [cb] params: (image, cbPayload)
     * @param {Object} [cbPayload] Payload on cb calling.
     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
     */


    function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
      if (!newImageOrSrc) {
        return image;
      } else if (typeof newImageOrSrc === 'string') {
        // Image should not be loaded repeatly.
        if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
          return image;
        } // Only when there is no existent image or existent image src
        // is different, this method is responsible for load.


        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        var pendingWrap = {
          hostEl: hostEl,
          cb: cb,
          cbPayload: cbPayload
        };

        if (cachedImgObj) {
          image = cachedImgObj.image;
          !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
        } else {
          image = new Image();
          image.onload = image.onerror = imageOnLoad;
          globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
            image: image,
            pending: [pendingWrap]
          });
          image.src = image.__zrImageSrc = newImageOrSrc;
        }

        return image;
      } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
      else {
          return newImageOrSrc;
        }
    }

    function imageOnLoad() {
      var cachedImgObj = this.__cachedImgObj;
      this.onload = this.onerror = this.__cachedImgObj = null;

      for (var i = 0; i < cachedImgObj.pending.length; i++) {
        var pendingWrap = cachedImgObj.pending[i];
        var cb = pendingWrap.cb;
        cb && cb(this, pendingWrap.cbPayload);
        pendingWrap.hostEl.dirty();
      }

      cachedImgObj.pending.length = 0;
    }

    function isImageReady(image) {
      return image && image.width && image.height;
    }

    var findExistImage_1 = findExistImage;
    var createOrUpdateImage_1 = createOrUpdateImage;
    var isImageReady_1 = isImageReady;

    var image = {
    	findExistImage: findExistImage_1,
    	createOrUpdateImage: createOrUpdateImage_1,
    	isImageReady: isImageReady_1
    };

    var getContext$2 = util.getContext;
    var extend$2 = util.extend;
    var retrieve2$1 = util.retrieve2;
    var retrieve3$1 = util.retrieve3;
    var trim$2 = util.trim;
    var textWidthCache = {};
    var textWidthCacheCounter = 0;
    var TEXT_CACHE_MAX = 5000;
    var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
    var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.

    var methods$1 = {};

    function $override$1(name, fn) {
      methods$1[name] = fn;
    }
    /**
     * @public
     * @param {string} text
     * @param {string} font
     * @return {number} width
     */


    function getWidth(text, font) {
      font = font || DEFAULT_FONT;
      var key = text + ':' + font;

      if (textWidthCache[key]) {
        return textWidthCache[key];
      }

      var textLines = (text + '').split('\n');
      var width = 0;

      for (var i = 0, l = textLines.length; i < l; i++) {
        // textContain.measureText may be overrided in SVG or VML
        width = Math.max(measureText(textLines[i], font).width, width);
      }

      if (textWidthCacheCounter > TEXT_CACHE_MAX) {
        textWidthCacheCounter = 0;
        textWidthCache = {};
      }

      textWidthCacheCounter++;
      textWidthCache[key] = width;
      return width;
    }
    /**
     * @public
     * @param {string} text
     * @param {string} font
     * @param {string} [textAlign='left']
     * @param {string} [textVerticalAlign='top']
     * @param {Array.<number>} [textPadding]
     * @param {Object} [rich]
     * @param {Object} [truncate]
     * @return {Object} {x, y, width, height, lineHeight}
     */


    function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
      return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);
    }

    function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {
      var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);
      var outerWidth = getWidth(text, font);

      if (textPadding) {
        outerWidth += textPadding[1] + textPadding[3];
      }

      var outerHeight = contentBlock.outerHeight;
      var x = adjustTextX(0, outerWidth, textAlign);
      var y = adjustTextY(0, outerHeight, textVerticalAlign);
      var rect = new BoundingRect_1(x, y, outerWidth, outerHeight);
      rect.lineHeight = contentBlock.lineHeight;
      return rect;
    }

    function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
      var contentBlock = parseRichText(text, {
        rich: rich,
        truncate: truncate,
        font: font,
        textAlign: textAlign,
        textPadding: textPadding,
        textLineHeight: textLineHeight
      });
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var x = adjustTextX(0, outerWidth, textAlign);
      var y = adjustTextY(0, outerHeight, textVerticalAlign);
      return new BoundingRect_1(x, y, outerWidth, outerHeight);
    }
    /**
     * @public
     * @param {number} x
     * @param {number} width
     * @param {string} [textAlign='left']
     * @return {number} Adjusted x.
     */


    function adjustTextX(x, width, textAlign) {
      // FIXME Right to left language
      if (textAlign === 'right') {
        x -= width;
      } else if (textAlign === 'center') {
        x -= width / 2;
      }

      return x;
    }
    /**
     * @public
     * @param {number} y
     * @param {number} height
     * @param {string} [textVerticalAlign='top']
     * @return {number} Adjusted y.
     */


    function adjustTextY(y, height, textVerticalAlign) {
      if (textVerticalAlign === 'middle') {
        y -= height / 2;
      } else if (textVerticalAlign === 'bottom') {
        y -= height;
      }

      return y;
    }
    /**
     * Follow same interface to `Displayable.prototype.calculateTextPosition`.
     * @public
     * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.
     * @param {module:zrender/graphic/Style} style where `textPosition` and `textDistance` are visited.
     * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.
     * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}
     */


    function calculateTextPosition(out, style, rect) {
      var textPosition = style.textPosition;
      var distance = style.textDistance;
      var x = rect.x;
      var y = rect.y;
      distance = distance || 0;
      var height = rect.height;
      var width = rect.width;
      var halfHeight = height / 2;
      var textAlign = 'left';
      var textVerticalAlign = 'top';

      switch (textPosition) {
        case 'left':
          x -= distance;
          y += halfHeight;
          textAlign = 'right';
          textVerticalAlign = 'middle';
          break;

        case 'right':
          x += distance + width;
          y += halfHeight;
          textVerticalAlign = 'middle';
          break;

        case 'top':
          x += width / 2;
          y -= distance;
          textAlign = 'center';
          textVerticalAlign = 'bottom';
          break;

        case 'bottom':
          x += width / 2;
          y += height + distance;
          textAlign = 'center';
          break;

        case 'inside':
          x += width / 2;
          y += halfHeight;
          textAlign = 'center';
          textVerticalAlign = 'middle';
          break;

        case 'insideLeft':
          x += distance;
          y += halfHeight;
          textVerticalAlign = 'middle';
          break;

        case 'insideRight':
          x += width - distance;
          y += halfHeight;
          textAlign = 'right';
          textVerticalAlign = 'middle';
          break;

        case 'insideTop':
          x += width / 2;
          y += distance;
          textAlign = 'center';
          break;

        case 'insideBottom':
          x += width / 2;
          y += height - distance;
          textAlign = 'center';
          textVerticalAlign = 'bottom';
          break;

        case 'insideTopLeft':
          x += distance;
          y += distance;
          break;

        case 'insideTopRight':
          x += width - distance;
          y += distance;
          textAlign = 'right';
          break;

        case 'insideBottomLeft':
          x += distance;
          y += height - distance;
          textVerticalAlign = 'bottom';
          break;

        case 'insideBottomRight':
          x += width - distance;
          y += height - distance;
          textAlign = 'right';
          textVerticalAlign = 'bottom';
          break;
      }

      out = out || {};
      out.x = x;
      out.y = y;
      out.textAlign = textAlign;
      out.textVerticalAlign = textVerticalAlign;
      return out;
    }
    /**
     * To be removed. But still do not remove in case that some one has imported it.
     * @deprecated
     * @public
     * @param {stirng} textPosition
     * @param {Object} rect {x, y, width, height}
     * @param {number} distance
     * @return {Object} {x, y, textAlign, textVerticalAlign}
     */


    function adjustTextPositionOnRect(textPosition, rect, distance) {
      var dummyStyle = {
        textPosition: textPosition,
        textDistance: distance
      };
      return calculateTextPosition({}, dummyStyle, rect);
    }
    /**
     * Show ellipsis if overflow.
     *
     * @public
     * @param  {string} text
     * @param  {string} containerWidth
     * @param  {string} font
     * @param  {number} [ellipsis='...']
     * @param  {Object} [options]
     * @param  {number} [options.maxIterations=3]
     * @param  {number} [options.minChar=0] If truncate result are less
     *                  then minChar, ellipsis will not show, which is
     *                  better for user hint in some cases.
     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
     * @return {string}
     */


    function truncateText(text, containerWidth, font, ellipsis, options) {
      if (!containerWidth) {
        return '';
      }

      var textLines = (text + '').split('\n');
      options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
      // It is not appropriate that every line has '...' when truncate multiple lines.

      for (var i = 0, len = textLines.length; i < len; i++) {
        textLines[i] = truncateSingleLine(textLines[i], options);
      }

      return textLines.join('\n');
    }

    function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
      options = extend$2({}, options);
      options.font = font;
      var ellipsis = retrieve2$1(ellipsis, '...');
      options.maxIterations = retrieve2$1(options.maxIterations, 2);
      var minChar = options.minChar = retrieve2$1(options.minChar, 0); // FIXME
      // Other languages?

      options.cnCharWidth = getWidth('国', font); // FIXME
      // Consider proportional font?

      var ascCharWidth = options.ascCharWidth = getWidth('a', font);
      options.placeholder = retrieve2$1(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
      // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.

      var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.

      for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
        contentWidth -= ascCharWidth;
      }

      var ellipsisWidth = getWidth(ellipsis, font);

      if (ellipsisWidth > contentWidth) {
        ellipsis = '';
        ellipsisWidth = 0;
      }

      contentWidth = containerWidth - ellipsisWidth;
      options.ellipsis = ellipsis;
      options.ellipsisWidth = ellipsisWidth;
      options.contentWidth = contentWidth;
      options.containerWidth = containerWidth;
      return options;
    }

    function truncateSingleLine(textLine, options) {
      var containerWidth = options.containerWidth;
      var font = options.font;
      var contentWidth = options.contentWidth;

      if (!containerWidth) {
        return '';
      }

      var lineWidth = getWidth(textLine, font);

      if (lineWidth <= containerWidth) {
        return textLine;
      }

      for (var j = 0;; j++) {
        if (lineWidth <= contentWidth || j >= options.maxIterations) {
          textLine += options.ellipsis;
          break;
        }

        var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
        textLine = textLine.substr(0, subLength);
        lineWidth = getWidth(textLine, font);
      }

      if (textLine === '') {
        textLine = options.placeholder;
      }

      return textLine;
    }

    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
      var width = 0;
      var i = 0;

      for (var len = text.length; i < len && width < contentWidth; i++) {
        var charCode = text.charCodeAt(i);
        width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
      }

      return i;
    }
    /**
     * @public
     * @param {string} font
     * @return {number} line height
     */


    function getLineHeight(font) {
      // FIXME A rough approach.
      return getWidth('国', font);
    }
    /**
     * @public
     * @param {string} text
     * @param {string} font
     * @return {Object} width
     */


    function measureText(text, font) {
      return methods$1.measureText(text, font);
    } // Avoid assign to an exported variable, for transforming to cjs.


    methods$1.measureText = function (text, font) {
      var ctx = getContext$2();
      ctx.font = font || DEFAULT_FONT;
      return ctx.measureText(text);
    };
    /**
     * @public
     * @param {string} text
     * @param {string} font
     * @param {Object} [truncate]
     * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}
     *  Notice: for performance, do not calculate outerWidth util needed.
     *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.
     *  Thus we can simply comparing the `input` text to determin whether the result changed,
     *  without travel the result `lines`.
     */


    function parsePlainText(text, font, padding, textLineHeight, truncate) {
      text != null && (text += '');
      var lineHeight = retrieve2$1(textLineHeight, getLineHeight(font));
      var lines = text ? text.split('\n') : [];
      var height = lines.length * lineHeight;
      var outerHeight = height;
      var canCacheByTextString = true;

      if (padding) {
        outerHeight += padding[0] + padding[2];
      }

      if (text && truncate) {
        canCacheByTextString = false;
        var truncOuterHeight = truncate.outerHeight;
        var truncOuterWidth = truncate.outerWidth;

        if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
          text = '';
          lines = [];
        } else if (truncOuterWidth != null) {
          var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
            minChar: truncate.minChar,
            placeholder: truncate.placeholder
          }); // FIXME
          // It is not appropriate that every line has '...' when truncate multiple lines.

          for (var i = 0, len = lines.length; i < len; i++) {
            lines[i] = truncateSingleLine(lines[i], options);
          }
        }
      }

      return {
        lines: lines,
        height: height,
        outerHeight: outerHeight,
        lineHeight: lineHeight,
        canCacheByTextString: canCacheByTextString
      };
    }
    /**
     * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
     * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
     *
     * @public
     * @param {string} text
     * @param {Object} style
     * @return {Object} block
     * {
     *      width,
     *      height,
     *      lines: [{
     *          lineHeight,
     *          width,
     *          tokens: [[{
     *              styleName,
     *              text,
     *              width,      // include textPadding
     *              height,     // include textPadding
     *              textWidth, // pure text width
     *              textHeight, // pure text height
     *              lineHeihgt,
     *              font,
     *              textAlign,
     *              textVerticalAlign
     *          }], [...], ...]
     *      }, ...]
     * }
     * If styleName is undefined, it is plain text.
     */


    function parseRichText(text, style) {
      var contentBlock = {
        lines: [],
        width: 0,
        height: 0
      };
      text != null && (text += '');

      if (!text) {
        return contentBlock;
      }

      var lastIndex = STYLE_REG.lastIndex = 0;
      var result;

      while ((result = STYLE_REG.exec(text)) != null) {
        var matchedIndex = result.index;

        if (matchedIndex > lastIndex) {
          pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
        }

        pushTokens(contentBlock, result[2], result[1]);
        lastIndex = STYLE_REG.lastIndex;
      }

      if (lastIndex < text.length) {
        pushTokens(contentBlock, text.substring(lastIndex, text.length));
      }

      var lines = contentBlock.lines;
      var contentHeight = 0;
      var contentWidth = 0; // For `textWidth: 100%`

      var pendingList = [];
      var stlPadding = style.textPadding;
      var truncate = style.truncate;
      var truncateWidth = truncate && truncate.outerWidth;
      var truncateHeight = truncate && truncate.outerHeight;

      if (stlPadding) {
        truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
        truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
      } // Calculate layout info of tokens.


      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var lineHeight = 0;
        var lineWidth = 0;

        for (var j = 0; j < line.tokens.length; j++) {
          var token = line.tokens[j];
          var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.

          var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.

          var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.

          var tokenHeight = token.textHeight = retrieve2$1( // textHeight should not be inherited, consider it can be specified
          // as box height of the block.
          tokenStyle.textHeight, getLineHeight(font));
          textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
          token.height = tokenHeight;
          token.lineHeight = retrieve3$1(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
          token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
          token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';

          if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
            return {
              lines: [],
              width: 0,
              height: 0
            };
          }

          token.textWidth = getWidth(token.text, font);
          var tokenWidth = tokenStyle.textWidth;
          var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
          // line when box width is needed to be auto.

          if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
            token.percentWidth = tokenWidth;
            pendingList.push(token);
            tokenWidth = 0; // Do not truncate in this case, because there is no user case
            // and it is too complicated.
          } else {
            if (tokenWidthNotSpecified) {
              tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
              // `getBoundingRect()` will not get correct result.

              var textBackgroundColor = tokenStyle.textBackgroundColor;
              var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
              // (1) If image is not loaded, it will be loaded at render phase and call
              // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
              // image, and then the right size will be calculated here at the next tick.
              // See `graphic/helper/text.js`.
              // (2) If image loaded, and `textBackgroundColor.image` is image src string,
              // use `imageHelper.findExistImage` to find cached image.
              // `imageHelper.findExistImage` will always be called here before
              // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
              // which ensures that image will not be rendered before correct size calcualted.

              if (bgImg) {
                bgImg = image.findExistImage(bgImg);

                if (image.isImageReady(bgImg)) {
                  tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
                }
              }
            }

            var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
            tokenWidth += paddingW;
            var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;

            if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
              if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
                token.text = '';
                token.textWidth = tokenWidth = 0;
              } else {
                token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
                  minChar: truncate.minChar
                });
                token.textWidth = getWidth(token.text, font);
                tokenWidth = token.textWidth + paddingW;
              }
            }
          }

          lineWidth += token.width = tokenWidth;
          tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
        }

        line.width = lineWidth;
        line.lineHeight = lineHeight;
        contentHeight += lineHeight;
        contentWidth = Math.max(contentWidth, lineWidth);
      }

      contentBlock.outerWidth = contentBlock.width = retrieve2$1(style.textWidth, contentWidth);
      contentBlock.outerHeight = contentBlock.height = retrieve2$1(style.textHeight, contentHeight);

      if (stlPadding) {
        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
      }

      for (var i = 0; i < pendingList.length; i++) {
        var token = pendingList[i];
        var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.

        token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
      }

      return contentBlock;
    }

    function pushTokens(block, str, styleName) {
      var isEmptyStr = str === '';
      var strs = str.split('\n');
      var lines = block.lines;

      for (var i = 0; i < strs.length; i++) {
        var text = strs[i];
        var token = {
          styleName: styleName,
          text: text,
          isLineHolder: !text && !isEmptyStr
        }; // The first token should be appended to the last line.

        if (!i) {
          var tokens = (lines[lines.length - 1] || (lines[0] = {
            tokens: []
          })).tokens; // Consider cases:
          // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
          // (which is a placeholder) should be replaced by new token.
          // (2) A image backage, where token likes {a|}.
          // (3) A redundant '' will affect textAlign in line.
          // (4) tokens with the same tplName should not be merged, because
          // they should be displayed in different box (with border and padding).

          var tokensLen = tokens.length;
          tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
          // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
          (text || !tokensLen || isEmptyStr) && tokens.push(token);
        } // Other tokens always start a new line.
        else {
            // If there is '', insert it as a placeholder.
            lines.push({
              tokens: [token]
            });
          }
      }
    }

    function makeFont(style) {
      // FIXME in node-canvas fontWeight is before fontStyle
      // Use `fontSize` `fontFamily` to check whether font properties are defined.
      var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
      style.fontFamily || 'sans-serif'].join(' ');
      return font && trim$2(font) || style.textFont || style.font;
    }

    var DEFAULT_FONT_1 = DEFAULT_FONT;
    var $override_1$1 = $override$1;
    var getWidth_1 = getWidth;
    var getBoundingRect_1 = getBoundingRect;
    var adjustTextX_1 = adjustTextX;
    var adjustTextY_1 = adjustTextY;
    var calculateTextPosition_1 = calculateTextPosition;
    var adjustTextPositionOnRect_1 = adjustTextPositionOnRect;
    var truncateText_1 = truncateText;
    var getLineHeight_1 = getLineHeight;
    var measureText_1 = measureText;
    var parsePlainText_1 = parsePlainText;
    var parseRichText_1 = parseRichText;
    var makeFont_1 = makeFont;

    var text$1 = {
    	DEFAULT_FONT: DEFAULT_FONT_1,
    	$override: $override_1$1,
    	getWidth: getWidth_1,
    	getBoundingRect: getBoundingRect_1,
    	adjustTextX: adjustTextX_1,
    	adjustTextY: adjustTextY_1,
    	calculateTextPosition: calculateTextPosition_1,
    	adjustTextPositionOnRect: adjustTextPositionOnRect_1,
    	truncateText: truncateText_1,
    	getLineHeight: getLineHeight_1,
    	measureText: measureText_1,
    	parsePlainText: parsePlainText_1,
    	parseRichText: parseRichText_1,
    	makeFont: makeFont_1
    };

    /**
     * @param {Object} ctx
     * @param {Object} shape
     * @param {number} shape.x
     * @param {number} shape.y
     * @param {number} shape.width
     * @param {number} shape.height
     * @param {number} shape.r
     */
    function buildPath(ctx, shape) {
      var x = shape.x;
      var y = shape.y;
      var width = shape.width;
      var height = shape.height;
      var r = shape.r;
      var r1;
      var r2;
      var r3;
      var r4; // Convert width and height to positive for better borderRadius

      if (width < 0) {
        x = x + width;
        width = -width;
      }

      if (height < 0) {
        y = y + height;
        height = -height;
      }

      if (typeof r === 'number') {
        r1 = r2 = r3 = r4 = r;
      } else if (r instanceof Array) {
        if (r.length === 1) {
          r1 = r2 = r3 = r4 = r[0];
        } else if (r.length === 2) {
          r1 = r3 = r[0];
          r2 = r4 = r[1];
        } else if (r.length === 3) {
          r1 = r[0];
          r2 = r4 = r[1];
          r3 = r[2];
        } else {
          r1 = r[0];
          r2 = r[1];
          r3 = r[2];
          r4 = r[3];
        }
      } else {
        r1 = r2 = r3 = r4 = 0;
      }

      var total;

      if (r1 + r2 > width) {
        total = r1 + r2;
        r1 *= width / total;
        r2 *= width / total;
      }

      if (r3 + r4 > width) {
        total = r3 + r4;
        r3 *= width / total;
        r4 *= width / total;
      }

      if (r2 + r3 > height) {
        total = r2 + r3;
        r2 *= height / total;
        r3 *= height / total;
      }

      if (r1 + r4 > height) {
        total = r1 + r4;
        r1 *= height / total;
        r4 *= height / total;
      }

      ctx.moveTo(x + r1, y);
      ctx.lineTo(x + width - r2, y);
      r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
      ctx.lineTo(x + width, y + height - r3);
      r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
      ctx.lineTo(x + r4, y + height);
      r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
      ctx.lineTo(x, y + r1);
      r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
    }

    var buildPath_1 = buildPath;

    var roundRect = {
    	buildPath: buildPath_1
    };

    var retrieve2$2 = util.retrieve2;
    var retrieve3$2 = util.retrieve3;
    var each$1 = util.each;
    var normalizeCssArray$1 = util.normalizeCssArray;
    var isString$3 = util.isString;
    var isObject$3 = util.isObject;











    var ContextCachedBy$2 = constant.ContextCachedBy;
    var WILL_BE_RESTORED$1 = constant.WILL_BE_RESTORED;
    var DEFAULT_FONT$1 = text$1.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.

    var VALID_TEXT_ALIGN = {
      left: 1,
      right: 1,
      center: 1
    };
    var VALID_TEXT_VERTICAL_ALIGN = {
      top: 1,
      bottom: 1,
      middle: 1
    }; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,
    // the default value of shadowColor is `'transparent'`.

    var SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];
    var _tmpTextPositionResult = {};
    var _tmpBoxPositionResult = {};
    /**
     * @param {module:zrender/graphic/Style} style
     * @return {module:zrender/graphic/Style} The input style.
     */

    function normalizeTextStyle(style) {
      normalizeStyle(style);
      each$1(style.rich, normalizeStyle);
      return style;
    }

    function normalizeStyle(style) {
      if (style) {
        style.font = text$1.makeFont(style);
        var textAlign = style.textAlign;
        textAlign === 'middle' && (textAlign = 'center');
        style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.

        var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
        textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
        style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
        var textPadding = style.textPadding;

        if (textPadding) {
          style.textPadding = normalizeCssArray$1(style.textPadding);
        }
      }
    }
    /**
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} text
     * @param {module:zrender/graphic/Style} style
     * @param {Object|boolean} [rect] {x, y, width, height}
     *                  If set false, rect text is not used.
     * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.
     */


    function renderText(hostEl, ctx, text, style, rect, prevEl) {
      style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);
    } // Avoid setting to ctx according to prevEl if possible for
    // performance in scenarios of large amount text.


    function renderPlainText(hostEl, ctx, text, style, rect, prevEl) {

      var needDrawBg = needDrawBackground(style);
      var prevStyle;
      var checkCache = false;
      var cachedByMe = ctx.__attrCachedBy === ContextCachedBy$2.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.

      if (prevEl !== WILL_BE_RESTORED$1) {
        if (prevEl) {
          prevStyle = prevEl.style;
          checkCache = !needDrawBg && cachedByMe && prevStyle;
        } // Prevent from using cache in `Style::bind`, because of the case:
        // ctx property is modified by other properties than `Style::bind`
        // used, and Style::bind is called next.


        ctx.__attrCachedBy = needDrawBg ? ContextCachedBy$2.NONE : ContextCachedBy$2.PLAIN_TEXT;
      } // Since this will be restored, prevent from using these props to check cache in the next
      // entering of this method. But do not need to clear other cache like `Style::bind`.
      else if (cachedByMe) {
          ctx.__attrCachedBy = ContextCachedBy$2.NONE;
        }

      var styleFont = style.font || DEFAULT_FONT$1; // PENDING
      // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically
      // we can make font cache on ctx, which can cache for text el that are discontinuous.
      // But layer save/restore needed to be considered.
      // if (styleFont !== ctx.__fontCache) {
      //     ctx.font = styleFont;
      //     if (prevEl !== WILL_BE_RESTORED) {
      //         ctx.__fontCache = styleFont;
      //     }
      // }

      if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT$1)) {
        ctx.font = styleFont;
      } // Use the final font from context-2d, because the final
      // font might not be the style.font when it is illegal.
      // But get `ctx.font` might be time consuming.


      var computedFont = hostEl.__computedFont;

      if (hostEl.__styleFont !== styleFont) {
        hostEl.__styleFont = styleFont;
        computedFont = hostEl.__computedFont = ctx.font;
      }

      var textPadding = style.textPadding;
      var textLineHeight = style.textLineHeight;
      var contentBlock = hostEl.__textCotentBlock;

      if (!contentBlock || hostEl.__dirtyText) {
        contentBlock = hostEl.__textCotentBlock = text$1.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);
      }

      var outerHeight = contentBlock.outerHeight;
      var textLines = contentBlock.lines;
      var lineHeight = contentBlock.lineHeight;
      var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
      var baseX = boxPos.baseX;
      var baseY = boxPos.baseY;
      var textAlign = boxPos.textAlign || 'left';
      var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

      applyTextRotation(ctx, style, rect, baseX, baseY);
      var boxY = text$1.adjustTextY(baseY, outerHeight, textVerticalAlign);
      var textX = baseX;
      var textY = boxY;

      if (needDrawBg || textPadding) {
        // Consider performance, do not call getTextWidth util necessary.
        var textWidth = text$1.getWidth(text, computedFont);
        var outerWidth = textWidth;
        textPadding && (outerWidth += textPadding[1] + textPadding[3]);
        var boxX = text$1.adjustTextX(baseX, outerWidth, textAlign);
        needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

        if (textPadding) {
          textX = getTextXForPadding(baseX, textAlign, textPadding);
          textY += textPadding[0];
        }
      } // Always set textAlign and textBase line, because it is difficute to calculate
      // textAlign from prevEl, and we dont sure whether textAlign will be reset if
      // font set happened.


      ctx.textAlign = textAlign; // Force baseline to be "middle". Otherwise, if using "top", the
      // text will offset downward a little bit in font "Microsoft YaHei".

      ctx.textBaseline = 'middle'; // Set text opacity

      ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.

      for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {
        var propItem = SHADOW_STYLE_COMMON_PROPS[i];
        var styleProp = propItem[0];
        var ctxProp = propItem[1];
        var val = style[styleProp];

        if (!checkCache || val !== prevStyle[styleProp]) {
          ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);
        }
      } // `textBaseline` is set as 'middle'.


      textY += lineHeight / 2;
      var textStrokeWidth = style.textStrokeWidth;
      var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;
      var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;
      var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;
      var textStroke = getStroke(style.textStroke, textStrokeWidth);
      var textFill = getFill(style.textFill);

      if (textStroke) {
        if (strokeWidthChanged) {
          ctx.lineWidth = textStrokeWidth;
        }

        if (strokeChanged) {
          ctx.strokeStyle = textStroke;
        }
      }

      if (textFill) {
        if (!checkCache || style.textFill !== prevStyle.textFill) {
          ctx.fillStyle = textFill;
        }
      } // Optimize simply, in most cases only one line exists.


      if (textLines.length === 1) {
        // Fill after stroke so the outline will not cover the main part.
        textStroke && ctx.strokeText(textLines[0], textX, textY);
        textFill && ctx.fillText(textLines[0], textX, textY);
      } else {
        for (var i = 0; i < textLines.length; i++) {
          // Fill after stroke so the outline will not cover the main part.
          textStroke && ctx.strokeText(textLines[i], textX, textY);
          textFill && ctx.fillText(textLines[i], textX, textY);
          textY += lineHeight;
        }
      }
    }

    function renderRichText(hostEl, ctx, text, style, rect, prevEl) {
      // Do not do cache for rich text because of the complexity.
      // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.
      if (prevEl !== WILL_BE_RESTORED$1) {
        ctx.__attrCachedBy = ContextCachedBy$2.NONE;
      }

      var contentBlock = hostEl.__textCotentBlock;

      if (!contentBlock || hostEl.__dirtyText) {
        contentBlock = hostEl.__textCotentBlock = text$1.parseRichText(text, style);
      }

      drawRichText(hostEl, ctx, contentBlock, style, rect);
    }

    function drawRichText(hostEl, ctx, contentBlock, style, rect) {
      var contentWidth = contentBlock.width;
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var textPadding = style.textPadding;
      var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
      var baseX = boxPos.baseX;
      var baseY = boxPos.baseY;
      var textAlign = boxPos.textAlign;
      var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

      applyTextRotation(ctx, style, rect, baseX, baseY);
      var boxX = text$1.adjustTextX(baseX, outerWidth, textAlign);
      var boxY = text$1.adjustTextY(baseY, outerHeight, textVerticalAlign);
      var xLeft = boxX;
      var lineTop = boxY;

      if (textPadding) {
        xLeft += textPadding[3];
        lineTop += textPadding[0];
      }

      var xRight = xLeft + contentWidth;
      needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

      for (var i = 0; i < contentBlock.lines.length; i++) {
        var line = contentBlock.lines[i];
        var tokens = line.tokens;
        var tokenCount = tokens.length;
        var lineHeight = line.lineHeight;
        var usedWidth = line.width;
        var leftIndex = 0;
        var lineXLeft = xLeft;
        var lineXRight = xRight;
        var rightIndex = tokenCount - 1;
        var token;

        while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
          usedWidth -= token.width;
          lineXLeft += token.width;
          leftIndex++;
        }

        while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
          usedWidth -= token.width;
          lineXRight -= token.width;
          rightIndex--;
        } // The other tokens are placed as textAlign 'center' if there is enough space.


        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;

        while (leftIndex <= rightIndex) {
          token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.

          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
          lineXLeft += token.width;
          leftIndex++;
        }

        lineTop += lineHeight;
      }
    }

    function applyTextRotation(ctx, style, rect, x, y) {
      // textRotation only apply in RectText.
      if (rect && style.textRotation) {
        var origin = style.textOrigin;

        if (origin === 'center') {
          x = rect.width / 2 + rect.x;
          y = rect.height / 2 + rect.y;
        } else if (origin) {
          x = origin[0] + rect.x;
          y = origin[1] + rect.y;
        }

        ctx.translate(x, y); // Positive: anticlockwise

        ctx.rotate(-style.textRotation);
        ctx.translate(-x, -y);
      }
    }

    function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
      var tokenStyle = style.rich[token.styleName] || {};
      tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of
      // the bias of "Microsoft YaHei".

      var textVerticalAlign = token.textVerticalAlign;
      var y = lineTop + lineHeight / 2;

      if (textVerticalAlign === 'top') {
        y = lineTop + token.height / 2;
      } else if (textVerticalAlign === 'bottom') {
        y = lineTop + lineHeight - token.height / 2;
      }

      !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
      var textPadding = token.textPadding;

      if (textPadding) {
        x = getTextXForPadding(x, textAlign, textPadding);
        y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
      }

      setCtx(ctx, 'shadowBlur', retrieve3$2(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
      setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
      setCtx(ctx, 'shadowOffsetX', retrieve3$2(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
      setCtx(ctx, 'shadowOffsetY', retrieve3$2(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
      setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
      // text will offset downward a little bit in font "Microsoft YaHei".

      setCtx(ctx, 'textBaseline', 'middle');
      setCtx(ctx, 'font', token.font || DEFAULT_FONT$1);
      var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
      var textFill = getFill(tokenStyle.textFill || style.textFill);
      var textStrokeWidth = retrieve2$2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.

      if (textStroke) {
        setCtx(ctx, 'lineWidth', textStrokeWidth);
        setCtx(ctx, 'strokeStyle', textStroke);
        ctx.strokeText(token.text, x, y);
      }

      if (textFill) {
        setCtx(ctx, 'fillStyle', textFill);
        ctx.fillText(token.text, x, y);
      }
    }

    function needDrawBackground(style) {
      return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);
    } // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}
    // shape: {x, y, width, height}


    function drawBackground(hostEl, ctx, style, x, y, width, height) {
      var textBackgroundColor = style.textBackgroundColor;
      var textBorderWidth = style.textBorderWidth;
      var textBorderColor = style.textBorderColor;
      var isPlainBg = isString$3(textBackgroundColor);
      setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
      setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
      setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
      setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);

      if (isPlainBg || textBorderWidth && textBorderColor) {
        ctx.beginPath();
        var textBorderRadius = style.textBorderRadius;

        if (!textBorderRadius) {
          ctx.rect(x, y, width, height);
        } else {
          roundRect.buildPath(ctx, {
            x: x,
            y: y,
            width: width,
            height: height,
            r: textBorderRadius
          });
        }

        ctx.closePath();
      }

      if (isPlainBg) {
        setCtx(ctx, 'fillStyle', textBackgroundColor);

        if (style.fillOpacity != null) {
          var originalGlobalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = style.fillOpacity * style.opacity;
          ctx.fill();
          ctx.globalAlpha = originalGlobalAlpha;
        } else {
          ctx.fill();
        }
      } else if (isObject$3(textBackgroundColor)) {
        var image$1 = textBackgroundColor.image;
        image$1 = image.createOrUpdateImage(image$1, null, hostEl, onBgImageLoaded, textBackgroundColor);

        if (image$1 && image.isImageReady(image$1)) {
          ctx.drawImage(image$1, x, y, width, height);
        }
      }

      if (textBorderWidth && textBorderColor) {
        setCtx(ctx, 'lineWidth', textBorderWidth);
        setCtx(ctx, 'strokeStyle', textBorderColor);

        if (style.strokeOpacity != null) {
          var originalGlobalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = style.strokeOpacity * style.opacity;
          ctx.stroke();
          ctx.globalAlpha = originalGlobalAlpha;
        } else {
          ctx.stroke();
        }
      }
    }

    function onBgImageLoaded(image, textBackgroundColor) {
      // Replace image, so that `contain/text.js#parseRichText`
      // will get correct result in next tick.
      textBackgroundColor.image = image;
    }

    function getBoxPosition(out, hostEl, style, rect) {
      var baseX = style.x || 0;
      var baseY = style.y || 0;
      var textAlign = style.textAlign;
      var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord

      if (rect) {
        var textPosition = style.textPosition;

        if (textPosition instanceof Array) {
          // Percent
          baseX = rect.x + parsePercent(textPosition[0], rect.width);
          baseY = rect.y + parsePercent(textPosition[1], rect.height);
        } else {
          var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : text$1.calculateTextPosition(_tmpTextPositionResult, style, rect);
          baseX = res.x;
          baseY = res.y; // Default align and baseline when has textPosition

          textAlign = textAlign || res.textAlign;
          textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
        } // textOffset is only support in RectText, otherwise
        // we have to adjust boundingRect for textOffset.


        var textOffset = style.textOffset;

        if (textOffset) {
          baseX += textOffset[0];
          baseY += textOffset[1];
        }
      }

      out = out || {};
      out.baseX = baseX;
      out.baseY = baseY;
      out.textAlign = textAlign;
      out.textVerticalAlign = textVerticalAlign;
      return out;
    }

    function setCtx(ctx, prop, value) {
      ctx[prop] = fixShadow(ctx, prop, value);
      return ctx[prop];
    }
    /**
     * @param {string} [stroke] If specified, do not check style.textStroke.
     * @param {string} [lineWidth] If specified, do not check style.textStroke.
     * @param {number} style
     */


    function getStroke(stroke, lineWidth) {
      return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
      : stroke.image || stroke.colorStops ? '#000' : stroke;
    }

    function getFill(fill) {
      return fill == null || fill === 'none' ? null // TODO pattern and gradient?
      : fill.image || fill.colorStops ? '#000' : fill;
    }

    function parsePercent(value, maxValue) {
      if (typeof value === 'string') {
        if (value.lastIndexOf('%') >= 0) {
          return parseFloat(value) / 100 * maxValue;
        }

        return parseFloat(value);
      }

      return value;
    }

    function getTextXForPadding(x, textAlign, textPadding) {
      return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
    }
    /**
     * @param {string} text
     * @param {module:zrender/Style} style
     * @return {boolean}
     */


    function needDrawText(text, style) {
      return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
    }

    var normalizeTextStyle_1 = normalizeTextStyle;
    var renderText_1 = renderText;
    var getBoxPosition_1 = getBoxPosition;
    var getStroke_1 = getStroke;
    var getFill_1 = getFill;
    var parsePercent_1 = parsePercent;
    var needDrawText_1 = needDrawText;

    var text$2 = {
    	normalizeTextStyle: normalizeTextStyle_1,
    	renderText: renderText_1,
    	getBoxPosition: getBoxPosition_1,
    	getStroke: getStroke_1,
    	getFill: getFill_1,
    	parsePercent: parsePercent_1,
    	needDrawText: needDrawText_1
    };

    var WILL_BE_RESTORED$2 = constant.WILL_BE_RESTORED;

    /**
     * Mixin for drawing text in a element bounding rect
     * @module zrender/mixin/RectText
     */
    var tmpRect = new BoundingRect_1();

    var RectText = function () {};

    RectText.prototype = {
      constructor: RectText,

      /**
       * Draw text in a rect with specified position.
       * @param  {CanvasRenderingContext2D} ctx
       * @param  {Object} rect Displayable rect
       */
      drawRectText: function (ctx, rect) {
        var style = this.style;
        rect = style.textRect || rect; // Optimize, avoid normalize every time.

        this.__dirty && text$2.normalizeTextStyle(style, true);
        var text = style.text; // Convert to string

        text != null && (text += '');

        if (!text$2.needDrawText(text, style)) {
          return;
        } // FIXME
        // Do not provide prevEl to `textHelper.renderText` for ctx prop cache,
        // but use `ctx.save()` and `ctx.restore()`. Because the cache for rect
        // text propably break the cache for its host elements.


        ctx.save(); // Transform rect to view space

        var transform = this.transform;

        if (!style.transformText) {
          if (transform) {
            tmpRect.copy(rect);
            tmpRect.applyTransform(transform);
            rect = tmpRect;
          }
        } else {
          this.setTransform(ctx);
        } // transformText and textRotation can not be used at the same time.


        text$2.renderText(this, ctx, text, style, rect, WILL_BE_RESTORED$2);
        ctx.restore();
      }
    };
    var _default$n = RectText;
    var RectText_1 = _default$n;

    /**
     * Base class of all displayable graphic objects
     * @module zrender/graphic/Displayable
     */

    /**
     * @alias module:zrender/graphic/Displayable
     * @extends module:zrender/Element
     * @extends module:zrender/graphic/mixin/RectText
     */
    function Displayable(opts) {
      opts = opts || {};
      Element_1.call(this, opts); // Extend properties

      for (var name in opts) {
        if (opts.hasOwnProperty(name) && name !== 'style') {
          this[name] = opts[name];
        }
      }
      /**
       * @type {module:zrender/graphic/Style}
       */


      this.style = new Style_1(opts.style, this);
      this._rect = null; // Shapes for cascade clipping.
      // Can only be `null`/`undefined` or an non-empty array, MUST NOT be an empty array.
      // because it is easy to only using null to check whether clipPaths changed.

      this.__clipPaths = null; // FIXME Stateful must be mixined after style is setted
      // Stateful.call(this, opts);
    }

    Displayable.prototype = {
      constructor: Displayable,
      type: 'displayable',

      /**
       * Dirty flag. From which painter will determine if this displayable object needs brush.
       * @name module:zrender/graphic/Displayable#__dirty
       * @type {boolean}
       */
      __dirty: true,

      /**
       * Whether the displayable object is visible. when it is true, the displayable object
       * is not drawn, but the mouse event can still trigger the object.
       * @name module:/zrender/graphic/Displayable#invisible
       * @type {boolean}
       * @default false
       */
      invisible: false,

      /**
       * @name module:/zrender/graphic/Displayable#z
       * @type {number}
       * @default 0
       */
      z: 0,

      /**
       * @name module:/zrender/graphic/Displayable#z
       * @type {number}
       * @default 0
       */
      z2: 0,

      /**
       * The z level determines the displayable object can be drawn in which layer canvas.
       * @name module:/zrender/graphic/Displayable#zlevel
       * @type {number}
       * @default 0
       */
      zlevel: 0,

      /**
       * Whether it can be dragged.
       * @name module:/zrender/graphic/Displayable#draggable
       * @type {boolean}
       * @default false
       */
      draggable: false,

      /**
       * Whether is it dragging.
       * @name module:/zrender/graphic/Displayable#draggable
       * @type {boolean}
       * @default false
       */
      dragging: false,

      /**
       * Whether to respond to mouse events.
       * @name module:/zrender/graphic/Displayable#silent
       * @type {boolean}
       * @default false
       */
      silent: false,

      /**
       * If enable culling
       * @type {boolean}
       * @default false
       */
      culling: false,

      /**
       * Mouse cursor when hovered
       * @name module:/zrender/graphic/Displayable#cursor
       * @type {string}
       */
      cursor: 'pointer',

      /**
       * If hover area is bounding rect
       * @name module:/zrender/graphic/Displayable#rectHover
       * @type {string}
       */
      rectHover: false,

      /**
       * Render the element progressively when the value >= 0,
       * usefull for large data.
       * @type {boolean}
       */
      progressive: false,

      /**
       * @type {boolean}
       */
      incremental: false,

      /**
       * Scale ratio for global scale.
       * @type {boolean}
       */
      globalScaleRatio: 1,
      beforeBrush: function (ctx) {},
      afterBrush: function (ctx) {},

      /**
       * Graphic drawing method.
       * @param {CanvasRenderingContext2D} ctx
       */
      // Interface
      brush: function (ctx, prevEl) {},

      /**
       * Get the minimum bounding box.
       * @return {module:zrender/core/BoundingRect}
       */
      // Interface
      getBoundingRect: function () {},

      /**
       * If displayable element contain coord x, y
       * @param  {number} x
       * @param  {number} y
       * @return {boolean}
       */
      contain: function (x, y) {
        return this.rectContain(x, y);
      },

      /**
       * @param  {Function} cb
       * @param  {}   context
       */
      traverse: function (cb, context) {
        cb.call(context, this);
      },

      /**
       * If bounding rect of element contain coord x, y
       * @param  {number} x
       * @param  {number} y
       * @return {boolean}
       */
      rectContain: function (x, y) {
        var coord = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        return rect.contain(coord[0], coord[1]);
      },

      /**
       * Mark displayable element dirty and refresh next frame
       */
      dirty: function () {
        this.__dirty = this.__dirtyText = true;
        this._rect = null;
        this.__zr && this.__zr.refresh();
      },

      /**
       * If displayable object binded any event
       * @return {boolean}
       */
      // TODO, events bound by bind
      // isSilent: function () {
      //     return !(
      //         this.hoverable || this.draggable
      //         || this.onmousemove || this.onmouseover || this.onmouseout
      //         || this.onmousedown || this.onmouseup || this.onclick
      //         || this.ondragenter || this.ondragover || this.ondragleave
      //         || this.ondrop
      //     );
      // },

      /**
       * Alias for animate('style')
       * @param {boolean} loop
       */
      animateStyle: function (loop) {
        return this.animate('style', loop);
      },
      attrKV: function (key, value) {
        if (key !== 'style') {
          Element_1.prototype.attrKV.call(this, key, value);
        } else {
          this.style.set(value);
        }
      },

      /**
       * @param {Object|string} key
       * @param {*} value
       */
      setStyle: function (key, value) {
        this.style.set(key, value);
        this.dirty(false);
        return this;
      },

      /**
       * Use given style object
       * @param  {Object} obj
       */
      useStyle: function (obj) {
        this.style = new Style_1(obj, this);
        this.dirty(false);
        return this;
      },

      /**
       * The string value of `textPosition` needs to be calculated to a real postion.
       * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`
       * by default. See `contain/text.js#calculateTextPosition` for more details.
       * But some coutom shapes like "pin", "flag" have center that is not exactly
       * `[width/2, height/2]`. So we provide this hook to customize the calculation
       * for those shapes. It will be called if the `style.textPosition` is a string.
       * @param {Obejct} [out] Prepared out object. If not provided, this method should
       *        be responsible for creating one.
       * @param {module:zrender/graphic/Style} style
       * @param {Object} rect {x, y, width, height}
       * @return {Obejct} out The same as the input out.
       *         {
       *             x: number. mandatory.
       *             y: number. mandatory.
       *             textAlign: string. optional. use style.textAlign by default.
       *             textVerticalAlign: string. optional. use style.textVerticalAlign by default.
       *         }
       */
      calculateTextPosition: null
    };
    util.inherits(Displayable, Element_1);
    util.mixin(Displayable, RectText_1); // zrUtil.mixin(Displayable, Stateful);

    var _default$o = Displayable;
    var Displayable_1 = _default$o;

    /**
     * @alias zrender/graphic/Image
     * @extends module:zrender/graphic/Displayable
     * @constructor
     * @param {Object} opts
     */
    function ZImage(opts) {
      Displayable_1.call(this, opts);
    }

    ZImage.prototype = {
      constructor: ZImage,
      type: 'image',
      brush: function (ctx, prevEl) {
        var style = this.style;
        var src = style.image; // Must bind each time

        style.bind(ctx, this, prevEl);
        var image$1 = this._image = image.createOrUpdateImage(src, this._image, this, this.onload);

        if (!image$1 || !image.isImageReady(image$1)) {
          return;
        } // 图片已经加载完成
        // if (image.nodeName.toUpperCase() == 'IMG') {
        //     if (!image.complete) {
        //         return;
        //     }
        // }
        // Else is canvas


        var x = style.x || 0;
        var y = style.y || 0;
        var width = style.width;
        var height = style.height;
        var aspect = image$1.width / image$1.height;

        if (width == null && height != null) {
          // Keep image/height ratio
          width = height * aspect;
        } else if (height == null && width != null) {
          height = width / aspect;
        } else if (width == null && height == null) {
          width = image$1.width;
          height = image$1.height;
        } // 设置transform


        this.setTransform(ctx);

        if (style.sWidth && style.sHeight) {
          var sx = style.sx || 0;
          var sy = style.sy || 0;
          ctx.drawImage(image$1, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
        } else if (style.sx && style.sy) {
          var sx = style.sx;
          var sy = style.sy;
          var sWidth = width - sx;
          var sHeight = height - sy;
          ctx.drawImage(image$1, sx, sy, sWidth, sHeight, x, y, width, height);
        } else {
          ctx.drawImage(image$1, x, y, width, height);
        } // Draw rect text


        if (style.text != null) {
          // Only restore transform when needs draw text.
          this.restoreTransform(ctx);
          this.drawRectText(ctx, this.getBoundingRect());
        }
      },
      getBoundingRect: function () {
        var style = this.style;

        if (!this._rect) {
          this._rect = new BoundingRect_1(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
        }

        return this._rect;
      }
    };
    util.inherits(ZImage, Displayable_1);
    var _default$p = ZImage;
    var Image$1 = _default$p;

    var devicePixelRatio$2 = config.devicePixelRatio;

















    var HOVER_LAYER_ZLEVEL = 1e5;
    var CANVAS_ZLEVEL = 314159;
    var EL_AFTER_INCREMENTAL_INC = 0.01;
    var INCREMENTAL_INC = 0.001;

    function parseInt10(val) {
      return parseInt(val, 10);
    }

    function isLayerValid(layer) {
      if (!layer) {
        return false;
      }

      if (layer.__builtin__) {
        return true;
      }

      if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
        return false;
      }

      return true;
    }

    var tmpRect$1 = new BoundingRect_1(0, 0, 0, 0);
    var viewRect = new BoundingRect_1(0, 0, 0, 0);

    function isDisplayableCulled(el, width, height) {
      tmpRect$1.copy(el.getBoundingRect());

      if (el.transform) {
        tmpRect$1.applyTransform(el.transform);
      }

      viewRect.width = width;
      viewRect.height = height;
      return !tmpRect$1.intersect(viewRect);
    }

    function isClipPathChanged(clipPaths, prevClipPaths) {
      // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.
      if (clipPaths === prevClipPaths) {
        return false;
      }

      if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
        return true;
      }

      for (var i = 0; i < clipPaths.length; i++) {
        if (clipPaths[i] !== prevClipPaths[i]) {
          return true;
        }
      }

      return false;
    }

    function doClip(clipPaths, ctx) {
      for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];
        clipPath.setTransform(ctx);
        ctx.beginPath();
        clipPath.buildPath(ctx, clipPath.shape);
        ctx.clip(); // Transform back

        clipPath.restoreTransform(ctx);
      }
    }

    function createRoot(width, height) {
      var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // Avoid page selected

      domRoot.style.cssText = ['position:relative', // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent
      // dom does not act as expected) when some of the parent dom has
      // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and
      // the canvas is not at the top part of the page.
      // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove
      // this `overflow:hidden` to avoid the bug.
      // 'overflow:hidden',
      'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
      return domRoot;
    }
    /**
     * @alias module:zrender/Painter
     * @constructor
     * @param {HTMLElement} root 绘图容器
     * @param {module:zrender/Storage} storage
     * @param {Object} opts
     */


    var Painter = function (root, storage, opts) {
      this.type = 'canvas'; // In node environment using node-canvas

      var singleCanvas = !root.nodeName // In node ?
      || root.nodeName.toUpperCase() === 'CANVAS';
      this._opts = opts = util.extend({}, opts || {});
      /**
       * @type {number}
       */

      this.dpr = opts.devicePixelRatio || devicePixelRatio$2;
      /**
       * @type {boolean}
       * @private
       */

      this._singleCanvas = singleCanvas;
      /**
       * 绘图容器
       * @type {HTMLElement}
       */

      this.root = root;
      var rootStyle = root.style;

      if (rootStyle) {
        rootStyle['-webkit-tap-highlight-color'] = 'transparent';
        rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
        root.innerHTML = '';
      }
      /**
       * @type {module:zrender/Storage}
       */


      this.storage = storage;
      /**
       * @type {Array.<number>}
       * @private
       */

      var zlevelList = this._zlevelList = [];
      /**
       * @type {Object.<string, module:zrender/Layer>}
       * @private
       */

      var layers = this._layers = {};
      /**
       * @type {Object.<string, Object>}
       * @private
       */

      this._layerConfig = {};
      /**
       * zrender will do compositing when root is a canvas and have multiple zlevels.
       */

      this._needsManuallyCompositing = false;

      if (!singleCanvas) {
        this._width = this._getSize(0);
        this._height = this._getSize(1);
        var domRoot = this._domRoot = createRoot(this._width, this._height);
        root.appendChild(domRoot);
      } else {
        var width = root.width;
        var height = root.height;

        if (opts.width != null) {
          width = opts.width;
        }

        if (opts.height != null) {
          height = opts.height;
        }

        this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly

        root.width = width * this.dpr;
        root.height = height * this.dpr;
        this._width = width;
        this._height = height; // Create layer if only one given canvas
        // Device can be specified to create a high dpi image.

        var mainLayer = new Layer_1(root, this, this.dpr);
        mainLayer.__builtin__ = true;
        mainLayer.initContext(); // FIXME Use canvas width and height
        // mainLayer.resize(width, height);

        layers[CANVAS_ZLEVEL] = mainLayer;
        mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.

        zlevelList.push(CANVAS_ZLEVEL);
        this._domRoot = root;
      }
      /**
       * @type {module:zrender/Layer}
       * @private
       */


      this._hoverlayer = null;
      this._hoverElements = [];
    };

    Painter.prototype = {
      constructor: Painter,
      getType: function () {
        return 'canvas';
      },

      /**
       * If painter use a single canvas
       * @return {boolean}
       */
      isSingleCanvas: function () {
        return this._singleCanvas;
      },

      /**
       * @return {HTMLDivElement}
       */
      getViewportRoot: function () {
        return this._domRoot;
      },
      getViewportRootOffset: function () {
        var viewportRoot = this.getViewportRoot();

        if (viewportRoot) {
          return {
            offsetLeft: viewportRoot.offsetLeft || 0,
            offsetTop: viewportRoot.offsetTop || 0
          };
        }
      },

      /**
       * 刷新
       * @param {boolean} [paintAll=false] 强制绘制所有displayable
       */
      refresh: function (paintAll) {
        var list = this.storage.getDisplayList(true);
        var zlevelList = this._zlevelList;
        this._redrawId = Math.random();

        this._paintList(list, paintAll, this._redrawId); // Paint custum layers


        for (var i = 0; i < zlevelList.length; i++) {
          var z = zlevelList[i];
          var layer = this._layers[z];

          if (!layer.__builtin__ && layer.refresh) {
            var clearColor = i === 0 ? this._backgroundColor : null;
            layer.refresh(clearColor);
          }
        }

        this.refreshHover();
        return this;
      },
      addHover: function (el, hoverStyle) {
        if (el.__hoverMir) {
          return;
        }

        var elMirror = new el.constructor({
          style: el.style,
          shape: el.shape,
          z: el.z,
          z2: el.z2,
          silent: el.silent
        });
        elMirror.__from = el;
        el.__hoverMir = elMirror;
        hoverStyle && elMirror.setStyle(hoverStyle);

        this._hoverElements.push(elMirror);

        return elMirror;
      },
      removeHover: function (el) {
        var elMirror = el.__hoverMir;
        var hoverElements = this._hoverElements;
        var idx = util.indexOf(hoverElements, elMirror);

        if (idx >= 0) {
          hoverElements.splice(idx, 1);
        }

        el.__hoverMir = null;
      },
      clearHover: function (el) {
        var hoverElements = this._hoverElements;

        for (var i = 0; i < hoverElements.length; i++) {
          var from = hoverElements[i].__from;

          if (from) {
            from.__hoverMir = null;
          }
        }

        hoverElements.length = 0;
      },
      refreshHover: function () {
        var hoverElements = this._hoverElements;
        var len = hoverElements.length;
        var hoverLayer = this._hoverlayer;
        hoverLayer && hoverLayer.clear();

        if (!len) {
          return;
        }

        timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
        // FIXME?

        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }

        var scope = {};
        hoverLayer.ctx.save();

        for (var i = 0; i < len;) {
          var el = hoverElements[i];
          var originalEl = el.__from; // Original el is removed
          // PENDING

          if (!(originalEl && originalEl.__zr)) {
            hoverElements.splice(i, 1);
            originalEl.__hoverMir = null;
            len--;
            continue;
          }

          i++; // Use transform
          // FIXME style and shape ?

          if (!originalEl.invisible) {
            el.transform = originalEl.transform;
            el.invTransform = originalEl.invTransform;
            el.__clipPaths = originalEl.__clipPaths; // el.

            this._doPaintEl(el, hoverLayer, true, scope);
          }
        }

        hoverLayer.ctx.restore();
      },
      getHoverLayer: function () {
        return this.getLayer(HOVER_LAYER_ZLEVEL);
      },
      _paintList: function (list, paintAll, redrawId) {
        if (this._redrawId !== redrawId) {
          return;
        }

        paintAll = paintAll || false;

        this._updateLayerStatus(list);

        var finished = this._doPaintList(list, paintAll);

        if (this._needsManuallyCompositing) {
          this._compositeManually();
        }

        if (!finished) {
          var self = this;
          requestAnimationFrame$1(function () {
            self._paintList(list, paintAll, redrawId);
          });
        }
      },
      _compositeManually: function () {
        var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
        var width = this._domRoot.width;
        var height = this._domRoot.height;
        ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?

        this.eachBuiltinLayer(function (layer) {
          if (layer.virtual) {
            ctx.drawImage(layer.dom, 0, 0, width, height);
          }
        });
      },
      _doPaintList: function (list, paintAll) {
        var layerList = [];

        for (var zi = 0; zi < this._zlevelList.length; zi++) {
          var zlevel = this._zlevelList[zi];
          var layer = this._layers[zlevel];

          if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
            layerList.push(layer);
          }
        }

        var finished = true;

        for (var k = 0; k < layerList.length; k++) {
          var layer = layerList[k];
          var ctx = layer.ctx;
          var scope = {};
          ctx.save();
          var start = paintAll ? layer.__startIndex : layer.__drawIndex;
          var useTimer = !paintAll && layer.incremental && Date.now;
          var startTime = useTimer && Date.now();
          var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.

          if (layer.__startIndex === layer.__endIndex) {
            layer.clear(false, clearColor);
          } else if (start === layer.__startIndex) {
            var firstEl = list[start];

            if (!firstEl.incremental || !firstEl.notClear || paintAll) {
              layer.clear(false, clearColor);
            }
          }

          if (start === -1) {
            console.error('For some unknown reason. drawIndex is -1');
            start = layer.__startIndex;
          }

          for (var i = start; i < layer.__endIndex; i++) {
            var el = list[i];

            this._doPaintEl(el, layer, paintAll, scope);

            el.__dirty = el.__dirtyText = false;

            if (useTimer) {
              // Date.now can be executed in 13,025,305 ops/second.
              var dTime = Date.now() - startTime; // Give 15 millisecond to draw.
              // The rest elements will be drawn in the next frame.

              if (dTime > 15) {
                break;
              }
            }
          }

          layer.__drawIndex = i;

          if (layer.__drawIndex < layer.__endIndex) {
            finished = false;
          }

          if (scope.prevElClipPaths) {
            // Needs restore the state. If last drawn element is in the clipping area.
            ctx.restore();
          }

          ctx.restore();
        }

        if (env_1.wxa) {
          // Flush for weixin application
          util.each(this._layers, function (layer) {
            if (layer && layer.ctx && layer.ctx.draw) {
              layer.ctx.draw();
            }
          });
        }

        return finished;
      },
      _doPaintEl: function (el, currentLayer, forcePaint, scope) {
        var ctx = currentLayer.ctx;
        var m = el.transform;

        if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
        !el.invisible // Ignore transparent element
        && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
        // Draw a scale 0 element can cause all following draw wrong
        // And setTransform with scale 0 will cause set back transform failed.
        && !(m && !m[0] && !m[3]) // Ignore culled element
        && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
          var clipPaths = el.__clipPaths;
          var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements

          if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
            // If has previous clipping state, restore from it
            if (prevElClipPaths) {
              ctx.restore();
              scope.prevElClipPaths = null; // Reset prevEl since context has been restored

              scope.prevEl = null;
            } // New clipping state


            if (clipPaths) {
              ctx.save();
              doClip(clipPaths, ctx);
              scope.prevElClipPaths = clipPaths;
            }
          }

          el.beforeBrush && el.beforeBrush(ctx);
          el.brush(ctx, scope.prevEl || null);
          scope.prevEl = el;
          el.afterBrush && el.afterBrush(ctx);
        }
      },

      /**
       * 获取 zlevel 所在层，如果不存在则会创建一个新的层
       * @param {number} zlevel
       * @param {boolean} virtual Virtual layer will not be inserted into dom.
       * @return {module:zrender/Layer}
       */
      getLayer: function (zlevel, virtual) {
        if (this._singleCanvas && !this._needsManuallyCompositing) {
          zlevel = CANVAS_ZLEVEL;
        }

        var layer = this._layers[zlevel];

        if (!layer) {
          // Create a new layer
          layer = new Layer_1('zr_' + zlevel, this, this.dpr);
          layer.zlevel = zlevel;
          layer.__builtin__ = true;

          if (this._layerConfig[zlevel]) {
            util.merge(layer, this._layerConfig[zlevel], true);
          } // TODO Remove EL_AFTER_INCREMENTAL_INC magic number
          else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
              util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
            }

          if (virtual) {
            layer.virtual = virtual;
          }

          this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
          // Or excanvas will get 0px clientWidth and clientHeight

          layer.initContext();
        }

        return layer;
      },
      insertLayer: function (zlevel, layer) {
        var layersMap = this._layers;
        var zlevelList = this._zlevelList;
        var len = zlevelList.length;
        var prevLayer = null;
        var i = -1;
        var domRoot = this._domRoot;

        if (layersMap[zlevel]) {
          return;
        } // Check if is a valid layer


        if (!isLayerValid(layer)) {
          return;
        }

        if (len > 0 && zlevel > zlevelList[0]) {
          for (i = 0; i < len - 1; i++) {
            if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
              break;
            }
          }

          prevLayer = layersMap[zlevelList[i]];
        }

        zlevelList.splice(i + 1, 0, zlevel);
        layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
        // (It can be a WebGL layer and assigned to a ZImage element)
        // But it still under management of zrender.

        if (!layer.virtual) {
          if (prevLayer) {
            var prevDom = prevLayer.dom;

            if (prevDom.nextSibling) {
              domRoot.insertBefore(layer.dom, prevDom.nextSibling);
            } else {
              domRoot.appendChild(layer.dom);
            }
          } else {
            if (domRoot.firstChild) {
              domRoot.insertBefore(layer.dom, domRoot.firstChild);
            } else {
              domRoot.appendChild(layer.dom);
            }
          }
        }
      },
      // Iterate each layer
      eachLayer: function (cb, context) {
        var zlevelList = this._zlevelList;
        var z;
        var i;

        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          cb.call(context, this._layers[z], z);
        }
      },
      // Iterate each buildin layer
      eachBuiltinLayer: function (cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;

        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          layer = this._layers[z];

          if (layer.__builtin__) {
            cb.call(context, layer, z);
          }
        }
      },
      // Iterate each other layer except buildin layer
      eachOtherLayer: function (cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;

        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          layer = this._layers[z];

          if (!layer.__builtin__) {
            cb.call(context, layer, z);
          }
        }
      },

      /**
       * 获取所有已创建的层
       * @param {Array.<module:zrender/Layer>} [prevLayer]
       */
      getLayers: function () {
        return this._layers;
      },
      _updateLayerStatus: function (list) {
        this.eachBuiltinLayer(function (layer, z) {
          layer.__dirty = layer.__used = false;
        });

        function updatePrevLayer(idx) {
          if (prevLayer) {
            if (prevLayer.__endIndex !== idx) {
              prevLayer.__dirty = true;
            }

            prevLayer.__endIndex = idx;
          }
        }

        if (this._singleCanvas) {
          for (var i = 1; i < list.length; i++) {
            var el = list[i];

            if (el.zlevel !== list[i - 1].zlevel || el.incremental) {
              this._needsManuallyCompositing = true;
              break;
            }
          }
        }

        var prevLayer = null;
        var incrementalLayerCount = 0;
        var prevZlevel;

        for (var i = 0; i < list.length; i++) {
          var el = list[i];
          var zlevel = el.zlevel;
          var layer;

          if (prevZlevel !== zlevel) {
            prevZlevel = zlevel;
            incrementalLayerCount = 0;
          } // TODO Not use magic number on zlevel.
          // Each layer with increment element can be separated to 3 layers.
          //          (Other Element drawn after incremental element)
          // -----------------zlevel + EL_AFTER_INCREMENTAL_INC--------------------
          //                      (Incremental element)
          // ----------------------zlevel + INCREMENTAL_INC------------------------
          //              (Element drawn before incremental element)
          // --------------------------------zlevel--------------------------------


          if (el.incremental) {
            layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
            layer.incremental = true;
            incrementalLayerCount = 1;
          } else {
            layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
          }

          if (!layer.__builtin__) {
            log('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);
          }

          if (layer !== prevLayer) {
            layer.__used = true;

            if (layer.__startIndex !== i) {
              layer.__dirty = true;
            }

            layer.__startIndex = i;

            if (!layer.incremental) {
              layer.__drawIndex = i;
            } else {
              // Mark layer draw index needs to update.
              layer.__drawIndex = -1;
            }

            updatePrevLayer(i);
            prevLayer = layer;
          }

          if (el.__dirty) {
            layer.__dirty = true;

            if (layer.incremental && layer.__drawIndex < 0) {
              // Start draw from the first dirty element.
              layer.__drawIndex = i;
            }
          }
        }

        updatePrevLayer(i);
        this.eachBuiltinLayer(function (layer, z) {
          // Used in last frame but not in this frame. Needs clear
          if (!layer.__used && layer.getElementCount() > 0) {
            layer.__dirty = true;
            layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;
          } // For incremental layer. In case start index changed and no elements are dirty.


          if (layer.__dirty && layer.__drawIndex < 0) {
            layer.__drawIndex = layer.__startIndex;
          }
        });
      },

      /**
       * 清除hover层外所有内容
       */
      clear: function () {
        this.eachBuiltinLayer(this._clearLayer);
        return this;
      },
      _clearLayer: function (layer) {
        layer.clear();
      },
      setBackgroundColor: function (backgroundColor) {
        this._backgroundColor = backgroundColor;
      },

      /**
       * 修改指定zlevel的绘制参数
       *
       * @param {string} zlevel
       * @param {Object} config 配置对象
       * @param {string} [config.clearColor=0] 每次清空画布的颜色
       * @param {string} [config.motionBlur=false] 是否开启动态模糊
       * @param {number} [config.lastFrameAlpha=0.7]
       *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
       */
      configLayer: function (zlevel, config) {
        if (config) {
          var layerConfig = this._layerConfig;

          if (!layerConfig[zlevel]) {
            layerConfig[zlevel] = config;
          } else {
            util.merge(layerConfig[zlevel], config, true);
          }

          for (var i = 0; i < this._zlevelList.length; i++) {
            var _zlevel = this._zlevelList[i]; // TODO Remove EL_AFTER_INCREMENTAL_INC magic number

            if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
              var layer = this._layers[_zlevel];
              util.merge(layer, layerConfig[zlevel], true);
            }
          }
        }
      },

      /**
       * 删除指定层
       * @param {number} zlevel 层所在的zlevel
       */
      delLayer: function (zlevel) {
        var layers = this._layers;
        var zlevelList = this._zlevelList;
        var layer = layers[zlevel];

        if (!layer) {
          return;
        }

        layer.dom.parentNode.removeChild(layer.dom);
        delete layers[zlevel];
        zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
      },

      /**
       * 区域大小变化后重绘
       */
      resize: function (width, height) {
        if (!this._domRoot.style) {
          // Maybe in node or worker
          if (width == null || height == null) {
            return;
          }

          this._width = width;
          this._height = height;
          this.getLayer(CANVAS_ZLEVEL).resize(width, height);
        } else {
          var domRoot = this._domRoot; // FIXME Why ?

          domRoot.style.display = 'none'; // Save input w/h

          var opts = this._opts;
          width != null && (opts.width = width);
          height != null && (opts.height = height);
          width = this._getSize(0);
          height = this._getSize(1);
          domRoot.style.display = ''; // 优化没有实际改变的resize

          if (this._width !== width || height !== this._height) {
            domRoot.style.width = width + 'px';
            domRoot.style.height = height + 'px';

            for (var id in this._layers) {
              if (this._layers.hasOwnProperty(id)) {
                this._layers[id].resize(width, height);
              }
            }

            util.each(this._progressiveLayers, function (layer) {
              layer.resize(width, height);
            });
            this.refresh(true);
          }

          this._width = width;
          this._height = height;
        }

        return this;
      },

      /**
       * 清除单独的一个层
       * @param {number} zlevel
       */
      clearLayer: function (zlevel) {
        var layer = this._layers[zlevel];

        if (layer) {
          layer.clear();
        }
      },

      /**
       * 释放
       */
      dispose: function () {
        this.root.innerHTML = '';
        this.root = this.storage = this._domRoot = this._layers = null;
      },

      /**
       * Get canvas which has all thing rendered
       * @param {Object} opts
       * @param {string} [opts.backgroundColor]
       * @param {number} [opts.pixelRatio]
       */
      getRenderedCanvas: function (opts) {
        opts = opts || {};

        if (this._singleCanvas && !this._compositeManually) {
          return this._layers[CANVAS_ZLEVEL].dom;
        }

        var imageLayer = new Layer_1('image', this, opts.pixelRatio || this.dpr);
        imageLayer.initContext();
        imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);

        if (opts.pixelRatio <= this.dpr) {
          this.refresh();
          var width = imageLayer.dom.width;
          var height = imageLayer.dom.height;
          var ctx = imageLayer.ctx;
          this.eachLayer(function (layer) {
            if (layer.__builtin__) {
              ctx.drawImage(layer.dom, 0, 0, width, height);
            } else if (layer.renderToCanvas) {
              imageLayer.ctx.save();
              layer.renderToCanvas(imageLayer.ctx);
              imageLayer.ctx.restore();
            }
          });
        } else {
          // PENDING, echarts-gl and incremental rendering.
          var scope = {};
          var displayList = this.storage.getDisplayList(true);

          for (var i = 0; i < displayList.length; i++) {
            var el = displayList[i];

            this._doPaintEl(el, imageLayer, true, scope);
          }
        }

        return imageLayer.dom;
      },

      /**
       * 获取绘图区域宽度
       */
      getWidth: function () {
        return this._width;
      },

      /**
       * 获取绘图区域高度
       */
      getHeight: function () {
        return this._height;
      },
      _getSize: function (whIdx) {
        var opts = this._opts;
        var wh = ['width', 'height'][whIdx];
        var cwh = ['clientWidth', 'clientHeight'][whIdx];
        var plt = ['paddingLeft', 'paddingTop'][whIdx];
        var prb = ['paddingRight', 'paddingBottom'][whIdx];

        if (opts[wh] != null && opts[wh] !== 'auto') {
          return parseFloat(opts[wh]);
        }

        var root = this.root; // IE8 does not support getComputedStyle, but it use VML.

        var stl = document.defaultView.getComputedStyle(root);
        return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
      },
      pathToImage: function (path, dpr) {
        dpr = dpr || this.dpr;
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var rect = path.getBoundingRect();
        var style = path.style;
        var shadowBlurSize = style.shadowBlur * dpr;
        var shadowOffsetX = style.shadowOffsetX * dpr;
        var shadowOffsetY = style.shadowOffsetY * dpr;
        var lineWidth = style.hasStroke() ? style.lineWidth : 0;
        var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
        var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
        var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
        var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
        var width = rect.width + leftMargin + rightMargin;
        var height = rect.height + topMargin + bottomMargin;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);
        ctx.dpr = dpr;
        var pathTransform = {
          position: path.position,
          rotation: path.rotation,
          scale: path.scale
        };
        path.position = [leftMargin - rect.x, topMargin - rect.y];
        path.rotation = 0;
        path.scale = [1, 1];
        path.updateTransform();

        if (path) {
          path.brush(ctx);
        }

        var ImageShape = Image$1;
        var imgShape = new ImageShape({
          style: {
            x: 0,
            y: 0,
            image: canvas
          }
        });

        if (pathTransform.position != null) {
          imgShape.position = path.position = pathTransform.position;
        }

        if (pathTransform.rotation != null) {
          imgShape.rotation = path.rotation = pathTransform.rotation;
        }

        if (pathTransform.scale != null) {
          imgShape.scale = path.scale = pathTransform.scale;
        }

        return imgShape;
      }
    };
    var _default$q = Painter;
    var Painter_1 = _default$q;

    var Dispatcher$1 = event.Dispatcher;





    /**
     * Animation main class, dispatch and manage all animation controllers
     *
     * @module zrender/animation/Animation
     * @author pissang(https://github.com/pissang)
     */
    // TODO Additive animation
    // http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
    // https://developer.apple.com/videos/wwdc2014/#236

    /**
     * @typedef {Object} IZRenderStage
     * @property {Function} update
     */

    /**
     * @alias module:zrender/animation/Animation
     * @constructor
     * @param {Object} [options]
     * @param {Function} [options.onframe]
     * @param {IZRenderStage} [options.stage]
     * @example
     *     var animation = new Animation();
     *     var obj = {
     *         x: 100,
     *         y: 100
     *     };
     *     animation.animate(node.position)
     *         .when(1000, {
     *             x: 500,
     *             y: 500
     *         })
     *         .when(2000, {
     *             x: 100,
     *             y: 100
     *         })
     *         .start('spline');
     */
    var Animation = function (options) {
      options = options || {};
      this.stage = options.stage || {};

      this.onframe = options.onframe || function () {}; // private properties


      this._clips = [];
      this._running = false;
      this._time;
      this._pausedTime;
      this._pauseStart;
      this._paused = false;
      Dispatcher$1.call(this);
    };

    Animation.prototype = {
      constructor: Animation,

      /**
       * Add clip
       * @param {module:zrender/animation/Clip} clip
       */
      addClip: function (clip) {
        this._clips.push(clip);
      },

      /**
       * Add animator
       * @param {module:zrender/animation/Animator} animator
       */
      addAnimator: function (animator) {
        animator.animation = this;
        var clips = animator.getClips();

        for (var i = 0; i < clips.length; i++) {
          this.addClip(clips[i]);
        }
      },

      /**
       * Delete animation clip
       * @param {module:zrender/animation/Clip} clip
       */
      removeClip: function (clip) {
        var idx = util.indexOf(this._clips, clip);

        if (idx >= 0) {
          this._clips.splice(idx, 1);
        }
      },

      /**
       * Delete animation clip
       * @param {module:zrender/animation/Animator} animator
       */
      removeAnimator: function (animator) {
        var clips = animator.getClips();

        for (var i = 0; i < clips.length; i++) {
          this.removeClip(clips[i]);
        }

        animator.animation = null;
      },
      _update: function () {
        var time = new Date().getTime() - this._pausedTime;

        var delta = time - this._time;
        var clips = this._clips;
        var len = clips.length;
        var deferredEvents = [];
        var deferredClips = [];

        for (var i = 0; i < len; i++) {
          var clip = clips[i];
          var e = clip.step(time, delta); // Throw out the events need to be called after
          // stage.update, like destroy

          if (e) {
            deferredEvents.push(e);
            deferredClips.push(clip);
          }
        } // Remove the finished clip


        for (var i = 0; i < len;) {
          if (clips[i]._needsRemove) {
            clips[i] = clips[len - 1];
            clips.pop();
            len--;
          } else {
            i++;
          }
        }

        len = deferredEvents.length;

        for (var i = 0; i < len; i++) {
          deferredClips[i].fire(deferredEvents[i]);
        }

        this._time = time;
        this.onframe(delta); // 'frame' should be triggered before stage, because upper application
        // depends on the sequence (e.g., echarts-stream and finish
        // event judge)

        this.trigger('frame', delta);

        if (this.stage.update) {
          this.stage.update();
        }
      },
      _startLoop: function () {
        var self = this;
        this._running = true;

        function step() {
          if (self._running) {
            requestAnimationFrame$1(step);
            !self._paused && self._update();
          }
        }

        requestAnimationFrame$1(step);
      },

      /**
       * Start animation.
       */
      start: function () {
        this._time = new Date().getTime();
        this._pausedTime = 0;

        this._startLoop();
      },

      /**
       * Stop animation.
       */
      stop: function () {
        this._running = false;
      },

      /**
       * Pause animation.
       */
      pause: function () {
        if (!this._paused) {
          this._pauseStart = new Date().getTime();
          this._paused = true;
        }
      },

      /**
       * Resume animation.
       */
      resume: function () {
        if (this._paused) {
          this._pausedTime += new Date().getTime() - this._pauseStart;
          this._paused = false;
        }
      },

      /**
       * Clear animation.
       */
      clear: function () {
        this._clips = [];
      },

      /**
       * Whether animation finished.
       */
      isFinished: function () {
        return !this._clips.length;
      },

      /**
       * Creat animator for a target, whose props can be animated.
       *
       * @param  {Object} target
       * @param  {Object} options
       * @param  {boolean} [options.loop=false] Whether loop animation.
       * @param  {Function} [options.getter=null] Get value from target.
       * @param  {Function} [options.setter=null] Set value to target.
       * @return {module:zrender/animation/Animation~Animator}
       */
      // TODO Gap
      animate: function (target, options) {
        options = options || {};
        var animator = new Animator_1(target, options.loop, options.getter, options.setter);
        this.addAnimator(animator);
        return animator;
      }
    };
    util.mixin(Animation, Dispatcher$1);
    var _default$r = Animation;
    var Animation_1 = _default$r;

    var addEventListener$2 = event.addEventListener;
    var removeEventListener$2 = event.removeEventListener;
    var normalizeEvent$1 = event.normalizeEvent;
    var getNativeEvent$1 = event.getNativeEvent;







    /* global document */
    var TOUCH_CLICK_DELAY = 300;
    var globalEventSupported = env_1.domSupported;

    var localNativeListenerNames = function () {
      var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
      var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
      var pointerEventNameMap = {
        pointerdown: 1,
        pointerup: 1,
        pointermove: 1,
        pointerout: 1
      };
      var pointerHandlerNames = util.map(mouseHandlerNames, function (name) {
        var nm = name.replace('mouse', 'pointer');
        return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
      });
      return {
        mouse: mouseHandlerNames,
        touch: touchHandlerNames,
        pointer: pointerHandlerNames
      };
    }();

    var globalNativeListenerNames = {
      mouse: ['mousemove', 'mouseup'],
      pointer: ['pointermove', 'pointerup']
    };

    function eventNameFix(name) {
      return name === 'mousewheel' && env_1.browser.firefox ? 'DOMMouseScroll' : name;
    }

    function isPointerFromTouch(event) {
      var pointerType = event.pointerType;
      return pointerType === 'pen' || pointerType === 'touch';
    } // function useMSGuesture(handlerProxy, event) {
    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
    // }
    // function onMSGestureChange(proxy, event) {
    //     if (event.translationX || event.translationY) {
    //         // mousemove is carried by MSGesture to reduce the sensitivity.
    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
    //     }
    //     if (event.scale !== 1) {
    //         event.pinchX = event.offsetX;
    //         event.pinchY = event.offsetY;
    //         event.pinchScale = event.scale;
    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);
    //     }
    // }

    /**
     * Prevent mouse event from being dispatched after Touch Events action
     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
     * Result: Blocking Mouse Events for 700ms.
     *
     * @param {DOMHandlerScope} scope
     */


    function setTouchTimer(scope) {
      scope.touching = true;

      if (scope.touchTimer != null) {
        clearTimeout(scope.touchTimer);
        scope.touchTimer = null;
      }

      scope.touchTimer = setTimeout(function () {
        scope.touching = false;
        scope.touchTimer = null;
      }, 700);
    } // Mark touch, which is useful in distinguish touch and
    // mouse event in upper applicatoin.


    function markTouch(event) {
      event && (event.zrByTouch = true);
    } // function markTriggeredFromLocal(event) {
    //     event && (event.__zrIsFromLocal = true);
    // }
    // function isTriggeredFromLocal(instance, event) {
    //     return !!(event && event.__zrIsFromLocal);
    // }


    function normalizeGlobalEvent(instance, event) {
      // offsetX, offsetY still need to be calculated. They are necessary in the event
      // handlers of the upper applications. Set `true` to force calculate them.
      return normalizeEvent$1(instance.dom, new FakeGlobalEvent(instance, event), true);
    }
    /**
     * Detect whether the given el is in `painterRoot`.
     */


    function isLocalEl(instance, el) {
      var elTmp = el;
      var isLocal = false;

      while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
        elTmp = elTmp.parentNode;
      }

      return isLocal;
    }
    /**
     * Make a fake event but not change the original event,
     * becuase the global event probably be used by other
     * listeners not belonging to zrender.
     * @class
     */


    function FakeGlobalEvent(instance, event) {
      this.type = event.type;
      this.target = this.currentTarget = instance.dom;
      this.pointerType = event.pointerType; // Necessray for the force calculation of zrX, zrY

      this.clientX = event.clientX;
      this.clientY = event.clientY; // Because we do not mount global listeners to touch events,
      // we do not copy `targetTouches` and `changedTouches` here.
    }

    var fakeGlobalEventProto = FakeGlobalEvent.prototype; // we make the default methods on the event do nothing,
    // otherwise it is dangerous. See more details in
    // [Drag outside] in `Handler.js`.

    fakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = util.noop;
    /**
     * Local DOM Handlers
     * @this {HandlerProxy}
     */

    var localDOMHandlers = {
      mousedown: function (event) {
        event = normalizeEvent$1(this.dom, event);
        this._mayPointerCapture = [event.zrX, event.zrY];
        this.trigger('mousedown', event);
      },
      mousemove: function (event) {
        event = normalizeEvent$1(this.dom, event);
        var downPoint = this._mayPointerCapture;

        if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
          togglePointerCapture(this, true);
        }

        this.trigger('mousemove', event);
      },
      mouseup: function (event) {
        event = normalizeEvent$1(this.dom, event);
        togglePointerCapture(this, false);
        this.trigger('mouseup', event);
      },
      mouseout: function (event) {
        event = normalizeEvent$1(this.dom, event); // Similarly to the browser did on `document` and touch event,
        // `globalout` will be delayed to final pointer cature release.

        if (this._pointerCapturing) {
          event.zrEventControl = 'no_globalout';
        } // There might be some doms created by upper layer application
        // at the same level of painter.getViewportRoot() (e.g., tooltip
        // dom created by echarts), where 'globalout' event should not
        // be triggered when mouse enters these doms. (But 'mouseout'
        // should be triggered at the original hovered element as usual).


        var element = event.toElement || event.relatedTarget;
        event.zrIsToLocalDOM = isLocalEl(this, element);
        this.trigger('mouseout', event);
      },
      touchstart: function (event) {
        // Default mouse behaviour should not be disabled here.
        // For example, page may needs to be slided.
        event = normalizeEvent$1(this.dom, event);
        markTouch(event);
        this._lastTouchMoment = new Date();
        this.handler.processGesture(event, 'start'); // For consistent event listener for both touch device and mouse device,
        // we simulate "mouseover-->mousedown" in touch device. So we trigger
        // `mousemove` here (to trigger `mouseover` inside), and then trigger
        // `mousedown`.

        localDOMHandlers.mousemove.call(this, event);
        localDOMHandlers.mousedown.call(this, event);
      },
      touchmove: function (event) {
        event = normalizeEvent$1(this.dom, event);
        markTouch(event);
        this.handler.processGesture(event, 'change'); // Mouse move should always be triggered no matter whether
        // there is gestrue event, because mouse move and pinch may
        // be used at the same time.

        localDOMHandlers.mousemove.call(this, event);
      },
      touchend: function (event) {
        event = normalizeEvent$1(this.dom, event);
        markTouch(event);
        this.handler.processGesture(event, 'end');
        localDOMHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
        // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
        // we can conveniently implement "hover style" in both PC and touch device just
        // by listening to `mouseover` to add "hover style" and listening to `mouseout`
        // to remove "hover style" on an element, without any additional code for
        // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
        // style" will remain for user view)
        // click event should always be triggered no matter whether
        // there is gestrue event. System click can not be prevented.

        if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
          localDOMHandlers.click.call(this, event);
        }
      },
      pointerdown: function (event) {
        localDOMHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
        //     this._msGesture.addPointer(event.pointerId);
        // }
      },
      pointermove: function (event) {
        // FIXME
        // pointermove is so sensitive that it always triggered when
        // tap(click) on touch screen, which affect some judgement in
        // upper application. So, we dont support mousemove on MS touch
        // device yet.
        if (!isPointerFromTouch(event)) {
          localDOMHandlers.mousemove.call(this, event);
        }
      },
      pointerup: function (event) {
        localDOMHandlers.mouseup.call(this, event);
      },
      pointerout: function (event) {
        // pointerout will be triggered when tap on touch screen
        // (IE11+/Edge on MS Surface) after click event triggered,
        // which is inconsistent with the mousout behavior we defined
        // in touchend. So we unify them.
        // (check localDOMHandlers.touchend for detailed explanation)
        if (!isPointerFromTouch(event)) {
          localDOMHandlers.mouseout.call(this, event);
        }
      }
    };
    /**
     * Othere DOM UI Event handlers for zr dom.
     * @this {HandlerProxy}
     */

    util.each(['click', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
      localDOMHandlers[name] = function (event) {
        event = normalizeEvent$1(this.dom, event);
        this.trigger(name, event);
      };
    });
    /**
     * DOM UI Event handlers for global page.
     *
     * [Caution]:
     * those handlers should both support in capture phase and bubble phase!
     *
     * @this {HandlerProxy}
     */

    var globalDOMHandlers = {
      pointermove: function (event) {
        // FIXME
        // pointermove is so sensitive that it always triggered when
        // tap(click) on touch screen, which affect some judgement in
        // upper application. So, we dont support mousemove on MS touch
        // device yet.
        if (!isPointerFromTouch(event)) {
          globalDOMHandlers.mousemove.call(this, event);
        }
      },
      pointerup: function (event) {
        globalDOMHandlers.mouseup.call(this, event);
      },
      mousemove: function (event) {
        this.trigger('mousemove', event);
      },
      mouseup: function (event) {
        var pointerCaptureReleasing = this._pointerCapturing;
        togglePointerCapture(this, false);
        this.trigger('mouseup', event);

        if (pointerCaptureReleasing) {
          event.zrEventControl = 'only_globalout';
          this.trigger('mouseout', event);
        }
      }
    };
    /**
     * @param {HandlerProxy} instance
     * @param {DOMHandlerScope} scope
     */

    function mountLocalDOMEventListeners(instance, scope) {
      var domHandlers = scope.domHandlers;

      if (env_1.pointerEventsSupported) {
        // Only IE11+/Edge
        // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
        // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
        // at the same time.
        // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
        // screen, which do not occurs in pointer event.
        // So we use pointer event to both detect touch gesture and mouse behavior.
        util.each(localNativeListenerNames.pointer, function (nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function (event) {
            // markTriggeredFromLocal(event);
            domHandlers[nativeEventName].call(instance, event);
          });
        }); // FIXME
        // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
        // which does not prevent defuault behavior occasionally (which may cause view port
        // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
        // So we have to not to use MSGesture and not to support touchmove and pinch on MS
        // touch screen. And we only support click behavior on MS touch screen now.
        // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
        // We dont support touch on IE on win7.
        // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
        // if (typeof MSGesture === 'function') {
        //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
        //     dom.addEventListener('MSGestureChange', onMSGestureChange);
        // }
      } else {
        if (env_1.touchEventsSupported) {
          util.each(localNativeListenerNames.touch, function (nativeEventName) {
            mountSingleDOMEventListener(scope, nativeEventName, function (event) {
              // markTriggeredFromLocal(event);
              domHandlers[nativeEventName].call(instance, event);
              setTouchTimer(scope);
            });
          }); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
          // addEventListener(root, 'mouseout', this._mouseoutHandler);
        } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
        // mouse event can not be handle in those devices.
        // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
        // mouseevent after touch event triggered, see `setTouchTimer`.


        util.each(localNativeListenerNames.mouse, function (nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function (event) {
            event = getNativeEvent$1(event);

            if (!scope.touching) {
              // markTriggeredFromLocal(event);
              domHandlers[nativeEventName].call(instance, event);
            }
          });
        });
      }
    }
    /**
     * @param {HandlerProxy} instance
     * @param {DOMHandlerScope} scope
     */


    function mountGlobalDOMEventListeners(instance, scope) {
      // Only IE11+/Edge. See the comment in `mountLocalDOMEventListeners`.
      if (env_1.pointerEventsSupported) {
        util.each(globalNativeListenerNames.pointer, mount);
      } // Touch event has implemented "drag outside" so we do not mount global listener for touch event.
      // (see https://www.w3.org/TR/touch-events/#the-touchmove-event)
      // We do not consider "both-support-touch-and-mouse device" for this feature (see the comment of
      // `mountLocalDOMEventListeners`) to avoid bugs util some requirements come.
      else if (!env_1.touchEventsSupported) {
          util.each(globalNativeListenerNames.mouse, mount);
        }

      function mount(nativeEventName) {
        function nativeEventListener(event) {
          event = getNativeEvent$1(event); // See the reason in [Drag outside] in `Handler.js`
          // This checking supports both `useCapture` or not.
          // PENDING: if there is performance issue in some devices,
          // we probably can not use `useCapture` and change a easier
          // to judes whether local (mark).

          if (!isLocalEl(instance, event.target)) {
            event = normalizeGlobalEvent(instance, event);
            scope.domHandlers[nativeEventName].call(instance, event);
          }
        }

        mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, {
          capture: true
        } // See [Drag Outside] in `Handler.js`
        );
      }
    }

    function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
      scope.mounted[nativeEventName] = listener;
      scope.listenerOpts[nativeEventName] = opt;
      addEventListener$2(scope.domTarget, eventNameFix(nativeEventName), listener, opt);
    }

    function unmountDOMEventListeners(scope) {
      var mounted = scope.mounted;

      for (var nativeEventName in mounted) {
        if (mounted.hasOwnProperty(nativeEventName)) {
          removeEventListener$2(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
        }
      }

      scope.mounted = {};
    }
    /**
     * See [Drag Outside] in `Handler.js`.
     * @implement
     * @param {boolean} isPointerCapturing Should never be `null`/`undefined`.
     *        `true`: start to capture pointer if it is not capturing.
     *        `false`: end the capture if it is capturing.
     */


    function togglePointerCapture(instance, isPointerCapturing) {
      instance._mayPointerCapture = null;

      if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {
        instance._pointerCapturing = isPointerCapturing;
        var globalHandlerScope = instance._globalHandlerScope;
        isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
      }
    }
    /**
     * @inner
     * @class
     */


    function DOMHandlerScope(domTarget, domHandlers) {
      this.domTarget = domTarget;
      this.domHandlers = domHandlers; // Key: eventName, value: mounted handler funcitons.
      // Used for unmount.

      this.mounted = {};
      this.listenerOpts = {};
      this.touchTimer = null;
      this.touching = false;
    }
    /**
     * @public
     * @class
     */


    function HandlerDomProxy(dom, painterRoot) {
      Eventful_1.call(this);
      this.dom = dom;
      this.painterRoot = painterRoot;
      this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);

      if (globalEventSupported) {
        this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
      }
      /**
       * @type {boolean}
       */


      this._pointerCapturing = false;
      /**
       * @type {Array.<number>} [x, y] or null.
       */

      this._mayPointerCapture = null;
      mountLocalDOMEventListeners(this, this._localHandlerScope);
    }

    var handlerDomProxyProto = HandlerDomProxy.prototype;

    handlerDomProxyProto.dispose = function () {
      unmountDOMEventListeners(this._localHandlerScope);

      if (globalEventSupported) {
        unmountDOMEventListeners(this._globalHandlerScope);
      }
    };

    handlerDomProxyProto.setCursor = function (cursorStyle) {
      this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');
    };

    util.mixin(HandlerDomProxy, Eventful_1);
    var _default$s = HandlerDomProxy;
    var HandlerProxy = _default$s;

    /*!
    * ZRender, a high performance 2d drawing library.
    *
    * Copyright (c) 2013, Baidu Inc.
    * All rights reserved.
    *
    * LICENSE
    * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
    */
    var useVML = !env_1.canvasSupported;
    var painterCtors = {
      canvas: Painter_1
    };
    var instances = {}; // ZRender实例map索引

    /**
     * @type {string}
     */

    var version = '4.3.1';
    /**
     * Initializing a zrender instance
     * @param {HTMLElement} dom
     * @param {Object} [opts]
     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
     * @param {number} [opts.devicePixelRatio]
     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
     * @return {module:zrender/ZRender}
     */

    function init$2(dom, opts) {
      var zr = new ZRender(guid(), dom, opts);
      instances[zr.id] = zr;
      return zr;
    }
    /**
     * Dispose zrender instance
     * @param {module:zrender/ZRender} zr
     */


    function dispose(zr) {
      if (zr) {
        zr.dispose();
      } else {
        for (var key in instances) {
          if (instances.hasOwnProperty(key)) {
            instances[key].dispose();
          }
        }

        instances = {};
      }

      return this;
    }
    /**
     * Get zrender instance by id
     * @param {string} id zrender instance id
     * @return {module:zrender/ZRender}
     */


    function getInstance(id) {
      return instances[id];
    }

    function registerPainter(name, Ctor) {
      painterCtors[name] = Ctor;
    }

    function delInstance(id) {
      delete instances[id];
    }
    /**
     * @module zrender/ZRender
     */

    /**
     * @constructor
     * @alias module:zrender/ZRender
     * @param {string} id
     * @param {HTMLElement} dom
     * @param {Object} opts
     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
     * @param {number} [opts.devicePixelRatio]
     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
     */


    var ZRender = function (id, dom, opts) {
      opts = opts || {};
      /**
       * @type {HTMLDomElement}
       */

      this.dom = dom;
      /**
       * @type {string}
       */

      this.id = id;
      var self = this;
      var storage = new Storage_1();
      var rendererType = opts.renderer; // TODO WebGL

      if (useVML) {
        if (!painterCtors.vml) {
          throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
        }

        rendererType = 'vml';
      } else if (!rendererType || !painterCtors[rendererType]) {
        rendererType = 'canvas';
      }

      var painter = new painterCtors[rendererType](dom, storage, opts, id);
      this.storage = storage;
      this.painter = painter;
      var handerProxy = !env_1.node && !env_1.worker ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;
      this.handler = new Handler_1(storage, painter, handerProxy, painter.root);
      /**
       * @type {module:zrender/animation/Animation}
       */

      this.animation = new Animation_1({
        stage: {
          update: util.bind(this.flush, this)
        }
      });
      this.animation.start();
      /**
       * @type {boolean}
       * @private
       */

      this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
      // FIXME 有点ugly

      var oldDelFromStorage = storage.delFromStorage;
      var oldAddToStorage = storage.addToStorage;

      storage.delFromStorage = function (el) {
        oldDelFromStorage.call(storage, el);
        el && el.removeSelfFromZr(self);
      };

      storage.addToStorage = function (el) {
        oldAddToStorage.call(storage, el);
        el.addSelfToZr(self);
      };
    };

    ZRender.prototype = {
      constructor: ZRender,

      /**
       * 获取实例唯一标识
       * @return {string}
       */
      getId: function () {
        return this.id;
      },

      /**
       * 添加元素
       * @param  {module:zrender/Element} el
       */
      add: function (el) {
        this.storage.addRoot(el);
        this._needsRefresh = true;
      },

      /**
       * 删除元素
       * @param  {module:zrender/Element} el
       */
      remove: function (el) {
        this.storage.delRoot(el);
        this._needsRefresh = true;
      },

      /**
       * Change configuration of layer
       * @param {string} zLevel
       * @param {Object} config
       * @param {string} [config.clearColor=0] Clear color
       * @param {string} [config.motionBlur=false] If enable motion blur
       * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
      */
      configLayer: function (zLevel, config) {
        if (this.painter.configLayer) {
          this.painter.configLayer(zLevel, config);
        }

        this._needsRefresh = true;
      },

      /**
       * Set background color
       * @param {string} backgroundColor
       */
      setBackgroundColor: function (backgroundColor) {
        if (this.painter.setBackgroundColor) {
          this.painter.setBackgroundColor(backgroundColor);
        }

        this._needsRefresh = true;
      },

      /**
       * Repaint the canvas immediately
       */
      refreshImmediately: function () {
        // var start = new Date();
        // Clear needsRefresh ahead to avoid something wrong happens in refresh
        // Or it will cause zrender refreshes again and again.
        this._needsRefresh = this._needsRefreshHover = false;
        this.painter.refresh(); // Avoid trigger zr.refresh in Element#beforeUpdate hook

        this._needsRefresh = this._needsRefreshHover = false; // var end = new Date();
        // var log = document.getElementById('log');
        // if (log) {
        //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
        // }
      },

      /**
       * Mark and repaint the canvas in the next frame of browser
       */
      refresh: function () {
        this._needsRefresh = true;
      },

      /**
       * Perform all refresh
       */
      flush: function () {
        var triggerRendered;

        if (this._needsRefresh) {
          triggerRendered = true;
          this.refreshImmediately();
        }

        if (this._needsRefreshHover) {
          triggerRendered = true;
          this.refreshHoverImmediately();
        }

        triggerRendered && this.trigger('rendered');
      },

      /**
       * Add element to hover layer
       * @param  {module:zrender/Element} el
       * @param {Object} style
       */
      addHover: function (el, style) {
        if (this.painter.addHover) {
          var elMirror = this.painter.addHover(el, style);
          this.refreshHover();
          return elMirror;
        }
      },

      /**
       * Add element from hover layer
       * @param  {module:zrender/Element} el
       */
      removeHover: function (el) {
        if (this.painter.removeHover) {
          this.painter.removeHover(el);
          this.refreshHover();
        }
      },

      /**
       * Clear all hover elements in hover layer
       * @param  {module:zrender/Element} el
       */
      clearHover: function () {
        if (this.painter.clearHover) {
          this.painter.clearHover();
          this.refreshHover();
        }
      },

      /**
       * Refresh hover in next frame
       */
      refreshHover: function () {
        this._needsRefreshHover = true;
      },

      /**
       * Refresh hover immediately
       */
      refreshHoverImmediately: function () {
        this._needsRefreshHover = false;
        this.painter.refreshHover && this.painter.refreshHover();
      },

      /**
       * Resize the canvas.
       * Should be invoked when container size is changed
       * @param {Object} [opts]
       * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
       * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
       */
      resize: function (opts) {
        opts = opts || {};
        this.painter.resize(opts.width, opts.height);
        this.handler.resize();
      },

      /**
       * Stop and clear all animation immediately
       */
      clearAnimation: function () {
        this.animation.clear();
      },

      /**
       * Get container width
       */
      getWidth: function () {
        return this.painter.getWidth();
      },

      /**
       * Get container height
       */
      getHeight: function () {
        return this.painter.getHeight();
      },

      /**
       * Export the canvas as Base64 URL
       * @param {string} type
       * @param {string} [backgroundColor='#fff']
       * @return {string} Base64 URL
       */
      // toDataURL: function(type, backgroundColor) {
      //     return this.painter.getRenderedCanvas({
      //         backgroundColor: backgroundColor
      //     }).toDataURL(type);
      // },

      /**
       * Converting a path to image.
       * It has much better performance of drawing image rather than drawing a vector path.
       * @param {module:zrender/graphic/Path} e
       * @param {number} width
       * @param {number} height
       */
      pathToImage: function (e, dpr) {
        return this.painter.pathToImage(e, dpr);
      },

      /**
       * Set default cursor
       * @param {string} [cursorStyle='default'] 例如 crosshair
       */
      setCursorStyle: function (cursorStyle) {
        this.handler.setCursorStyle(cursorStyle);
      },

      /**
       * Find hovered element
       * @param {number} x
       * @param {number} y
       * @return {Object} {target, topTarget}
       */
      findHover: function (x, y) {
        return this.handler.findHover(x, y);
      },

      /**
       * Bind event
       *
       * @param {string} eventName Event name
       * @param {Function} eventHandler Handler function
       * @param {Object} [context] Context object
       */
      on: function (eventName, eventHandler, context) {
        this.handler.on(eventName, eventHandler, context);
      },

      /**
       * Unbind event
       * @param {string} eventName Event name
       * @param {Function} [eventHandler] Handler function
       */
      off: function (eventName, eventHandler) {
        this.handler.off(eventName, eventHandler);
      },

      /**
       * Trigger event manually
       *
       * @param {string} eventName Event name
       * @param {event=} event Event object
       */
      trigger: function (eventName, event) {
        this.handler.trigger(eventName, event);
      },

      /**
       * Clear all objects and the canvas.
       */
      clear: function () {
        this.storage.delRoot();
        this.painter.clear();
      },

      /**
       * Dispose self.
       */
      dispose: function () {
        this.animation.stop();
        this.clear();
        this.storage.dispose();
        this.painter.dispose();
        this.handler.dispose();
        this.animation = this.storage = this.painter = this.handler = null;
        delInstance(this.id);
      }
    };
    var version_1 = version;
    var init_1 = init$2;
    var dispose_1 = dispose;
    var getInstance_1 = getInstance;
    var registerPainter_1 = registerPainter;

    var zrender = {
    	version: version_1,
    	init: init_1,
    	dispose: dispose_1,
    	getInstance: getInstance_1,
    	registerPainter: registerPainter_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var each$2 = util.each;
    var isObject$4 = util.isObject;
    var isArray$2 = util.isArray;
    /**
     * Make the name displayable. But we should
     * make sure it is not duplicated with user
     * specified name, so use '\0';
     */

    var DUMMY_COMPONENT_NAME_PREFIX = 'series\0';
    /**
     * If value is not array, then translate it to array.
     * @param  {*} value
     * @return {Array} [value] or value
     */

    function normalizeToArray(value) {
      return value instanceof Array ? value : value == null ? [] : [value];
    }
    /**
     * Sync default option between normal and emphasis like `position` and `show`
     * In case some one will write code like
     *     label: {
     *          show: false,
     *          position: 'outside',
     *          fontSize: 18
     *     },
     *     emphasis: {
     *          label: { show: true }
     *     }
     * @param {Object} opt
     * @param {string} key
     * @param {Array.<string>} subOpts
     */


    function defaultEmphasis(opt, key, subOpts) {
      // Caution: performance sensitive.
      if (opt) {
        opt[key] = opt[key] || {};
        opt.emphasis = opt.emphasis || {};
        opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal

        for (var i = 0, len = subOpts.length; i < len; i++) {
          var subOptName = subOpts[i];

          if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
            opt.emphasis[key][subOptName] = opt[key][subOptName];
          }
        }
      }
    }

    var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([
    //     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',
    //     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',
    //     // FIXME: deprecated, check and remove it.
    //     'textStyle'
    // ]);

    /**
     * The method do not ensure performance.
     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
     * This helper method retieves value from data.
     * @param {string|number|Date|Array|Object} dataItem
     * @return {number|string|Date|Array.<number|string|Date>}
     */

    function getDataItemValue(dataItem) {
      return isObject$4(dataItem) && !isArray$2(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
    }
    /**
     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
     * This helper method determine if dataItem has extra option besides value
     * @param {string|number|Date|Array|Object} dataItem
     */


    function isDataItemOption(dataItem) {
      return isObject$4(dataItem) && !(dataItem instanceof Array); // // markLine data can be array
      // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
    }
    /**
     * Mapping to exists for merge.
     *
     * @public
     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists
     * @param {Object|Array.<Object>} newCptOptions
     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
     *                          index of which is the same as exists.
     */


    function mappingToExists(exists, newCptOptions) {
      // Mapping by the order by original option (but not order of
      // new option) in merge mode. Because we should ensure
      // some specified index (like xAxisIndex) is consistent with
      // original option, which is easy to understand, espatially in
      // media query. And in most case, merge option is used to
      // update partial option but not be expected to change order.
      newCptOptions = (newCptOptions || []).slice();
      var result = util.map(exists || [], function (obj, index) {
        return {
          exist: obj
        };
      }); // Mapping by id or name if specified.

      each$2(newCptOptions, function (cptOption, index) {
        if (!isObject$4(cptOption)) {
          return;
        } // id has highest priority.


        for (var i = 0; i < result.length; i++) {
          if (!result[i].option // Consider name: two map to one.
          && cptOption.id != null && result[i].exist.id === cptOption.id + '') {
            result[i].option = cptOption;
            newCptOptions[index] = null;
            return;
          }
        }

        for (var i = 0; i < result.length; i++) {
          var exist = result[i].exist;

          if (!result[i].option // Consider name: two map to one.
          // Can not match when both ids exist but different.
          && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {
            result[i].option = cptOption;
            newCptOptions[index] = null;
            return;
          }
        }
      }); // Otherwise mapping by index.

      each$2(newCptOptions, function (cptOption, index) {
        if (!isObject$4(cptOption)) {
          return;
        }

        var i = 0;

        for (; i < result.length; i++) {
          var exist = result[i].exist;

          if (!result[i].option // Existing model that already has id should be able to
          // mapped to (because after mapping performed model may
          // be assigned with a id, whish should not affect next
          // mapping), except those has inner id.
          && !isIdInner(exist) // Caution:
          // Do not overwrite id. But name can be overwritten,
          // because axis use name as 'show label text'.
          // 'exist' always has id and name and we dont
          // need to check it.
          && cptOption.id == null) {
            result[i].option = cptOption;
            break;
          }
        }

        if (i >= result.length) {
          result.push({
            option: cptOption
          });
        }
      });
      return result;
    }
    /**
     * Make id and name for mapping result (result of mappingToExists)
     * into `keyInfo` field.
     *
     * @public
     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
     *                          which order is the same as exists.
     * @return {Array.<Object>} The input.
     */


    function makeIdAndName(mapResult) {
      // We use this id to hash component models and view instances
      // in echarts. id can be specified by user, or auto generated.
      // The id generation rule ensures new view instance are able
      // to mapped to old instance when setOption are called in
      // no-merge mode. So we generate model id by name and plus
      // type in view id.
      // name can be duplicated among components, which is convenient
      // to specify multi components (like series) by one name.
      // Ensure that each id is distinct.
      var idMap = util.createHashMap();
      each$2(mapResult, function (item, index) {
        var existCpt = item.exist;
        existCpt && idMap.set(existCpt.id, item);
      });
      each$2(mapResult, function (item, index) {
        var opt = item.option;
        util.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));
        opt && opt.id != null && idMap.set(opt.id, item);
        !item.keyInfo && (item.keyInfo = {});
      }); // Make name and id.

      each$2(mapResult, function (item, index) {
        var existCpt = item.exist;
        var opt = item.option;
        var keyInfo = item.keyInfo;

        if (!isObject$4(opt)) {
          return;
        } // name can be overwitten. Consider case: axis.name = '20km'.
        // But id generated by name will not be changed, which affect
        // only in that case: setOption with 'not merge mode' and view
        // instance will be recreated, which can be accepted.


        keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name // Avoid diffferent series has the same name,
        // because name may be used like in color pallet.
        : DUMMY_COMPONENT_NAME_PREFIX + index;

        if (existCpt) {
          keyInfo.id = existCpt.id;
        } else if (opt.id != null) {
          keyInfo.id = opt.id + '';
        } else {
          // Consider this situatoin:
          //  optionA: [{name: 'a'}, {name: 'a'}, {..}]
          //  optionB [{..}, {name: 'a'}, {name: 'a'}]
          // Series with the same name between optionA and optionB
          // should be mapped.
          var idNum = 0;

          do {
            keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
          } while (idMap.get(keyInfo.id));
        }

        idMap.set(keyInfo.id, item);
      });
    }

    function isNameSpecified(componentModel) {
      var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.

      return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
    }
    /**
     * @public
     * @param {Object} cptOption
     * @return {boolean}
     */


    function isIdInner(cptOption) {
      return isObject$4(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\0_ec_\0') === 0;
    }
    /**
     * A helper for removing duplicate items between batchA and batchB,
     * and in themselves, and categorize by series.
     *
     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]
     */


    function compressBatches(batchA, batchB) {
      var mapA = {};
      var mapB = {};
      makeMap(batchA || [], mapA);
      makeMap(batchB || [], mapB, mapA);
      return [mapToArray(mapA), mapToArray(mapB)];

      function makeMap(sourceBatch, map, otherMap) {
        for (var i = 0, len = sourceBatch.length; i < len; i++) {
          var seriesId = sourceBatch[i].seriesId;
          var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
          var otherDataIndices = otherMap && otherMap[seriesId];

          for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
            var dataIndex = dataIndices[j];

            if (otherDataIndices && otherDataIndices[dataIndex]) {
              otherDataIndices[dataIndex] = null;
            } else {
              (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
            }
          }
        }
      }

      function mapToArray(map, isData) {
        var result = [];

        for (var i in map) {
          if (map.hasOwnProperty(i) && map[i] != null) {
            if (isData) {
              result.push(+i);
            } else {
              var dataIndices = mapToArray(map[i], true);
              dataIndices.length && result.push({
                seriesId: i,
                dataIndex: dataIndices
              });
            }
          }
        }

        return result;
      }
    }
    /**
     * @param {module:echarts/data/List} data
     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name
     *                         each of which can be Array or primary type.
     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.
     */


    function queryDataIndex(data, payload) {
      if (payload.dataIndexInside != null) {
        return payload.dataIndexInside;
      } else if (payload.dataIndex != null) {
        return util.isArray(payload.dataIndex) ? util.map(payload.dataIndex, function (value) {
          return data.indexOfRawIndex(value);
        }) : data.indexOfRawIndex(payload.dataIndex);
      } else if (payload.name != null) {
        return util.isArray(payload.name) ? util.map(payload.name, function (value) {
          return data.indexOfName(value);
        }) : data.indexOfName(payload.name);
      }
    }
    /**
     * Enable property storage to any host object.
     * Notice: Serialization is not supported.
     *
     * For example:
     * var inner = zrUitl.makeInner();
     *
     * function some1(hostObj) {
     *      inner(hostObj).someProperty = 1212;
     *      ...
     * }
     * function some2() {
     *      var fields = inner(this);
     *      fields.someProperty1 = 1212;
     *      fields.someProperty2 = 'xx';
     *      ...
     * }
     *
     * @return {Function}
     */


    function makeInner() {
      // Consider different scope by es module import.
      var key = '__\0ec_inner_' + innerUniqueIndex++ + '_' + Math.random().toFixed(5);
      return function (hostObj) {
        return hostObj[key] || (hostObj[key] = {});
      };
    }

    var innerUniqueIndex = 0;
    /**
     * @param {module:echarts/model/Global} ecModel
     * @param {string|Object} finder
     *        If string, e.g., 'geo', means {geoIndex: 0}.
     *        If Object, could contain some of these properties below:
     *        {
     *            seriesIndex, seriesId, seriesName,
     *            geoIndex, geoId, geoName,
     *            bmapIndex, bmapId, bmapName,
     *            xAxisIndex, xAxisId, xAxisName,
     *            yAxisIndex, yAxisId, yAxisName,
     *            gridIndex, gridId, gridName,
     *            ... (can be extended)
     *        }
     *        Each properties can be number|string|Array.<number>|Array.<string>
     *        For example, a finder could be
     *        {
     *            seriesIndex: 3,
     *            geoId: ['aa', 'cc'],
     *            gridName: ['xx', 'rr']
     *        }
     *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)
     *        If nothing or null/undefined specified, return nothing.
     * @param {Object} [opt]
     * @param {string} [opt.defaultMainType]
     * @param {Array.<string>} [opt.includeMainTypes]
     * @return {Object} result like:
     *        {
     *            seriesModels: [seriesModel1, seriesModel2],
     *            seriesModel: seriesModel1, // The first model
     *            geoModels: [geoModel1, geoModel2],
     *            geoModel: geoModel1, // The first model
     *            ...
     *        }
     */

    function parseFinder(ecModel, finder, opt) {
      if (util.isString(finder)) {
        var obj = {};
        obj[finder + 'Index'] = 0;
        finder = obj;
      }

      var defaultMainType = opt && opt.defaultMainType;

      if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name')) {
        finder[defaultMainType + 'Index'] = 0;
      }

      var result = {};
      each$2(finder, function (value, key) {
        var value = finder[key]; // Exclude 'dataIndex' and other illgal keys.

        if (key === 'dataIndex' || key === 'dataIndexInside') {
          result[key] = value;
          return;
        }

        var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
        var mainType = parsedKey[1];
        var queryType = (parsedKey[2] || '').toLowerCase();

        if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && util.indexOf(opt.includeMainTypes, mainType) < 0) {
          return;
        }

        var queryParam = {
          mainType: mainType
        };

        if (queryType !== 'index' || value !== 'all') {
          queryParam[queryType] = value;
        }

        var models = ecModel.queryComponents(queryParam);
        result[mainType + 'Models'] = models;
        result[mainType + 'Model'] = models[0];
      });
      return result;
    }

    function has(obj, prop) {
      return obj && obj.hasOwnProperty(prop);
    }

    function setAttribute(dom, key, value) {
      dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
    }

    function getAttribute(dom, key) {
      return dom.getAttribute ? dom.getAttribute(key) : dom[key];
    }

    function getTooltipRenderMode(renderModeOption) {
      if (renderModeOption === 'auto') {
        // Using html when `document` exists, use richText otherwise
        return env_1.domSupported ? 'html' : 'richText';
      } else {
        return renderModeOption || 'html';
      }
    }
    /**
     * Group a list by key.
     *
     * @param {Array} array
     * @param {Function} getKey
     *        param {*} Array item
     *        return {string} key
     * @return {Object} Result
     *        {Array}: keys,
     *        {module:zrender/core/util/HashMap} buckets: {key -> Array}
     */


    function groupData(array, getKey) {
      var buckets = util.createHashMap();
      var keys = [];
      util.each(array, function (item) {
        var key = getKey(item);
        (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);
      });
      return {
        keys: keys,
        buckets: buckets
      };
    }

    var normalizeToArray_1 = normalizeToArray;
    var defaultEmphasis_1 = defaultEmphasis;
    var TEXT_STYLE_OPTIONS_1 = TEXT_STYLE_OPTIONS;
    var getDataItemValue_1 = getDataItemValue;
    var isDataItemOption_1 = isDataItemOption;
    var mappingToExists_1 = mappingToExists;
    var makeIdAndName_1 = makeIdAndName;
    var isNameSpecified_1 = isNameSpecified;
    var isIdInner_1 = isIdInner;
    var compressBatches_1 = compressBatches;
    var queryDataIndex_1 = queryDataIndex;
    var makeInner_1 = makeInner;
    var parseFinder_1 = parseFinder;
    var setAttribute_1 = setAttribute;
    var getAttribute_1 = getAttribute;
    var getTooltipRenderMode_1 = getTooltipRenderMode;
    var groupData_1 = groupData;

    var model = {
    	normalizeToArray: normalizeToArray_1,
    	defaultEmphasis: defaultEmphasis_1,
    	TEXT_STYLE_OPTIONS: TEXT_STYLE_OPTIONS_1,
    	getDataItemValue: getDataItemValue_1,
    	isDataItemOption: isDataItemOption_1,
    	mappingToExists: mappingToExists_1,
    	makeIdAndName: makeIdAndName_1,
    	isNameSpecified: isNameSpecified_1,
    	isIdInner: isIdInner_1,
    	compressBatches: compressBatches_1,
    	queryDataIndex: queryDataIndex_1,
    	makeInner: makeInner_1,
    	parseFinder: parseFinder_1,
    	setAttribute: setAttribute_1,
    	getAttribute: getAttribute_1,
    	getTooltipRenderMode: getTooltipRenderMode_1,
    	groupData: groupData_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var TYPE_DELIMITER = '.';
    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
    /**
     * Notice, parseClassType('') should returns {main: '', sub: ''}
     * @public
     */

    function parseClassType(componentType) {
      var ret = {
        main: '',
        sub: ''
      };

      if (componentType) {
        componentType = componentType.split(TYPE_DELIMITER);
        ret.main = componentType[0] || '';
        ret.sub = componentType[1] || '';
      }

      return ret;
    }
    /**
     * @public
     */


    function checkClassType(componentType) {
      util.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
    }
    /**
     * @public
     */


    function enableClassExtend(RootClass, mandatoryMethods) {
      RootClass.$constructor = RootClass;

      RootClass.extend = function (proto) {
        var superClass = this;

        var ExtendedClass = function () {
          if (!proto.$constructor) {
            superClass.apply(this, arguments);
          } else {
            proto.$constructor.apply(this, arguments);
          }
        };

        util.extend(ExtendedClass.prototype, proto);
        ExtendedClass.extend = this.extend;
        ExtendedClass.superCall = superCall;
        ExtendedClass.superApply = superApply;
        util.inherits(ExtendedClass, this);
        ExtendedClass.superClass = superClass;
        return ExtendedClass;
      };
    }

    var classBase = 0;
    /**
     * Can not use instanceof, consider different scope by
     * cross domain or es module import in ec extensions.
     * Mount a method "isInstance()" to Clz.
     */

    function enableClassCheck(Clz) {
      var classAttr = ['__\0is_clz', classBase++, Math.random().toFixed(3)].join('_');
      Clz.prototype[classAttr] = true;

      Clz.isInstance = function (obj) {
        return !!(obj && obj[classAttr]);
      };
    } // superCall should have class info, which can not be fetch from 'this'.
    // Consider this case:
    // class A has method f,
    // class B inherits class A, overrides method f, f call superApply('f'),
    // class C inherits class B, do not overrides method f,
    // then when method of class C is called, dead loop occured.


    function superCall(context, methodName) {
      var args = util.slice(arguments, 2);
      return this.superClass.prototype[methodName].apply(context, args);
    }

    function superApply(context, methodName, args) {
      return this.superClass.prototype[methodName].apply(context, args);
    }
    /**
     * @param {Object} entity
     * @param {Object} options
     * @param {boolean} [options.registerWhenExtend]
     * @public
     */


    function enableClassManagement(entity, options) {
      options = options || {};
      /**
       * Component model classes
       * key: componentType,
       * value:
       *     componentClass, when componentType is 'xxx'
       *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
       * @type {Object}
       */

      var storage = {};

      entity.registerClass = function (Clazz, componentType) {
        if (componentType) {
          checkClassType(componentType);
          componentType = parseClassType(componentType);

          if (!componentType.sub) {
            storage[componentType.main] = Clazz;
          } else if (componentType.sub !== IS_CONTAINER) {
            var container = makeContainer(componentType);
            container[componentType.sub] = Clazz;
          }
        }

        return Clazz;
      };

      entity.getClass = function (componentMainType, subType, throwWhenNotFound) {
        var Clazz = storage[componentMainType];

        if (Clazz && Clazz[IS_CONTAINER]) {
          Clazz = subType ? Clazz[subType] : null;
        }

        if (throwWhenNotFound && !Clazz) {
          throw new Error(!subType ? componentMainType + '.' + 'type should be specified.' : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.');
        }

        return Clazz;
      };

      entity.getClassesByMainType = function (componentType) {
        componentType = parseClassType(componentType);
        var result = [];
        var obj = storage[componentType.main];

        if (obj && obj[IS_CONTAINER]) {
          util.each(obj, function (o, type) {
            type !== IS_CONTAINER && result.push(o);
          });
        } else {
          result.push(obj);
        }

        return result;
      };

      entity.hasClass = function (componentType) {
        // Just consider componentType.main.
        componentType = parseClassType(componentType);
        return !!storage[componentType.main];
      };
      /**
       * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
       */


      entity.getAllClassMainTypes = function () {
        var types = [];
        util.each(storage, function (obj, type) {
          types.push(type);
        });
        return types;
      };
      /**
       * If a main type is container and has sub types
       * @param  {string}  mainType
       * @return {boolean}
       */


      entity.hasSubTypes = function (componentType) {
        componentType = parseClassType(componentType);
        var obj = storage[componentType.main];
        return obj && obj[IS_CONTAINER];
      };

      entity.parseClassType = parseClassType;

      function makeContainer(componentType) {
        var container = storage[componentType.main];

        if (!container || !container[IS_CONTAINER]) {
          container = storage[componentType.main] = {};
          container[IS_CONTAINER] = true;
        }

        return container;
      }

      if (options.registerWhenExtend) {
        var originalExtend = entity.extend;

        if (originalExtend) {
          entity.extend = function (proto) {
            var ExtendedClass = originalExtend.call(this, proto);
            return entity.registerClass(ExtendedClass, proto.type);
          };
        }
      }

      return entity;
    }
    /**
     * @param {string|Array.<string>} properties
     */


    function setReadOnly(obj, properties) {// FIXME It seems broken in IE8 simulation of IE11
      // if (!zrUtil.isArray(properties)) {
      //     properties = properties != null ? [properties] : [];
      // }
      // zrUtil.each(properties, function (prop) {
      //     var value = obj[prop];
      //     Object.defineProperty
      //         && Object.defineProperty(obj, prop, {
      //             value: value, writable: false
      //         });
      //     zrUtil.isArray(obj[prop])
      //         && Object.freeze
      //         && Object.freeze(obj[prop]);
      // });
    }

    var parseClassType_1 = parseClassType;
    var enableClassExtend_1 = enableClassExtend;
    var enableClassCheck_1 = enableClassCheck;
    var enableClassManagement_1 = enableClassManagement;
    var setReadOnly_1 = setReadOnly;

    var clazz = {
    	parseClassType: parseClassType_1,
    	enableClassExtend: enableClassExtend_1,
    	enableClassCheck: enableClassCheck_1,
    	enableClassManagement: enableClassManagement_1,
    	setReadOnly: setReadOnly_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // TODO Parse shadow style
    // TODO Only shallow path support
    function _default$t(properties) {
      // Normalize
      for (var i = 0; i < properties.length; i++) {
        if (!properties[i][1]) {
          properties[i][1] = properties[i][0];
        }
      }

      return function (model, excludes, includes) {
        var style = {};

        for (var i = 0; i < properties.length; i++) {
          var propName = properties[i][1];

          if (excludes && util.indexOf(excludes, propName) >= 0 || includes && util.indexOf(includes, propName) < 0) {
            continue;
          }

          var val = model.getShallow(propName);

          if (val != null) {
            style[properties[i][0]] = val;
          }
        }

        return style;
      };
    }

    var makeStyleMapper = _default$t;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var getLineStyle = makeStyleMapper([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
    var _default$u = {
      getLineStyle: function (excludes) {
        var style = getLineStyle(this, excludes); // Always set lineDash whether dashed, otherwise we can not
        // erase the previous style when assigning to el.style.

        style.lineDash = this.getLineDash(style.lineWidth);
        return style;
      },
      getLineDash: function (lineWidth) {
        if (lineWidth == null) {
          lineWidth = 1;
        }

        var lineType = this.get('type');
        var dotSize = Math.max(lineWidth, 2);
        var dashSize = lineWidth * 4;
        return lineType === 'solid' || lineType == null ? // Use `false` but not `null` for the solid line here, because `null` might be
        // ignored when assigning to `el.style`. e.g., when setting `lineStyle.type` as
        // `'dashed'` and `emphasis.lineStyle.type` as `'solid'` in graph series, the
        // `lineDash` gotten form the latter one is not able to erase that from the former
        // one if using `null` here according to the emhpsis strategy in `util/graphic.js`.
        false : lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize];
      }
    };
    var lineStyle = _default$u;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var getAreaStyle = makeStyleMapper([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]);
    var _default$v = {
      getAreaStyle: function (excludes, includes) {
        return getAreaStyle(this, excludes, includes);
      }
    };
    var areaStyle = _default$v;

    var v2Create = vector.create;
    var v2DistSquare = vector.distSquare;

    /**
     * 曲线辅助模块
     * @module zrender/core/curve
     * @author pissang(https://www.github.com/pissang)
     */
    var mathPow = Math.pow;
    var mathSqrt = Math.sqrt;
    var EPSILON$1 = 1e-8;
    var EPSILON_NUMERIC = 1e-4;
    var THREE_SQRT = mathSqrt(3);
    var ONE_THIRD = 1 / 3; // 临时变量

    var _v0 = v2Create();

    var _v1 = v2Create();

    var _v2 = v2Create();

    function isAroundZero(val) {
      return val > -EPSILON$1 && val < EPSILON$1;
    }

    function isNotAroundZero$1(val) {
      return val > EPSILON$1 || val < -EPSILON$1;
    }
    /**
     * 计算三次贝塞尔值
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @return {number}
     */


    function cubicAt(p0, p1, p2, p3, t) {
      var onet = 1 - t;
      return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
    }
    /**
     * 计算三次贝塞尔导数值
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @return {number}
     */


    function cubicDerivativeAt(p0, p1, p2, p3, t) {
      var onet = 1 - t;
      return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
    }
    /**
     * 计算三次贝塞尔方程根，使用盛金公式
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} val
     * @param  {Array.<number>} roots
     * @return {number} 有效根数目
     */


    function cubicRootAt(p0, p1, p2, p3, val, roots) {
      // Evaluate roots of cubic functions
      var a = p3 + 3 * (p1 - p2) - p0;
      var b = 3 * (p2 - p1 * 2 + p0);
      var c = 3 * (p1 - p0);
      var d = p0 - val;
      var A = b * b - 3 * a * c;
      var B = b * c - 9 * a * d;
      var C = c * c - 3 * b * d;
      var n = 0;

      if (isAroundZero(A) && isAroundZero(B)) {
        if (isAroundZero(b)) {
          roots[0] = 0;
        } else {
          var t1 = -c / b; //t1, t2, t3, b is not zero

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        }
      } else {
        var disc = B * B - 4 * A * C;

        if (isAroundZero(disc)) {
          var K = B / A;
          var t1 = -b / a + K; // t1, a is not zero

          var t2 = -K / 2; // t2, t3

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }

          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var Y1 = A * b + 1.5 * a * (-B + discSqrt);
          var Y2 = A * b + 1.5 * a * (-B - discSqrt);

          if (Y1 < 0) {
            Y1 = -mathPow(-Y1, ONE_THIRD);
          } else {
            Y1 = mathPow(Y1, ONE_THIRD);
          }

          if (Y2 < 0) {
            Y2 = -mathPow(-Y2, ONE_THIRD);
          } else {
            Y2 = mathPow(Y2, ONE_THIRD);
          }

          var t1 = (-b - (Y1 + Y2)) / (3 * a);

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        } else {
          var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
          var theta = Math.acos(T) / 3;
          var ASqrt = mathSqrt(A);
          var tmp = Math.cos(theta);
          var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
          var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
          var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }

          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }

          if (t3 >= 0 && t3 <= 1) {
            roots[n++] = t3;
          }
        }
      }

      return n;
    }
    /**
     * 计算三次贝塞尔方程极限值的位置
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {Array.<number>} extrema
     * @return {number} 有效数目
     */


    function cubicExtrema(p0, p1, p2, p3, extrema) {
      var b = 6 * p2 - 12 * p1 + 6 * p0;
      var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
      var c = 3 * p1 - 3 * p0;
      var n = 0;

      if (isAroundZero(a)) {
        if (isNotAroundZero$1(b)) {
          var t1 = -c / b;

          if (t1 >= 0 && t1 <= 1) {
            extrema[n++] = t1;
          }
        }
      } else {
        var disc = b * b - 4 * a * c;

        if (isAroundZero(disc)) {
          extrema[0] = -b / (2 * a);
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var t1 = (-b + discSqrt) / (2 * a);
          var t2 = (-b - discSqrt) / (2 * a);

          if (t1 >= 0 && t1 <= 1) {
            extrema[n++] = t1;
          }

          if (t2 >= 0 && t2 <= 1) {
            extrema[n++] = t2;
          }
        }
      }

      return n;
    }
    /**
     * 细分三次贝塞尔曲线
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @param  {Array.<number>} out
     */


    function cubicSubdivide(p0, p1, p2, p3, t, out) {
      var p01 = (p1 - p0) * t + p0;
      var p12 = (p2 - p1) * t + p1;
      var p23 = (p3 - p2) * t + p2;
      var p012 = (p12 - p01) * t + p01;
      var p123 = (p23 - p12) * t + p12;
      var p0123 = (p123 - p012) * t + p012; // Seg0

      out[0] = p0;
      out[1] = p01;
      out[2] = p012;
      out[3] = p0123; // Seg1

      out[4] = p0123;
      out[5] = p123;
      out[6] = p23;
      out[7] = p3;
    }
    /**
     * 投射点到三次贝塞尔曲线上，返回投射距离。
     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {number} x
     * @param {number} y
     * @param {Array.<number>} [out] 投射点
     * @return {number}
     */


    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
      // http://pomax.github.io/bezierinfo/#projections
      var t;
      var interval = 0.005;
      var d = Infinity;
      var prev;
      var next;
      var d1;
      var d2;
      _v0[0] = x;
      _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
      // PENDING

      for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = cubicAt(x0, x1, x2, x3, _t);
        _v1[1] = cubicAt(y0, y1, y2, y3, _t);
        d1 = v2DistSquare(_v0, _v1);

        if (d1 < d) {
          t = _t;
          d = d1;
        }
      }

      d = Infinity; // At most 32 iteration

      for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
          break;
        }

        prev = t - interval;
        next = t + interval; // t - interval

        _v1[0] = cubicAt(x0, x1, x2, x3, prev);
        _v1[1] = cubicAt(y0, y1, y2, y3, prev);
        d1 = v2DistSquare(_v1, _v0);

        if (prev >= 0 && d1 < d) {
          t = prev;
          d = d1;
        } else {
          // t + interval
          _v2[0] = cubicAt(x0, x1, x2, x3, next);
          _v2[1] = cubicAt(y0, y1, y2, y3, next);
          d2 = v2DistSquare(_v2, _v0);

          if (next <= 1 && d2 < d) {
            t = next;
            d = d2;
          } else {
            interval *= 0.5;
          }
        }
      } // t


      if (out) {
        out[0] = cubicAt(x0, x1, x2, x3, t);
        out[1] = cubicAt(y0, y1, y2, y3, t);
      } // console.log(interval, i);


      return mathSqrt(d);
    }
    /**
     * 计算二次方贝塞尔值
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @return {number}
     */


    function quadraticAt(p0, p1, p2, t) {
      var onet = 1 - t;
      return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
    }
    /**
     * 计算二次方贝塞尔导数值
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @return {number}
     */


    function quadraticDerivativeAt(p0, p1, p2, t) {
      return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
    }
    /**
     * 计算二次方贝塞尔方程根
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @param  {Array.<number>} roots
     * @return {number} 有效根数目
     */


    function quadraticRootAt(p0, p1, p2, val, roots) {
      var a = p0 - 2 * p1 + p2;
      var b = 2 * (p1 - p0);
      var c = p0 - val;
      var n = 0;

      if (isAroundZero(a)) {
        if (isNotAroundZero$1(b)) {
          var t1 = -c / b;

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        }
      } else {
        var disc = b * b - 4 * a * c;

        if (isAroundZero(disc)) {
          var t1 = -b / (2 * a);

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var t1 = (-b + discSqrt) / (2 * a);
          var t2 = (-b - discSqrt) / (2 * a);

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }

          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }
        }
      }

      return n;
    }
    /**
     * 计算二次贝塞尔方程极限值
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @return {number}
     */


    function quadraticExtremum(p0, p1, p2) {
      var divider = p0 + p2 - 2 * p1;

      if (divider === 0) {
        // p1 is center of p0 and p2
        return 0.5;
      } else {
        return (p0 - p1) / divider;
      }
    }
    /**
     * 细分二次贝塞尔曲线
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @param  {Array.<number>} out
     */


    function quadraticSubdivide(p0, p1, p2, t, out) {
      var p01 = (p1 - p0) * t + p0;
      var p12 = (p2 - p1) * t + p1;
      var p012 = (p12 - p01) * t + p01; // Seg0

      out[0] = p0;
      out[1] = p01;
      out[2] = p012; // Seg1

      out[3] = p012;
      out[4] = p12;
      out[5] = p2;
    }
    /**
     * 投射点到二次贝塞尔曲线上，返回投射距离。
     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x
     * @param {number} y
     * @param {Array.<number>} out 投射点
     * @return {number}
     */


    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
      // http://pomax.github.io/bezierinfo/#projections
      var t;
      var interval = 0.005;
      var d = Infinity;
      _v0[0] = x;
      _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
      // PENDING

      for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = quadraticAt(x0, x1, x2, _t);
        _v1[1] = quadraticAt(y0, y1, y2, _t);
        var d1 = v2DistSquare(_v0, _v1);

        if (d1 < d) {
          t = _t;
          d = d1;
        }
      }

      d = Infinity; // At most 32 iteration

      for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
          break;
        }

        var prev = t - interval;
        var next = t + interval; // t - interval

        _v1[0] = quadraticAt(x0, x1, x2, prev);
        _v1[1] = quadraticAt(y0, y1, y2, prev);
        var d1 = v2DistSquare(_v1, _v0);

        if (prev >= 0 && d1 < d) {
          t = prev;
          d = d1;
        } else {
          // t + interval
          _v2[0] = quadraticAt(x0, x1, x2, next);
          _v2[1] = quadraticAt(y0, y1, y2, next);
          var d2 = v2DistSquare(_v2, _v0);

          if (next <= 1 && d2 < d) {
            t = next;
            d = d2;
          } else {
            interval *= 0.5;
          }
        }
      } // t


      if (out) {
        out[0] = quadraticAt(x0, x1, x2, t);
        out[1] = quadraticAt(y0, y1, y2, t);
      } // console.log(interval, i);


      return mathSqrt(d);
    }

    var cubicAt_1 = cubicAt;
    var cubicDerivativeAt_1 = cubicDerivativeAt;
    var cubicRootAt_1 = cubicRootAt;
    var cubicExtrema_1 = cubicExtrema;
    var cubicSubdivide_1 = cubicSubdivide;
    var cubicProjectPoint_1 = cubicProjectPoint;
    var quadraticAt_1 = quadraticAt;
    var quadraticDerivativeAt_1 = quadraticDerivativeAt;
    var quadraticRootAt_1 = quadraticRootAt;
    var quadraticExtremum_1 = quadraticExtremum;
    var quadraticSubdivide_1 = quadraticSubdivide;
    var quadraticProjectPoint_1 = quadraticProjectPoint;

    var curve = {
    	cubicAt: cubicAt_1,
    	cubicDerivativeAt: cubicDerivativeAt_1,
    	cubicRootAt: cubicRootAt_1,
    	cubicExtrema: cubicExtrema_1,
    	cubicSubdivide: cubicSubdivide_1,
    	cubicProjectPoint: cubicProjectPoint_1,
    	quadraticAt: quadraticAt_1,
    	quadraticDerivativeAt: quadraticDerivativeAt_1,
    	quadraticRootAt: quadraticRootAt_1,
    	quadraticExtremum: quadraticExtremum_1,
    	quadraticSubdivide: quadraticSubdivide_1,
    	quadraticProjectPoint: quadraticProjectPoint_1
    };

    /**
     * @author Yi Shen(https://github.com/pissang)
     */
    var mathMin$1 = Math.min;
    var mathMax$1 = Math.max;
    var mathSin = Math.sin;
    var mathCos = Math.cos;
    var PI2 = Math.PI * 2;
    var start = vector.create();
    var end = vector.create();
    var extremity = vector.create();
    /**
     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
     * @module zrender/core/bbox
     * @param {Array<Object>} points 顶点数组
     * @param {number} min
     * @param {number} max
     */

    function fromPoints(points, min, max) {
      if (points.length === 0) {
        return;
      }

      var p = points[0];
      var left = p[0];
      var right = p[0];
      var top = p[1];
      var bottom = p[1];
      var i;

      for (i = 1; i < points.length; i++) {
        p = points[i];
        left = mathMin$1(left, p[0]);
        right = mathMax$1(right, p[0]);
        top = mathMin$1(top, p[1]);
        bottom = mathMax$1(bottom, p[1]);
      }

      min[0] = left;
      min[1] = top;
      max[0] = right;
      max[1] = bottom;
    }
    /**
     * @memberOf module:zrender/core/bbox
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {Array.<number>} min
     * @param {Array.<number>} max
     */


    function fromLine(x0, y0, x1, y1, min, max) {
      min[0] = mathMin$1(x0, x1);
      min[1] = mathMin$1(y0, y1);
      max[0] = mathMax$1(x0, x1);
      max[1] = mathMax$1(y0, y1);
    }

    var xDim = [];
    var yDim = [];
    /**
     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
     * @memberOf module:zrender/core/bbox
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {Array.<number>} min
     * @param {Array.<number>} max
     */

    function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
      var cubicExtrema = curve.cubicExtrema;
      var cubicAt = curve.cubicAt;
      var i;
      var n = cubicExtrema(x0, x1, x2, x3, xDim);
      min[0] = Infinity;
      min[1] = Infinity;
      max[0] = -Infinity;
      max[1] = -Infinity;

      for (i = 0; i < n; i++) {
        var x = cubicAt(x0, x1, x2, x3, xDim[i]);
        min[0] = mathMin$1(x, min[0]);
        max[0] = mathMax$1(x, max[0]);
      }

      n = cubicExtrema(y0, y1, y2, y3, yDim);

      for (i = 0; i < n; i++) {
        var y = cubicAt(y0, y1, y2, y3, yDim[i]);
        min[1] = mathMin$1(y, min[1]);
        max[1] = mathMax$1(y, max[1]);
      }

      min[0] = mathMin$1(x0, min[0]);
      max[0] = mathMax$1(x0, max[0]);
      min[0] = mathMin$1(x3, min[0]);
      max[0] = mathMax$1(x3, max[0]);
      min[1] = mathMin$1(y0, min[1]);
      max[1] = mathMax$1(y0, max[1]);
      min[1] = mathMin$1(y3, min[1]);
      max[1] = mathMax$1(y3, max[1]);
    }
    /**
     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
     * @memberOf module:zrender/core/bbox
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {Array.<number>} min
     * @param {Array.<number>} max
     */


    function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
      var quadraticExtremum = curve.quadraticExtremum;
      var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero

      var tx = mathMax$1(mathMin$1(quadraticExtremum(x0, x1, x2), 1), 0);
      var ty = mathMax$1(mathMin$1(quadraticExtremum(y0, y1, y2), 1), 0);
      var x = quadraticAt(x0, x1, x2, tx);
      var y = quadraticAt(y0, y1, y2, ty);
      min[0] = mathMin$1(x0, x2, x);
      min[1] = mathMin$1(y0, y2, y);
      max[0] = mathMax$1(x0, x2, x);
      max[1] = mathMax$1(y0, y2, y);
    }
    /**
     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
     * @method
     * @memberOf module:zrender/core/bbox
     * @param {number} x
     * @param {number} y
     * @param {number} rx
     * @param {number} ry
     * @param {number} startAngle
     * @param {number} endAngle
     * @param {number} anticlockwise
     * @param {Array.<number>} min
     * @param {Array.<number>} max
     */


    function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
      var vec2Min = vector.min;
      var vec2Max = vector.max;
      var diff = Math.abs(startAngle - endAngle);

      if (diff % PI2 < 1e-4 && diff > 1e-4) {
        // Is a circle
        min[0] = x - rx;
        min[1] = y - ry;
        max[0] = x + rx;
        max[1] = y + ry;
        return;
      }

      start[0] = mathCos(startAngle) * rx + x;
      start[1] = mathSin(startAngle) * ry + y;
      end[0] = mathCos(endAngle) * rx + x;
      end[1] = mathSin(endAngle) * ry + y;
      vec2Min(min, start, end);
      vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]

      startAngle = startAngle % PI2;

      if (startAngle < 0) {
        startAngle = startAngle + PI2;
      }

      endAngle = endAngle % PI2;

      if (endAngle < 0) {
        endAngle = endAngle + PI2;
      }

      if (startAngle > endAngle && !anticlockwise) {
        endAngle += PI2;
      } else if (startAngle < endAngle && anticlockwise) {
        startAngle += PI2;
      }

      if (anticlockwise) {
        var tmp = endAngle;
        endAngle = startAngle;
        startAngle = tmp;
      } // var number = 0;
      // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;


      for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
        if (angle > startAngle) {
          extremity[0] = mathCos(angle) * rx + x;
          extremity[1] = mathSin(angle) * ry + y;
          vec2Min(min, extremity, min);
          vec2Max(max, extremity, max);
        }
      }
    }

    var fromPoints_1 = fromPoints;
    var fromLine_1 = fromLine;
    var fromCubic_1 = fromCubic;
    var fromQuadratic_1 = fromQuadratic;
    var fromArc_1 = fromArc;

    var bbox = {
    	fromPoints: fromPoints_1,
    	fromLine: fromLine_1,
    	fromCubic: fromCubic_1,
    	fromQuadratic: fromQuadratic_1,
    	fromArc: fromArc_1
    };

    var dpr$1 = config.devicePixelRatio;

    /**
     * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
     * 可以用于 isInsidePath 判断以及获取boundingRect
     *
     * @module zrender/core/PathProxy
     * @author Yi Shen (http://www.github.com/pissang)
     */
    // TODO getTotalLength, getPointAtLength

    /* global Float32Array */
    var CMD = {
      M: 1,
      L: 2,
      C: 3,
      Q: 4,
      A: 5,
      Z: 6,
      // Rect
      R: 7
    }; // var CMD_MEM_SIZE = {
    //     M: 3,
    //     L: 3,
    //     C: 7,
    //     Q: 5,
    //     A: 9,
    //     R: 5,
    //     Z: 1
    // };

    var min$1 = [];
    var max$1 = [];
    var min2 = [];
    var max2 = [];
    var mathMin$2 = Math.min;
    var mathMax$2 = Math.max;
    var mathCos$1 = Math.cos;
    var mathSin$1 = Math.sin;
    var mathSqrt$1 = Math.sqrt;
    var mathAbs = Math.abs;
    var hasTypedArray = typeof Float32Array !== 'undefined';
    /**
     * @alias module:zrender/core/PathProxy
     * @constructor
     */

    var PathProxy = function (notSaveData) {
      this._saveData = !(notSaveData || false);

      if (this._saveData) {
        /**
         * Path data. Stored as flat array
         * @type {Array.<Object>}
         */
        this.data = [];
      }

      this._ctx = null;
    };
    /**
     * 快速计算Path包围盒（并不是最小包围盒）
     * @return {Object}
     */


    PathProxy.prototype = {
      constructor: PathProxy,
      _xi: 0,
      _yi: 0,
      _x0: 0,
      _y0: 0,
      // Unit x, Unit y. Provide for avoiding drawing that too short line segment
      _ux: 0,
      _uy: 0,
      _len: 0,
      _lineDash: null,
      _dashOffset: 0,
      _dashIdx: 0,
      _dashSum: 0,

      /**
       * @readOnly
       */
      setScale: function (sx, sy, segmentIgnoreThreshold) {
        // Compat. Previously there is no segmentIgnoreThreshold.
        segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
        this._ux = mathAbs(segmentIgnoreThreshold / dpr$1 / sx) || 0;
        this._uy = mathAbs(segmentIgnoreThreshold / dpr$1 / sy) || 0;
      },
      getContext: function () {
        return this._ctx;
      },

      /**
       * @param  {CanvasRenderingContext2D} ctx
       * @return {module:zrender/core/PathProxy}
       */
      beginPath: function (ctx) {
        this._ctx = ctx;
        ctx && ctx.beginPath();
        ctx && (this.dpr = ctx.dpr); // Reset

        if (this._saveData) {
          this._len = 0;
        }

        if (this._lineDash) {
          this._lineDash = null;
          this._dashOffset = 0;
        }

        return this;
      },

      /**
       * @param  {number} x
       * @param  {number} y
       * @return {module:zrender/core/PathProxy}
       */
      moveTo: function (x, y) {
        this.addData(CMD.M, x, y);
        this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
        // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
        // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
        // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持

        this._x0 = x;
        this._y0 = y;
        this._xi = x;
        this._yi = y;
        return this;
      },

      /**
       * @param  {number} x
       * @param  {number} y
       * @return {module:zrender/core/PathProxy}
       */
      lineTo: function (x, y) {
        var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
        || this._len < 5;
        this.addData(CMD.L, x, y);

        if (this._ctx && exceedUnit) {
          this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
        }

        if (exceedUnit) {
          this._xi = x;
          this._yi = y;
        }

        return this;
      },

      /**
       * @param  {number} x1
       * @param  {number} y1
       * @param  {number} x2
       * @param  {number} y2
       * @param  {number} x3
       * @param  {number} y3
       * @return {module:zrender/core/PathProxy}
       */
      bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
        this.addData(CMD.C, x1, y1, x2, y2, x3, y3);

        if (this._ctx) {
          this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }

        this._xi = x3;
        this._yi = y3;
        return this;
      },

      /**
       * @param  {number} x1
       * @param  {number} y1
       * @param  {number} x2
       * @param  {number} y2
       * @return {module:zrender/core/PathProxy}
       */
      quadraticCurveTo: function (x1, y1, x2, y2) {
        this.addData(CMD.Q, x1, y1, x2, y2);

        if (this._ctx) {
          this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
        }

        this._xi = x2;
        this._yi = y2;
        return this;
      },

      /**
       * @param  {number} cx
       * @param  {number} cy
       * @param  {number} r
       * @param  {number} startAngle
       * @param  {number} endAngle
       * @param  {boolean} anticlockwise
       * @return {module:zrender/core/PathProxy}
       */
      arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
        this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
        this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
        this._xi = mathCos$1(endAngle) * r + cx;
        this._yi = mathSin$1(endAngle) * r + cy;
        return this;
      },
      // TODO
      arcTo: function (x1, y1, x2, y2, radius) {
        if (this._ctx) {
          this._ctx.arcTo(x1, y1, x2, y2, radius);
        }

        return this;
      },
      // TODO
      rect: function (x, y, w, h) {
        this._ctx && this._ctx.rect(x, y, w, h);
        this.addData(CMD.R, x, y, w, h);
        return this;
      },

      /**
       * @return {module:zrender/core/PathProxy}
       */
      closePath: function () {
        this.addData(CMD.Z);
        var ctx = this._ctx;
        var x0 = this._x0;
        var y0 = this._y0;

        if (ctx) {
          this._needsDash() && this._dashedLineTo(x0, y0);
          ctx.closePath();
        }

        this._xi = x0;
        this._yi = y0;
        return this;
      },

      /**
       * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
       * stroke 同样
       * @param {CanvasRenderingContext2D} ctx
       * @return {module:zrender/core/PathProxy}
       */
      fill: function (ctx) {
        ctx && ctx.fill();
        this.toStatic();
      },

      /**
       * @param {CanvasRenderingContext2D} ctx
       * @return {module:zrender/core/PathProxy}
       */
      stroke: function (ctx) {
        ctx && ctx.stroke();
        this.toStatic();
      },

      /**
       * 必须在其它绘制命令前调用
       * Must be invoked before all other path drawing methods
       * @return {module:zrender/core/PathProxy}
       */
      setLineDash: function (lineDash) {
        if (lineDash instanceof Array) {
          this._lineDash = lineDash;
          this._dashIdx = 0;
          var lineDashSum = 0;

          for (var i = 0; i < lineDash.length; i++) {
            lineDashSum += lineDash[i];
          }

          this._dashSum = lineDashSum;
        }

        return this;
      },

      /**
       * 必须在其它绘制命令前调用
       * Must be invoked before all other path drawing methods
       * @return {module:zrender/core/PathProxy}
       */
      setLineDashOffset: function (offset) {
        this._dashOffset = offset;
        return this;
      },

      /**
       *
       * @return {boolean}
       */
      len: function () {
        return this._len;
      },

      /**
       * 直接设置 Path 数据
       */
      setData: function (data) {
        var len = data.length;

        if (!(this.data && this.data.length === len) && hasTypedArray) {
          this.data = new Float32Array(len);
        }

        for (var i = 0; i < len; i++) {
          this.data[i] = data[i];
        }

        this._len = len;
      },

      /**
       * 添加子路径
       * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
       */
      appendPath: function (path) {
        if (!(path instanceof Array)) {
          path = [path];
        }

        var len = path.length;
        var appendSize = 0;
        var offset = this._len;

        for (var i = 0; i < len; i++) {
          appendSize += path[i].len();
        }

        if (hasTypedArray && this.data instanceof Float32Array) {
          this.data = new Float32Array(offset + appendSize);
        }

        for (var i = 0; i < len; i++) {
          var appendPathData = path[i].data;

          for (var k = 0; k < appendPathData.length; k++) {
            this.data[offset++] = appendPathData[k];
          }
        }

        this._len = offset;
      },

      /**
       * 填充 Path 数据。
       * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
       */
      addData: function (cmd) {
        if (!this._saveData) {
          return;
        }

        var data = this.data;

        if (this._len + arguments.length > data.length) {
          // 因为之前的数组已经转换成静态的 Float32Array
          // 所以不够用时需要扩展一个新的动态数组
          this._expandData();

          data = this.data;
        }

        for (var i = 0; i < arguments.length; i++) {
          data[this._len++] = arguments[i];
        }

        this._prevCmd = cmd;
      },
      _expandData: function () {
        // Only if data is Float32Array
        if (!(this.data instanceof Array)) {
          var newData = [];

          for (var i = 0; i < this._len; i++) {
            newData[i] = this.data[i];
          }

          this.data = newData;
        }
      },

      /**
       * If needs js implemented dashed line
       * @return {boolean}
       * @private
       */
      _needsDash: function () {
        return this._lineDash;
      },
      _dashedLineTo: function (x1, y1) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;
        var x0 = this._xi;
        var y0 = this._yi;
        var dx = x1 - x0;
        var dy = y1 - y0;
        var dist = mathSqrt$1(dx * dx + dy * dy);
        var x = x0;
        var y = y0;
        var dash;
        var nDash = lineDash.length;
        var idx;
        dx /= dist;
        dy /= dist;

        if (offset < 0) {
          // Convert to positive offset
          offset = dashSum + offset;
        }

        offset %= dashSum;
        x -= offset * dx;
        y -= offset * dy;

        while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
          idx = this._dashIdx;
          dash = lineDash[idx];
          x += dx * dash;
          y += dy * dash;
          this._dashIdx = (idx + 1) % nDash; // Skip positive offset

          if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
            continue;
          }

          ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin$2(x, x1) : mathMax$2(x, x1), dy >= 0 ? mathMin$2(y, y1) : mathMax$2(y, y1));
        } // Offset for next lineTo


        dx = x - x1;
        dy = y - y1;
        this._dashOffset = -mathSqrt$1(dx * dx + dy * dy);
      },
      // Not accurate dashed line to
      _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;
        var x0 = this._xi;
        var y0 = this._yi;
        var t;
        var dx;
        var dy;
        var cubicAt = curve.cubicAt;
        var bezierLen = 0;
        var idx = this._dashIdx;
        var nDash = lineDash.length;
        var x;
        var y;
        var tmpLen = 0;

        if (offset < 0) {
          // Convert to positive offset
          offset = dashSum + offset;
        }

        offset %= dashSum; // Bezier approx length

        for (t = 0; t < 1; t += 0.1) {
          dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
          dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
          bezierLen += mathSqrt$1(dx * dx + dy * dy);
        } // Find idx after add offset


        for (; idx < nDash; idx++) {
          tmpLen += lineDash[idx];

          if (tmpLen > offset) {
            break;
          }
        }

        t = (tmpLen - offset) / bezierLen;

        while (t <= 1) {
          x = cubicAt(x0, x1, x2, x3, t);
          y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
          // Bad result if dash is long

          idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          t += lineDash[idx] / bezierLen;
          idx = (idx + 1) % nDash;
        } // Finish the last segment and calculate the new offset


        idx % 2 !== 0 && ctx.lineTo(x3, y3);
        dx = x3 - x;
        dy = y3 - y;
        this._dashOffset = -mathSqrt$1(dx * dx + dy * dy);
      },
      _dashedQuadraticTo: function (x1, y1, x2, y2) {
        // Convert quadratic to cubic using degree elevation
        var x3 = x2;
        var y3 = y2;
        x2 = (x2 + 2 * x1) / 3;
        y2 = (y2 + 2 * y1) / 3;
        x1 = (this._xi + 2 * x1) / 3;
        y1 = (this._yi + 2 * y1) / 3;

        this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
      },

      /**
       * 转成静态的 Float32Array 减少堆内存占用
       * Convert dynamic array to static Float32Array
       */
      toStatic: function () {
        var data = this.data;

        if (data instanceof Array) {
          data.length = this._len;

          if (hasTypedArray) {
            this.data = new Float32Array(data);
          }
        }
      },

      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getBoundingRect: function () {
        min$1[0] = min$1[1] = min2[0] = min2[1] = Number.MAX_VALUE;
        max$1[0] = max$1[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
        var data = this.data;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;

        for (var i = 0; i < data.length;) {
          var cmd = data[i++];

          if (i === 1) {
            // 如果第一个命令是 L, C, Q
            // 则 previous point 同绘制命令的第一个 point
            //
            // 第一个命令为 Arc 的情况下会在后面特殊处理
            xi = data[i];
            yi = data[i + 1];
            x0 = xi;
            y0 = yi;
          }

          switch (cmd) {
            case CMD.M:
              // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
              // 在 closePath 的时候使用
              x0 = data[i++];
              y0 = data[i++];
              xi = x0;
              yi = y0;
              min2[0] = x0;
              min2[1] = y0;
              max2[0] = x0;
              max2[1] = y0;
              break;

            case CMD.L:
              bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;

            case CMD.C:
              bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;

            case CMD.Q:
              bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;

            case CMD.A:
              // TODO Arc 判断的开销比较大
              var cx = data[i++];
              var cy = data[i++];
              var rx = data[i++];
              var ry = data[i++];
              var startAngle = data[i++];
              var endAngle = data[i++] + startAngle; // TODO Arc 旋转

              i += 1;
              var anticlockwise = 1 - data[i++];

              if (i === 1) {
                // 直接使用 arc 命令
                // 第一个命令起点还未定义
                x0 = mathCos$1(startAngle) * rx + cx;
                y0 = mathSin$1(startAngle) * ry + cy;
              }

              bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
              xi = mathCos$1(endAngle) * rx + cx;
              yi = mathSin$1(endAngle) * ry + cy;
              break;

            case CMD.R:
              x0 = xi = data[i++];
              y0 = yi = data[i++];
              var width = data[i++];
              var height = data[i++]; // Use fromLine

              bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
              break;

            case CMD.Z:
              xi = x0;
              yi = y0;
              break;
          } // Union


          vector.min(min$1, min$1, min2);
          vector.max(max$1, max$1, max2);
        } // No data


        if (i === 0) {
          min$1[0] = min$1[1] = max$1[0] = max$1[1] = 0;
        }

        return new BoundingRect_1(min$1[0], min$1[1], max$1[0] - min$1[0], max$1[1] - min$1[1]);
      },

      /**
       * Rebuild path from current data
       * Rebuild path will not consider javascript implemented line dash.
       * @param {CanvasRenderingContext2D} ctx
       */
      rebuildPath: function (ctx) {
        var d = this.data;
        var x0;
        var y0;
        var xi;
        var yi;
        var x;
        var y;
        var ux = this._ux;
        var uy = this._uy;
        var len = this._len;

        for (var i = 0; i < len;) {
          var cmd = d[i++];

          if (i === 1) {
            // 如果第一个命令是 L, C, Q
            // 则 previous point 同绘制命令的第一个 point
            //
            // 第一个命令为 Arc 的情况下会在后面特殊处理
            xi = d[i];
            yi = d[i + 1];
            x0 = xi;
            y0 = yi;
          }

          switch (cmd) {
            case CMD.M:
              x0 = xi = d[i++];
              y0 = yi = d[i++];
              ctx.moveTo(xi, yi);
              break;

            case CMD.L:
              x = d[i++];
              y = d[i++]; // Not draw too small seg between

              if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
                ctx.lineTo(x, y);
                xi = x;
                yi = y;
              }

              break;

            case CMD.C:
              ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
              xi = d[i - 2];
              yi = d[i - 1];
              break;

            case CMD.Q:
              ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
              xi = d[i - 2];
              yi = d[i - 1];
              break;

            case CMD.A:
              var cx = d[i++];
              var cy = d[i++];
              var rx = d[i++];
              var ry = d[i++];
              var theta = d[i++];
              var dTheta = d[i++];
              var psi = d[i++];
              var fs = d[i++];
              var r = rx > ry ? rx : ry;
              var scaleX = rx > ry ? 1 : rx / ry;
              var scaleY = rx > ry ? ry / rx : 1;
              var isEllipse = Math.abs(rx - ry) > 1e-3;
              var endAngle = theta + dTheta;

              if (isEllipse) {
                ctx.translate(cx, cy);
                ctx.rotate(psi);
                ctx.scale(scaleX, scaleY);
                ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
                ctx.scale(1 / scaleX, 1 / scaleY);
                ctx.rotate(-psi);
                ctx.translate(-cx, -cy);
              } else {
                ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
              }

              if (i === 1) {
                // 直接使用 arc 命令
                // 第一个命令起点还未定义
                x0 = mathCos$1(theta) * rx + cx;
                y0 = mathSin$1(theta) * ry + cy;
              }

              xi = mathCos$1(endAngle) * rx + cx;
              yi = mathSin$1(endAngle) * ry + cy;
              break;

            case CMD.R:
              x0 = xi = d[i];
              y0 = yi = d[i + 1];
              ctx.rect(d[i++], d[i++], d[i++], d[i++]);
              break;

            case CMD.Z:
              ctx.closePath();
              xi = x0;
              yi = y0;
          }
        }
      }
    };
    PathProxy.CMD = CMD;
    var _default$w = PathProxy;
    var PathProxy_1 = _default$w;

    /**
     * 线段包含判断
     * @param  {number}  x0
     * @param  {number}  y0
     * @param  {number}  x1
     * @param  {number}  y1
     * @param  {number}  lineWidth
     * @param  {number}  x
     * @param  {number}  y
     * @return {boolean}
     */
    function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }

      var _l = lineWidth;
      var _a = 0;
      var _b = x0; // Quick reject

      if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
        return false;
      }

      if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
      } else {
        return Math.abs(x - x0) <= _l / 2;
      }

      var tmp = _a * x - y + _b;

      var _s = tmp * tmp / (_a * _a + 1);

      return _s <= _l / 2 * _l / 2;
    }

    var containStroke_1 = containStroke;

    var line = {
    	containStroke: containStroke_1
    };

    /**
     * 三次贝塞尔曲线描边包含判断
     * @param  {number}  x0
     * @param  {number}  y0
     * @param  {number}  x1
     * @param  {number}  y1
     * @param  {number}  x2
     * @param  {number}  y2
     * @param  {number}  x3
     * @param  {number}  y3
     * @param  {number}  lineWidth
     * @param  {number}  x
     * @param  {number}  y
     * @return {boolean}
     */
    function containStroke$1(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }

      var _l = lineWidth; // Quick reject

      if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
        return false;
      }

      var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
      return d <= _l / 2;
    }

    var containStroke_1$1 = containStroke$1;

    var cubic = {
    	containStroke: containStroke_1$1
    };

    var quadraticProjectPoint$1 = curve.quadraticProjectPoint;

    /**
     * 二次贝塞尔曲线描边包含判断
     * @param  {number}  x0
     * @param  {number}  y0
     * @param  {number}  x1
     * @param  {number}  y1
     * @param  {number}  x2
     * @param  {number}  y2
     * @param  {number}  lineWidth
     * @param  {number}  x
     * @param  {number}  y
     * @return {boolean}
     */
    function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }

      var _l = lineWidth; // Quick reject

      if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
        return false;
      }

      var d = quadraticProjectPoint$1(x0, y0, x1, y1, x2, y2, x, y, null);
      return d <= _l / 2;
    }

    var containStroke_1$2 = containStroke$2;

    var quadratic = {
    	containStroke: containStroke_1$2
    };

    var PI2$1 = Math.PI * 2;

    function normalizeRadian(angle) {
      angle %= PI2$1;

      if (angle < 0) {
        angle += PI2$1;
      }

      return angle;
    }

    var normalizeRadian_1 = normalizeRadian;

    var util$1 = {
    	normalizeRadian: normalizeRadian_1
    };

    var normalizeRadian$1 = util$1.normalizeRadian;
    var PI2$2 = Math.PI * 2;
    /**
     * 圆弧描边包含判断
     * @param  {number}  cx
     * @param  {number}  cy
     * @param  {number}  r
     * @param  {number}  startAngle
     * @param  {number}  endAngle
     * @param  {boolean}  anticlockwise
     * @param  {number} lineWidth
     * @param  {number}  x
     * @param  {number}  y
     * @return {Boolean}
     */

    function containStroke$3(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }

      var _l = lineWidth;
      x -= cx;
      y -= cy;
      var d = Math.sqrt(x * x + y * y);

      if (d - _l > r || d + _l < r) {
        return false;
      }

      if (Math.abs(startAngle - endAngle) % PI2$2 < 1e-4) {
        // Is a circle
        return true;
      }

      if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian$1(endAngle);
        endAngle = normalizeRadian$1(tmp);
      } else {
        startAngle = normalizeRadian$1(startAngle);
        endAngle = normalizeRadian$1(endAngle);
      }

      if (startAngle > endAngle) {
        endAngle += PI2$2;
      }

      var angle = Math.atan2(y, x);

      if (angle < 0) {
        angle += PI2$2;
      }

      return angle >= startAngle && angle <= endAngle || angle + PI2$2 >= startAngle && angle + PI2$2 <= endAngle;
    }

    var containStroke_1$3 = containStroke$3;

    var arc = {
    	containStroke: containStroke_1$3
    };

    function windingLine(x0, y0, x1, y1, x, y) {
      if (y > y0 && y > y1 || y < y0 && y < y1) {
        return 0;
      } // Ignore horizontal line


      if (y1 === y0) {
        return 0;
      }

      var dir = y1 < y0 ? 1 : -1;
      var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon

      if (t === 1 || t === 0) {
        dir = y1 < y0 ? 0.5 : -0.5;
      }

      var x_ = t * (x1 - x0) + x0; // If (x, y) on the line, considered as "contain".

      return x_ === x ? Infinity : x_ > x ? dir : 0;
    }

    var windingLine_1 = windingLine;

    var normalizeRadian$2 = util$1.normalizeRadian;





    var CMD$1 = PathProxy_1.CMD;
    var PI2$3 = Math.PI * 2;
    var EPSILON$2 = 1e-4;

    function isAroundEqual(a, b) {
      return Math.abs(a - b) < EPSILON$2;
    } // 临时数组


    var roots = [-1, -1, -1];
    var extrema = [-1, -1];

    function swapExtrema() {
      var tmp = extrema[0];
      extrema[0] = extrema[1];
      extrema[1] = tmp;
    }

    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
      // Quick reject
      if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
        return 0;
      }

      var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);

      if (nRoots === 0) {
        return 0;
      } else {
        var w = 0;
        var nExtrema = -1;
        var y0_;
        var y1_;

        for (var i = 0; i < nRoots; i++) {
          var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon

          var unit = t === 0 || t === 1 ? 0.5 : 1;
          var x_ = curve.cubicAt(x0, x1, x2, x3, t);

          if (x_ < x) {
            // Quick reject
            continue;
          }

          if (nExtrema < 0) {
            nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);

            if (extrema[1] < extrema[0] && nExtrema > 1) {
              swapExtrema();
            }

            y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);

            if (nExtrema > 1) {
              y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
            }
          }

          if (nExtrema === 2) {
            // 分成三段单调函数
            if (t < extrema[0]) {
              w += y0_ < y0 ? unit : -unit;
            } else if (t < extrema[1]) {
              w += y1_ < y0_ ? unit : -unit;
            } else {
              w += y3 < y1_ ? unit : -unit;
            }
          } else {
            // 分成两段单调函数
            if (t < extrema[0]) {
              w += y0_ < y0 ? unit : -unit;
            } else {
              w += y3 < y0_ ? unit : -unit;
            }
          }
        }

        return w;
      }
    }

    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
      // Quick reject
      if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
        return 0;
      }

      var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);

      if (nRoots === 0) {
        return 0;
      } else {
        var t = curve.quadraticExtremum(y0, y1, y2);

        if (t >= 0 && t <= 1) {
          var w = 0;
          var y_ = curve.quadraticAt(y0, y1, y2, t);

          for (var i = 0; i < nRoots; i++) {
            // Remove one endpoint.
            var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
            var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);

            if (x_ < x) {
              // Quick reject
              continue;
            }

            if (roots[i] < t) {
              w += y_ < y0 ? unit : -unit;
            } else {
              w += y2 < y_ ? unit : -unit;
            }
          }

          return w;
        } else {
          // Remove one endpoint.
          var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
          var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);

          if (x_ < x) {
            // Quick reject
            return 0;
          }

          return y2 < y0 ? unit : -unit;
        }
      }
    } // TODO
    // Arc 旋转


    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
      y -= cy;

      if (y > r || y < -r) {
        return 0;
      }

      var tmp = Math.sqrt(r * r - y * y);
      roots[0] = -tmp;
      roots[1] = tmp;
      var diff = Math.abs(startAngle - endAngle);

      if (diff < 1e-4) {
        return 0;
      }

      if (diff % PI2$3 < 1e-4) {
        // Is a circle
        startAngle = 0;
        endAngle = PI2$3;
        var dir = anticlockwise ? 1 : -1;

        if (x >= roots[0] + cx && x <= roots[1] + cx) {
          return dir;
        } else {
          return 0;
        }
      }

      if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian$2(endAngle);
        endAngle = normalizeRadian$2(tmp);
      } else {
        startAngle = normalizeRadian$2(startAngle);
        endAngle = normalizeRadian$2(endAngle);
      }

      if (startAngle > endAngle) {
        endAngle += PI2$3;
      }

      var w = 0;

      for (var i = 0; i < 2; i++) {
        var x_ = roots[i];

        if (x_ + cx > x) {
          var angle = Math.atan2(y, x_);
          var dir = anticlockwise ? 1 : -1;

          if (angle < 0) {
            angle = PI2$3 + angle;
          }

          if (angle >= startAngle && angle <= endAngle || angle + PI2$3 >= startAngle && angle + PI2$3 <= endAngle) {
            if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
              dir = -dir;
            }

            w += dir;
          }
        }
      }

      return w;
    }

    function containPath(data, lineWidth, isStroke, x, y) {
      var w = 0;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;

      for (var i = 0; i < data.length;) {
        var cmd = data[i++]; // Begin a new subpath

        if (cmd === CMD$1.M && i > 1) {
          // Close previous subpath
          if (!isStroke) {
            w += windingLine_1(xi, yi, x0, y0, x, y);
          } // 如果被任何一个 subpath 包含
          // if (w !== 0) {
          //     return true;
          // }

        }

        if (i === 1) {
          // 如果第一个命令是 L, C, Q
          // 则 previous point 同绘制命令的第一个 point
          //
          // 第一个命令为 Arc 的情况下会在后面特殊处理
          xi = data[i];
          yi = data[i + 1];
          x0 = xi;
          y0 = yi;
        }

        switch (cmd) {
          case CMD$1.M:
            // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
            // 在 closePath 的时候使用
            x0 = data[i++];
            y0 = data[i++];
            xi = x0;
            yi = y0;
            break;

          case CMD$1.L:
            if (isStroke) {
              if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
              w += windingLine_1(xi, yi, data[i], data[i + 1], x, y) || 0;
            }

            xi = data[i++];
            yi = data[i++];
            break;

          case CMD$1.C:
            if (isStroke) {
              if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
            }

            xi = data[i++];
            yi = data[i++];
            break;

          case CMD$1.Q:
            if (isStroke) {
              if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
            }

            xi = data[i++];
            yi = data[i++];
            break;

          case CMD$1.A:
            // TODO Arc 判断的开销比较大
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var theta = data[i++];
            var dTheta = data[i++]; // TODO Arc 旋转

            i += 1;
            var anticlockwise = 1 - data[i++];
            var x1 = Math.cos(theta) * rx + cx;
            var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令

            if (i > 1) {
              w += windingLine_1(xi, yi, x1, y1, x, y);
            } else {
              // 第一个命令起点还未定义
              x0 = x1;
              y0 = y1;
            } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放


            var _x = (x - cx) * ry / rx + cx;

            if (isStroke) {
              if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
                return true;
              }
            } else {
              w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
            }

            xi = Math.cos(theta + dTheta) * rx + cx;
            yi = Math.sin(theta + dTheta) * ry + cy;
            break;

          case CMD$1.R:
            x0 = xi = data[i++];
            y0 = yi = data[i++];
            var width = data[i++];
            var height = data[i++];
            var x1 = x0 + width;
            var y1 = y0 + height;

            if (isStroke) {
              if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
                return true;
              }
            } else {
              // FIXME Clockwise ?
              w += windingLine_1(x1, y0, x1, y1, x, y);
              w += windingLine_1(x0, y1, x0, y0, x, y);
            }

            break;

          case CMD$1.Z:
            if (isStroke) {
              if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
                return true;
              }
            } else {
              // Close a subpath
              w += windingLine_1(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
              // FIXME subpaths may overlap
              // if (w !== 0) {
              //     return true;
              // }
            }

            xi = x0;
            yi = y0;
            break;
        }
      }

      if (!isStroke && !isAroundEqual(yi, y0)) {
        w += windingLine_1(xi, yi, x0, y0, x, y) || 0;
      }

      return w !== 0;
    }

    function contain(pathData, x, y) {
      return containPath(pathData, 0, false, x, y);
    }

    function containStroke$4(pathData, lineWidth, x, y) {
      return containPath(pathData, lineWidth, true, x, y);
    }

    var contain_1 = contain;
    var containStroke_1$4 = containStroke$4;

    var path = {
    	contain: contain_1,
    	containStroke: containStroke_1$4
    };

    var getCanvasPattern = Pattern_1.prototype.getCanvasPattern;
    var abs = Math.abs;
    var pathProxyForDraw = new PathProxy_1(true);
    /**
     * @alias module:zrender/graphic/Path
     * @extends module:zrender/graphic/Displayable
     * @constructor
     * @param {Object} opts
     */

    function Path(opts) {
      Displayable_1.call(this, opts);
      /**
       * @type {module:zrender/core/PathProxy}
       * @readOnly
       */

      this.path = null;
    }

    Path.prototype = {
      constructor: Path,
      type: 'path',
      __dirtyPath: true,
      strokeContainThreshold: 5,
      // This item default to be false. But in map series in echarts,
      // in order to improve performance, it should be set to true,
      // so the shorty segment won't draw.
      segmentIgnoreThreshold: 0,

      /**
       * See `module:zrender/src/graphic/helper/subPixelOptimize`.
       * @type {boolean}
       */
      subPixelOptimize: false,
      brush: function (ctx, prevEl) {
        var style = this.style;
        var path = this.path || pathProxyForDraw;
        var hasStroke = style.hasStroke();
        var hasFill = style.hasFill();
        var fill = style.fill;
        var stroke = style.stroke;
        var hasFillGradient = hasFill && !!fill.colorStops;
        var hasStrokeGradient = hasStroke && !!stroke.colorStops;
        var hasFillPattern = hasFill && !!fill.image;
        var hasStrokePattern = hasStroke && !!stroke.image;
        style.bind(ctx, this, prevEl);
        this.setTransform(ctx);

        if (this.__dirty) {
          var rect; // Update gradient because bounding rect may changed

          if (hasFillGradient) {
            rect = rect || this.getBoundingRect();
            this._fillGradient = style.getGradient(ctx, fill, rect);
          }

          if (hasStrokeGradient) {
            rect = rect || this.getBoundingRect();
            this._strokeGradient = style.getGradient(ctx, stroke, rect);
          }
        } // Use the gradient or pattern


        if (hasFillGradient) {
          // PENDING If may have affect the state
          ctx.fillStyle = this._fillGradient;
        } else if (hasFillPattern) {
          ctx.fillStyle = getCanvasPattern.call(fill, ctx);
        }

        if (hasStrokeGradient) {
          ctx.strokeStyle = this._strokeGradient;
        } else if (hasStrokePattern) {
          ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
        }

        var lineDash = style.lineDash;
        var lineDashOffset = style.lineDashOffset;
        var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy

        var scale = this.getGlobalScale();
        path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context
        // Rebuild path in following 2 cases
        // 1. Path is dirty
        // 2. Path needs javascript implemented lineDash stroking.
        //    In this case, lineDash information will not be saved in PathProxy

        if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
          path.beginPath(ctx); // Setting line dash before build path

          if (lineDash && !ctxLineDash) {
            path.setLineDash(lineDash);
            path.setLineDashOffset(lineDashOffset);
          }

          this.buildPath(path, this.shape, false); // Clear path dirty flag

          if (this.path) {
            this.__dirtyPath = false;
          }
        } else {
          // Replay path building
          ctx.beginPath();
          this.path.rebuildPath(ctx);
        }

        if (hasFill) {
          if (style.fillOpacity != null) {
            var originalGlobalAlpha = ctx.globalAlpha;
            ctx.globalAlpha = style.fillOpacity * style.opacity;
            path.fill(ctx);
            ctx.globalAlpha = originalGlobalAlpha;
          } else {
            path.fill(ctx);
          }
        }

        if (lineDash && ctxLineDash) {
          ctx.setLineDash(lineDash);
          ctx.lineDashOffset = lineDashOffset;
        }

        if (hasStroke) {
          if (style.strokeOpacity != null) {
            var originalGlobalAlpha = ctx.globalAlpha;
            ctx.globalAlpha = style.strokeOpacity * style.opacity;
            path.stroke(ctx);
            ctx.globalAlpha = originalGlobalAlpha;
          } else {
            path.stroke(ctx);
          }
        }

        if (lineDash && ctxLineDash) {
          // PENDING
          // Remove lineDash
          ctx.setLineDash([]);
        } // Draw rect text


        if (style.text != null) {
          // Only restore transform when needs draw text.
          this.restoreTransform(ctx);
          this.drawRectText(ctx, this.getBoundingRect());
        }
      },
      // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
      // Like in circle
      buildPath: function (ctx, shapeCfg, inBundle) {},
      createPathProxy: function () {
        this.path = new PathProxy_1();
      },
      getBoundingRect: function () {
        var rect = this._rect;
        var style = this.style;
        var needsUpdateRect = !rect;

        if (needsUpdateRect) {
          var path = this.path;

          if (!path) {
            // Create path on demand.
            path = this.path = new PathProxy_1();
          }

          if (this.__dirtyPath) {
            path.beginPath();
            this.buildPath(path, this.shape, false);
          }

          rect = path.getBoundingRect();
        }

        this._rect = rect;

        if (style.hasStroke()) {
          // Needs update rect with stroke lineWidth when
          // 1. Element changes scale or lineWidth
          // 2. Shape is changed
          var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());

          if (this.__dirty || needsUpdateRect) {
            rectWithStroke.copy(rect); // FIXME Must after updateTransform

            var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical

            var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill

            if (!style.hasFill()) {
              w = Math.max(w, this.strokeContainThreshold || 4);
            } // Consider line width
            // Line scale can't be 0;


            if (lineScale > 1e-10) {
              rectWithStroke.width += w / lineScale;
              rectWithStroke.height += w / lineScale;
              rectWithStroke.x -= w / lineScale / 2;
              rectWithStroke.y -= w / lineScale / 2;
            }
          } // Return rect with stroke


          return rectWithStroke;
        }

        return rect;
      },
      contain: function (x, y) {
        var localPos = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        var style = this.style;
        x = localPos[0];
        y = localPos[1];

        if (rect.contain(x, y)) {
          var pathData = this.path.data;

          if (style.hasStroke()) {
            var lineWidth = style.lineWidth;
            var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;

            if (lineScale > 1e-10) {
              // Only add extra hover lineWidth when there are no fill
              if (!style.hasFill()) {
                lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
              }

              if (path.containStroke(pathData, lineWidth / lineScale, x, y)) {
                return true;
              }
            }
          }

          if (style.hasFill()) {
            return path.contain(pathData, x, y);
          }
        }

        return false;
      },

      /**
       * @param  {boolean} dirtyPath
       */
      dirty: function (dirtyPath) {
        if (dirtyPath == null) {
          dirtyPath = true;
        } // Only mark dirty, not mark clean


        if (dirtyPath) {
          this.__dirtyPath = dirtyPath;
          this._rect = null;
        }

        this.__dirty = this.__dirtyText = true;
        this.__zr && this.__zr.refresh(); // Used as a clipping path

        if (this.__clipTarget) {
          this.__clipTarget.dirty();
        }
      },

      /**
       * Alias for animate('shape')
       * @param {boolean} loop
       */
      animateShape: function (loop) {
        return this.animate('shape', loop);
      },
      // Overwrite attrKV
      attrKV: function (key, value) {
        // FIXME
        if (key === 'shape') {
          this.setShape(value);
          this.__dirtyPath = true;
          this._rect = null;
        } else {
          Displayable_1.prototype.attrKV.call(this, key, value);
        }
      },

      /**
       * @param {Object|string} key
       * @param {*} value
       */
      setShape: function (key, value) {
        var shape = this.shape; // Path from string may not have shape

        if (shape) {
          if (util.isObject(key)) {
            for (var name in key) {
              if (key.hasOwnProperty(name)) {
                shape[name] = key[name];
              }
            }
          } else {
            shape[key] = value;
          }

          this.dirty(true);
        }

        return this;
      },
      getLineScale: function () {
        var m = this.transform; // Get the line scale.
        // Determinant of `m` means how much the area is enlarged by the
        // transformation. So its square root can be used as a scale factor
        // for width.

        return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
      }
    };
    /**
     * 扩展一个 Path element, 比如星形，圆等。
     * Extend a path element
     * @param {Object} props
     * @param {string} props.type Path type
     * @param {Function} props.init Initialize
     * @param {Function} props.buildPath Overwrite buildPath method
     * @param {Object} [props.style] Extended default style config
     * @param {Object} [props.shape] Extended default shape config
     */

    Path.extend = function (defaults) {
      var Sub = function (opts) {
        Path.call(this, opts);

        if (defaults.style) {
          // Extend default style
          this.style.extendFrom(defaults.style, false);
        } // Extend default shape


        var defaultShape = defaults.shape;

        if (defaultShape) {
          this.shape = this.shape || {};
          var thisShape = this.shape;

          for (var name in defaultShape) {
            if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
              thisShape[name] = defaultShape[name];
            }
          }
        }

        defaults.init && defaults.init.call(this, opts);
      };

      util.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象

      for (var name in defaults) {
        // Extending prototype values and methods
        if (name !== 'style' && name !== 'shape') {
          Sub.prototype[name] = defaults[name];
        }
      }

      return Sub;
    };

    util.inherits(Path, Displayable_1);
    var _default$x = Path;
    var Path_1 = _default$x;

    var v2ApplyTransform$1 = vector.applyTransform;
    var CMD$2 = PathProxy_1.CMD;
    var points = [[], [], []];
    var mathSqrt$2 = Math.sqrt;
    var mathAtan2 = Math.atan2;

    function _default$y(path, m) {
      var data = path.data;
      var cmd;
      var nPoint;
      var i;
      var j;
      var k;
      var p;
      var M = CMD$2.M;
      var C = CMD$2.C;
      var L = CMD$2.L;
      var R = CMD$2.R;
      var A = CMD$2.A;
      var Q = CMD$2.Q;

      for (i = 0, j = 0; i < data.length;) {
        cmd = data[i++];
        j = i;
        nPoint = 0;

        switch (cmd) {
          case M:
            nPoint = 1;
            break;

          case L:
            nPoint = 1;
            break;

          case C:
            nPoint = 3;
            break;

          case Q:
            nPoint = 2;
            break;

          case A:
            var x = m[4];
            var y = m[5];
            var sx = mathSqrt$2(m[0] * m[0] + m[1] * m[1]);
            var sy = mathSqrt$2(m[2] * m[2] + m[3] * m[3]);
            var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx

            data[i] *= sx;
            data[i++] += x; // cy

            data[i] *= sy;
            data[i++] += y; // Scale rx and ry
            // FIXME Assume psi is 0 here

            data[i++] *= sx;
            data[i++] *= sy; // Start angle

            data[i++] += angle; // end angle

            data[i++] += angle; // FIXME psi

            i += 2;
            j = i;
            break;

          case R:
            // x0, y0
            p[0] = data[i++];
            p[1] = data[i++];
            v2ApplyTransform$1(p, p, m);
            data[j++] = p[0];
            data[j++] = p[1]; // x1, y1

            p[0] += data[i++];
            p[1] += data[i++];
            v2ApplyTransform$1(p, p, m);
            data[j++] = p[0];
            data[j++] = p[1];
        }

        for (k = 0; k < nPoint; k++) {
          var p = points[k];
          p[0] = data[i++];
          p[1] = data[i++];
          v2ApplyTransform$1(p, p, m); // Write back

          data[j++] = p[0];
          data[j++] = p[1];
        }
      }
    }

    var transformPath = _default$y;

    // command chars
    // var cc = [
    //     'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
    //     'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
    // ];
    var mathSqrt$3 = Math.sqrt;
    var mathSin$2 = Math.sin;
    var mathCos$2 = Math.cos;
    var PI = Math.PI;

    var vMag = function (v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };

    var vRatio = function (u, v) {
      return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
    };

    var vAngle = function (u, v) {
      return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
    };

    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
      var psi = psiDeg * (PI / 180.0);
      var xp = mathCos$2(psi) * (x1 - x2) / 2.0 + mathSin$2(psi) * (y1 - y2) / 2.0;
      var yp = -1 * mathSin$2(psi) * (x1 - x2) / 2.0 + mathCos$2(psi) * (y1 - y2) / 2.0;
      var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

      if (lambda > 1) {
        rx *= mathSqrt$3(lambda);
        ry *= mathSqrt$3(lambda);
      }

      var f = (fa === fs ? -1 : 1) * mathSqrt$3((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
      var cxp = f * rx * yp / ry;
      var cyp = f * -ry * xp / rx;
      var cx = (x1 + x2) / 2.0 + mathCos$2(psi) * cxp - mathSin$2(psi) * cyp;
      var cy = (y1 + y2) / 2.0 + mathSin$2(psi) * cxp + mathCos$2(psi) * cyp;
      var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
      var u = [(xp - cxp) / rx, (yp - cyp) / ry];
      var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
      var dTheta = vAngle(u, v);

      if (vRatio(u, v) <= -1) {
        dTheta = PI;
      }

      if (vRatio(u, v) >= 1) {
        dTheta = 0;
      }

      if (fs === 0 && dTheta > 0) {
        dTheta = dTheta - 2 * PI;
      }

      if (fs === 1 && dTheta < 0) {
        dTheta = dTheta + 2 * PI;
      }

      path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
    }

    var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig; // Consider case:
    // (1) delimiter can be comma or space, where continuous commas
    // or spaces should be seen as one comma.
    // (2) value can be like:
    // '2e-4', 'l.5.9' (ignore 0), 'M-10-10', 'l-2.43e-1,34.9983',
    // 'l-.5E1,54', '121-23-44-11' (no delimiter)

    var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g; // var valueSplitReg = /[\s,]+/;

    function createPathProxyFromString(data) {
      if (!data) {
        return new PathProxy_1();
      } // var data = data.replace(/-/g, ' -')
      //     .replace(/  /g, ' ')
      //     .replace(/ /g, ',')
      //     .replace(/,,/g, ',');
      // var n;
      // create pipes so that we can split the data
      // for (n = 0; n < cc.length; n++) {
      //     cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
      // }
      // data = data.replace(/-/g, ',-');
      // create array
      // var arr = cs.split('|');
      // init context point


      var cpx = 0;
      var cpy = 0;
      var subpathX = cpx;
      var subpathY = cpy;
      var prevCmd;
      var path = new PathProxy_1();
      var CMD = PathProxy_1.CMD; // commandReg.lastIndex = 0;
      // var cmdResult;
      // while ((cmdResult = commandReg.exec(data)) != null) {
      //     var cmdStr = cmdResult[1];
      //     var cmdContent = cmdResult[2];

      var cmdList = data.match(commandReg);

      for (var l = 0; l < cmdList.length; l++) {
        var cmdText = cmdList[l];
        var cmdStr = cmdText.charAt(0);
        var cmd; // String#split is faster a little bit than String#replace or RegExp#exec.
        // var p = cmdContent.split(valueSplitReg);
        // var pLen = 0;
        // for (var i = 0; i < p.length; i++) {
        //     // '' and other invalid str => NaN
        //     var val = parseFloat(p[i]);
        //     !isNaN(val) && (p[pLen++] = val);
        // }

        var p = cmdText.match(numberReg) || [];
        var pLen = p.length;

        for (var i = 0; i < pLen; i++) {
          p[i] = parseFloat(p[i]);
        }

        var off = 0;

        while (off < pLen) {
          var ctlPtx;
          var ctlPty;
          var rx;
          var ry;
          var psi;
          var fa;
          var fs;
          var x1 = cpx;
          var y1 = cpy; // convert l, H, h, V, and v to L

          switch (cmdStr) {
            case 'l':
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'L':
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'm':
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.M;
              path.addData(cmd, cpx, cpy);
              subpathX = cpx;
              subpathY = cpy;
              cmdStr = 'l';
              break;

            case 'M':
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.M;
              path.addData(cmd, cpx, cpy);
              subpathX = cpx;
              subpathY = cpy;
              cmdStr = 'L';
              break;

            case 'h':
              cpx += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'H':
              cpx = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'v':
              cpy += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'V':
              cpy = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'C':
              cmd = CMD.C;
              path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
              cpx = p[off - 2];
              cpy = p[off - 1];
              break;

            case 'c':
              cmd = CMD.C;
              path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
              cpx += p[off - 2];
              cpy += p[off - 1];
              break;

            case 'S':
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;

              if (prevCmd === CMD.C) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }

              cmd = CMD.C;
              x1 = p[off++];
              y1 = p[off++];
              cpx = p[off++];
              cpy = p[off++];
              path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
              break;

            case 's':
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;

              if (prevCmd === CMD.C) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }

              cmd = CMD.C;
              x1 = cpx + p[off++];
              y1 = cpy + p[off++];
              cpx += p[off++];
              cpy += p[off++];
              path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
              break;

            case 'Q':
              x1 = p[off++];
              y1 = p[off++];
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.Q;
              path.addData(cmd, x1, y1, cpx, cpy);
              break;

            case 'q':
              x1 = p[off++] + cpx;
              y1 = p[off++] + cpy;
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.Q;
              path.addData(cmd, x1, y1, cpx, cpy);
              break;

            case 'T':
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;

              if (prevCmd === CMD.Q) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }

              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.Q;
              path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
              break;

            case 't':
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;

              if (prevCmd === CMD.Q) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }

              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.Q;
              path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
              break;

            case 'A':
              rx = p[off++];
              ry = p[off++];
              psi = p[off++];
              fa = p[off++];
              fs = p[off++];
              x1 = cpx, y1 = cpy;
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.A;
              processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
              break;

            case 'a':
              rx = p[off++];
              ry = p[off++];
              psi = p[off++];
              fa = p[off++];
              fs = p[off++];
              x1 = cpx, y1 = cpy;
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.A;
              processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
              break;
          }
        }

        if (cmdStr === 'z' || cmdStr === 'Z') {
          cmd = CMD.Z;
          path.addData(cmd); // z may be in the middle of the path.

          cpx = subpathX;
          cpy = subpathY;
        }

        prevCmd = cmd;
      }

      path.toStatic();
      return path;
    } // TODO Optimize double memory cost problem


    function createPathOptions(str, opts) {
      var pathProxy = createPathProxyFromString(str);
      opts = opts || {};

      opts.buildPath = function (path) {
        if (path.setData) {
          path.setData(pathProxy.data); // Svg and vml renderer don't have context

          var ctx = path.getContext();

          if (ctx) {
            path.rebuildPath(ctx);
          }
        } else {
          var ctx = path;
          pathProxy.rebuildPath(ctx);
        }
      };

      opts.applyTransform = function (m) {
        transformPath(pathProxy, m);
        this.dirty(true);
      };

      return opts;
    }
    /**
     * Create a Path object from path string data
     * http://www.w3.org/TR/SVG/paths.html#PathData
     * @param  {Object} opts Other options
     */


    function createFromString(str, opts) {
      return new Path_1(createPathOptions(str, opts));
    }
    /**
     * Create a Path class from path string data
     * @param  {string} str
     * @param  {Object} opts Other options
     */


    function extendFromString(str, opts) {
      return Path_1.extend(createPathOptions(str, opts));
    }
    /**
     * Merge multiple paths
     */
    // TODO Apply transform
    // TODO stroke dash
    // TODO Optimize double memory cost problem


    function mergePath(pathEls, opts) {
      var pathList = [];
      var len = pathEls.length;

      for (var i = 0; i < len; i++) {
        var pathEl = pathEls[i];

        if (!pathEl.path) {
          pathEl.createPathProxy();
        }

        if (pathEl.__dirtyPath) {
          pathEl.buildPath(pathEl.path, pathEl.shape, true);
        }

        pathList.push(pathEl.path);
      }

      var pathBundle = new Path_1(opts); // Need path proxy.

      pathBundle.createPathProxy();

      pathBundle.buildPath = function (path) {
        path.appendPath(pathList); // Svg and vml renderer don't have context

        var ctx = path.getContext();

        if (ctx) {
          path.rebuildPath(ctx);
        }
      };

      return pathBundle;
    }

    var createFromString_1 = createFromString;
    var extendFromString_1 = extendFromString;
    var mergePath_1 = mergePath;

    var path$1 = {
    	createFromString: createFromString_1,
    	extendFromString: extendFromString_1,
    	mergePath: mergePath_1
    };

    var ContextCachedBy$3 = constant.ContextCachedBy;

    /**
     * @alias zrender/graphic/Text
     * @extends module:zrender/graphic/Displayable
     * @constructor
     * @param {Object} opts
     */
    var Text = function (opts) {
      // jshint ignore:line
      Displayable_1.call(this, opts);
    };

    Text.prototype = {
      constructor: Text,
      type: 'text',
      brush: function (ctx, prevEl) {
        var style = this.style; // Optimize, avoid normalize every time.

        this.__dirty && text$2.normalizeTextStyle(style, true); // Use props with prefix 'text'.

        style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
        var text = style.text; // Convert to string

        text != null && (text += ''); // Do not apply style.bind in Text node. Because the real bind job
        // is in textHelper.renderText, and performance of text render should
        // be considered.
        // style.bind(ctx, this, prevEl);

        if (!text$2.needDrawText(text, style)) {
          // The current el.style is not applied
          // and should not be used as cache.
          ctx.__attrCachedBy = ContextCachedBy$3.NONE;
          return;
        }

        this.setTransform(ctx);
        text$2.renderText(this, ctx, text, style, null, prevEl);
        this.restoreTransform(ctx);
      },
      getBoundingRect: function () {
        var style = this.style; // Optimize, avoid normalize every time.

        this.__dirty && text$2.normalizeTextStyle(style, true);

        if (!this._rect) {
          var text = style.text;
          text != null ? text += '' : text = '';
          var rect = text$1.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.textLineHeight, style.rich);
          rect.x += style.x || 0;
          rect.y += style.y || 0;

          if (text$2.getStroke(style.textStroke, style.textStrokeWidth)) {
            var w = style.textStrokeWidth;
            rect.x -= w / 2;
            rect.y -= w / 2;
            rect.width += w;
            rect.height += w;
          }

          this._rect = rect;
        }

        return this._rect;
      }
    };
    util.inherits(Text, Displayable_1);
    var _default$z = Text;
    var Text_1 = _default$z;

    /**
     * 圆形
     * @module zrender/shape/Circle
     */
    var _default$A = Path_1.extend({
      type: 'circle',
      shape: {
        cx: 0,
        cy: 0,
        r: 0
      },
      buildPath: function (ctx, shape, inBundle) {
        // Better stroking in ShapeBundle
        // Always do it may have performence issue ( fill may be 2x more cost)
        if (inBundle) {
          ctx.moveTo(shape.cx + shape.r, shape.cy);
        } // else {
        //     if (ctx.allocate && !ctx.data.length) {
        //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
        //     }
        // }
        // Better stroking in ShapeBundle
        // ctx.moveTo(shape.cx + shape.r, shape.cy);


        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
      }
    });

    var Circle = _default$A;

    // Fix weird bug in some version of IE11 (like 11.0.9600.178**),
    // where exception "unexpected call to method or property access"
    // might be thrown when calling ctx.fill or ctx.stroke after a path
    // whose area size is zero is drawn and ctx.clip() is called and
    // shadowBlur is set. See #4572, #3112, #5777.
    // (e.g.,
    //  ctx.moveTo(10, 10);
    //  ctx.lineTo(20, 10);
    //  ctx.closePath();
    //  ctx.clip();
    //  ctx.shadowBlur = 10;
    //  ...
    //  ctx.fill();
    // )
    var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];

    function _default$B(orignalBrush) {
      // version string can be: '11.0'
      return env_1.browser.ie && env_1.browser.version >= 11 ? function () {
        var clipPaths = this.__clipPaths;
        var style = this.style;
        var modified;

        if (clipPaths) {
          for (var i = 0; i < clipPaths.length; i++) {
            var clipPath = clipPaths[i];
            var shape = clipPath && clipPath.shape;
            var type = clipPath && clipPath.type;

            if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
              for (var j = 0; j < shadowTemp.length; j++) {
                // It is save to put shadowTemp static, because shadowTemp
                // will be all modified each item brush called.
                shadowTemp[j][2] = style[shadowTemp[j][0]];
                style[shadowTemp[j][0]] = shadowTemp[j][1];
              }

              modified = true;
              break;
            }
          }
        }

        orignalBrush.apply(this, arguments);

        if (modified) {
          for (var j = 0; j < shadowTemp.length; j++) {
            style[shadowTemp[j][0]] = shadowTemp[j][2];
          }
        }
      } : orignalBrush;
    }

    var fixClipWithShadow = _default$B;

    /**
     * 扇形
     * @module zrender/graphic/shape/Sector
     */
    var _default$C = Path_1.extend({
      type: 'sector',
      shape: {
        cx: 0,
        cy: 0,
        r0: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      brush: fixClipWithShadow(Path_1.prototype.brush),
      buildPath: function (ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r0 = Math.max(shape.r0 || 0, 0);
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);
        ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
        ctx.lineTo(unitX * r + x, unitY * r + y);
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
        ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);

        if (r0 !== 0) {
          ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
        }

        ctx.closePath();
      }
    });

    var Sector = _default$C;

    /**
     * 圆环
     * @module zrender/graphic/shape/Ring
     */
    var _default$D = Path_1.extend({
      type: 'ring',
      shape: {
        cx: 0,
        cy: 0,
        r: 0,
        r0: 0
      },
      buildPath: function (ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var PI2 = Math.PI * 2;
        ctx.moveTo(x + shape.r, y);
        ctx.arc(x, y, shape.r, 0, PI2, false);
        ctx.moveTo(x + shape.r0, y);
        ctx.arc(x, y, shape.r0, 0, PI2, true);
      }
    });

    var Ring = _default$D;

    var v2Distance = vector.distance;

    /**
     * Catmull-Rom spline 插值折线
     * @module zrender/shape/util/smoothSpline
     * @author pissang (https://www.github.com/pissang)
     *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
     *         errorrik (errorrik@gmail.com)
     */

    /**
     * @inner
     */
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    /**
     * @alias module:zrender/shape/util/smoothSpline
     * @param {Array} points 线段顶点数组
     * @param {boolean} isLoop
     * @return {Array}
     */


    function _default$E(points, isLoop) {
      var len = points.length;
      var ret = [];
      var distance = 0;

      for (var i = 1; i < len; i++) {
        distance += v2Distance(points[i - 1], points[i]);
      }

      var segs = distance / 2;
      segs = segs < len ? len : segs;

      for (var i = 0; i < segs; i++) {
        var pos = i / (segs - 1) * (isLoop ? len : len - 1);
        var idx = Math.floor(pos);
        var w = pos - idx;
        var p0;
        var p1 = points[idx % len];
        var p2;
        var p3;

        if (!isLoop) {
          p0 = points[idx === 0 ? idx : idx - 1];
          p2 = points[idx > len - 2 ? len - 1 : idx + 1];
          p3 = points[idx > len - 3 ? len - 1 : idx + 2];
        } else {
          p0 = points[(idx - 1 + len) % len];
          p2 = points[(idx + 1) % len];
          p3 = points[(idx + 2) % len];
        }

        var w2 = w * w;
        var w3 = w * w2;
        ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
      }

      return ret;
    }

    var smoothSpline = _default$E;

    var v2Min = vector.min;
    var v2Max = vector.max;
    var v2Scale = vector.scale;
    var v2Distance$1 = vector.distance;
    var v2Add = vector.add;
    var v2Clone = vector.clone;
    var v2Sub = vector.sub;

    /**
     * 贝塞尔平滑曲线
     * @module zrender/shape/util/smoothBezier
     * @author pissang (https://www.github.com/pissang)
     *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
     *         errorrik (errorrik@gmail.com)
     */

    /**
     * 贝塞尔平滑曲线
     * @alias module:zrender/shape/util/smoothBezier
     * @param {Array} points 线段顶点数组
     * @param {number} smooth 平滑等级, 0-1
     * @param {boolean} isLoop
     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
     *                           整个折线的包围盒做一个并集用来约束控制点。
     * @param {Array} 计算出来的控制点数组
     */
    function _default$F(points, smooth, isLoop, constraint) {
      var cps = [];
      var v = [];
      var v1 = [];
      var v2 = [];
      var prevPoint;
      var nextPoint;
      var min;
      var max;

      if (constraint) {
        min = [Infinity, Infinity];
        max = [-Infinity, -Infinity];

        for (var i = 0, len = points.length; i < len; i++) {
          v2Min(min, min, points[i]);
          v2Max(max, max, points[i]);
        } // 与指定的包围盒做并集


        v2Min(min, min, constraint[0]);
        v2Max(max, max, constraint[1]);
      }

      for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];

        if (isLoop) {
          prevPoint = points[i ? i - 1 : len - 1];
          nextPoint = points[(i + 1) % len];
        } else {
          if (i === 0 || i === len - 1) {
            cps.push(v2Clone(points[i]));
            continue;
          } else {
            prevPoint = points[i - 1];
            nextPoint = points[i + 1];
          }
        }

        v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length

        v2Scale(v, v, smooth);
        var d0 = v2Distance$1(point, prevPoint);
        var d1 = v2Distance$1(point, nextPoint);
        var sum = d0 + d1;

        if (sum !== 0) {
          d0 /= sum;
          d1 /= sum;
        }

        v2Scale(v1, v, -d0);
        v2Scale(v2, v, d1);
        var cp0 = v2Add([], point, v1);
        var cp1 = v2Add([], point, v2);

        if (constraint) {
          v2Max(cp0, cp0, min);
          v2Min(cp0, cp0, max);
          v2Max(cp1, cp1, min);
          v2Min(cp1, cp1, max);
        }

        cps.push(cp0);
        cps.push(cp1);
      }

      if (isLoop) {
        cps.push(cps.shift());
      }

      return cps;
    }

    var smoothBezier = _default$F;

    function buildPath$1(ctx, shape, closePath) {
      var points = shape.points;
      var smooth = shape.smooth;

      if (points && points.length >= 2) {
        if (smooth && smooth !== 'spline') {
          var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
          ctx.moveTo(points[0][0], points[0][1]);
          var len = points.length;

          for (var i = 0; i < (closePath ? len : len - 1); i++) {
            var cp1 = controlPoints[i * 2];
            var cp2 = controlPoints[i * 2 + 1];
            var p = points[(i + 1) % len];
            ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
          }
        } else {
          if (smooth === 'spline') {
            points = smoothSpline(points, closePath);
          }

          ctx.moveTo(points[0][0], points[0][1]);

          for (var i = 1, l = points.length; i < l; i++) {
            ctx.lineTo(points[i][0], points[i][1]);
          }
        }

        closePath && ctx.closePath();
      }
    }

    var buildPath_1$1 = buildPath$1;

    var poly = {
    	buildPath: buildPath_1$1
    };

    /**
     * 多边形
     * @module zrender/shape/Polygon
     */
    var _default$G = Path_1.extend({
      type: 'polygon',
      shape: {
        points: null,
        smooth: false,
        smoothConstraint: null
      },
      buildPath: function (ctx, shape) {
        poly.buildPath(ctx, shape, true);
      }
    });

    var Polygon = _default$G;

    /**
     * @module zrender/graphic/shape/Polyline
     */
    var _default$H = Path_1.extend({
      type: 'polyline',
      shape: {
        points: null,
        smooth: false,
        smoothConstraint: null
      },
      style: {
        stroke: '#000',
        fill: null
      },
      buildPath: function (ctx, shape) {
        poly.buildPath(ctx, shape, false);
      }
    });

    var Polyline = _default$H;

    /**
     * Sub-pixel optimize for canvas rendering, prevent from blur
     * when rendering a thin vertical/horizontal line.
     */
    var round = Math.round;
    /**
     * Sub pixel optimize line for canvas
     *
     * @param {Object} outputShape The modification will be performed on `outputShape`.
     *                 `outputShape` and `inputShape` can be the same object.
     *                 `outputShape` object can be used repeatly, because all of
     *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.
     * @param {Object} [inputShape]
     * @param {number} [inputShape.x1]
     * @param {number} [inputShape.y1]
     * @param {number} [inputShape.x2]
     * @param {number} [inputShape.y2]
     * @param {Object} [style]
     * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.
     */

    function subPixelOptimizeLine(outputShape, inputShape, style) {
      if (!inputShape) {
        return;
      }

      var x1 = inputShape.x1;
      var x2 = inputShape.x2;
      var y1 = inputShape.y1;
      var y2 = inputShape.y2;
      outputShape.x1 = x1;
      outputShape.x2 = x2;
      outputShape.y1 = y1;
      outputShape.y2 = y2;
      var lineWidth = style && style.lineWidth;

      if (!lineWidth) {
        return;
      }

      if (round(x1 * 2) === round(x2 * 2)) {
        outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
      }

      if (round(y1 * 2) === round(y2 * 2)) {
        outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
      }
    }
    /**
     * Sub pixel optimize rect for canvas
     *
     * @param {Object} outputShape The modification will be performed on `outputShape`.
     *                 `outputShape` and `inputShape` can be the same object.
     *                 `outputShape` object can be used repeatly, because all of
     *                 the `x`, `y`, `width`, `height` will be assigned in this method.
     * @param {Object} [inputShape]
     * @param {number} [inputShape.x]
     * @param {number} [inputShape.y]
     * @param {number} [inputShape.width]
     * @param {number} [inputShape.height]
     * @param {Object} [style]
     * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.
     */


    function subPixelOptimizeRect(outputShape, inputShape, style) {
      if (!inputShape) {
        return;
      }

      var originX = inputShape.x;
      var originY = inputShape.y;
      var originWidth = inputShape.width;
      var originHeight = inputShape.height;
      outputShape.x = originX;
      outputShape.y = originY;
      outputShape.width = originWidth;
      outputShape.height = originHeight;
      var lineWidth = style && style.lineWidth;

      if (!lineWidth) {
        return;
      }

      outputShape.x = subPixelOptimize(originX, lineWidth, true);
      outputShape.y = subPixelOptimize(originY, lineWidth, true);
      outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
      outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
    }
    /**
     * Sub pixel optimize for canvas
     *
     * @param {number} position Coordinate, such as x, y
     * @param {number} lineWidth If `null`/`undefined`/`0`, do not optimize.
     * @param {boolean=} positiveOrNegative Default false (negative).
     * @return {number} Optimized position.
     */


    function subPixelOptimize(position, lineWidth, positiveOrNegative) {
      if (!lineWidth) {
        return position;
      } // Assure that (position + lineWidth / 2) is near integer edge,
      // otherwise line will be fuzzy in canvas.


      var doubledPosition = round(position * 2);
      return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
    }

    var subPixelOptimizeLine_1 = subPixelOptimizeLine;
    var subPixelOptimizeRect_1 = subPixelOptimizeRect;
    var subPixelOptimize_2 = subPixelOptimize;

    var subPixelOptimize_1 = {
    	subPixelOptimizeLine: subPixelOptimizeLine_1,
    	subPixelOptimizeRect: subPixelOptimizeRect_1,
    	subPixelOptimize: subPixelOptimize_2
    };

    var subPixelOptimizeRect$1 = subPixelOptimize_1.subPixelOptimizeRect;

    /**
     * 矩形
     * @module zrender/graphic/shape/Rect
     */
    // Avoid create repeatly.
    var subPixelOptimizeOutputShape = {};

    var _default$I = Path_1.extend({
      type: 'rect',
      shape: {
        // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
        // r缩写为1         相当于 [1, 1, 1, 1]
        // r缩写为[1]       相当于 [1, 1, 1, 1]
        // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
        // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
        r: 0,
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      buildPath: function (ctx, shape) {
        var x;
        var y;
        var width;
        var height;

        if (this.subPixelOptimize) {
          subPixelOptimizeRect$1(subPixelOptimizeOutputShape, shape, this.style);
          x = subPixelOptimizeOutputShape.x;
          y = subPixelOptimizeOutputShape.y;
          width = subPixelOptimizeOutputShape.width;
          height = subPixelOptimizeOutputShape.height;
          subPixelOptimizeOutputShape.r = shape.r;
          shape = subPixelOptimizeOutputShape;
        } else {
          x = shape.x;
          y = shape.y;
          width = shape.width;
          height = shape.height;
        }

        if (!shape.r) {
          ctx.rect(x, y, width, height);
        } else {
          roundRect.buildPath(ctx, shape);
        }

        ctx.closePath();
        return;
      }
    });

    var Rect = _default$I;

    var subPixelOptimizeLine$1 = subPixelOptimize_1.subPixelOptimizeLine;

    /**
     * 直线
     * @module zrender/graphic/shape/Line
     */
    // Avoid create repeatly.
    var subPixelOptimizeOutputShape$1 = {};

    var _default$J = Path_1.extend({
      type: 'line',
      shape: {
        // Start point
        x1: 0,
        y1: 0,
        // End point
        x2: 0,
        y2: 0,
        percent: 1
      },
      style: {
        stroke: '#000',
        fill: null
      },
      buildPath: function (ctx, shape) {
        var x1;
        var y1;
        var x2;
        var y2;

        if (this.subPixelOptimize) {
          subPixelOptimizeLine$1(subPixelOptimizeOutputShape$1, shape, this.style);
          x1 = subPixelOptimizeOutputShape$1.x1;
          y1 = subPixelOptimizeOutputShape$1.y1;
          x2 = subPixelOptimizeOutputShape$1.x2;
          y2 = subPixelOptimizeOutputShape$1.y2;
        } else {
          x1 = shape.x1;
          y1 = shape.y1;
          x2 = shape.x2;
          y2 = shape.y2;
        }

        var percent = shape.percent;

        if (percent === 0) {
          return;
        }

        ctx.moveTo(x1, y1);

        if (percent < 1) {
          x2 = x1 * (1 - percent) + x2 * percent;
          y2 = y1 * (1 - percent) + y2 * percent;
        }

        ctx.lineTo(x2, y2);
      },

      /**
       * Get point at percent
       * @param  {number} percent
       * @return {Array.<number>}
       */
      pointAt: function (p) {
        var shape = this.shape;
        return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
      }
    });

    var Line = _default$J;

    var quadraticSubdivide$1 = curve.quadraticSubdivide;
    var cubicSubdivide$1 = curve.cubicSubdivide;
    var quadraticAt$1 = curve.quadraticAt;
    var cubicAt$1 = curve.cubicAt;
    var quadraticDerivativeAt$1 = curve.quadraticDerivativeAt;
    var cubicDerivativeAt$1 = curve.cubicDerivativeAt;

    /**
     * 贝塞尔曲线
     * @module zrender/shape/BezierCurve
     */
    var out = [];

    function someVectorAt(shape, t, isTangent) {
      var cpx2 = shape.cpx2;
      var cpy2 = shape.cpy2;

      if (cpx2 === null || cpy2 === null) {
        return [(isTangent ? cubicDerivativeAt$1 : cubicAt$1)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt$1 : cubicAt$1)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
      } else {
        return [(isTangent ? quadraticDerivativeAt$1 : quadraticAt$1)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt$1 : quadraticAt$1)(shape.y1, shape.cpy1, shape.y2, t)];
      }
    }

    var _default$K = Path_1.extend({
      type: 'bezier-curve',
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        cpx1: 0,
        cpy1: 0,
        // cpx2: 0,
        // cpy2: 0
        // Curve show percent, for animating
        percent: 1
      },
      style: {
        stroke: '#000',
        fill: null
      },
      buildPath: function (ctx, shape) {
        var x1 = shape.x1;
        var y1 = shape.y1;
        var x2 = shape.x2;
        var y2 = shape.y2;
        var cpx1 = shape.cpx1;
        var cpy1 = shape.cpy1;
        var cpx2 = shape.cpx2;
        var cpy2 = shape.cpy2;
        var percent = shape.percent;

        if (percent === 0) {
          return;
        }

        ctx.moveTo(x1, y1);

        if (cpx2 == null || cpy2 == null) {
          if (percent < 1) {
            quadraticSubdivide$1(x1, cpx1, x2, percent, out);
            cpx1 = out[1];
            x2 = out[2];
            quadraticSubdivide$1(y1, cpy1, y2, percent, out);
            cpy1 = out[1];
            y2 = out[2];
          }

          ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
        } else {
          if (percent < 1) {
            cubicSubdivide$1(x1, cpx1, cpx2, x2, percent, out);
            cpx1 = out[1];
            cpx2 = out[2];
            x2 = out[3];
            cubicSubdivide$1(y1, cpy1, cpy2, y2, percent, out);
            cpy1 = out[1];
            cpy2 = out[2];
            y2 = out[3];
          }

          ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
        }
      },

      /**
       * Get point at percent
       * @param  {number} t
       * @return {Array.<number>}
       */
      pointAt: function (t) {
        return someVectorAt(this.shape, t, false);
      },

      /**
       * Get tangent at percent
       * @param  {number} t
       * @return {Array.<number>}
       */
      tangentAt: function (t) {
        var p = someVectorAt(this.shape, t, true);
        return vector.normalize(p, p);
      }
    });

    var BezierCurve = _default$K;

    /**
     * 圆弧
     * @module zrender/graphic/shape/Arc
     */
    var _default$L = Path_1.extend({
      type: 'arc',
      shape: {
        cx: 0,
        cy: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      style: {
        stroke: '#000',
        fill: null
      },
      buildPath: function (ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);
        ctx.moveTo(unitX * r + x, unitY * r + y);
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
      }
    });

    var Arc = _default$L;

    // CompoundPath to improve performance
    var _default$M = Path_1.extend({
      type: 'compound',
      shape: {
        paths: null
      },
      _updatePathDirty: function () {
        var dirtyPath = this.__dirtyPath;
        var paths = this.shape.paths;

        for (var i = 0; i < paths.length; i++) {
          // Mark as dirty if any subpath is dirty
          dirtyPath = dirtyPath || paths[i].__dirtyPath;
        }

        this.__dirtyPath = dirtyPath;
        this.__dirty = this.__dirty || dirtyPath;
      },
      beforeBrush: function () {
        this._updatePathDirty();

        var paths = this.shape.paths || [];
        var scale = this.getGlobalScale(); // Update path scale

        for (var i = 0; i < paths.length; i++) {
          if (!paths[i].path) {
            paths[i].createPathProxy();
          }

          paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);
        }
      },
      buildPath: function (ctx, shape) {
        var paths = shape.paths || [];

        for (var i = 0; i < paths.length; i++) {
          paths[i].buildPath(ctx, paths[i].shape, true);
        }
      },
      afterBrush: function () {
        var paths = this.shape.paths || [];

        for (var i = 0; i < paths.length; i++) {
          paths[i].__dirtyPath = false;
        }
      },
      getBoundingRect: function () {
        this._updatePathDirty();

        return Path_1.prototype.getBoundingRect.call(this);
      }
    });

    var CompoundPath = _default$M;

    /**
     * @param {Array.<Object>} colorStops
     */
    var Gradient = function (colorStops) {
      this.colorStops = colorStops || [];
    };

    Gradient.prototype = {
      constructor: Gradient,
      addColorStop: function (offset, color) {
        this.colorStops.push({
          offset: offset,
          color: color
        });
      }
    };
    var _default$N = Gradient;
    var Gradient_1 = _default$N;

    /**
     * x, y, x2, y2 are all percent from 0 to 1
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @param {number} [x2=1]
     * @param {number} [y2=0]
     * @param {Array.<Object>} colorStops
     * @param {boolean} [globalCoord=false]
     */
    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
      // Should do nothing more in this constructor. Because gradient can be
      // declard by `color: {type: 'linear', colorStops: ...}`, where
      // this constructor will not be called.
      this.x = x == null ? 0 : x;
      this.y = y == null ? 0 : y;
      this.x2 = x2 == null ? 1 : x2;
      this.y2 = y2 == null ? 0 : y2; // Can be cloned

      this.type = 'linear'; // If use global coord

      this.global = globalCoord || false;
      Gradient_1.call(this, colorStops);
    };

    LinearGradient.prototype = {
      constructor: LinearGradient
    };
    util.inherits(LinearGradient, Gradient_1);
    var _default$O = LinearGradient;
    var LinearGradient_1 = _default$O;

    /**
     * x, y, r are all percent from 0 to 1
     * @param {number} [x=0.5]
     * @param {number} [y=0.5]
     * @param {number} [r=0.5]
     * @param {Array.<Object>} [colorStops]
     * @param {boolean} [globalCoord=false]
     */
    var RadialGradient = function (x, y, r, colorStops, globalCoord) {
      // Should do nothing more in this constructor. Because gradient can be
      // declard by `color: {type: 'radial', colorStops: ...}`, where
      // this constructor will not be called.
      this.x = x == null ? 0.5 : x;
      this.y = y == null ? 0.5 : y;
      this.r = r == null ? 0.5 : r; // Can be cloned

      this.type = 'radial'; // If use global coord

      this.global = globalCoord || false;
      Gradient_1.call(this, colorStops);
    };

    RadialGradient.prototype = {
      constructor: RadialGradient
    };
    util.inherits(RadialGradient, Gradient_1);
    var _default$P = RadialGradient;
    var RadialGradient_1 = _default$P;

    var inherits$1 = util.inherits;





    /**
     * Displayable for incremental rendering. It will be rendered in a separate layer
     * IncrementalDisplay have two main methods. `clearDisplayables` and `addDisplayables`
     * addDisplayables will render the added displayables incremetally.
     *
     * It use a not clearFlag to tell the painter don't clear the layer if it's the first element.
     */
    // TODO Style override ?
    function IncrementalDisplayble(opts) {
      Displayable_1.call(this, opts);
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.notClear = true;
    }

    IncrementalDisplayble.prototype.incremental = true;

    IncrementalDisplayble.prototype.clearDisplaybles = function () {
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.dirty();
      this.notClear = false;
    };

    IncrementalDisplayble.prototype.addDisplayable = function (displayable, notPersistent) {
      if (notPersistent) {
        this._temporaryDisplayables.push(displayable);
      } else {
        this._displayables.push(displayable);
      }

      this.dirty();
    };

    IncrementalDisplayble.prototype.addDisplayables = function (displayables, notPersistent) {
      notPersistent = notPersistent || false;

      for (var i = 0; i < displayables.length; i++) {
        this.addDisplayable(displayables[i], notPersistent);
      }
    };

    IncrementalDisplayble.prototype.eachPendingDisplayable = function (cb) {
      for (var i = this._cursor; i < this._displayables.length; i++) {
        cb && cb(this._displayables[i]);
      }

      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        cb && cb(this._temporaryDisplayables[i]);
      }
    };

    IncrementalDisplayble.prototype.update = function () {
      this.updateTransform();

      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i]; // PENDING

        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }

      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i]; // PENDING

        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
    };

    IncrementalDisplayble.prototype.brush = function (ctx, prevEl) {
      // Render persistant displayables.
      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        displayable.beforeBrush && displayable.beforeBrush(ctx);
        displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]);
        displayable.afterBrush && displayable.afterBrush(ctx);
      }

      this._cursor = i; // Render temporary displayables.

      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i];
        displayable.beforeBrush && displayable.beforeBrush(ctx);
        displayable.brush(ctx, i === 0 ? null : this._temporaryDisplayables[i - 1]);
        displayable.afterBrush && displayable.afterBrush(ctx);
      }

      this._temporaryDisplayables = [];
      this.notClear = true;
    };

    var m = [];

    IncrementalDisplayble.prototype.getBoundingRect = function () {
      if (!this._rect) {
        var rect = new BoundingRect_1(Infinity, Infinity, -Infinity, -Infinity);

        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];
          var childRect = displayable.getBoundingRect().clone();

          if (displayable.needLocalTransform()) {
            childRect.applyTransform(displayable.getLocalTransform(m));
          }

          rect.union(childRect);
        }

        this._rect = rect;
      }

      return this._rect;
    };

    IncrementalDisplayble.prototype.contain = function (x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();

      if (rect.contain(localPos[0], localPos[1])) {
        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];

          if (displayable.contain(x, y)) {
            return true;
          }
        }
      }

      return false;
    };

    inherits$1(IncrementalDisplayble, Displayable_1);
    var _default$Q = IncrementalDisplayble;
    var IncrementalDisplayable = _default$Q;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

















    var Image$2 = Image$1;



    var Group_1$1 = Group_1;



    var Text_1$1 = Text_1;



    var Circle_1 = Circle;



    var Sector_1 = Sector;



    var Ring_1 = Ring;



    var Polygon_1 = Polygon;



    var Polyline_1 = Polyline;



    var Rect_1 = Rect;



    var Line_1 = Line;



    var BezierCurve_1 = BezierCurve;



    var Arc_1 = Arc;



    var CompoundPath_1 = CompoundPath;



    var LinearGradient_1$1 = LinearGradient_1;



    var RadialGradient_1$1 = RadialGradient_1;



    var BoundingRect_1$1 = BoundingRect_1;



    var IncrementalDisplayable_1 = IncrementalDisplayable;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var mathMax$3 = Math.max;
    var mathMin$3 = Math.min;
    var EMPTY_OBJ = {};
    var Z2_EMPHASIS_LIFT = 1; // key: label model property nane, value: style property name.

    var CACHED_LABEL_STYLE_PROPERTIES = {
      color: 'textFill',
      textBorderColor: 'textStroke',
      textBorderWidth: 'textStrokeWidth'
    };
    var EMPHASIS = 'emphasis';
    var NORMAL = 'normal'; // Reserve 0 as default.

    var _highlightNextDigit = 1;
    var _highlightKeyMap = {};
    var _customShapeMap = {};
    /**
     * Extend shape with parameters
     */

    function extendShape(opts) {
      return Path_1.extend(opts);
    }
    /**
     * Extend path
     */


    function extendPath(pathData, opts) {
      return path$1.extendFromString(pathData, opts);
    }
    /**
     * Register a user defined shape.
     * The shape class can be fetched by `getShapeClass`
     * This method will overwrite the registered shapes, including
     * the registered built-in shapes, if using the same `name`.
     * The shape can be used in `custom series` and
     * `graphic component` by declaring `{type: name}`.
     *
     * @param {string} name
     * @param {Object} ShapeClass Can be generated by `extendShape`.
     */


    function registerShape(name, ShapeClass) {
      _customShapeMap[name] = ShapeClass;
    }
    /**
     * Find shape class registered by `registerShape`. Usually used in
     * fetching user defined shape.
     *
     * [Caution]:
     * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared
     * to use user registered shapes.
     * Because the built-in shape (see `getBuiltInShape`) will be registered by
     * `registerShape` by default. That enables users to get both built-in
     * shapes as well as the shapes belonging to themsleves. But users can overwrite
     * the built-in shapes by using names like 'circle', 'rect' via calling
     * `registerShape`. So the echarts inner featrues should not fetch shapes from here
     * in case that it is overwritten by users, except that some features, like
     * `custom series`, `graphic component`, do it deliberately.
     *
     * (2) In the features like `custom series`, `graphic component`, the user input
     * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic
     * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names
     * are reserved names, that is, if some user register a shape named `'image'`,
     * the shape will not be used. If we intending to add some more reserved names
     * in feature, that might bring break changes (disable some existing user shape
     * names). But that case probably rearly happen. So we dont make more mechanism
     * to resolve this issue here.
     *
     * @param {string} name
     * @return {Object} The shape class. If not found, return nothing.
     */


    function getShapeClass(name) {
      if (_customShapeMap.hasOwnProperty(name)) {
        return _customShapeMap[name];
      }
    }
    /**
     * Create a path element from path data string
     * @param {string} pathData
     * @param {Object} opts
     * @param {module:zrender/core/BoundingRect} rect
     * @param {string} [layout=cover] 'center' or 'cover'
     */


    function makePath(pathData, opts, rect, layout) {
      var path = path$1.createFromString(pathData, opts);

      if (rect) {
        if (layout === 'center') {
          rect = centerGraphic(rect, path.getBoundingRect());
        }

        resizePath(path, rect);
      }

      return path;
    }
    /**
     * Create a image element from image url
     * @param {string} imageUrl image url
     * @param {Object} opts options
     * @param {module:zrender/core/BoundingRect} rect constrain rect
     * @param {string} [layout=cover] 'center' or 'cover'
     */


    function makeImage(imageUrl, rect, layout) {
      var path = new Image$1({
        style: {
          image: imageUrl,
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        },
        onload: function (img) {
          if (layout === 'center') {
            var boundingRect = {
              width: img.width,
              height: img.height
            };
            path.setStyle(centerGraphic(rect, boundingRect));
          }
        }
      });
      return path;
    }
    /**
     * Get position of centered element in bounding box.
     *
     * @param  {Object} rect         element local bounding box
     * @param  {Object} boundingRect constraint bounding box
     * @return {Object} element position containing x, y, width, and height
     */


    function centerGraphic(rect, boundingRect) {
      // Set rect to center, keep width / height ratio.
      var aspect = boundingRect.width / boundingRect.height;
      var width = rect.height * aspect;
      var height;

      if (width <= rect.width) {
        height = rect.height;
      } else {
        width = rect.width;
        height = width / aspect;
      }

      var cx = rect.x + rect.width / 2;
      var cy = rect.y + rect.height / 2;
      return {
        x: cx - width / 2,
        y: cy - height / 2,
        width: width,
        height: height
      };
    }

    var mergePath$1 = path$1.mergePath;
    /**
     * Resize a path to fit the rect
     * @param {module:zrender/graphic/Path} path
     * @param {Object} rect
     */

    function resizePath(path, rect) {
      if (!path.applyTransform) {
        return;
      }

      var pathRect = path.getBoundingRect();
      var m = pathRect.calculateTransform(rect);
      path.applyTransform(m);
    }
    /**
     * Sub pixel optimize line for canvas
     *
     * @param {Object} param
     * @param {Object} [param.shape]
     * @param {number} [param.shape.x1]
     * @param {number} [param.shape.y1]
     * @param {number} [param.shape.x2]
     * @param {number} [param.shape.y2]
     * @param {Object} [param.style]
     * @param {number} [param.style.lineWidth]
     * @return {Object} Modified param
     */


    function subPixelOptimizeLine$2(param) {
      subPixelOptimize_1.subPixelOptimizeLine(param.shape, param.shape, param.style);
      return param;
    }
    /**
     * Sub pixel optimize rect for canvas
     *
     * @param {Object} param
     * @param {Object} [param.shape]
     * @param {number} [param.shape.x]
     * @param {number} [param.shape.y]
     * @param {number} [param.shape.width]
     * @param {number} [param.shape.height]
     * @param {Object} [param.style]
     * @param {number} [param.style.lineWidth]
     * @return {Object} Modified param
     */


    function subPixelOptimizeRect$2(param) {
      subPixelOptimize_1.subPixelOptimizeRect(param.shape, param.shape, param.style);
      return param;
    }
    /**
     * Sub pixel optimize for canvas
     *
     * @param {number} position Coordinate, such as x, y
     * @param {number} lineWidth Should be nonnegative integer.
     * @param {boolean=} positiveOrNegative Default false (negative).
     * @return {number} Optimized position.
     */


    var subPixelOptimize$1 = subPixelOptimize_1.subPixelOptimize;

    function hasFillOrStroke(fillOrStroke) {
      return fillOrStroke != null && fillOrStroke !== 'none';
    } // Most lifted color are duplicated.


    var liftedColorMap = util.createHashMap();
    var liftedColorCount = 0;

    function liftColor(color$1) {
      if (typeof color$1 !== 'string') {
        return color$1;
      }

      var liftedColor = liftedColorMap.get(color$1);

      if (!liftedColor) {
        liftedColor = color.lift(color$1, -0.1);

        if (liftedColorCount < 10000) {
          liftedColorMap.set(color$1, liftedColor);
          liftedColorCount++;
        }
      }

      return liftedColor;
    }

    function cacheElementStl(el) {
      if (!el.__hoverStlDirty) {
        return;
      }

      el.__hoverStlDirty = false;
      var hoverStyle = el.__hoverStl;

      if (!hoverStyle) {
        el.__cachedNormalStl = el.__cachedNormalZ2 = null;
        return;
      }

      var normalStyle = el.__cachedNormalStl = {};
      el.__cachedNormalZ2 = el.z2;
      var elStyle = el.style;

      for (var name in hoverStyle) {
        // See comment in `singleEnterEmphasis`.
        if (hoverStyle[name] != null) {
          normalStyle[name] = elStyle[name];
        }
      } // Always cache fill and stroke to normalStyle for lifting color.


      normalStyle.fill = elStyle.fill;
      normalStyle.stroke = elStyle.stroke;
    }

    function singleEnterEmphasis(el) {
      var hoverStl = el.__hoverStl;

      if (!hoverStl || el.__highlighted) {
        return;
      }

      var zr = el.__zr;
      var useHoverLayer = el.useHoverLayer && zr && zr.painter.type === 'canvas';
      el.__highlighted = useHoverLayer ? 'layer' : 'plain';

      if (el.isGroup || !zr && el.useHoverLayer) {
        return;
      }

      var elTarget = el;
      var targetStyle = el.style;

      if (useHoverLayer) {
        elTarget = zr.addHover(el);
        targetStyle = elTarget.style;
      }

      rollbackDefaultTextStyle(targetStyle);

      if (!useHoverLayer) {
        cacheElementStl(elTarget);
      } // styles can be:
      // {
      //    label: {
      //        show: false,
      //        position: 'outside',
      //        fontSize: 18
      //    },
      //    emphasis: {
      //        label: {
      //            show: true
      //        }
      //    }
      // },
      // where properties of `emphasis` may not appear in `normal`. We previously use
      // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.
      // But consider rich text and setOption in merge mode, it is impossible to cover
      // all properties in merge. So we use merge mode when setting style here.
      // But we choose the merge strategy that only properties that is not `null/undefined`.
      // Because when making a textStyle (espacially rich text), it is not easy to distinguish
      // `hasOwnProperty` and `null/undefined` in code, so we trade them as the same for simplicity.
      // But this strategy brings a trouble that `null/undefined` can not be used to remove
      // style any more in `emphasis`. Users can both set properties directly on normal and
      // emphasis to avoid this issue, or we might support `'none'` for this case if required.


      targetStyle.extendFrom(hoverStl);
      setDefaultHoverFillStroke(targetStyle, hoverStl, 'fill');
      setDefaultHoverFillStroke(targetStyle, hoverStl, 'stroke');
      applyDefaultTextStyle(targetStyle);

      if (!useHoverLayer) {
        el.dirty(false);
        el.z2 += Z2_EMPHASIS_LIFT;
      }
    }

    function setDefaultHoverFillStroke(targetStyle, hoverStyle, prop) {
      if (!hasFillOrStroke(hoverStyle[prop]) && hasFillOrStroke(targetStyle[prop])) {
        targetStyle[prop] = liftColor(targetStyle[prop]);
      }
    }

    function singleEnterNormal(el) {
      var highlighted = el.__highlighted;

      if (!highlighted) {
        return;
      }

      el.__highlighted = false;

      if (el.isGroup) {
        return;
      }

      if (highlighted === 'layer') {
        el.__zr && el.__zr.removeHover(el);
      } else {
        var style = el.style;
        var normalStl = el.__cachedNormalStl;

        if (normalStl) {
          rollbackDefaultTextStyle(style);
          el.setStyle(normalStl);
          applyDefaultTextStyle(style);
        } // `__cachedNormalZ2` will not be reset if calling `setElementHoverStyle`
        // when `el` is on emphasis state. So here by comparing with 1, we try
        // hard to make the bug case rare.


        var normalZ2 = el.__cachedNormalZ2;

        if (normalZ2 != null && el.z2 - normalZ2 === Z2_EMPHASIS_LIFT) {
          el.z2 = normalZ2;
        }
      }
    }

    function traverseUpdate(el, updater, commonParam) {
      // If root is group, also enter updater for `highDownOnUpdate`.
      var fromState = NORMAL;
      var toState = NORMAL;
      var trigger; // See the rule of `highDownOnUpdate` on `graphic.setAsHighDownDispatcher`.

      el.__highlighted && (fromState = EMPHASIS, trigger = true);
      updater(el, commonParam);
      el.__highlighted && (toState = EMPHASIS, trigger = true);
      el.isGroup && el.traverse(function (child) {
        !child.isGroup && updater(child, commonParam);
      });
      trigger && el.__highDownOnUpdate && el.__highDownOnUpdate(fromState, toState);
    }
    /**
     * Set hover style (namely "emphasis style") of element, based on the current
     * style of the given `el`.
     * This method should be called after all of the normal styles have been adopted
     * to the `el`. See the reason on `setHoverStyle`.
     *
     * @param {module:zrender/Element} el Should not be `zrender/container/Group`.
     * @param {Object} [el.hoverStyle] Can be set on el or its descendants,
     *        e.g., `el.hoverStyle = ...; graphic.setHoverStyle(el); `.
     *        Often used when item group has a label element and it's hoverStyle is different.
     * @param {Object|boolean} [hoverStl] The specified hover style.
     *        If set as `false`, disable the hover style.
     *        Similarly, The `el.hoverStyle` can alse be set
     *        as `false` to disable the hover style.
     *        Otherwise, use the default hover style if not provided.
     */


    function setElementHoverStyle(el, hoverStl) {
      // For performance consideration, it might be better to make the "hover style" only the
      // difference properties from the "normal style", but not a entire copy of all styles.
      hoverStl = el.__hoverStl = hoverStl !== false && (el.hoverStyle || hoverStl || {});
      el.__hoverStlDirty = true; // FIXME
      // It is not completely right to save "normal"/"emphasis" flag on elements.
      // It probably should be saved on `data` of series. Consider the cases:
      // (1) A highlighted elements are moved out of the view port and re-enter
      // again by dataZoom.
      // (2) call `setOption` and replace elements totally when they are highlighted.

      if (el.__highlighted) {
        // Consider the case:
        // The styles of a highlighted `el` is being updated. The new "emphasis style"
        // should be adapted to the `el`. Notice here new "normal styles" should have
        // been set outside and the cached "normal style" is out of date.
        el.__cachedNormalStl = null; // Do not clear `__cachedNormalZ2` here, because setting `z2` is not a constraint
        // of this method. In most cases, `z2` is not set and hover style should be able
        // to rollback. Of course, that would bring bug, but only in a rare case, see
        // `doSingleLeaveHover` for details.

        singleEnterNormal(el);
        singleEnterEmphasis(el);
      }
    }

    function onElementMouseOver(e) {
      !shouldSilent(this, e) // "emphasis" event highlight has higher priority than mouse highlight.
      && !this.__highByOuter && traverseUpdate(this, singleEnterEmphasis);
    }

    function onElementMouseOut(e) {
      !shouldSilent(this, e) // "emphasis" event highlight has higher priority than mouse highlight.
      && !this.__highByOuter && traverseUpdate(this, singleEnterNormal);
    }

    function onElementEmphasisEvent(highlightDigit) {
      this.__highByOuter |= 1 << (highlightDigit || 0);
      traverseUpdate(this, singleEnterEmphasis);
    }

    function onElementNormalEvent(highlightDigit) {
      !(this.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdate(this, singleEnterNormal);
    }

    function shouldSilent(el, e) {
      return el.__highDownSilentOnTouch && e.zrByTouch;
    }
    /**
     * Set hover style (namely "emphasis style") of element,
     * based on the current style of the given `el`.
     *
     * (1)
     * **CONSTRAINTS** for this method:
     * <A> This method MUST be called after all of the normal styles having been adopted
     * to the `el`.
     * <B> The input `hoverStyle` (that is, "emphasis style") MUST be the subset of the
     * "normal style" having been set to the el.
     * <C> `color` MUST be one of the "normal styles" (because color might be lifted as
     * a default hover style).
     *
     * The reason: this method treat the current style of the `el` as the "normal style"
     * and cache them when enter/update the "emphasis style". Consider the case: the `el`
     * is in "emphasis" state and `setOption`/`dispatchAction` trigger the style updating
     * logic, where the el should shift from the original emphasis style to the new
     * "emphasis style" and should be able to "downplay" back to the new "normal style".
     *
     * Indeed, it is error-prone to make a interface has so many constraints, but I have
     * not found a better solution yet to fit the backward compatibility, performance and
     * the current programming style.
     *
     * (2)
     * Call the method for a "root" element once. Do not call it for each descendants.
     * If the descendants elemenets of a group has itself hover style different from the
     * root group, we can simply mount the style on `el.hoverStyle` for them, but should
     * not call this method for them.
     *
     * (3) These input parameters can be set directly on `el`:
     *
     * @param {module:zrender/Element} el
     * @param {Object} [el.hoverStyle] See `graphic.setElementHoverStyle`.
     * @param {boolean} [el.highDownSilentOnTouch=false] See `graphic.setAsHighDownDispatcher`.
     * @param {Function} [el.highDownOnUpdate] See `graphic.setAsHighDownDispatcher`.
     * @param {Object|boolean} [hoverStyle] See `graphic.setElementHoverStyle`.
     */


    function setHoverStyle(el, hoverStyle) {
      setAsHighDownDispatcher(el, true);
      traverseUpdate(el, setElementHoverStyle, hoverStyle);
    }
    /**
     * @param {module:zrender/Element} el
     * @param {Function} [el.highDownOnUpdate] Called when state updated.
     *        Since `setHoverStyle` has the constraint that it must be called after
     *        all of the normal style updated, `highDownOnUpdate` is not needed to
     *        trigger if both `fromState` and `toState` is 'normal', and needed to
     *        trigger if both `fromState` and `toState` is 'emphasis', which enables
     *        to sync outside style settings to "emphasis" state.
     *        @this {string} This dispatcher `el`.
     *        @param {string} fromState Can be "normal" or "emphasis".
     *               `fromState` might equal to `toState`,
     *               for example, when this method is called when `el` is
     *               on "emphasis" state.
     *        @param {string} toState Can be "normal" or "emphasis".
     *
     *        FIXME
     *        CAUTION: Do not expose `highDownOnUpdate` outside echarts.
     *        Because it is not a complete solution. The update
     *        listener should not have been mount in element,
     *        and the normal/emphasis state should not have
     *        mantained on elements.
     *
     * @param {boolean} [el.highDownSilentOnTouch=false]
     *        In touch device, mouseover event will be trigger on touchstart event
     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
     *        conveniently use hoverStyle when tap on touch screen without additional
     *        code for compatibility.
     *        But if the chart/component has select feature, which usually also use
     *        hoverStyle, there might be conflict between 'select-highlight' and
     *        'hover-highlight' especially when roam is enabled (see geo for example).
     *        In this case, `highDownSilentOnTouch` should be used to disable
     *        hover-highlight on touch device.
     * @param {boolean} [asDispatcher=true] If `false`, do not set as "highDownDispatcher".
     */


    function setAsHighDownDispatcher(el, asDispatcher) {
      var disable = asDispatcher === false; // Make `highDownSilentOnTouch` and `highDownOnUpdate` only work after
      // `setAsHighDownDispatcher` called. Avoid it is modified by user unexpectedly.

      el.__highDownSilentOnTouch = el.highDownSilentOnTouch;
      el.__highDownOnUpdate = el.highDownOnUpdate; // Simple optimize, since this method might be
      // called for each elements of a group in some cases.

      if (!disable || el.__highDownDispatcher) {
        var method = disable ? 'off' : 'on'; // Duplicated function will be auto-ignored, see Eventful.js.

        el[method]('mouseover', onElementMouseOver)[method]('mouseout', onElementMouseOut); // Emphasis, normal can be triggered manually by API or other components like hover link.

        el[method]('emphasis', onElementEmphasisEvent)[method]('normal', onElementNormalEvent); // Also keep previous record.

        el.__highByOuter = el.__highByOuter || 0;
        el.__highDownDispatcher = !disable;
      }
    }
    /**
     * @param {module:zrender/src/Element} el
     * @return {boolean}
     */


    function isHighDownDispatcher(el) {
      return !!(el && el.__highDownDispatcher);
    }
    /**
     * Support hightlight/downplay record on each elements.
     * For the case: hover highlight/downplay (legend, visualMap, ...) and
     * user triggerred hightlight/downplay should not conflict.
     * Only all of the highlightDigit cleared, return to normal.
     * @param {string} highlightKey
     * @return {number} highlightDigit
     */


    function getHighlightDigit(highlightKey) {
      var highlightDigit = _highlightKeyMap[highlightKey];

      if (highlightDigit == null && _highlightNextDigit <= 32) {
        highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
      }

      return highlightDigit;
    }
    /**
     * See more info in `setTextStyleCommon`.
     * @param {Object|module:zrender/graphic/Style} normalStyle
     * @param {Object} emphasisStyle
     * @param {module:echarts/model/Model} normalModel
     * @param {module:echarts/model/Model} emphasisModel
     * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.
     * @param {string|Function} [opt.defaultText]
     * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by
     *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex, opt.labelProp)`
     * @param {number} [opt.labelDataIndex] Fetch text by
     *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex, opt.labelProp)`
     * @param {number} [opt.labelDimIndex] Fetch text by
     *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex, opt.labelProp)`
     * @param {string} [opt.labelProp] Fetch text by
     *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex, opt.labelProp)`
     * @param {Object} [normalSpecified]
     * @param {Object} [emphasisSpecified]
     */


    function setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {
      opt = opt || EMPTY_OBJ;
      var labelFetcher = opt.labelFetcher;
      var labelDataIndex = opt.labelDataIndex;
      var labelDimIndex = opt.labelDimIndex;
      var labelProp = opt.labelProp; // This scenario, `label.normal.show = true; label.emphasis.show = false`,
      // is not supported util someone requests.

      var showNormal = normalModel.getShallow('show');
      var showEmphasis = emphasisModel.getShallow('show'); // Consider performance, only fetch label when necessary.
      // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,
      // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.

      var baseText;

      if (showNormal || showEmphasis) {
        if (labelFetcher) {
          baseText = labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex, labelProp);
        }

        if (baseText == null) {
          baseText = util.isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt) : opt.defaultText;
        }
      }

      var normalStyleText = showNormal ? baseText : null;
      var emphasisStyleText = showEmphasis ? util.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex, labelProp) : null, baseText) : null; // Optimize: If style.text is null, text will not be drawn.

      if (normalStyleText != null || emphasisStyleText != null) {
        // Always set `textStyle` even if `normalStyle.text` is null, because default
        // values have to be set on `normalStyle`.
        // If we set default values on `emphasisStyle`, consider case:
        // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`
        // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`
        // Then the 'red' will not work on emphasis.
        setTextStyle(normalStyle, normalModel, normalSpecified, opt);
        setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);
      }

      normalStyle.text = normalStyleText;
      emphasisStyle.text = emphasisStyleText;
    }
    /**
     * Modify label style manually.
     * Only works after `setLabelStyle` and `setElementHoverStyle` called.
     *
     * @param {module:zrender/src/Element} el
     * @param {Object} [normalStyleProps] optional
     * @param {Object} [emphasisStyleProps] optional
     */


    function modifyLabelStyle(el, normalStyleProps, emphasisStyleProps) {
      var elStyle = el.style;

      if (normalStyleProps) {
        rollbackDefaultTextStyle(elStyle);
        el.setStyle(normalStyleProps);
        applyDefaultTextStyle(elStyle);
      }

      elStyle = el.__hoverStl;

      if (emphasisStyleProps && elStyle) {
        rollbackDefaultTextStyle(elStyle);
        util.extend(elStyle, emphasisStyleProps);
        applyDefaultTextStyle(elStyle);
      }
    }
    /**
     * Set basic textStyle properties.
     * See more info in `setTextStyleCommon`.
     * @param {Object|module:zrender/graphic/Style} textStyle
     * @param {module:echarts/model/Model} model
     * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.
     * @param {Object} [opt] See `opt` of `setTextStyleCommon`.
     * @param {boolean} [isEmphasis]
     */


    function setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {
      setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);
      specifiedTextStyle && util.extend(textStyle, specifiedTextStyle); // textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);

      return textStyle;
    }
    /**
     * Set text option in the style.
     * See more info in `setTextStyleCommon`.
     * @deprecated
     * @param {Object} textStyle
     * @param {module:echarts/model/Model} labelModel
     * @param {string|boolean} defaultColor Default text color.
     *        If set as false, it will be processed as a emphasis style.
     */


    function setText(textStyle, labelModel, defaultColor) {
      var opt = {
        isRectText: true
      };
      var isEmphasis;

      if (defaultColor === false) {
        isEmphasis = true;
      } else {
        // Support setting color as 'auto' to get visual color.
        opt.autoColor = defaultColor;
      }

      setTextStyleCommon(textStyle, labelModel, opt, isEmphasis); // textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);
    }
    /**
     * The uniform entry of set text style, that is, retrieve style definitions
     * from `model` and set to `textStyle` object.
     *
     * Never in merge mode, but in overwrite mode, that is, all of the text style
     * properties will be set. (Consider the states of normal and emphasis and
     * default value can be adopted, merge would make the logic too complicated
     * to manage.)
     *
     * The `textStyle` object can either be a plain object or an instance of
     * `zrender/src/graphic/Style`, and either be the style of normal or emphasis.
     * After this mothod called, the `textStyle` object can then be used in
     * `el.setStyle(textStyle)` or `el.hoverStyle = textStyle`.
     *
     * Default value will be adopted and `insideRollbackOpt` will be created.
     * See `applyDefaultTextStyle` `rollbackDefaultTextStyle` for more details.
     *
     * opt: {
     *      disableBox: boolean, Whether diable drawing box of block (outer most).
     *      isRectText: boolean,
     *      autoColor: string, specify a color when color is 'auto',
     *              for textFill, textStroke, textBackgroundColor, and textBorderColor.
     *              If autoColor specified, it is used as default textFill.
     *      useInsideStyle:
     *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)
     *                  if `textFill` is not specified.
     *              `false`: Do not use inside style.
     *              `null/undefined`: use inside style if `isRectText` is true and
     *                  `textFill` is not specified and textPosition contains `'inside'`.
     *      forceRich: boolean
     * }
     */


    function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {
      // Consider there will be abnormal when merge hover style to normal style if given default value.
      opt = opt || EMPTY_OBJ;

      if (opt.isRectText) {
        var textPosition;

        if (opt.getTextPosition) {
          textPosition = opt.getTextPosition(textStyleModel, isEmphasis);
        } else {
          textPosition = textStyleModel.getShallow('position') || (isEmphasis ? null : 'inside'); // 'outside' is not a valid zr textPostion value, but used
          // in bar series, and magric type should be considered.

          textPosition === 'outside' && (textPosition = 'top');
        }

        textStyle.textPosition = textPosition;
        textStyle.textOffset = textStyleModel.getShallow('offset');
        var labelRotate = textStyleModel.getShallow('rotate');
        labelRotate != null && (labelRotate *= Math.PI / 180);
        textStyle.textRotation = labelRotate;
        textStyle.textDistance = util.retrieve2(textStyleModel.getShallow('distance'), isEmphasis ? null : 5);
      }

      var ecModel = textStyleModel.ecModel;
      var globalTextStyle = ecModel && ecModel.option.textStyle; // Consider case:
      // {
      //     data: [{
      //         value: 12,
      //         label: {
      //             rich: {
      //                 // no 'a' here but using parent 'a'.
      //             }
      //         }
      //     }],
      //     rich: {
      //         a: { ... }
      //     }
      // }

      var richItemNames = getRichItemNames(textStyleModel);
      var richResult;

      if (richItemNames) {
        richResult = {};

        for (var name in richItemNames) {
          if (richItemNames.hasOwnProperty(name)) {
            // Cascade is supported in rich.
            var richTextStyle = textStyleModel.getModel(['rich', name]); // In rich, never `disableBox`.
            // FIXME: consider `label: {formatter: '{a|xx}', color: 'blue', rich: {a: {}}}`,
            // the default color `'blue'` will not be adopted if no color declared in `rich`.
            // That might confuses users. So probably we should put `textStyleModel` as the
            // root ancestor of the `richTextStyle`. But that would be a break change.

            setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);
          }
        }
      }

      textStyle.rich = richResult;
      setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);

      if (opt.forceRich && !opt.textStyle) {
        opt.textStyle = {};
      }

      return textStyle;
    } // Consider case:
    // {
    //     data: [{
    //         value: 12,
    //         label: {
    //             rich: {
    //                 // no 'a' here but using parent 'a'.
    //             }
    //         }
    //     }],
    //     rich: {
    //         a: { ... }
    //     }
    // }


    function getRichItemNames(textStyleModel) {
      // Use object to remove duplicated names.
      var richItemNameMap;

      while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
        var rich = (textStyleModel.option || EMPTY_OBJ).rich;

        if (rich) {
          richItemNameMap = richItemNameMap || {};

          for (var name in rich) {
            if (rich.hasOwnProperty(name)) {
              richItemNameMap[name] = 1;
            }
          }
        }

        textStyleModel = textStyleModel.parentModel;
      }

      return richItemNameMap;
    }

    function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {
      // In merge mode, default value should not be given.
      globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;
      textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt) || globalTextStyle.color;
      textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt) || globalTextStyle.textBorderColor;
      textStyle.textStrokeWidth = util.retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);

      if (!isEmphasis) {
        if (isBlock) {
          textStyle.insideRollbackOpt = opt;
          applyDefaultTextStyle(textStyle);
        } // Set default finally.


        if (textStyle.textFill == null) {
          textStyle.textFill = opt.autoColor;
        }
      } // Do not use `getFont` here, because merge should be supported, where
      // part of these properties may be changed in emphasis style, and the
      // others should remain their original value got from normal style.


      textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;
      textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;
      textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;
      textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;
      textStyle.textAlign = textStyleModel.getShallow('align');
      textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign') || textStyleModel.getShallow('baseline');
      textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');
      textStyle.textWidth = textStyleModel.getShallow('width');
      textStyle.textHeight = textStyleModel.getShallow('height');
      textStyle.textTag = textStyleModel.getShallow('tag');

      if (!isBlock || !opt.disableBox) {
        textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);
        textStyle.textPadding = textStyleModel.getShallow('padding');
        textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);
        textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');
        textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');
        textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');
        textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');
        textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');
        textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');
      }

      textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor') || globalTextStyle.textShadowColor;
      textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur') || globalTextStyle.textShadowBlur;
      textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX') || globalTextStyle.textShadowOffsetX;
      textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY') || globalTextStyle.textShadowOffsetY;
    }

    function getAutoColor(color, opt) {
      return color !== 'auto' ? color : opt && opt.autoColor ? opt.autoColor : null;
    }
    /**
     * Give some default value to the input `textStyle` object, based on the current settings
     * in this `textStyle` object.
     *
     * The Scenario:
     * when text position is `inside` and `textFill` is not specified, we show
     * text border by default for better view. But it should be considered that text position
     * might be changed when hovering or being emphasis, where the `insideRollback` is used to
     * restore the style.
     *
     * Usage (& NOTICE):
     * When a style object (eithor plain object or instance of `zrender/src/graphic/Style`) is
     * about to be modified on its text related properties, `rollbackDefaultTextStyle` should
     * be called before the modification and `applyDefaultTextStyle` should be called after that.
     * (For the case that all of the text related properties is reset, like `setTextStyleCommon`
     * does, `rollbackDefaultTextStyle` is not needed to be called).
     */


    function applyDefaultTextStyle(textStyle) {
      var textPosition = textStyle.textPosition;
      var opt = textStyle.insideRollbackOpt;
      var insideRollback;

      if (opt && textStyle.textFill == null) {
        var autoColor = opt.autoColor;
        var isRectText = opt.isRectText;
        var useInsideStyle = opt.useInsideStyle;
        var useInsideStyleCache = useInsideStyle !== false && (useInsideStyle === true || isRectText && textPosition // textPosition can be [10, 30]
        && typeof textPosition === 'string' && textPosition.indexOf('inside') >= 0);
        var useAutoColorCache = !useInsideStyleCache && autoColor != null; // All of the props declared in `CACHED_LABEL_STYLE_PROPERTIES` are to be cached.

        if (useInsideStyleCache || useAutoColorCache) {
          insideRollback = {
            textFill: textStyle.textFill,
            textStroke: textStyle.textStroke,
            textStrokeWidth: textStyle.textStrokeWidth
          };
        }

        if (useInsideStyleCache) {
          textStyle.textFill = '#fff'; // Consider text with #fff overflow its container.

          if (textStyle.textStroke == null) {
            textStyle.textStroke = autoColor;
            textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);
          }
        }

        if (useAutoColorCache) {
          textStyle.textFill = autoColor;
        }
      } // Always set `insideRollback`, so that the previous one can be cleared.


      textStyle.insideRollback = insideRollback;
    }
    /**
     * Consider the case: in a scatter,
     * label: {
     *     normal: {position: 'inside'},
     *     emphasis: {position: 'top'}
     * }
     * In the normal state, the `textFill` will be set as '#fff' for pretty view (see
     * `applyDefaultTextStyle`), but when switching to emphasis state, the `textFill`
     * should be retured to 'autoColor', but not keep '#fff'.
     */


    function rollbackDefaultTextStyle(style) {
      var insideRollback = style.insideRollback;

      if (insideRollback) {
        // Reset all of the props in `CACHED_LABEL_STYLE_PROPERTIES`.
        style.textFill = insideRollback.textFill;
        style.textStroke = insideRollback.textStroke;
        style.textStrokeWidth = insideRollback.textStrokeWidth;
        style.insideRollback = null;
      }
    }

    function getFont(opt, ecModel) {
      var gTextStyleModel = ecModel && ecModel.getModel('textStyle');
      return util.trim([// FIXME in node-canvas fontWeight is before fontStyle
      opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' '));
    }

    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
      if (typeof dataIndex === 'function') {
        cb = dataIndex;
        dataIndex = null;
      } // Do not check 'animation' property directly here. Consider this case:
      // animation model is an `itemModel`, whose does not have `isAnimationEnabled`
      // but its parent model (`seriesModel`) does.


      var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();

      if (animationEnabled) {
        var postfix = isUpdate ? 'Update' : '';
        var duration = animatableModel.getShallow('animationDuration' + postfix);
        var animationEasing = animatableModel.getShallow('animationEasing' + postfix);
        var animationDelay = animatableModel.getShallow('animationDelay' + postfix);

        if (typeof animationDelay === 'function') {
          animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
        }

        if (typeof duration === 'function') {
          duration = duration(dataIndex);
        }

        duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());
      } else {
        el.stopAnimation();
        el.attr(props);
        cb && cb();
      }
    }
    /**
     * Update graphic element properties with or without animation according to the
     * configuration in series.
     *
     * Caution: this method will stop previous animation.
     * So do not use this method to one element twice before
     * animation starts, unless you know what you are doing.
     *
     * @param {module:zrender/Element} el
     * @param {Object} props
     * @param {module:echarts/model/Model} [animatableModel]
     * @param {number} [dataIndex]
     * @param {Function} [cb]
     * @example
     *     graphic.updateProps(el, {
     *         position: [100, 100]
     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
     *     // Or
     *     graphic.updateProps(el, {
     *         position: [100, 100]
     *     }, seriesModel, function () { console.log('Animation done!'); });
     */


    function updateProps(el, props, animatableModel, dataIndex, cb) {
      animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
    }
    /**
     * Init graphic element properties with or without animation according to the
     * configuration in series.
     *
     * Caution: this method will stop previous animation.
     * So do not use this method to one element twice before
     * animation starts, unless you know what you are doing.
     *
     * @param {module:zrender/Element} el
     * @param {Object} props
     * @param {module:echarts/model/Model} [animatableModel]
     * @param {number} [dataIndex]
     * @param {Function} cb
     */


    function initProps(el, props, animatableModel, dataIndex, cb) {
      animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
    }
    /**
     * Get transform matrix of target (param target),
     * in coordinate of its ancestor (param ancestor)
     *
     * @param {module:zrender/mixin/Transformable} target
     * @param {module:zrender/mixin/Transformable} [ancestor]
     */


    function getTransform(target, ancestor) {
      var mat = matrix.identity([]);

      while (target && target !== ancestor) {
        matrix.mul(mat, target.getLocalTransform(), mat);
        target = target.parent;
      }

      return mat;
    }
    /**
     * Apply transform to an vertex.
     * @param {Array.<number>} target [x, y]
     * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:
     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]
     *      + {position, rotation, scale}, the same as `zrender/Transformable`.
     * @param {boolean=} invert Whether use invert matrix.
     * @return {Array.<number>} [x, y]
     */


    function applyTransform$1(target, transform, invert) {
      if (transform && !util.isArrayLike(transform)) {
        transform = Transformable_1.getLocalTransform(transform);
      }

      if (invert) {
        transform = matrix.invert([], transform);
      }

      return vector.applyTransform([], target, transform);
    }
    /**
     * @param {string} direction 'left' 'right' 'top' 'bottom'
     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
     * @param {boolean=} invert Whether use invert matrix.
     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
     */


    function transformDirection(direction, transform, invert) {
      // Pick a base, ensure that transform result will not be (0, 0).
      var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
      var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
      var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];
      vertex = applyTransform$1(vertex, transform, invert);
      return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';
    }
    /**
     * Apply group transition animation from g1 to g2.
     * If no animatableModel, no animation.
     */


    function groupTransition(g1, g2, animatableModel, cb) {
      if (!g1 || !g2) {
        return;
      }

      function getElMap(g) {
        var elMap = {};
        g.traverse(function (el) {
          if (!el.isGroup && el.anid) {
            elMap[el.anid] = el;
          }
        });
        return elMap;
      }

      function getAnimatableProps(el) {
        var obj = {
          position: vector.clone(el.position),
          rotation: el.rotation
        };

        if (el.shape) {
          obj.shape = util.extend({}, el.shape);
        }

        return obj;
      }

      var elMap1 = getElMap(g1);
      g2.traverse(function (el) {
        if (!el.isGroup && el.anid) {
          var oldEl = elMap1[el.anid];

          if (oldEl) {
            var newProp = getAnimatableProps(el);
            el.attr(getAnimatableProps(oldEl));
            updateProps(el, newProp, animatableModel, el.dataIndex);
          } // else {
          //     if (el.previousProps) {
          //         graphic.updateProps
          //     }
          // }

        }
      });
    }
    /**
     * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]
     * @param {Object} rect {x, y, width, height}
     * @return {Array.<Array.<number>>} A new clipped points.
     */


    function clipPointsByRect(points, rect) {
      // FIXME: this way migth be incorrect when grpahic clipped by a corner.
      // and when element have border.
      return util.map(points, function (point) {
        var x = point[0];
        x = mathMax$3(x, rect.x);
        x = mathMin$3(x, rect.x + rect.width);
        var y = point[1];
        y = mathMax$3(y, rect.y);
        y = mathMin$3(y, rect.y + rect.height);
        return [x, y];
      });
    }
    /**
     * @param {Object} targetRect {x, y, width, height}
     * @param {Object} rect {x, y, width, height}
     * @return {Object} A new clipped rect. If rect size are negative, return undefined.
     */


    function clipRectByRect(targetRect, rect) {
      var x = mathMax$3(targetRect.x, rect.x);
      var x2 = mathMin$3(targetRect.x + targetRect.width, rect.x + rect.width);
      var y = mathMax$3(targetRect.y, rect.y);
      var y2 = mathMin$3(targetRect.y + targetRect.height, rect.y + rect.height); // If the total rect is cliped, nothing, including the border,
      // should be painted. So return undefined.

      if (x2 >= x && y2 >= y) {
        return {
          x: x,
          y: y,
          width: x2 - x,
          height: y2 - y
        };
      }
    }
    /**
     * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.
     * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.
     * @param {Object} [rect] {x, y, width, height}
     * @return {module:zrender/Element} Icon path or image element.
     */


    function createIcon(iconStr, opt, rect) {
      opt = util.extend({
        rectHover: true
      }, opt);
      var style = opt.style = {
        strokeNoScale: true
      };
      rect = rect || {
        x: -1,
        y: -1,
        width: 2,
        height: 2
      };

      if (iconStr) {
        return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), util.defaults(style, rect), new Image$1(opt)) : makePath(iconStr.replace('path://', ''), opt, rect, 'center');
      }
    }
    /**
     * Return `true` if the given line (line `a`) and the given polygon
     * are intersect.
     * Note that we do not count colinear as intersect here because no
     * requirement for that. We could do that if required in future.
     *
     * @param {number} a1x
     * @param {number} a1y
     * @param {number} a2x
     * @param {number} a2y
     * @param {Array.<Array.<number>>} points Points of the polygon.
     * @return {boolean}
     */


    function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {
      for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {
        var p = points[i];

        if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
          return true;
        }

        p2 = p;
      }
    }
    /**
     * Return `true` if the given two lines (line `a` and line `b`)
     * are intersect.
     * Note that we do not count colinear as intersect here because no
     * requirement for that. We could do that if required in future.
     *
     * @param {number} a1x
     * @param {number} a1y
     * @param {number} a2x
     * @param {number} a2y
     * @param {number} b1x
     * @param {number} b1y
     * @param {number} b2x
     * @param {number} b2y
     * @return {boolean}
     */


    function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
      // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.
      var mx = a2x - a1x;
      var my = a2y - a1y;
      var nx = b2x - b1x;
      var ny = b2y - b1y; // `vec_m` and `vec_n` are parallel iff
      //     exising `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.

      var nmCrossProduct = crossProduct2d(nx, ny, mx, my);

      if (nearZero(nmCrossProduct)) {
        return false;
      } // `vec_m` and `vec_n` are intersect iff
      //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,
      //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`
      //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.


      var b1a1x = a1x - b1x;
      var b1a1y = a1y - b1y;
      var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;

      if (q < 0 || q > 1) {
        return false;
      }

      var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;

      if (p < 0 || p > 1) {
        return false;
      }

      return true;
    }
    /**
     * Cross product of 2-dimension vector.
     */


    function crossProduct2d(x1, y1, x2, y2) {
      return x1 * y2 - x2 * y1;
    }

    function nearZero(val) {
      return val <= 1e-6 && val >= -1e-6;
    } // Register built-in shapes. These shapes might be overwirtten
    // by users, although we do not recommend that.


    registerShape('circle', Circle);
    registerShape('sector', Sector);
    registerShape('ring', Ring);
    registerShape('polygon', Polygon);
    registerShape('polyline', Polyline);
    registerShape('rect', Rect);
    registerShape('line', Line);
    registerShape('bezierCurve', BezierCurve);
    registerShape('arc', Arc);
    var Z2_EMPHASIS_LIFT_1 = Z2_EMPHASIS_LIFT;
    var CACHED_LABEL_STYLE_PROPERTIES_1 = CACHED_LABEL_STYLE_PROPERTIES;
    var extendShape_1 = extendShape;
    var extendPath_1 = extendPath;
    var registerShape_1 = registerShape;
    var getShapeClass_1 = getShapeClass;
    var makePath_1 = makePath;
    var makeImage_1 = makeImage;
    var mergePath_1$1 = mergePath$1;
    var resizePath_1 = resizePath;
    var subPixelOptimizeLine_1$1 = subPixelOptimizeLine$2;
    var subPixelOptimizeRect_1$1 = subPixelOptimizeRect$2;
    var subPixelOptimize_1$1 = subPixelOptimize$1;
    var setElementHoverStyle_1 = setElementHoverStyle;
    var setHoverStyle_1 = setHoverStyle;
    var setAsHighDownDispatcher_1 = setAsHighDownDispatcher;
    var isHighDownDispatcher_1 = isHighDownDispatcher;
    var getHighlightDigit_1 = getHighlightDigit;
    var setLabelStyle_1 = setLabelStyle;
    var modifyLabelStyle_1 = modifyLabelStyle;
    var setTextStyle_1 = setTextStyle;
    var setText_1 = setText;
    var getFont_1 = getFont;
    var updateProps_1 = updateProps;
    var initProps_1 = initProps;
    var getTransform_1 = getTransform;
    var applyTransform_1$1 = applyTransform$1;
    var transformDirection_1 = transformDirection;
    var groupTransition_1 = groupTransition;
    var clipPointsByRect_1 = clipPointsByRect;
    var clipRectByRect_1 = clipRectByRect;
    var createIcon_1 = createIcon;
    var linePolygonIntersect_1 = linePolygonIntersect;
    var lineLineIntersect_1 = lineLineIntersect;

    var graphic = {
    	Image: Image$2,
    	Group: Group_1$1,
    	Text: Text_1$1,
    	Circle: Circle_1,
    	Sector: Sector_1,
    	Ring: Ring_1,
    	Polygon: Polygon_1,
    	Polyline: Polyline_1,
    	Rect: Rect_1,
    	Line: Line_1,
    	BezierCurve: BezierCurve_1,
    	Arc: Arc_1,
    	CompoundPath: CompoundPath_1,
    	LinearGradient: LinearGradient_1$1,
    	RadialGradient: RadialGradient_1$1,
    	BoundingRect: BoundingRect_1$1,
    	IncrementalDisplayable: IncrementalDisplayable_1,
    	Z2_EMPHASIS_LIFT: Z2_EMPHASIS_LIFT_1,
    	CACHED_LABEL_STYLE_PROPERTIES: CACHED_LABEL_STYLE_PROPERTIES_1,
    	extendShape: extendShape_1,
    	extendPath: extendPath_1,
    	registerShape: registerShape_1,
    	getShapeClass: getShapeClass_1,
    	makePath: makePath_1,
    	makeImage: makeImage_1,
    	mergePath: mergePath_1$1,
    	resizePath: resizePath_1,
    	subPixelOptimizeLine: subPixelOptimizeLine_1$1,
    	subPixelOptimizeRect: subPixelOptimizeRect_1$1,
    	subPixelOptimize: subPixelOptimize_1$1,
    	setElementHoverStyle: setElementHoverStyle_1,
    	setHoverStyle: setHoverStyle_1,
    	setAsHighDownDispatcher: setAsHighDownDispatcher_1,
    	isHighDownDispatcher: isHighDownDispatcher_1,
    	getHighlightDigit: getHighlightDigit_1,
    	setLabelStyle: setLabelStyle_1,
    	modifyLabelStyle: modifyLabelStyle_1,
    	setTextStyle: setTextStyle_1,
    	setText: setText_1,
    	getFont: getFont_1,
    	updateProps: updateProps_1,
    	initProps: initProps_1,
    	getTransform: getTransform_1,
    	applyTransform: applyTransform_1$1,
    	transformDirection: transformDirection_1,
    	groupTransition: groupTransition_1,
    	clipPointsByRect: clipPointsByRect_1,
    	clipRectByRect: clipRectByRect_1,
    	createIcon: createIcon_1,
    	linePolygonIntersect: linePolygonIntersect_1,
    	lineLineIntersect: lineLineIntersect_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var PATH_COLOR = ['textStyle', 'color'];
    var _default$R = {
      /**
       * Get color property or get color from option.textStyle.color
       * @param {boolean} [isEmphasis]
       * @return {string}
       */
      getTextColor: function (isEmphasis) {
        var ecModel = this.ecModel;
        return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
      },

      /**
       * Create font string from fontStyle, fontWeight, fontSize, fontFamily
       * @return {string}
       */
      getFont: function () {
        return graphic.getFont({
          fontStyle: this.getShallow('fontStyle'),
          fontWeight: this.getShallow('fontWeight'),
          fontSize: this.getShallow('fontSize'),
          fontFamily: this.getShallow('fontFamily')
        }, this.ecModel);
      },
      getTextRect: function (text) {
        return text$1.getBoundingRect(text, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('lineHeight'), this.getShallow('rich'), this.getShallow('truncateText'));
      }
    };
    var textStyle = _default$R;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var getItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]);
    var _default$S = {
      getItemStyle: function (excludes, includes) {
        var style = getItemStyle(this, excludes, includes);
        var lineDash = this.getBorderLineDash();
        lineDash && (style.lineDash = lineDash);
        return style;
      },
      getBorderLineDash: function () {
        var lineType = this.get('borderType');
        return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [5, 5] : [1, 1];
      }
    };
    var itemStyle = _default$S;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var makeInner$1 = model.makeInner;



    var enableClassExtend$1 = clazz.enableClassExtend;
    var enableClassCheck$1 = clazz.enableClassCheck;









    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @module echarts/model/Model
     */
    var mixin$1 = util.mixin;
    var inner = makeInner$1();
    /**
     * @alias module:echarts/model/Model
     * @constructor
     * @param {Object} [option]
     * @param {module:echarts/model/Model} [parentModel]
     * @param {module:echarts/model/Global} [ecModel]
     */

    function Model(option, parentModel, ecModel) {
      /**
       * @type {module:echarts/model/Model}
       * @readOnly
       */
      this.parentModel = parentModel;
      /**
       * @type {module:echarts/model/Global}
       * @readOnly
       */

      this.ecModel = ecModel;
      /**
       * @type {Object}
       * @protected
       */

      this.option = option; // Simple optimization
      // if (this.init) {
      //     if (arguments.length <= 4) {
      //         this.init(option, parentModel, ecModel, extraOpt);
      //     }
      //     else {
      //         this.init.apply(this, arguments);
      //     }
      // }
    }

    Model.prototype = {
      constructor: Model,

      /**
       * Model 的初始化函数
       * @param {Object} option
       */
      init: null,

      /**
       * 从新的 Option merge
       */
      mergeOption: function (option) {
        util.merge(this.option, option, true);
      },

      /**
       * @param {string|Array.<string>} path
       * @param {boolean} [ignoreParent=false]
       * @return {*}
       */
      get: function (path, ignoreParent) {
        if (path == null) {
          return this.option;
        }

        return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));
      },

      /**
       * @param {string} key
       * @param {boolean} [ignoreParent=false]
       * @return {*}
       */
      getShallow: function (key, ignoreParent) {
        var option = this.option;
        var val = option == null ? option : option[key];
        var parentModel = !ignoreParent && getParent(this, key);

        if (val == null && parentModel) {
          val = parentModel.getShallow(key);
        }

        return val;
      },

      /**
       * @param {string|Array.<string>} [path]
       * @param {module:echarts/model/Model} [parentModel]
       * @return {module:echarts/model/Model}
       */
      getModel: function (path, parentModel) {
        var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));
        var thisParentModel;
        parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);
        return new Model(obj, parentModel, this.ecModel);
      },

      /**
       * If model has option
       */
      isEmpty: function () {
        return this.option == null;
      },
      restoreData: function () {},
      // Pending
      clone: function () {
        var Ctor = this.constructor;
        return new Ctor(util.clone(this.option));
      },
      setReadOnly: function (properties) {// clazzUtil.setReadOnly(this, properties);
      },
      // If path is null/undefined, return null/undefined.
      parsePath: function (path) {
        if (typeof path === 'string') {
          path = path.split('.');
        }

        return path;
      },

      /**
       * @param {Function} getParentMethod
       *        param {Array.<string>|string} path
       *        return {module:echarts/model/Model}
       */
      customizeGetParent: function (getParentMethod) {
        inner(this).getParent = getParentMethod;
      },
      isAnimationEnabled: function () {
        if (!env_1.node) {
          if (this.option.animation != null) {
            return !!this.option.animation;
          } else if (this.parentModel) {
            return this.parentModel.isAnimationEnabled();
          }
        }
      }
    };

    function doGet(obj, pathArr, parentModel) {
      for (var i = 0; i < pathArr.length; i++) {
        // Ignore empty
        if (!pathArr[i]) {
          continue;
        } // obj could be number/string/... (like 0)


        obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;

        if (obj == null) {
          break;
        }
      }

      if (obj == null && parentModel) {
        obj = parentModel.get(pathArr);
      }

      return obj;
    } // `path` can be null/undefined


    function getParent(model, path) {
      var getParentMethod = inner(model).getParent;
      return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;
    } // Enable Model.extend.


    enableClassExtend$1(Model);
    enableClassCheck$1(Model);
    mixin$1(Model, lineStyle);
    mixin$1(Model, areaStyle);
    mixin$1(Model, textStyle);
    mixin$1(Model, itemStyle);
    var _default$T = Model;
    var Model_1 = _default$T;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    var parseClassType$1 = clazz.parseClassType;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var base = 0;
    /**
     * @public
     * @param {string} type
     * @return {string}
     */

    function getUID(type) {
      // Considering the case of crossing js context,
      // use Math.random to make id as unique as possible.
      return [type || '', base++, Math.random().toFixed(5)].join('_');
    }
    /**
     * @inner
     */


    function enableSubTypeDefaulter(entity) {
      var subTypeDefaulters = {};

      entity.registerSubTypeDefaulter = function (componentType, defaulter) {
        componentType = parseClassType$1(componentType);
        subTypeDefaulters[componentType.main] = defaulter;
      };

      entity.determineSubType = function (componentType, option) {
        var type = option.type;

        if (!type) {
          var componentTypeMain = parseClassType$1(componentType).main;

          if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
            type = subTypeDefaulters[componentTypeMain](option);
          }
        }

        return type;
      };

      return entity;
    }
    /**
     * Topological travel on Activity Network (Activity On Vertices).
     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
     *
     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
     *
     * If there is circle dependencey, Error will be thrown.
     *
     */


    function enableTopologicalTravel(entity, dependencyGetter) {
      /**
       * @public
       * @param {Array.<string>} targetNameList Target Component type list.
       *                                           Can be ['aa', 'bb', 'aa.xx']
       * @param {Array.<string>} fullNameList By which we can build dependency graph.
       * @param {Function} callback Params: componentType, dependencies.
       * @param {Object} context Scope of callback.
       */
      entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
        if (!targetNameList.length) {
          return;
        }

        var result = makeDepndencyGraph(fullNameList);
        var graph = result.graph;
        var stack = result.noEntryList;
        var targetNameSet = {};
        util.each(targetNameList, function (name) {
          targetNameSet[name] = true;
        });

        while (stack.length) {
          var currComponentType = stack.pop();
          var currVertex = graph[currComponentType];
          var isInTargetNameSet = !!targetNameSet[currComponentType];

          if (isInTargetNameSet) {
            callback.call(context, currComponentType, currVertex.originalDeps.slice());
            delete targetNameSet[currComponentType];
          }

          util.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
        }

        util.each(targetNameSet, function () {
          throw new Error('Circle dependency may exists');
        });

        function removeEdge(succComponentType) {
          graph[succComponentType].entryCount--;

          if (graph[succComponentType].entryCount === 0) {
            stack.push(succComponentType);
          }
        } // Consider this case: legend depends on series, and we call
        // chart.setOption({series: [...]}), where only series is in option.
        // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
        // not be called, but only sereis.mergeOption is called. Thus legend
        // have no chance to update its local record about series (like which
        // name of series is available in legend).


        function removeEdgeAndAdd(succComponentType) {
          targetNameSet[succComponentType] = true;
          removeEdge(succComponentType);
        }
      };
      /**
       * DepndencyGraph: {Object}
       * key: conponentType,
       * value: {
       *     successor: [conponentTypes...],
       *     originalDeps: [conponentTypes...],
       *     entryCount: {number}
       * }
       */


      function makeDepndencyGraph(fullNameList) {
        var graph = {};
        var noEntryList = [];
        util.each(fullNameList, function (name) {
          var thisItem = createDependencyGraphItem(graph, name);
          var originalDeps = thisItem.originalDeps = dependencyGetter(name);
          var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
          thisItem.entryCount = availableDeps.length;

          if (thisItem.entryCount === 0) {
            noEntryList.push(name);
          }

          util.each(availableDeps, function (dependentName) {
            if (util.indexOf(thisItem.predecessor, dependentName) < 0) {
              thisItem.predecessor.push(dependentName);
            }

            var thatItem = createDependencyGraphItem(graph, dependentName);

            if (util.indexOf(thatItem.successor, dependentName) < 0) {
              thatItem.successor.push(name);
            }
          });
        });
        return {
          graph: graph,
          noEntryList: noEntryList
        };
      }

      function createDependencyGraphItem(graph, name) {
        if (!graph[name]) {
          graph[name] = {
            predecessor: [],
            successor: []
          };
        }

        return graph[name];
      }

      function getAvailableDependencies(originalDeps, fullNameList) {
        var availableDeps = [];
        util.each(originalDeps, function (dep) {
          util.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
        });
        return availableDeps;
      }
    }

    var getUID_1 = getUID;
    var enableSubTypeDefaulter_1 = enableSubTypeDefaulter;
    var enableTopologicalTravel_1 = enableTopologicalTravel;

    var component = {
    	getUID: getUID_1,
    	enableSubTypeDefaulter: enableSubTypeDefaulter_1,
    	enableTopologicalTravel: enableTopologicalTravel_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * A third-party license is embeded for some of the code in this file:
    * The method "quantile" was copied from "d3.js".
    * (See more details in the comment of the method below.)
    * The use of the source code of this file is also subject to the terms
    * and consitions of the license of "d3.js" (BSD-3Clause, see
    * </licenses/LICENSE-d3>).
    */
    var RADIAN_EPSILON = 1e-4;

    function _trim(str) {
      return str.replace(/^\s+|\s+$/g, '');
    }
    /**
     * Linear mapping a value from domain to range
     * @memberOf module:echarts/util/number
     * @param  {(number|Array.<number>)} val
     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]
     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]
     * @param  {boolean} clamp
     * @return {(number|Array.<number>}
     */


    function linearMap(val, domain, range, clamp) {
      var subDomain = domain[1] - domain[0];
      var subRange = range[1] - range[0];

      if (subDomain === 0) {
        return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
      } // Avoid accuracy problem in edge, such as
      // 146.39 - 62.83 === 83.55999999999999.
      // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
      // It is a little verbose for efficiency considering this method
      // is a hotspot.


      if (clamp) {
        if (subDomain > 0) {
          if (val <= domain[0]) {
            return range[0];
          } else if (val >= domain[1]) {
            return range[1];
          }
        } else {
          if (val >= domain[0]) {
            return range[0];
          } else if (val <= domain[1]) {
            return range[1];
          }
        }
      } else {
        if (val === domain[0]) {
          return range[0];
        }

        if (val === domain[1]) {
          return range[1];
        }
      }

      return (val - domain[0]) / subDomain * subRange + range[0];
    }
    /**
     * Convert a percent string to absolute number.
     * Returns NaN if percent is not a valid string or number
     * @memberOf module:echarts/util/number
     * @param {string|number} percent
     * @param {number} all
     * @return {number}
     */


    function parsePercent$1(percent, all) {
      switch (percent) {
        case 'center':
        case 'middle':
          percent = '50%';
          break;

        case 'left':
        case 'top':
          percent = '0%';
          break;

        case 'right':
        case 'bottom':
          percent = '100%';
          break;
      }

      if (typeof percent === 'string') {
        if (_trim(percent).match(/%$/)) {
          return parseFloat(percent) / 100 * all;
        }

        return parseFloat(percent);
      }

      return percent == null ? NaN : +percent;
    }
    /**
     * (1) Fix rounding error of float numbers.
     * (2) Support return string to avoid scientific notation like '3.5e-7'.
     *
     * @param {number} x
     * @param {number} [precision]
     * @param {boolean} [returnStr]
     * @return {number|string}
     */


    function round$1(x, precision, returnStr) {
      if (precision == null) {
        precision = 10;
      } // Avoid range error


      precision = Math.min(Math.max(0, precision), 20);
      x = (+x).toFixed(precision);
      return returnStr ? x : +x;
    }
    /**
     * asc sort arr.
     * The input arr will be modified.
     *
     * @param {Array} arr
     * @return {Array} The input arr.
     */


    function asc(arr) {
      arr.sort(function (a, b) {
        return a - b;
      });
      return arr;
    }
    /**
     * Get precision
     * @param {number} val
     */


    function getPrecision(val) {
      val = +val;

      if (isNaN(val)) {
        return 0;
      } // It is much faster than methods converting number to string as follows
      //      var tmp = val.toString();
      //      return tmp.length - 1 - tmp.indexOf('.');
      // especially when precision is low


      var e = 1;
      var count = 0;

      while (Math.round(val * e) / e !== val) {
        e *= 10;
        count++;
      }

      return count;
    }
    /**
     * @param {string|number} val
     * @return {number}
     */


    function getPrecisionSafe(val) {
      var str = val.toString(); // Consider scientific notation: '3.4e-12' '3.4e+12'

      var eIndex = str.indexOf('e');

      if (eIndex > 0) {
        var precision = +str.slice(eIndex + 1);
        return precision < 0 ? -precision : 0;
      } else {
        var dotIndex = str.indexOf('.');
        return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
      }
    }
    /**
     * Minimal dicernible data precisioin according to a single pixel.
     *
     * @param {Array.<number>} dataExtent
     * @param {Array.<number>} pixelExtent
     * @return {number} precision
     */


    function getPixelPrecision(dataExtent, pixelExtent) {
      var log = Math.log;
      var LN10 = Math.LN10;
      var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
      var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20.

      var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
      return !isFinite(precision) ? 20 : precision;
    }
    /**
     * Get a data of given precision, assuring the sum of percentages
     * in valueList is 1.
     * The largest remainer method is used.
     * https://en.wikipedia.org/wiki/Largest_remainder_method
     *
     * @param {Array.<number>} valueList a list of all data
     * @param {number} idx index of the data to be processed in valueList
     * @param {number} precision integer number showing digits of precision
     * @return {number} percent ranging from 0 to 100
     */


    function getPercentWithPrecision(valueList, idx, precision) {
      if (!valueList[idx]) {
        return 0;
      }

      var sum = util.reduce(valueList, function (acc, val) {
        return acc + (isNaN(val) ? 0 : val);
      }, 0);

      if (sum === 0) {
        return 0;
      }

      var digits = Math.pow(10, precision);
      var votesPerQuota = util.map(valueList, function (val) {
        return (isNaN(val) ? 0 : val) / sum * digits * 100;
      });
      var targetSeats = digits * 100;
      var seats = util.map(votesPerQuota, function (votes) {
        // Assign automatic seats.
        return Math.floor(votes);
      });
      var currentSum = util.reduce(seats, function (acc, val) {
        return acc + val;
      }, 0);
      var remainder = util.map(votesPerQuota, function (votes, idx) {
        return votes - seats[idx];
      }); // Has remainding votes.

      while (currentSum < targetSeats) {
        // Find next largest remainder.
        var max = Number.NEGATIVE_INFINITY;
        var maxId = null;

        for (var i = 0, len = remainder.length; i < len; ++i) {
          if (remainder[i] > max) {
            max = remainder[i];
            maxId = i;
          }
        } // Add a vote to max remainder.


        ++seats[maxId];
        remainder[maxId] = 0;
        ++currentSum;
      }

      return seats[idx] / digits;
    } // Number.MAX_SAFE_INTEGER, ie do not support.


    var MAX_SAFE_INTEGER = 9007199254740991;
    /**
     * To 0 - 2 * PI, considering negative radian.
     * @param {number} radian
     * @return {number}
     */

    function remRadian(radian) {
      var pi2 = Math.PI * 2;
      return (radian % pi2 + pi2) % pi2;
    }
    /**
     * @param {type} radian
     * @return {boolean}
     */


    function isRadianAroundZero(val) {
      return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
    }
    /* eslint-disable */


    var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; // jshint ignore:line

    /* eslint-enable */

    /**
     * @param {string|Date|number} value These values can be accepted:
     *   + An instance of Date, represent a time in its own time zone.
     *   + Or string in a subset of ISO 8601, only including:
     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
     *     all of which will be treated as local time if time zone is not specified
     *     (see <https://momentjs.com/>).
     *   + Or other string format, including (all of which will be treated as loacal time):
     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
     *   + a timestamp, which represent a time in UTC.
     * @return {Date} date
     */

    function parseDate(value) {
      if (value instanceof Date) {
        return value;
      } else if (typeof value === 'string') {
        // Different browsers parse date in different way, so we parse it manually.
        // Some other issues:
        // new Date('1970-01-01') is UTC,
        // new Date('1970/01/01') and new Date('1970-1-01') is local.
        // See issue #3623
        var match = TIME_REG.exec(value);

        if (!match) {
          // return Invalid Date.
          return new Date(NaN);
        } // Use local time when no timezone offset specifed.


        if (!match[8]) {
          // match[n] can only be string or undefined.
          // But take care of '12' + 1 => '121'.
          return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
        } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,
        // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).
        // For example, system timezone is set as "Time Zone: America/Toronto",
        // then these code will get different result:
        // `new Date(1478411999999).getTimezoneOffset();  // get 240`
        // `new Date(1478412000000).getTimezoneOffset();  // get 300`
        // So we should not use `new Date`, but use `Date.UTC`.
        else {
            var hour = +match[4] || 0;

            if (match[8].toUpperCase() !== 'Z') {
              hour -= match[8].slice(0, 3);
            }

            return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
          }
      } else if (value == null) {
        return new Date(NaN);
      }

      return new Date(Math.round(value));
    }
    /**
     * Quantity of a number. e.g. 0.1, 1, 10, 100
     *
     * @param  {number} val
     * @return {number}
     */


    function quantity(val) {
      return Math.pow(10, quantityExponent(val));
    }
    /**
     * Exponent of the quantity of a number
     * e.g., 1234 equals to 1.234*10^3, so quantityExponent(1234) is 3
     *
     * @param  {number} val non-negative value
     * @return {number}
     */


    function quantityExponent(val) {
      if (val === 0) {
        return 0;
      }

      var exp = Math.floor(Math.log(val) / Math.LN10);
      /**
       * exp is expected to be the rounded-down result of the base-10 log of val.
       * But due to the precision loss with Math.log(val), we need to restore it
       * using 10^exp to make sure we can get val back from exp. #11249
       */

      if (val / Math.pow(10, exp) >= 10) {
        exp++;
      }

      return exp;
    }
    /**
     * find a “nice” number approximately equal to x. Round the number if round = true,
     * take ceiling if round = false. The primary observation is that the “nicest”
     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
     *
     * See "Nice Numbers for Graph Labels" of Graphic Gems.
     *
     * @param  {number} val Non-negative value.
     * @param  {boolean} round
     * @return {number}
     */


    function nice(val, round) {
      var exponent = quantityExponent(val);
      var exp10 = Math.pow(10, exponent);
      var f = val / exp10; // 1 <= f < 10

      var nf;

      if (round) {
        if (f < 1.5) {
          nf = 1;
        } else if (f < 2.5) {
          nf = 2;
        } else if (f < 4) {
          nf = 3;
        } else if (f < 7) {
          nf = 5;
        } else {
          nf = 10;
        }
      } else {
        if (f < 1) {
          nf = 1;
        } else if (f < 2) {
          nf = 2;
        } else if (f < 3) {
          nf = 3;
        } else if (f < 5) {
          nf = 5;
        } else {
          nf = 10;
        }
      }

      val = nf * exp10; // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).
      // 20 is the uppper bound of toFixed.

      return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
    }
    /**
     * This code was copied from "d3.js"
     * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/arrays/quantile.js>.
     * See the license statement at the head of this file.
     * @param {Array.<number>} ascArr
     */


    function quantile(ascArr, p) {
      var H = (ascArr.length - 1) * p + 1;
      var h = Math.floor(H);
      var v = +ascArr[h - 1];
      var e = H - h;
      return e ? v + e * (ascArr[h] - v) : v;
    }
    /**
     * Order intervals asc, and split them when overlap.
     * expect(numberUtil.reformIntervals([
     *     {interval: [18, 62], close: [1, 1]},
     *     {interval: [-Infinity, -70], close: [0, 0]},
     *     {interval: [-70, -26], close: [1, 1]},
     *     {interval: [-26, 18], close: [1, 1]},
     *     {interval: [62, 150], close: [1, 1]},
     *     {interval: [106, 150], close: [1, 1]},
     *     {interval: [150, Infinity], close: [0, 0]}
     * ])).toEqual([
     *     {interval: [-Infinity, -70], close: [0, 0]},
     *     {interval: [-70, -26], close: [1, 1]},
     *     {interval: [-26, 18], close: [0, 1]},
     *     {interval: [18, 62], close: [0, 1]},
     *     {interval: [62, 150], close: [0, 1]},
     *     {interval: [150, Infinity], close: [0, 0]}
     * ]);
     * @param {Array.<Object>} list, where `close` mean open or close
     *        of the interval, and Infinity can be used.
     * @return {Array.<Object>} The origin list, which has been reformed.
     */


    function reformIntervals(list) {
      list.sort(function (a, b) {
        return littleThan(a, b, 0) ? -1 : 1;
      });
      var curr = -Infinity;
      var currClose = 1;

      for (var i = 0; i < list.length;) {
        var interval = list[i].interval;
        var close = list[i].close;

        for (var lg = 0; lg < 2; lg++) {
          if (interval[lg] <= curr) {
            interval[lg] = curr;
            close[lg] = !lg ? 1 - currClose : 1;
          }

          curr = interval[lg];
          currClose = close[lg];
        }

        if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
          list.splice(i, 1);
        } else {
          i++;
        }
      }

      return list;

      function littleThan(a, b, lg) {
        return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));
      }
    }
    /**
     * parseFloat NaNs numeric-cast false positives (null|true|false|"")
     * ...but misinterprets leading-number strings, particularly hex literals ("0x...")
     * subtraction forces infinities to NaN
     *
     * @param {*} v
     * @return {boolean}
     */


    function isNumeric(v) {
      return v - parseFloat(v) >= 0;
    }

    var linearMap_1 = linearMap;
    var parsePercent_1$1 = parsePercent$1;
    var round_1 = round$1;
    var asc_1 = asc;
    var getPrecision_1 = getPrecision;
    var getPrecisionSafe_1 = getPrecisionSafe;
    var getPixelPrecision_1 = getPixelPrecision;
    var getPercentWithPrecision_1 = getPercentWithPrecision;
    var MAX_SAFE_INTEGER_1 = MAX_SAFE_INTEGER;
    var remRadian_1 = remRadian;
    var isRadianAroundZero_1 = isRadianAroundZero;
    var parseDate_1 = parseDate;
    var quantity_1 = quantity;
    var quantityExponent_1 = quantityExponent;
    var nice_1 = nice;
    var quantile_1 = quantile;
    var reformIntervals_1 = reformIntervals;
    var isNumeric_1 = isNumeric;

    var number = {
    	linearMap: linearMap_1,
    	parsePercent: parsePercent_1$1,
    	round: round_1,
    	asc: asc_1,
    	getPrecision: getPrecision_1,
    	getPrecisionSafe: getPrecisionSafe_1,
    	getPixelPrecision: getPixelPrecision_1,
    	getPercentWithPrecision: getPercentWithPrecision_1,
    	MAX_SAFE_INTEGER: MAX_SAFE_INTEGER_1,
    	remRadian: remRadian_1,
    	isRadianAroundZero: isRadianAroundZero_1,
    	parseDate: parseDate_1,
    	quantity: quantity_1,
    	quantityExponent: quantityExponent_1,
    	nice: nice_1,
    	quantile: quantile_1,
    	reformIntervals: reformIntervals_1,
    	isNumeric: isNumeric_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // import Text from 'zrender/src/graphic/Text';

    /**
     * add commas after every three numbers
     * @param {string|number} x
     * @return {string}
     */
    function addCommas(x) {
      if (isNaN(x)) {
        return '-';
      }

      x = (x + '').split('.');
      return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');
    }
    /**
     * @param {string} str
     * @param {boolean} [upperCaseFirst=false]
     * @return {string} str
     */


    function toCamelCase(str, upperCaseFirst) {
      str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
        return group1.toUpperCase();
      });

      if (upperCaseFirst && str) {
        str = str.charAt(0).toUpperCase() + str.slice(1);
      }

      return str;
    }

    var normalizeCssArray$2 = util.normalizeCssArray;
    var replaceReg = /([&<>"'])/g;
    var replaceMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&#39;'
    };

    function encodeHTML(source) {
      return source == null ? '' : (source + '').replace(replaceReg, function (str, c) {
        return replaceMap[c];
      });
    }

    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

    var wrapVar = function (varName, seriesIdx) {
      return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
    };
    /**
     * Template formatter
     * @param {string} tpl
     * @param {Array.<Object>|Object} paramsList
     * @param {boolean} [encode=false]
     * @return {string}
     */


    function formatTpl(tpl, paramsList, encode) {
      if (!util.isArray(paramsList)) {
        paramsList = [paramsList];
      }

      var seriesLen = paramsList.length;

      if (!seriesLen) {
        return '';
      }

      var $vars = paramsList[0].$vars || [];

      for (var i = 0; i < $vars.length; i++) {
        var alias = TPL_VAR_ALIAS[i];
        tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
      }

      for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
        for (var k = 0; k < $vars.length; k++) {
          var val = paramsList[seriesIdx][$vars[k]];
          tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
        }
      }

      return tpl;
    }
    /**
     * simple Template formatter
     *
     * @param {string} tpl
     * @param {Object} param
     * @param {boolean} [encode=false]
     * @return {string}
     */


    function formatTplSimple(tpl, param, encode) {
      util.each(param, function (value, key) {
        tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);
      });
      return tpl;
    }
    /**
     * @param {Object|string} [opt] If string, means color.
     * @param {string} [opt.color]
     * @param {string} [opt.extraCssText]
     * @param {string} [opt.type='item'] 'item' or 'subItem'
     * @param {string} [opt.renderMode='html'] render mode of tooltip, 'html' or 'richText'
     * @param {string} [opt.markerId='X'] id name for marker. If only one marker is in a rich text, this can be omitted.
     * @return {string}
     */


    function getTooltipMarker(opt, extraCssText) {
      opt = util.isString(opt) ? {
        color: opt,
        extraCssText: extraCssText
      } : opt || {};
      var color = opt.color;
      var type = opt.type;
      var extraCssText = opt.extraCssText;
      var renderMode = opt.renderMode || 'html';
      var markerId = opt.markerId || 'X';

      if (!color) {
        return '';
      }

      if (renderMode === 'html') {
        return type === 'subItem' ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;' + 'border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>' : '<span style="display:inline-block;margin-right:5px;' + 'border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>';
      } else {
        // Space for rich element marker
        return {
          renderMode: renderMode,
          content: '{marker' + markerId + '|}  ',
          style: {
            color: color
          }
        };
      }
    }

    function pad(str, len) {
      str += '';
      return '0000'.substr(0, len - str.length) + str;
    }
    /**
     * ISO Date format
     * @param {string} tpl
     * @param {number} value
     * @param {boolean} [isUTC=false] Default in local time.
     *           see `module:echarts/scale/Time`
     *           and `module:echarts/util/number#parseDate`.
     * @inner
     */


    function formatTime(tpl, value, isUTC) {
      if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
        tpl = 'MM-dd\nyyyy';
      }

      var date = number.parseDate(value);
      var utc = isUTC ? 'UTC' : '';
      var y = date['get' + utc + 'FullYear']();
      var M = date['get' + utc + 'Month']() + 1;
      var d = date['get' + utc + 'Date']();
      var h = date['get' + utc + 'Hours']();
      var m = date['get' + utc + 'Minutes']();
      var s = date['get' + utc + 'Seconds']();
      var S = date['get' + utc + 'Milliseconds']();
      tpl = tpl.replace('MM', pad(M, 2)).replace('M', M).replace('yyyy', y).replace('yy', y % 100).replace('dd', pad(d, 2)).replace('d', d).replace('hh', pad(h, 2)).replace('h', h).replace('mm', pad(m, 2)).replace('m', m).replace('ss', pad(s, 2)).replace('s', s).replace('SSS', pad(S, 3));
      return tpl;
    }
    /**
     * Capital first
     * @param {string} str
     * @return {string}
     */


    function capitalFirst(str) {
      return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
    }

    var truncateText$1 = text$1.truncateText;
    /**
     * @public
     * @param {Object} opt
     * @param {string} opt.text
     * @param {string} opt.font
     * @param {string} [opt.textAlign='left']
     * @param {string} [opt.textVerticalAlign='top']
     * @param {Array.<number>} [opt.textPadding]
     * @param {number} [opt.textLineHeight]
     * @param {Object} [opt.rich]
     * @param {Object} [opt.truncate]
     * @return {Object} {x, y, width, height, lineHeight}
     */

    function getTextBoundingRect(opt) {
      return text$1.getBoundingRect(opt.text, opt.font, opt.textAlign, opt.textVerticalAlign, opt.textPadding, opt.textLineHeight, opt.rich, opt.truncate);
    }
    /**
     * @deprecated
     * the `textLineHeight` was added later.
     * For backward compatiblility, put it as the last parameter.
     * But deprecated this interface. Please use `getTextBoundingRect` instead.
     */


    function getTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate, textLineHeight) {
      return text$1.getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate);
    }
    /**
     * open new tab
     * @param {string} link url
     * @param {string} target blank or self
     */


    function windowOpen(link, target) {
      if (target === '_blank' || target === 'blank') {
        var blank = window.open();
        blank.opener = null;
        blank.location = link;
      } else {
        window.open(link, target);
      }
    }

    var addCommas_1 = addCommas;
    var toCamelCase_1 = toCamelCase;
    var normalizeCssArray_1$1 = normalizeCssArray$2;
    var encodeHTML_1 = encodeHTML;
    var formatTpl_1 = formatTpl;
    var formatTplSimple_1 = formatTplSimple;
    var getTooltipMarker_1 = getTooltipMarker;
    var formatTime_1 = formatTime;
    var capitalFirst_1 = capitalFirst;
    var truncateText_1$1 = truncateText$1;
    var getTextBoundingRect_1 = getTextBoundingRect;
    var getTextRect_1 = getTextRect;
    var windowOpen_1 = windowOpen;

    var format$1 = {
    	addCommas: addCommas_1,
    	toCamelCase: toCamelCase_1,
    	normalizeCssArray: normalizeCssArray_1$1,
    	encodeHTML: encodeHTML_1,
    	formatTpl: formatTpl_1,
    	formatTplSimple: formatTplSimple_1,
    	getTooltipMarker: getTooltipMarker_1,
    	formatTime: formatTime_1,
    	capitalFirst: capitalFirst_1,
    	truncateText: truncateText_1$1,
    	getTextBoundingRect: getTextBoundingRect_1,
    	getTextRect: getTextRect_1,
    	windowOpen: windowOpen_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var parsePercent$2 = number.parsePercent;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // Layout helpers for each component positioning
    var each$3 = util.each;
    /**
     * @public
     */

    var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];
    /**
     * @public
     */

    var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];

    function boxLayout(orient, group, gap, maxWidth, maxHeight) {
      var x = 0;
      var y = 0;

      if (maxWidth == null) {
        maxWidth = Infinity;
      }

      if (maxHeight == null) {
        maxHeight = Infinity;
      }

      var currentLineMaxSize = 0;
      group.eachChild(function (child, idx) {
        var position = child.position;
        var rect = child.getBoundingRect();
        var nextChild = group.childAt(idx + 1);
        var nextChildRect = nextChild && nextChild.getBoundingRect();
        var nextX;
        var nextY;

        if (orient === 'horizontal') {
          var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
          nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group
          // FIXME compare before adding gap?

          if (nextX > maxWidth || child.newline) {
            x = 0;
            nextX = moveX;
            y += currentLineMaxSize + gap;
            currentLineMaxSize = rect.height;
          } else {
            // FIXME: consider rect.y is not `0`?
            currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
          }
        } else {
          var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
          nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group

          if (nextY > maxHeight || child.newline) {
            x += currentLineMaxSize + gap;
            y = 0;
            nextY = moveY;
            currentLineMaxSize = rect.width;
          } else {
            currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
          }
        }

        if (child.newline) {
          return;
        }

        position[0] = x;
        position[1] = y;
        orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;
      });
    }
    /**
     * VBox or HBox layouting
     * @param {string} orient
     * @param {module:zrender/container/Group} group
     * @param {number} gap
     * @param {number} [width=Infinity]
     * @param {number} [height=Infinity]
     */


    var box = boxLayout;
    /**
     * VBox layouting
     * @param {module:zrender/container/Group} group
     * @param {number} gap
     * @param {number} [width=Infinity]
     * @param {number} [height=Infinity]
     */

    var vbox = util.curry(boxLayout, 'vertical');
    /**
     * HBox layouting
     * @param {module:zrender/container/Group} group
     * @param {number} gap
     * @param {number} [width=Infinity]
     * @param {number} [height=Infinity]
     */

    var hbox = util.curry(boxLayout, 'horizontal');
    /**
     * If x or x2 is not specified or 'center' 'left' 'right',
     * the width would be as long as possible.
     * If y or y2 is not specified or 'middle' 'top' 'bottom',
     * the height would be as long as possible.
     *
     * @param {Object} positionInfo
     * @param {number|string} [positionInfo.x]
     * @param {number|string} [positionInfo.y]
     * @param {number|string} [positionInfo.x2]
     * @param {number|string} [positionInfo.y2]
     * @param {Object} containerRect {width, height}
     * @param {string|number} margin
     * @return {Object} {width, height}
     */

    function getAvailableSize(positionInfo, containerRect, margin) {
      var containerWidth = containerRect.width;
      var containerHeight = containerRect.height;
      var x = parsePercent$2(positionInfo.x, containerWidth);
      var y = parsePercent$2(positionInfo.y, containerHeight);
      var x2 = parsePercent$2(positionInfo.x2, containerWidth);
      var y2 = parsePercent$2(positionInfo.y2, containerHeight);
      (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
      (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
      (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
      (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
      margin = format$1.normalizeCssArray(margin || 0);
      return {
        width: Math.max(x2 - x - margin[1] - margin[3], 0),
        height: Math.max(y2 - y - margin[0] - margin[2], 0)
      };
    }
    /**
     * Parse position info.
     *
     * @param {Object} positionInfo
     * @param {number|string} [positionInfo.left]
     * @param {number|string} [positionInfo.top]
     * @param {number|string} [positionInfo.right]
     * @param {number|string} [positionInfo.bottom]
     * @param {number|string} [positionInfo.width]
     * @param {number|string} [positionInfo.height]
     * @param {number|string} [positionInfo.aspect] Aspect is width / height
     * @param {Object} containerRect
     * @param {string|number} [margin]
     *
     * @return {module:zrender/core/BoundingRect}
     */


    function getLayoutRect(positionInfo, containerRect, margin) {
      margin = format$1.normalizeCssArray(margin || 0);
      var containerWidth = containerRect.width;
      var containerHeight = containerRect.height;
      var left = parsePercent$2(positionInfo.left, containerWidth);
      var top = parsePercent$2(positionInfo.top, containerHeight);
      var right = parsePercent$2(positionInfo.right, containerWidth);
      var bottom = parsePercent$2(positionInfo.bottom, containerHeight);
      var width = parsePercent$2(positionInfo.width, containerWidth);
      var height = parsePercent$2(positionInfo.height, containerHeight);
      var verticalMargin = margin[2] + margin[0];
      var horizontalMargin = margin[1] + margin[3];
      var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right

      if (isNaN(width)) {
        width = containerWidth - right - horizontalMargin - left;
      }

      if (isNaN(height)) {
        height = containerHeight - bottom - verticalMargin - top;
      }

      if (aspect != null) {
        // If width and height are not given
        // 1. Graph should not exceeds the container
        // 2. Aspect must be keeped
        // 3. Graph should take the space as more as possible
        // FIXME
        // Margin is not considered, because there is no case that both
        // using margin and aspect so far.
        if (isNaN(width) && isNaN(height)) {
          if (aspect > containerWidth / containerHeight) {
            width = containerWidth * 0.8;
          } else {
            height = containerHeight * 0.8;
          }
        } // Calculate width or height with given aspect


        if (isNaN(width)) {
          width = aspect * height;
        }

        if (isNaN(height)) {
          height = width / aspect;
        }
      } // If left is not specified, calculate left from right and width


      if (isNaN(left)) {
        left = containerWidth - right - width - horizontalMargin;
      }

      if (isNaN(top)) {
        top = containerHeight - bottom - height - verticalMargin;
      } // Align left and top


      switch (positionInfo.left || positionInfo.right) {
        case 'center':
          left = containerWidth / 2 - width / 2 - margin[3];
          break;

        case 'right':
          left = containerWidth - width - horizontalMargin;
          break;
      }

      switch (positionInfo.top || positionInfo.bottom) {
        case 'middle':
        case 'center':
          top = containerHeight / 2 - height / 2 - margin[0];
          break;

        case 'bottom':
          top = containerHeight - height - verticalMargin;
          break;
      } // If something is wrong and left, top, width, height are calculated as NaN


      left = left || 0;
      top = top || 0;

      if (isNaN(width)) {
        // Width may be NaN if only one value is given except width
        width = containerWidth - horizontalMargin - left - (right || 0);
      }

      if (isNaN(height)) {
        // Height may be NaN if only one value is given except height
        height = containerHeight - verticalMargin - top - (bottom || 0);
      }

      var rect = new BoundingRect_1(left + margin[3], top + margin[0], width, height);
      rect.margin = margin;
      return rect;
    }
    /**
     * Position a zr element in viewport
     *  Group position is specified by either
     *  {left, top}, {right, bottom}
     *  If all properties exists, right and bottom will be igonred.
     *
     * Logic:
     *     1. Scale (against origin point in parent coord)
     *     2. Rotate (against origin point in parent coord)
     *     3. Traslate (with el.position by this method)
     * So this method only fixes the last step 'Traslate', which does not affect
     * scaling and rotating.
     *
     * If be called repeatly with the same input el, the same result will be gotten.
     *
     * @param {module:zrender/Element} el Should have `getBoundingRect` method.
     * @param {Object} positionInfo
     * @param {number|string} [positionInfo.left]
     * @param {number|string} [positionInfo.top]
     * @param {number|string} [positionInfo.right]
     * @param {number|string} [positionInfo.bottom]
     * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'
     * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'
     * @param {Object} containerRect
     * @param {string|number} margin
     * @param {Object} [opt]
     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.
     * @param {Array.<number>} [opt.boundingMode='all']
     *        Specify how to calculate boundingRect when locating.
     *        'all': Position the boundingRect that is transformed and uioned
     *               both itself and its descendants.
     *               This mode simplies confine the elements in the bounding
     *               of their container (e.g., using 'right: 0').
     *        'raw': Position the boundingRect that is not transformed and only itself.
     *               This mode is useful when you want a element can overflow its
     *               container. (Consider a rotated circle needs to be located in a corner.)
     *               In this mode positionInfo.width/height can only be number.
     */


    function positionElement(el, positionInfo, containerRect, margin, opt) {
      var h = !opt || !opt.hv || opt.hv[0];
      var v = !opt || !opt.hv || opt.hv[1];
      var boundingMode = opt && opt.boundingMode || 'all';

      if (!h && !v) {
        return;
      }

      var rect;

      if (boundingMode === 'raw') {
        rect = el.type === 'group' ? new BoundingRect_1(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
      } else {
        rect = el.getBoundingRect();

        if (el.needLocalTransform()) {
          var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,
          // which should not be modified.

          rect = rect.clone();
          rect.applyTransform(transform);
        }
      } // The real width and height can not be specified but calculated by the given el.


      positionInfo = getLayoutRect(util.defaults({
        width: rect.width,
        height: rect.height
      }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform
      // (see zrender/core/Transformable#getLocalTransform),
      // we can just only modify el.position to get final result.

      var elPos = el.position;
      var dx = h ? positionInfo.x - rect.x : 0;
      var dy = v ? positionInfo.y - rect.y : 0;
      el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
    }
    /**
     * @param {Object} option Contains some of the properties in HV_NAMES.
     * @param {number} hvIdx 0: horizontal; 1: vertical.
     */


    function sizeCalculable(option, hvIdx) {
      return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
    }
    /**
     * Consider Case:
     * When defulat option has {left: 0, width: 100}, and we set {right: 0}
     * through setOption or media query, using normal zrUtil.merge will cause
     * {right: 0} does not take effect.
     *
     * @example
     * ComponentModel.extend({
     *     init: function () {
     *         ...
     *         var inputPositionParams = layout.getLayoutParams(option);
     *         this.mergeOption(inputPositionParams);
     *     },
     *     mergeOption: function (newOption) {
     *         newOption && zrUtil.merge(thisOption, newOption, true);
     *         layout.mergeLayoutParam(thisOption, newOption);
     *     }
     * });
     *
     * @param {Object} targetOption
     * @param {Object} newOption
     * @param {Object|string} [opt]
     * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components
     *  that width (or height) should not be calculated by left and right (or top and bottom).
     */


    function mergeLayoutParam(targetOption, newOption, opt) {
      !util.isObject(opt) && (opt = {});
      var ignoreSize = opt.ignoreSize;
      !util.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
      var hResult = merge(HV_NAMES[0], 0);
      var vResult = merge(HV_NAMES[1], 1);
      copy(HV_NAMES[0], targetOption, hResult);
      copy(HV_NAMES[1], targetOption, vResult);

      function merge(names, hvIdx) {
        var newParams = {};
        var newValueCount = 0;
        var merged = {};
        var mergedValueCount = 0;
        var enoughParamNumber = 2;
        each$3(names, function (name) {
          merged[name] = targetOption[name];
        });
        each$3(names, function (name) {
          // Consider case: newOption.width is null, which is
          // set by user for removing width setting.
          hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
          hasValue(newParams, name) && newValueCount++;
          hasValue(merged, name) && mergedValueCount++;
        });

        if (ignoreSize[hvIdx]) {
          // Only one of left/right is premitted to exist.
          if (hasValue(newOption, names[1])) {
            merged[names[2]] = null;
          } else if (hasValue(newOption, names[2])) {
            merged[names[1]] = null;
          }

          return merged;
        } // Case: newOption: {width: ..., right: ...},
        // or targetOption: {right: ...} and newOption: {width: ...},
        // There is no conflict when merged only has params count
        // little than enoughParamNumber.


        if (mergedValueCount === enoughParamNumber || !newValueCount) {
          return merged;
        } // Case: newOption: {width: ..., right: ...},
        // Than we can make sure user only want those two, and ignore
        // all origin params in targetOption.
        else if (newValueCount >= enoughParamNumber) {
            return newParams;
          } else {
            // Chose another param from targetOption by priority.
            for (var i = 0; i < names.length; i++) {
              var name = names[i];

              if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
                newParams[name] = targetOption[name];
                break;
              }
            }

            return newParams;
          }
      }

      function hasProp(obj, name) {
        return obj.hasOwnProperty(name);
      }

      function hasValue(obj, name) {
        return obj[name] != null && obj[name] !== 'auto';
      }

      function copy(names, target, source) {
        each$3(names, function (name) {
          target[name] = source[name];
        });
      }
    }
    /**
     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
     * @param {Object} source
     * @return {Object} Result contains those props.
     */


    function getLayoutParams(source) {
      return copyLayoutParams({}, source);
    }
    /**
     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
     * @param {Object} source
     * @return {Object} Result contains those props.
     */


    function copyLayoutParams(target, source) {
      source && target && each$3(LOCATION_PARAMS, function (name) {
        source.hasOwnProperty(name) && (target[name] = source[name]);
      });
      return target;
    }

    var LOCATION_PARAMS_1 = LOCATION_PARAMS;
    var HV_NAMES_1 = HV_NAMES;
    var box_1 = box;
    var vbox_1 = vbox;
    var hbox_1 = hbox;
    var getAvailableSize_1 = getAvailableSize;
    var getLayoutRect_1 = getLayoutRect;
    var positionElement_1 = positionElement;
    var sizeCalculable_1 = sizeCalculable;
    var mergeLayoutParam_1 = mergeLayoutParam;
    var getLayoutParams_1 = getLayoutParams;
    var copyLayoutParams_1 = copyLayoutParams;

    var layout = {
    	LOCATION_PARAMS: LOCATION_PARAMS_1,
    	HV_NAMES: HV_NAMES_1,
    	box: box_1,
    	vbox: vbox_1,
    	hbox: hbox_1,
    	getAvailableSize: getAvailableSize_1,
    	getLayoutRect: getLayoutRect_1,
    	positionElement: positionElement_1,
    	sizeCalculable: sizeCalculable_1,
    	mergeLayoutParam: mergeLayoutParam_1,
    	getLayoutParams: getLayoutParams_1,
    	copyLayoutParams: copyLayoutParams_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var _default$U = {
      getBoxLayoutParams: function () {
        return {
          left: this.get('left'),
          top: this.get('top'),
          right: this.get('right'),
          bottom: this.get('bottom'),
          width: this.get('width'),
          height: this.get('height')
        };
      }
    };
    var boxLayout$1 = _default$U;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    var enableClassManagement$1 = clazz.enableClassManagement;
    var parseClassType$2 = clazz.parseClassType;



    var makeInner$2 = model.makeInner;





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Component model
     *
     * @module echarts/model/Component
     */
    var inner$1 = makeInner$2();
    /**
     * @alias module:echarts/model/Component
     * @constructor
     * @param {Object} option
     * @param {module:echarts/model/Model} parentModel
     * @param {module:echarts/model/Model} ecModel
     */

    var ComponentModel = Model_1.extend({
      type: 'component',

      /**
       * @readOnly
       * @type {string}
       */
      id: '',

      /**
       * Because simplified concept is probably better, series.name (or component.name)
       * has been having too many resposibilities:
       * (1) Generating id (which requires name in option should not be modified).
       * (2) As an index to mapping series when merging option or calling API (a name
       * can refer to more then one components, which is convinient is some case).
       * (3) Display.
       * @readOnly
       */
      name: '',

      /**
       * @readOnly
       * @type {string}
       */
      mainType: '',

      /**
       * @readOnly
       * @type {string}
       */
      subType: '',

      /**
       * @readOnly
       * @type {number}
       */
      componentIndex: 0,

      /**
       * @type {Object}
       * @protected
       */
      defaultOption: null,

      /**
       * @type {module:echarts/model/Global}
       * @readOnly
       */
      ecModel: null,

      /**
       * key: componentType
       * value:  Component model list, can not be null.
       * @type {Object.<string, Array.<module:echarts/model/Model>>}
       * @readOnly
       */
      dependentModels: [],

      /**
       * @type {string}
       * @readOnly
       */
      uid: null,

      /**
       * Support merge layout params.
       * Only support 'box' now (left/right/top/bottom/width/height).
       * @type {string|Object} Object can be {ignoreSize: true}
       * @readOnly
       */
      layoutMode: null,
      $constructor: function (option, parentModel, ecModel, extraOpt) {
        Model_1.call(this, option, parentModel, ecModel, extraOpt);
        this.uid = component.getUID('ec_cpt_model');
      },
      init: function (option, parentModel, ecModel, extraOpt) {
        this.mergeDefaultAndTheme(option, ecModel);
      },
      mergeDefaultAndTheme: function (option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        util.merge(option, themeModel.get(this.mainType));
        util.merge(option, this.getDefaultOption());

        if (layoutMode) {
          layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      },
      mergeOption: function (option, extraOpt) {
        util.merge(this.option, option, true);
        var layoutMode = this.layoutMode;

        if (layoutMode) {
          layout.mergeLayoutParam(this.option, option, layoutMode);
        }
      },
      // Hooker after init or mergeOption
      optionUpdated: function (newCptOption, isInit) {},
      getDefaultOption: function () {
        var fields = inner$1(this);

        if (!fields.defaultOption) {
          var optList = [];
          var Class = this.constructor;

          while (Class) {
            var opt = Class.prototype.defaultOption;
            opt && optList.push(opt);
            Class = Class.superClass;
          }

          var defaultOption = {};

          for (var i = optList.length - 1; i >= 0; i--) {
            defaultOption = util.merge(defaultOption, optList[i], true);
          }

          fields.defaultOption = defaultOption;
        }

        return fields.defaultOption;
      },
      getReferringComponents: function (mainType) {
        return this.ecModel.queryComponents({
          mainType: mainType,
          index: this.get(mainType + 'Index', true),
          id: this.get(mainType + 'Id', true)
        });
      }
    }); // Reset ComponentModel.extend, add preConstruct.
    // clazzUtil.enableClassExtend(
    //     ComponentModel,
    //     function (option, parentModel, ecModel, extraOpt) {
    //         // Set dependentModels, componentIndex, name, id, mainType, subType.
    //         zrUtil.extend(this, extraOpt);
    //         this.uid = componentUtil.getUID('componentModel');
    //         // this.setReadOnly([
    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',
    //         //     'dependentModels', 'componentIndex'
    //         // ]);
    //     }
    // );
    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

    enableClassManagement$1(ComponentModel, {
      registerWhenExtend: true
    });
    component.enableSubTypeDefaulter(ComponentModel); // Add capability of ComponentModel.topologicalTravel.

    component.enableTopologicalTravel(ComponentModel, getDependencies);

    function getDependencies(componentType) {
      var deps = [];
      util.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {
        deps = deps.concat(Clazz.prototype.dependencies || []);
      }); // Ensure main type.

      deps = util.map(deps, function (type) {
        return parseClassType$2(type).main;
      }); // Hack dataset for convenience.

      if (componentType !== 'dataset' && util.indexOf(deps, 'dataset') <= 0) {
        deps.unshift('dataset');
      }

      return deps;
    }

    util.mixin(ComponentModel, boxLayout$1);
    var _default$V = ComponentModel;
    var Component = _default$V;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var platform = ''; // Navigator not exists in node

    if (typeof navigator !== 'undefined') {
      platform = navigator.platform || '';
    }

    var _default$W = {
      // backgroundColor: 'rgba(0,0,0,0)',
      // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
      // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
      // Light colors:
      // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
      // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
      // Dark colors:
      color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'],
      gradientColor: ['#f6efa6', '#d88273', '#bf444c'],
      // If xAxis and yAxis declared, grid is created by default.
      // grid: {},
      textStyle: {
        // color: '#000',
        // decoration: 'none',
        // PENDING
        fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
        // fontFamily: 'Arial, Verdana, sans-serif',
        fontSize: 12,
        fontStyle: 'normal',
        fontWeight: 'normal'
      },
      // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
      // Default is source-over
      blendMode: null,
      animation: 'auto',
      animationDuration: 1000,
      animationDurationUpdate: 300,
      animationEasing: 'exponentialOut',
      animationEasingUpdate: 'cubicOut',
      animationThreshold: 2000,
      // Configuration for progressive/incremental rendering
      progressiveThreshold: 3000,
      progressive: 400,
      // Threshold of if use single hover layer to optimize.
      // It is recommended that `hoverLayerThreshold` is equivalent to or less than
      // `progressiveThreshold`, otherwise hover will cause restart of progressive,
      // which is unexpected.
      // see example <echarts/test/heatmap-large.html>.
      hoverLayerThreshold: 3000,
      // See: module:echarts/scale/Time
      useUTC: false
    };
    var globalDefault = _default$W;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var makeInner$3 = model.makeInner;
    var normalizeToArray$1 = model.normalizeToArray;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var inner$2 = makeInner$3();

    function getNearestColorPalette(colors, requestColorNum) {
      var paletteNum = colors.length; // TODO colors must be in order

      for (var i = 0; i < paletteNum; i++) {
        if (colors[i].length > requestColorNum) {
          return colors[i];
        }
      }

      return colors[paletteNum - 1];
    }

    var _default$X = {
      clearColorPalette: function () {
        inner$2(this).colorIdx = 0;
        inner$2(this).colorNameMap = {};
      },

      /**
       * @param {string} name MUST NOT be null/undefined. Otherwise call this function
       *                 twise with the same parameters will get different result.
       * @param {Object} [scope=this]
       * @param {Object} [requestColorNum]
       * @return {string} color string.
       */
      getColorFromPalette: function (name, scope, requestColorNum) {
        scope = scope || this;
        var scopeFields = inner$2(scope);
        var colorIdx = scopeFields.colorIdx || 0;
        var colorNameMap = scopeFields.colorNameMap = scopeFields.colorNameMap || {}; // Use `hasOwnProperty` to avoid conflict with Object.prototype.

        if (colorNameMap.hasOwnProperty(name)) {
          return colorNameMap[name];
        }

        var defaultColorPalette = normalizeToArray$1(this.get('color', true));
        var layeredColorPalette = this.get('colorLayer', true);
        var colorPalette = requestColorNum == null || !layeredColorPalette ? defaultColorPalette : getNearestColorPalette(layeredColorPalette, requestColorNum); // In case can't find in layered color palette.

        colorPalette = colorPalette || defaultColorPalette;

        if (!colorPalette || !colorPalette.length) {
          return;
        }

        var color = colorPalette[colorIdx];

        if (name) {
          colorNameMap[name] = color;
        }

        scopeFields.colorIdx = (colorIdx + 1) % colorPalette.length;
        return color;
      }
    };
    var colorPalette = _default$X;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // Avoid typo.
    var SOURCE_FORMAT_ORIGINAL = 'original';
    var SOURCE_FORMAT_ARRAY_ROWS = 'arrayRows';
    var SOURCE_FORMAT_OBJECT_ROWS = 'objectRows';
    var SOURCE_FORMAT_KEYED_COLUMNS = 'keyedColumns';
    var SOURCE_FORMAT_UNKNOWN = 'unknown'; // ??? CHANGE A NAME

    var SOURCE_FORMAT_TYPED_ARRAY = 'typedArray';
    var SERIES_LAYOUT_BY_COLUMN = 'column';
    var SERIES_LAYOUT_BY_ROW = 'row';
    var SOURCE_FORMAT_ORIGINAL_1 = SOURCE_FORMAT_ORIGINAL;
    var SOURCE_FORMAT_ARRAY_ROWS_1 = SOURCE_FORMAT_ARRAY_ROWS;
    var SOURCE_FORMAT_OBJECT_ROWS_1 = SOURCE_FORMAT_OBJECT_ROWS;
    var SOURCE_FORMAT_KEYED_COLUMNS_1 = SOURCE_FORMAT_KEYED_COLUMNS;
    var SOURCE_FORMAT_UNKNOWN_1 = SOURCE_FORMAT_UNKNOWN;
    var SOURCE_FORMAT_TYPED_ARRAY_1 = SOURCE_FORMAT_TYPED_ARRAY;
    var SERIES_LAYOUT_BY_COLUMN_1 = SERIES_LAYOUT_BY_COLUMN;
    var SERIES_LAYOUT_BY_ROW_1 = SERIES_LAYOUT_BY_ROW;

    var sourceType = {
    	SOURCE_FORMAT_ORIGINAL: SOURCE_FORMAT_ORIGINAL_1,
    	SOURCE_FORMAT_ARRAY_ROWS: SOURCE_FORMAT_ARRAY_ROWS_1,
    	SOURCE_FORMAT_OBJECT_ROWS: SOURCE_FORMAT_OBJECT_ROWS_1,
    	SOURCE_FORMAT_KEYED_COLUMNS: SOURCE_FORMAT_KEYED_COLUMNS_1,
    	SOURCE_FORMAT_UNKNOWN: SOURCE_FORMAT_UNKNOWN_1,
    	SOURCE_FORMAT_TYPED_ARRAY: SOURCE_FORMAT_TYPED_ARRAY_1,
    	SERIES_LAYOUT_BY_COLUMN: SERIES_LAYOUT_BY_COLUMN_1,
    	SERIES_LAYOUT_BY_ROW: SERIES_LAYOUT_BY_ROW_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var createHashMap$1 = util.createHashMap;
    var isTypedArray$1 = util.isTypedArray;



    var enableClassCheck$2 = clazz.enableClassCheck;



    var SOURCE_FORMAT_ORIGINAL$1 = sourceType.SOURCE_FORMAT_ORIGINAL;
    var SERIES_LAYOUT_BY_COLUMN$1 = sourceType.SERIES_LAYOUT_BY_COLUMN;
    var SOURCE_FORMAT_UNKNOWN$1 = sourceType.SOURCE_FORMAT_UNKNOWN;
    var SOURCE_FORMAT_TYPED_ARRAY$1 = sourceType.SOURCE_FORMAT_TYPED_ARRAY;
    var SOURCE_FORMAT_KEYED_COLUMNS$1 = sourceType.SOURCE_FORMAT_KEYED_COLUMNS;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * [sourceFormat]
     *
     * + "original":
     * This format is only used in series.data, where
     * itemStyle can be specified in data item.
     *
     * + "arrayRows":
     * [
     *     ['product', 'score', 'amount'],
     *     ['Matcha Latte', 89.3, 95.8],
     *     ['Milk Tea', 92.1, 89.4],
     *     ['Cheese Cocoa', 94.4, 91.2],
     *     ['Walnut Brownie', 85.4, 76.9]
     * ]
     *
     * + "objectRows":
     * [
     *     {product: 'Matcha Latte', score: 89.3, amount: 95.8},
     *     {product: 'Milk Tea', score: 92.1, amount: 89.4},
     *     {product: 'Cheese Cocoa', score: 94.4, amount: 91.2},
     *     {product: 'Walnut Brownie', score: 85.4, amount: 76.9}
     * ]
     *
     * + "keyedColumns":
     * {
     *     'product': ['Matcha Latte', 'Milk Tea', 'Cheese Cocoa', 'Walnut Brownie'],
     *     'count': [823, 235, 1042, 988],
     *     'score': [95.8, 81.4, 91.2, 76.9]
     * }
     *
     * + "typedArray"
     *
     * + "unknown"
     */

    /**
     * @constructor
     * @param {Object} fields
     * @param {string} fields.sourceFormat
     * @param {Array|Object} fields.fromDataset
     * @param {Array|Object} [fields.data]
     * @param {string} [seriesLayoutBy='column']
     * @param {Array.<Object|string>} [dimensionsDefine]
     * @param {Objet|HashMap} [encodeDefine]
     * @param {number} [startIndex=0]
     * @param {number} [dimensionsDetectCount]
     */
    function Source(fields) {
      /**
       * @type {boolean}
       */
      this.fromDataset = fields.fromDataset;
      /**
       * Not null/undefined.
       * @type {Array|Object}
       */

      this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS$1 ? {} : []);
      /**
       * See also "detectSourceFormat".
       * Not null/undefined.
       * @type {string}
       */

      this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN$1;
      /**
       * 'row' or 'column'
       * Not null/undefined.
       * @type {string} seriesLayoutBy
       */

      this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN$1;
      /**
       * dimensions definition in option.
       * can be null/undefined.
       * @type {Array.<Object|string>}
       */

      this.dimensionsDefine = fields.dimensionsDefine;
      /**
       * encode definition in option.
       * can be null/undefined.
       * @type {Objet|HashMap}
       */

      this.encodeDefine = fields.encodeDefine && createHashMap$1(fields.encodeDefine);
      /**
       * Not null/undefined, uint.
       * @type {number}
       */

      this.startIndex = fields.startIndex || 0;
      /**
       * Can be null/undefined (when unknown), uint.
       * @type {number}
       */

      this.dimensionsDetectCount = fields.dimensionsDetectCount;
    }
    /**
     * Wrap original series data for some compatibility cases.
     */


    Source.seriesDataToSource = function (data) {
      return new Source({
        data: data,
        sourceFormat: isTypedArray$1(data) ? SOURCE_FORMAT_TYPED_ARRAY$1 : SOURCE_FORMAT_ORIGINAL$1,
        fromDataset: false
      });
    };

    enableClassCheck$2(Source);
    var _default$Y = Source;
    var Source_1 = _default$Y;

    var makeInner$4 = model.makeInner;
    var getDataItemValue$1 = model.getDataItemValue;



    var createHashMap$2 = util.createHashMap;
    var each$4 = util.each;
    var map$1 = util.map;
    var isArray$3 = util.isArray;
    var isString$4 = util.isString;
    var isObject$5 = util.isObject;
    var isTypedArray$2 = util.isTypedArray;
    var isArrayLike$3 = util.isArrayLike;
    var extend$3 = util.extend;





    var SOURCE_FORMAT_ORIGINAL$2 = sourceType.SOURCE_FORMAT_ORIGINAL;
    var SOURCE_FORMAT_ARRAY_ROWS$1 = sourceType.SOURCE_FORMAT_ARRAY_ROWS;
    var SOURCE_FORMAT_OBJECT_ROWS$1 = sourceType.SOURCE_FORMAT_OBJECT_ROWS;
    var SOURCE_FORMAT_KEYED_COLUMNS$2 = sourceType.SOURCE_FORMAT_KEYED_COLUMNS;
    var SOURCE_FORMAT_UNKNOWN$2 = sourceType.SOURCE_FORMAT_UNKNOWN;
    var SOURCE_FORMAT_TYPED_ARRAY$2 = sourceType.SOURCE_FORMAT_TYPED_ARRAY;
    var SERIES_LAYOUT_BY_ROW$1 = sourceType.SERIES_LAYOUT_BY_ROW;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // The result of `guessOrdinal`.
    var BE_ORDINAL = {
      Must: 1,
      // Encounter string but not '-' and not number-like.
      Might: 2,
      // Encounter string but number-like.
      Not: 3 // Other cases

    };
    var inner$3 = makeInner$4();
    /**
     * @see {module:echarts/data/Source}
     * @param {module:echarts/component/dataset/DatasetModel} datasetModel
     * @return {string} sourceFormat
     */

    function detectSourceFormat(datasetModel) {
      var data = datasetModel.option.source;
      var sourceFormat = SOURCE_FORMAT_UNKNOWN$2;

      if (isTypedArray$2(data)) {
        sourceFormat = SOURCE_FORMAT_TYPED_ARRAY$2;
      } else if (isArray$3(data)) {
        // FIXME Whether tolerate null in top level array?
        if (data.length === 0) {
          sourceFormat = SOURCE_FORMAT_ARRAY_ROWS$1;
        }

        for (var i = 0, len = data.length; i < len; i++) {
          var item = data[i];

          if (item == null) {
            continue;
          } else if (isArray$3(item)) {
            sourceFormat = SOURCE_FORMAT_ARRAY_ROWS$1;
            break;
          } else if (isObject$5(item)) {
            sourceFormat = SOURCE_FORMAT_OBJECT_ROWS$1;
            break;
          }
        }
      } else if (isObject$5(data)) {
        for (var key in data) {
          if (data.hasOwnProperty(key) && isArrayLike$3(data[key])) {
            sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS$2;
            break;
          }
        }
      } else if (data != null) {
        throw new Error('Invalid data');
      }

      inner$3(datasetModel).sourceFormat = sourceFormat;
    }
    /**
     * [Scenarios]:
     * (1) Provide source data directly:
     *     series: {
     *         encode: {...},
     *         dimensions: [...]
     *         seriesLayoutBy: 'row',
     *         data: [[...]]
     *     }
     * (2) Refer to datasetModel.
     *     series: [{
     *         encode: {...}
     *         // Ignore datasetIndex means `datasetIndex: 0`
     *         // and the dimensions defination in dataset is used
     *     }, {
     *         encode: {...},
     *         seriesLayoutBy: 'column',
     *         datasetIndex: 1
     *     }]
     *
     * Get data from series itself or datset.
     * @return {module:echarts/data/Source} source
     */


    function getSource(seriesModel) {
      return inner$3(seriesModel).source;
    }
    /**
     * MUST be called before mergeOption of all series.
     * @param {module:echarts/model/Global} ecModel
     */


    function resetSourceDefaulter(ecModel) {
      // `datasetMap` is used to make default encode.
      inner$3(ecModel).datasetMap = createHashMap$2();
    }
    /**
     * [Caution]:
     * MUST be called after series option merged and
     * before "series.getInitailData()" called.
     *
     * [The rule of making default encode]:
     * Category axis (if exists) alway map to the first dimension.
     * Each other axis occupies a subsequent dimension.
     *
     * [Why make default encode]:
     * Simplify the typing of encode in option, avoiding the case like that:
     * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],
     * where the "y" have to be manually typed as "1, 2, 3, ...".
     *
     * @param {module:echarts/model/Series} seriesModel
     */


    function prepareSource(seriesModel) {
      var seriesOption = seriesModel.option;
      var data = seriesOption.data;
      var sourceFormat = isTypedArray$2(data) ? SOURCE_FORMAT_TYPED_ARRAY$2 : SOURCE_FORMAT_ORIGINAL$2;
      var fromDataset = false;
      var seriesLayoutBy = seriesOption.seriesLayoutBy;
      var sourceHeader = seriesOption.sourceHeader;
      var dimensionsDefine = seriesOption.dimensions;
      var datasetModel = getDatasetModel(seriesModel);

      if (datasetModel) {
        var datasetOption = datasetModel.option;
        data = datasetOption.source;
        sourceFormat = inner$3(datasetModel).sourceFormat;
        fromDataset = true; // These settings from series has higher priority.

        seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;
        sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);
        dimensionsDefine = dimensionsDefine || datasetOption.dimensions;
      }

      var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine);
      inner$3(seriesModel).source = new Source_1({
        data: data,
        fromDataset: fromDataset,
        seriesLayoutBy: seriesLayoutBy,
        sourceFormat: sourceFormat,
        dimensionsDefine: completeResult.dimensionsDefine,
        startIndex: completeResult.startIndex,
        dimensionsDetectCount: completeResult.dimensionsDetectCount,
        // Note: dataset option does not have `encode`.
        encodeDefine: seriesOption.encode
      });
    } // return {startIndex, dimensionsDefine, dimensionsCount}


    function completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
      if (!data) {
        return {
          dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)
        };
      }

      var dimensionsDetectCount;
      var startIndex;

      if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS$1) {
        // Rule: Most of the first line are string: it is header.
        // Caution: consider a line with 5 string and 1 number,
        // it still can not be sure it is a head, because the
        // 5 string may be 5 values of category columns.
        if (sourceHeader === 'auto' || sourceHeader == null) {
          arrayRowsTravelFirst(function (val) {
            // '-' is regarded as null/undefined.
            if (val != null && val !== '-') {
              if (isString$4(val)) {
                startIndex == null && (startIndex = 1);
              } else {
                startIndex = 0;
              }
            } // 10 is an experience number, avoid long loop.

          }, seriesLayoutBy, data, 10);
        } else {
          startIndex = sourceHeader ? 1 : 0;
        }

        if (!dimensionsDefine && startIndex === 1) {
          dimensionsDefine = [];
          arrayRowsTravelFirst(function (val, index) {
            dimensionsDefine[index] = val != null ? val : '';
          }, seriesLayoutBy, data);
        }

        dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW$1 ? data.length : data[0] ? data[0].length : null;
      } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS$1) {
        if (!dimensionsDefine) {
          dimensionsDefine = objectRowsCollectDimensions(data);
        }
      } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS$2) {
        if (!dimensionsDefine) {
          dimensionsDefine = [];
          each$4(data, function (colArr, key) {
            dimensionsDefine.push(key);
          });
        }
      } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL$2) {
        var value0 = getDataItemValue$1(data[0]);
        dimensionsDetectCount = isArray$3(value0) && value0.length || 1;
      }

      return {
        startIndex: startIndex,
        dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),
        dimensionsDetectCount: dimensionsDetectCount
      };
    } // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],
    // which is reasonable. But dimension name is duplicated.
    // Returns undefined or an array contains only object without null/undefiend or string.


    function normalizeDimensionsDefine(dimensionsDefine) {
      if (!dimensionsDefine) {
        // The meaning of null/undefined is different from empty array.
        return;
      }

      var nameMap = createHashMap$2();
      return map$1(dimensionsDefine, function (item, index) {
        item = extend$3({}, isObject$5(item) ? item : {
          name: item
        }); // User can set null in dimensions.
        // We dont auto specify name, othewise a given name may
        // cause it be refered unexpectedly.

        if (item.name == null) {
          return item;
        } // Also consider number form like 2012.


        item.name += ''; // User may also specify displayName.
        // displayName will always exists except user not
        // specified or dim name is not specified or detected.
        // (A auto generated dim name will not be used as
        // displayName).

        if (item.displayName == null) {
          item.displayName = item.name;
        }

        var exist = nameMap.get(item.name);

        if (!exist) {
          nameMap.set(item.name, {
            count: 1
          });
        } else {
          item.name += '-' + exist.count++;
        }

        return item;
      });
    }

    function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
      maxLoop == null && (maxLoop = Infinity);

      if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW$1) {
        for (var i = 0; i < data.length && i < maxLoop; i++) {
          cb(data[i] ? data[i][0] : null, i);
        }
      } else {
        var value0 = data[0] || [];

        for (var i = 0; i < value0.length && i < maxLoop; i++) {
          cb(value0[i], i);
        }
      }
    }

    function objectRowsCollectDimensions(data) {
      var firstIndex = 0;
      var obj;

      while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line


      if (obj) {
        var dimensions = [];
        each$4(obj, function (value, key) {
          dimensions.push(key);
        });
        return dimensions;
      }
    }
    /**
     * [The strategy of the arrengment of data dimensions for dataset]:
     * "value way": all axes are non-category axes. So series one by one take
     *     several (the number is coordSysDims.length) dimensions from dataset.
     *     The result of data arrengment of data dimensions like:
     *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |
     * "category way": at least one axis is category axis. So the the first data
     *     dimension is always mapped to the first category axis and shared by
     *     all of the series. The other data dimensions are taken by series like
     *     "value way" does.
     *     The result of data arrengment of data dimensions like:
     *     | ser_shared_x | ser0_y | ser1_y | ser2_y |
     *
     * @param {Array.<Object|string>} coordDimensions [{name: <string>, type: <string>, dimsDef: <Array>}, ...]
     * @param {module:model/Series} seriesModel
     * @param {module:data/Source} source
     * @return {Object} encode Never be `null/undefined`.
     */


    function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
      var encode = {};
      var datasetModel = getDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.

      if (!datasetModel || !coordDimensions) {
        return encode;
      }

      var encodeItemName = [];
      var encodeSeriesName = [];
      var ecModel = seriesModel.ecModel;
      var datasetMap = inner$3(ecModel).datasetMap;
      var key = datasetModel.uid + '_' + source.seriesLayoutBy;
      var baseCategoryDimIndex;
      var categoryWayValueDimStart;
      coordDimensions = coordDimensions.slice();
      each$4(coordDimensions, function (coordDimInfo, coordDimIdx) {
        !isObject$5(coordDimInfo) && (coordDimensions[coordDimIdx] = {
          name: coordDimInfo
        });

        if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {
          baseCategoryDimIndex = coordDimIdx;
          categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimensions[coordDimIdx]);
        }

        encode[coordDimInfo.name] = [];
      });
      var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
        categoryWayDim: categoryWayValueDimStart,
        valueWayDim: 0
      }); // TODO
      // Auto detect first time axis and do arrangement.

      each$4(coordDimensions, function (coordDimInfo, coordDimIdx) {
        var coordDimName = coordDimInfo.name;
        var count = getDataDimCountOnCoordDim(coordDimInfo); // In value way.

        if (baseCategoryDimIndex == null) {
          var start = datasetRecord.valueWayDim;
          pushDim(encode[coordDimName], start, count);
          pushDim(encodeSeriesName, start, count);
          datasetRecord.valueWayDim += count; // ??? TODO give a better default series name rule?
          // especially when encode x y specified.
          // consider: when mutiple series share one dimension
          // category axis, series name should better use
          // the other dimsion name. On the other hand, use
          // both dimensions name.
        } // In category way, the first category axis.
        else if (baseCategoryDimIndex === coordDimIdx) {
            pushDim(encode[coordDimName], 0, count);
            pushDim(encodeItemName, 0, count);
          } // In category way, the other axis.
          else {
              var start = datasetRecord.categoryWayDim;
              pushDim(encode[coordDimName], start, count);
              pushDim(encodeSeriesName, start, count);
              datasetRecord.categoryWayDim += count;
            }
      });

      function pushDim(dimIdxArr, idxFrom, idxCount) {
        for (var i = 0; i < idxCount; i++) {
          dimIdxArr.push(idxFrom + i);
        }
      }

      function getDataDimCountOnCoordDim(coordDimInfo) {
        var dimsDef = coordDimInfo.dimsDef;
        return dimsDef ? dimsDef.length : 1;
      }

      encodeItemName.length && (encode.itemName = encodeItemName);
      encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
      return encode;
    }
    /**
     * Work for data like [{name: ..., value: ...}, ...].
     *
     * @param {module:model/Series} seriesModel
     * @param {module:data/Source} source
     * @return {Object} encode Never be `null/undefined`.
     */


    function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
      var encode = {};
      var datasetModel = getDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.

      if (!datasetModel) {
        return encode;
      }

      var sourceFormat = source.sourceFormat;
      var dimensionsDefine = source.dimensionsDefine;
      var potentialNameDimIndex;

      if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS$1 || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS$2) {
        each$4(dimensionsDefine, function (dim, idx) {
          if ((isObject$5(dim) ? dim.name : dim) === 'name') {
            potentialNameDimIndex = idx;
          }
        });
      } // idxResult: {v, n}.


      var idxResult = function () {
        var idxRes0 = {};
        var idxRes1 = {};
        var guessRecords = []; // 5 is an experience value.

        for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {
          var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
          guessRecords.push(guessResult);
          var isPureNumber = guessResult === BE_ORDINAL.Not; // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,
          // and then find a name dim with the priority:
          // "BE_ORDINAL.Might|BE_ORDINAL.Must" > "other dim" > "the value dim itself".

          if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
            idxRes0.v = i;
          }

          if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
            idxRes0.n = i;
          }

          if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
            return idxRes0;
          } // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),
          // find the first BE_ORDINAL.Might as the value dim,
          // and then find a name dim with the priority:
          // "other dim" > "the value dim itself".
          // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be
          // treated as number.


          if (!isPureNumber) {
            if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
              idxRes1.v = i;
            }

            if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
              idxRes1.n = i;
            }
          }
        }

        function fulfilled(idxResult) {
          return idxResult.v != null && idxResult.n != null;
        }

        return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
      }();

      if (idxResult) {
        encode.value = idxResult.v; // `potentialNameDimIndex` has highest priority.

        var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n; // By default, label use itemName in charts.
        // So we dont set encodeLabel here.

        encode.itemName = [nameDimIndex];
        encode.seriesName = [nameDimIndex];
      }

      return encode;
    }
    /**
     * If return null/undefined, indicate that should not use datasetModel.
     */


    function getDatasetModel(seriesModel) {
      var option = seriesModel.option; // Caution: consider the scenario:
      // A dataset is declared and a series is not expected to use the dataset,
      // and at the beginning `setOption({series: { noData })` (just prepare other
      // option but no data), then `setOption({series: {data: [...]}); In this case,
      // the user should set an empty array to avoid that dataset is used by default.

      var thisData = option.data;

      if (!thisData) {
        return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);
      }
    }
    /**
     * The rule should not be complex, otherwise user might not
     * be able to known where the data is wrong.
     * The code is ugly, but how to make it neat?
     *
     * @param {module:echars/data/Source} source
     * @param {number} dimIndex
     * @return {BE_ORDINAL} guess result.
     */


    function guessOrdinal(source, dimIndex) {
      return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
    } // dimIndex may be overflow source data.
    // return {BE_ORDINAL}


    function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
      var result; // Experience value.

      var maxLoop = 5;

      if (isTypedArray$2(data)) {
        return BE_ORDINAL.Not;
      } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine
      // always exists in source.


      var dimName;
      var dimType;

      if (dimensionsDefine) {
        var dimDefItem = dimensionsDefine[dimIndex];

        if (isObject$5(dimDefItem)) {
          dimName = dimDefItem.name;
          dimType = dimDefItem.type;
        } else if (isString$4(dimDefItem)) {
          dimName = dimDefItem;
        }
      }

      if (dimType != null) {
        return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;
      }

      if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS$1) {
        if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW$1) {
          var sample = data[dimIndex];

          for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
            if ((result = detectValue(sample[startIndex + i])) != null) {
              return result;
            }
          }
        } else {
          for (var i = 0; i < data.length && i < maxLoop; i++) {
            var row = data[startIndex + i];

            if (row && (result = detectValue(row[dimIndex])) != null) {
              return result;
            }
          }
        }
      } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS$1) {
        if (!dimName) {
          return BE_ORDINAL.Not;
        }

        for (var i = 0; i < data.length && i < maxLoop; i++) {
          var item = data[i];

          if (item && (result = detectValue(item[dimName])) != null) {
            return result;
          }
        }
      } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS$2) {
        if (!dimName) {
          return BE_ORDINAL.Not;
        }

        var sample = data[dimName];

        if (!sample || isTypedArray$2(sample)) {
          return BE_ORDINAL.Not;
        }

        for (var i = 0; i < sample.length && i < maxLoop; i++) {
          if ((result = detectValue(sample[i])) != null) {
            return result;
          }
        }
      } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL$2) {
        for (var i = 0; i < data.length && i < maxLoop; i++) {
          var item = data[i];
          var val = getDataItemValue$1(item);

          if (!isArray$3(val)) {
            return BE_ORDINAL.Not;
          }

          if ((result = detectValue(val[dimIndex])) != null) {
            return result;
          }
        }
      }

      function detectValue(val) {
        var beStr = isString$4(val); // Consider usage convenience, '1', '2' will be treated as "number".
        // `isFinit('')` get `true`.

        if (val != null && isFinite(val) && val !== '') {
          return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
        } else if (beStr && val !== '-') {
          return BE_ORDINAL.Must;
        }
      }

      return BE_ORDINAL.Not;
    }

    var BE_ORDINAL_1 = BE_ORDINAL;
    var detectSourceFormat_1 = detectSourceFormat;
    var getSource_1 = getSource;
    var resetSourceDefaulter_1 = resetSourceDefaulter;
    var prepareSource_1 = prepareSource;
    var makeSeriesEncodeForAxisCoordSys_1 = makeSeriesEncodeForAxisCoordSys;
    var makeSeriesEncodeForNameBased_1 = makeSeriesEncodeForNameBased;
    var guessOrdinal_1 = guessOrdinal;

    var sourceHelper = {
    	BE_ORDINAL: BE_ORDINAL_1,
    	detectSourceFormat: detectSourceFormat_1,
    	getSource: getSource_1,
    	resetSourceDefaulter: resetSourceDefaulter_1,
    	prepareSource: prepareSource_1,
    	makeSeriesEncodeForAxisCoordSys: makeSeriesEncodeForAxisCoordSys_1,
    	makeSeriesEncodeForNameBased: makeSeriesEncodeForNameBased_1,
    	guessOrdinal: guessOrdinal_1
    };

    var each$5 = util.each;
    var filter$1 = util.filter;
    var map$2 = util.map;
    var isArray$4 = util.isArray;
    var indexOf$2 = util.indexOf;
    var isObject$6 = util.isObject;
    var isString$5 = util.isString;
    var createHashMap$3 = util.createHashMap;
    var assert$1 = util.assert;
    var clone$4 = util.clone;
    var merge$2 = util.merge;
    var extend$4 = util.extend;
    var mixin$2 = util.mixin;













    var resetSourceDefaulter$1 = sourceHelper.resetSourceDefaulter;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * ECharts global model
     *
     * @module {echarts/model/Global}
     */

    /**
     * Caution: If the mechanism should be changed some day, these cases
     * should be considered:
     *
     * (1) In `merge option` mode, if using the same option to call `setOption`
     * many times, the result should be the same (try our best to ensure that).
     * (2) In `merge option` mode, if a component has no id/name specified, it
     * will be merged by index, and the result sequence of the components is
     * consistent to the original sequence.
     * (3) `reset` feature (in toolbox). Find detailed info in comments about
     * `mergeOption` in module:echarts/model/OptionManager.
     */
    var OPTION_INNER_KEY = '\0_ec_inner';
    /**
     * @alias module:echarts/model/Global
     *
     * @param {Object} option
     * @param {module:echarts/model/Model} parentModel
     * @param {Object} theme
     */

    var GlobalModel = Model_1.extend({
      init: function (option, parentModel, theme, optionManager) {
        theme = theme || {};
        this.option = null; // Mark as not initialized.

        /**
         * @type {module:echarts/model/Model}
         * @private
         */

        this._theme = new Model_1(theme);
        /**
         * @type {module:echarts/model/OptionManager}
         */

        this._optionManager = optionManager;
      },
      setOption: function (option, optionPreprocessorFuncs) {
        assert$1(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');

        this._optionManager.setOption(option, optionPreprocessorFuncs);

        this.resetOption(null);
      },

      /**
       * @param {string} type null/undefined: reset all.
       *                      'recreate': force recreate all.
       *                      'timeline': only reset timeline option
       *                      'media': only reset media query option
       * @return {boolean} Whether option changed.
       */
      resetOption: function (type) {
        var optionChanged = false;
        var optionManager = this._optionManager;

        if (!type || type === 'recreate') {
          var baseOption = optionManager.mountOption(type === 'recreate');

          if (!this.option || type === 'recreate') {
            initBase.call(this, baseOption);
          } else {
            this.restoreData();
            this.mergeOption(baseOption);
          }

          optionChanged = true;
        }

        if (type === 'timeline' || type === 'media') {
          this.restoreData();
        }

        if (!type || type === 'recreate' || type === 'timeline') {
          var timelineOption = optionManager.getTimelineOption(this);
          timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
        }

        if (!type || type === 'recreate' || type === 'media') {
          var mediaOptions = optionManager.getMediaOption(this, this._api);

          if (mediaOptions.length) {
            each$5(mediaOptions, function (mediaOption) {
              this.mergeOption(mediaOption, optionChanged = true);
            }, this);
          }
        }

        return optionChanged;
      },

      /**
       * @protected
       */
      mergeOption: function (newOption) {
        var option = this.option;
        var componentsMap = this._componentsMap;
        var newCptTypes = [];
        resetSourceDefaulter$1(this); // If no component class, merge directly.
        // For example: color, animaiton options, etc.

        each$5(newOption, function (componentOption, mainType) {
          if (componentOption == null) {
            return;
          }

          if (!Component.hasClass(mainType)) {
            // globalSettingTask.dirty();
            option[mainType] = option[mainType] == null ? clone$4(componentOption) : merge$2(option[mainType], componentOption, true);
          } else if (mainType) {
            newCptTypes.push(mainType);
          }
        });
        Component.topologicalTravel(newCptTypes, Component.getAllClassMainTypes(), visitComponent, this);

        function visitComponent(mainType, dependencies) {
          var newCptOptionList = model.normalizeToArray(newOption[mainType]);
          var mapResult = model.mappingToExists(componentsMap.get(mainType), newCptOptionList);
          model.makeIdAndName(mapResult); // Set mainType and complete subType.

          each$5(mapResult, function (item, index) {
            var opt = item.option;

            if (isObject$6(opt)) {
              item.keyInfo.mainType = mainType;
              item.keyInfo.subType = determineSubType(mainType, opt, item.exist);
            }
          });
          var dependentModels = getComponentsByTypes(componentsMap, dependencies);
          option[mainType] = [];
          componentsMap.set(mainType, []);
          each$5(mapResult, function (resultItem, index) {
            var componentModel = resultItem.exist;
            var newCptOption = resultItem.option;
            assert$1(isObject$6(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},
            // see removeEdgeAndAdd in topologicalTravel and
            // ComponentModel.getAllClassMainTypes.

            if (!newCptOption) {
              componentModel.mergeOption({}, this);
              componentModel.optionUpdated({}, false);
            } else {
              var ComponentModelClass = Component.getClass(mainType, resultItem.keyInfo.subType, true);

              if (componentModel && componentModel.constructor === ComponentModelClass) {
                componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();

                componentModel.mergeOption(newCptOption, this);
                componentModel.optionUpdated(newCptOption, false);
              } else {
                // PENDING Global as parent ?
                var extraOpt = extend$4({
                  dependentModels: dependentModels,
                  componentIndex: index
                }, resultItem.keyInfo);
                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);
                extend$4(componentModel, extraOpt);
                componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.
                // newCptOption has been used as componentModel.option
                // and may be merged with theme and default, so pass null
                // to avoid confusion.

                componentModel.optionUpdated(null, true);
              }
            }

            componentsMap.get(mainType)[index] = componentModel;
            option[mainType][index] = componentModel.option;
          }, this); // Backup series for filtering.

          if (mainType === 'series') {
            createSeriesIndices(this, componentsMap.get('series'));
          }
        }

        this._seriesIndicesMap = createHashMap$3(this._seriesIndices = this._seriesIndices || []);
      },

      /**
       * Get option for output (cloned option and inner info removed)
       * @public
       * @return {Object}
       */
      getOption: function () {
        var option = clone$4(this.option);
        each$5(option, function (opts, mainType) {
          if (Component.hasClass(mainType)) {
            var opts = model.normalizeToArray(opts);

            for (var i = opts.length - 1; i >= 0; i--) {
              // Remove options with inner id.
              if (model.isIdInner(opts[i])) {
                opts.splice(i, 1);
              }
            }

            option[mainType] = opts;
          }
        });
        delete option[OPTION_INNER_KEY];
        return option;
      },

      /**
       * @return {module:echarts/model/Model}
       */
      getTheme: function () {
        return this._theme;
      },

      /**
       * @param {string} mainType
       * @param {number} [idx=0]
       * @return {module:echarts/model/Component}
       */
      getComponent: function (mainType, idx) {
        var list = this._componentsMap.get(mainType);

        if (list) {
          return list[idx || 0];
        }
      },

      /**
       * If none of index and id and name used, return all components with mainType.
       * @param {Object} condition
       * @param {string} condition.mainType
       * @param {string} [condition.subType] If ignore, only query by mainType
       * @param {number|Array.<number>} [condition.index] Either input index or id or name.
       * @param {string|Array.<string>} [condition.id] Either input index or id or name.
       * @param {string|Array.<string>} [condition.name] Either input index or id or name.
       * @return {Array.<module:echarts/model/Component>}
       */
      queryComponents: function (condition) {
        var mainType = condition.mainType;

        if (!mainType) {
          return [];
        }

        var index = condition.index;
        var id = condition.id;
        var name = condition.name;

        var cpts = this._componentsMap.get(mainType);

        if (!cpts || !cpts.length) {
          return [];
        }

        var result;

        if (index != null) {
          if (!isArray$4(index)) {
            index = [index];
          }

          result = filter$1(map$2(index, function (idx) {
            return cpts[idx];
          }), function (val) {
            return !!val;
          });
        } else if (id != null) {
          var isIdArray = isArray$4(id);
          result = filter$1(cpts, function (cpt) {
            return isIdArray && indexOf$2(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
          });
        } else if (name != null) {
          var isNameArray = isArray$4(name);
          result = filter$1(cpts, function (cpt) {
            return isNameArray && indexOf$2(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;
          });
        } else {
          // Return all components with mainType
          result = cpts.slice();
        }

        return filterBySubType(result, condition);
      },

      /**
       * The interface is different from queryComponents,
       * which is convenient for inner usage.
       *
       * @usage
       * var result = findComponents(
       *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
       * );
       * var result = findComponents(
       *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
       * );
       * var result = findComponents(
       *     {mainType: 'series',
       *     filter: function (model, index) {...}}
       * );
       * // result like [component0, componnet1, ...]
       *
       * @param {Object} condition
       * @param {string} condition.mainType Mandatory.
       * @param {string} [condition.subType] Optional.
       * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
       *        where xxx is mainType.
       *        If query attribute is null/undefined or has no index/id/name,
       *        do not filtering by query conditions, which is convenient for
       *        no-payload situations or when target of action is global.
       * @param {Function} [condition.filter] parameter: component, return boolean.
       * @return {Array.<module:echarts/model/Component>}
       */
      findComponents: function (condition) {
        var query = condition.query;
        var mainType = condition.mainType;
        var queryCond = getQueryCond(query);
        var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);
        return doFilter(filterBySubType(result, condition));

        function getQueryCond(q) {
          var indexAttr = mainType + 'Index';
          var idAttr = mainType + 'Id';
          var nameAttr = mainType + 'Name';
          return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
            mainType: mainType,
            // subType will be filtered finally.
            index: q[indexAttr],
            id: q[idAttr],
            name: q[nameAttr]
          } : null;
        }

        function doFilter(res) {
          return condition.filter ? filter$1(res, condition.filter) : res;
        }
      },

      /**
       * @usage
       * eachComponent('legend', function (legendModel, index) {
       *     ...
       * });
       * eachComponent(function (componentType, model, index) {
       *     // componentType does not include subType
       *     // (componentType is 'xxx' but not 'xxx.aa')
       * });
       * eachComponent(
       *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
       *     function (model, index) {...}
       * );
       * eachComponent(
       *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
       *     function (model, index) {...}
       * );
       *
       * @param {string|Object=} mainType When mainType is object, the definition
       *                                  is the same as the method 'findComponents'.
       * @param {Function} cb
       * @param {*} context
       */
      eachComponent: function (mainType, cb, context) {
        var componentsMap = this._componentsMap;

        if (typeof mainType === 'function') {
          context = cb;
          cb = mainType;
          componentsMap.each(function (components, componentType) {
            each$5(components, function (component, index) {
              cb.call(context, componentType, component, index);
            });
          });
        } else if (isString$5(mainType)) {
          each$5(componentsMap.get(mainType), cb, context);
        } else if (isObject$6(mainType)) {
          var queryResult = this.findComponents(mainType);
          each$5(queryResult, cb, context);
        }
      },

      /**
       * @param {string} name
       * @return {Array.<module:echarts/model/Series>}
       */
      getSeriesByName: function (name) {
        var series = this._componentsMap.get('series');

        return filter$1(series, function (oneSeries) {
          return oneSeries.name === name;
        });
      },

      /**
       * @param {number} seriesIndex
       * @return {module:echarts/model/Series}
       */
      getSeriesByIndex: function (seriesIndex) {
        return this._componentsMap.get('series')[seriesIndex];
      },

      /**
       * Get series list before filtered by type.
       * FIXME: rename to getRawSeriesByType?
       *
       * @param {string} subType
       * @return {Array.<module:echarts/model/Series>}
       */
      getSeriesByType: function (subType) {
        var series = this._componentsMap.get('series');

        return filter$1(series, function (oneSeries) {
          return oneSeries.subType === subType;
        });
      },

      /**
       * @return {Array.<module:echarts/model/Series>}
       */
      getSeries: function () {
        return this._componentsMap.get('series').slice();
      },

      /**
       * @return {number}
       */
      getSeriesCount: function () {
        return this._componentsMap.get('series').length;
      },

      /**
       * After filtering, series may be different
       * frome raw series.
       *
       * @param {Function} cb
       * @param {*} context
       */
      eachSeries: function (cb, context) {
        each$5(this._seriesIndices, function (rawSeriesIndex) {
          var series = this._componentsMap.get('series')[rawSeriesIndex];

          cb.call(context, series, rawSeriesIndex);
        }, this);
      },

      /**
       * Iterate raw series before filtered.
       *
       * @param {Function} cb
       * @param {*} context
       */
      eachRawSeries: function (cb, context) {
        each$5(this._componentsMap.get('series'), cb, context);
      },

      /**
       * After filtering, series may be different.
       * frome raw series.
       *
       * @param {string} subType.
       * @param {Function} cb
       * @param {*} context
       */
      eachSeriesByType: function (subType, cb, context) {
        each$5(this._seriesIndices, function (rawSeriesIndex) {
          var series = this._componentsMap.get('series')[rawSeriesIndex];

          if (series.subType === subType) {
            cb.call(context, series, rawSeriesIndex);
          }
        }, this);
      },

      /**
       * Iterate raw series before filtered of given type.
       *
       * @parma {string} subType
       * @param {Function} cb
       * @param {*} context
       */
      eachRawSeriesByType: function (subType, cb, context) {
        return each$5(this.getSeriesByType(subType), cb, context);
      },

      /**
       * @param {module:echarts/model/Series} seriesModel
       */
      isSeriesFiltered: function (seriesModel) {
        return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
      },

      /**
       * @return {Array.<number>}
       */
      getCurrentSeriesIndices: function () {
        return (this._seriesIndices || []).slice();
      },

      /**
       * @param {Function} cb
       * @param {*} context
       */
      filterSeries: function (cb, context) {
        var filteredSeries = filter$1(this._componentsMap.get('series'), cb, context);
        createSeriesIndices(this, filteredSeries);
      },
      restoreData: function (payload) {
        var componentsMap = this._componentsMap;
        createSeriesIndices(this, componentsMap.get('series'));
        var componentTypes = [];
        componentsMap.each(function (components, componentType) {
          componentTypes.push(componentType);
        });
        Component.topologicalTravel(componentTypes, Component.getAllClassMainTypes(), function (componentType, dependencies) {
          each$5(componentsMap.get(componentType), function (component) {
            (componentType !== 'series' || !isNotTargetSeries(component, payload)) && component.restoreData();
          });
        });
      }
    });

    function isNotTargetSeries(seriesModel, payload) {
      if (payload) {
        var index = payload.seiresIndex;
        var id = payload.seriesId;
        var name = payload.seriesName;
        return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;
      }
    }
    /**
     * @inner
     */


    function mergeTheme(option, theme) {
      // PENDING
      // NOT use `colorLayer` in theme if option has `color`
      var notMergeColorLayer = option.color && !option.colorLayer;
      each$5(theme, function (themeItem, name) {
        if (name === 'colorLayer' && notMergeColorLayer) {
          return;
        } // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理


        if (!Component.hasClass(name)) {
          if (typeof themeItem === 'object') {
            option[name] = !option[name] ? clone$4(themeItem) : merge$2(option[name], themeItem, false);
          } else {
            if (option[name] == null) {
              option[name] = themeItem;
            }
          }
        }
      });
    }

    function initBase(baseOption) {
      baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,
      // i.e. `chart.setOption(chart.getModel().option);` is forbiden.

      this.option = {};
      this.option[OPTION_INNER_KEY] = 1;
      /**
       * Init with series: [], in case of calling findSeries method
       * before series initialized.
       * @type {Object.<string, Array.<module:echarts/model/Model>>}
       * @private
       */

      this._componentsMap = createHashMap$3({
        series: []
      });
      /**
       * Mapping between filtered series list and raw series list.
       * key: filtered series indices, value: raw series indices.
       * @type {Array.<nubmer>}
       * @private
       */

      this._seriesIndices;
      this._seriesIndicesMap;
      mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property

      merge$2(baseOption, globalDefault, false);
      this.mergeOption(baseOption);
    }
    /**
     * @inner
     * @param {Array.<string>|string} types model types
     * @return {Object} key: {string} type, value: {Array.<Object>} models
     */


    function getComponentsByTypes(componentsMap, types) {
      if (!isArray$4(types)) {
        types = types ? [types] : [];
      }

      var ret = {};
      each$5(types, function (type) {
        ret[type] = (componentsMap.get(type) || []).slice();
      });
      return ret;
    }
    /**
     * @inner
     */


    function determineSubType(mainType, newCptOption, existComponent) {
      var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.
      : Component.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType

      return subType;
    }
    /**
     * @inner
     */


    function createSeriesIndices(ecModel, seriesModels) {
      ecModel._seriesIndicesMap = createHashMap$3(ecModel._seriesIndices = map$2(seriesModels, function (series) {
        return series.componentIndex;
      }) || []);
    }
    /**
     * @inner
     */


    function filterBySubType(components, condition) {
      // Using hasOwnProperty for restrict. Consider
      // subType is undefined in user payload.
      return condition.hasOwnProperty('subType') ? filter$1(components, function (cpt) {
        return cpt.subType === condition.subType;
      }) : components;
    }

    mixin$2(GlobalModel, colorPalette);
    var _default$Z = GlobalModel;
    var Global = _default$Z;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var echartsAPIList = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel']; // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js

    function ExtensionAPI(chartInstance) {
      util.each(echartsAPIList, function (name) {
        this[name] = util.bind(chartInstance[name], chartInstance);
      }, this);
    }

    var _default$_ = ExtensionAPI;
    var ExtensionAPI_1 = _default$_;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var coordinateSystemCreators = {};

    function CoordinateSystemManager() {
      this._coordinateSystems = [];
    }

    CoordinateSystemManager.prototype = {
      constructor: CoordinateSystemManager,
      create: function (ecModel, api) {
        var coordinateSystems = [];
        util.each(coordinateSystemCreators, function (creater, type) {
          var list = creater.create(ecModel, api);
          coordinateSystems = coordinateSystems.concat(list || []);
        });
        this._coordinateSystems = coordinateSystems;
      },
      update: function (ecModel, api) {
        util.each(this._coordinateSystems, function (coordSys) {
          coordSys.update && coordSys.update(ecModel, api);
        });
      },
      getCoordinateSystems: function () {
        return this._coordinateSystems.slice();
      }
    };

    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {
      coordinateSystemCreators[type] = coordinateSystemCreator;
    };

    CoordinateSystemManager.get = function (type) {
      return coordinateSystemCreators[type];
    };

    var _default$$ = CoordinateSystemManager;
    var CoordinateSystem = _default$$;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * ECharts option manager
     *
     * @module {echarts/model/OptionManager}
     */
    var each$6 = util.each;
    var clone$5 = util.clone;
    var map$3 = util.map;
    var merge$3 = util.merge;
    var QUERY_REG = /^(min|max)?(.+)$/;
    /**
     * TERM EXPLANATIONS:
     *
     * [option]:
     *
     *     An object that contains definitions of components. For example:
     *     var option = {
     *         title: {...},
     *         legend: {...},
     *         visualMap: {...},
     *         series: [
     *             {data: [...]},
     *             {data: [...]},
     *             ...
     *         ]
     *     };
     *
     * [rawOption]:
     *
     *     An object input to echarts.setOption. 'rawOption' may be an
     *     'option', or may be an object contains multi-options. For example:
     *     var option = {
     *         baseOption: {
     *             title: {...},
     *             legend: {...},
     *             series: [
     *                 {data: [...]},
     *                 {data: [...]},
     *                 ...
     *             ]
     *         },
     *         timeline: {...},
     *         options: [
     *             {title: {...}, series: {data: [...]}},
     *             {title: {...}, series: {data: [...]}},
     *             ...
     *         ],
     *         media: [
     *             {
     *                 query: {maxWidth: 320},
     *                 option: {series: {x: 20}, visualMap: {show: false}}
     *             },
     *             {
     *                 query: {minWidth: 320, maxWidth: 720},
     *                 option: {series: {x: 500}, visualMap: {show: true}}
     *             },
     *             {
     *                 option: {series: {x: 1200}, visualMap: {show: true}}
     *             }
     *         ]
     *     };
     *
     * @alias module:echarts/model/OptionManager
     * @param {module:echarts/ExtensionAPI} api
     */

    function OptionManager(api) {
      /**
       * @private
       * @type {module:echarts/ExtensionAPI}
       */
      this._api = api;
      /**
       * @private
       * @type {Array.<number>}
       */

      this._timelineOptions = [];
      /**
       * @private
       * @type {Array.<Object>}
       */

      this._mediaList = [];
      /**
       * @private
       * @type {Object}
       */

      this._mediaDefault;
      /**
       * -1, means default.
       * empty means no media.
       * @private
       * @type {Array.<number>}
       */

      this._currentMediaIndices = [];
      /**
       * @private
       * @type {Object}
       */

      this._optionBackup;
      /**
       * @private
       * @type {Object}
       */

      this._newBaseOption;
    } // timeline.notMerge is not supported in ec3. Firstly there is rearly
    // case that notMerge is needed. Secondly supporting 'notMerge' requires
    // rawOption cloned and backuped when timeline changed, which does no
    // good to performance. What's more, that both timeline and setOption
    // method supply 'notMerge' brings complex and some problems.
    // Consider this case:
    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);


    OptionManager.prototype = {
      constructor: OptionManager,

      /**
       * @public
       * @param {Object} rawOption Raw option.
       * @param {module:echarts/model/Global} ecModel
       * @param {Array.<Function>} optionPreprocessorFuncs
       * @return {Object} Init option
       */
      setOption: function (rawOption, optionPreprocessorFuncs) {
        if (rawOption) {
          // That set dat primitive is dangerous if user reuse the data when setOption again.
          util.each(model.normalizeToArray(rawOption.series), function (series) {
            series && series.data && util.isTypedArray(series.data) && util.setAsPrimitive(series.data);
          });
        } // Caution: some series modify option data, if do not clone,
        // it should ensure that the repeat modify correctly
        // (create a new object when modify itself).


        rawOption = clone$5(rawOption); // FIXME
        // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。

        var oldOptionBackup = this._optionBackup;
        var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
        this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);

        if (oldOptionBackup) {
          // Only baseOption can be merged.
          mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,
          // that is, if you `setOption` twice and both has timeline options, the latter
          // timeline opitons will not be merged to the formers, but just substitude them.

          if (newParsedOption.timelineOptions.length) {
            oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
          }

          if (newParsedOption.mediaList.length) {
            oldOptionBackup.mediaList = newParsedOption.mediaList;
          }

          if (newParsedOption.mediaDefault) {
            oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
          }
        } else {
          this._optionBackup = newParsedOption;
        }
      },

      /**
       * @param {boolean} isRecreate
       * @return {Object}
       */
      mountOption: function (isRecreate) {
        var optionBackup = this._optionBackup; // TODO
        // 如果没有reset功能则不clone。

        this._timelineOptions = map$3(optionBackup.timelineOptions, clone$5);
        this._mediaList = map$3(optionBackup.mediaList, clone$5);
        this._mediaDefault = clone$5(optionBackup.mediaDefault);
        this._currentMediaIndices = [];
        return clone$5(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`
        // called, and is merged into every new option by inner method `mergeOption`
        // each time `setOption` called, can be only used in `isRecreate`, because
        // its reliability is under suspicion. In other cases option merge is
        // performed by `model.mergeOption`.
        ? optionBackup.baseOption : this._newBaseOption);
      },

      /**
       * @param {module:echarts/model/Global} ecModel
       * @return {Object}
       */
      getTimelineOption: function (ecModel) {
        var option;
        var timelineOptions = this._timelineOptions;

        if (timelineOptions.length) {
          // getTimelineOption can only be called after ecModel inited,
          // so we can get currentIndex from timelineModel.
          var timelineModel = ecModel.getComponent('timeline');

          if (timelineModel) {
            option = clone$5(timelineOptions[timelineModel.getCurrentIndex()], true);
          }
        }

        return option;
      },

      /**
       * @param {module:echarts/model/Global} ecModel
       * @return {Array.<Object>}
       */
      getMediaOption: function (ecModel) {
        var ecWidth = this._api.getWidth();

        var ecHeight = this._api.getHeight();

        var mediaList = this._mediaList;
        var mediaDefault = this._mediaDefault;
        var indices = [];
        var result = []; // No media defined.

        if (!mediaList.length && !mediaDefault) {
          return result;
        } // Multi media may be applied, the latter defined media has higher priority.


        for (var i = 0, len = mediaList.length; i < len; i++) {
          if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
            indices.push(i);
          }
        } // FIXME
        // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。


        if (!indices.length && mediaDefault) {
          indices = [-1];
        }

        if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
          result = map$3(indices, function (index) {
            return clone$5(index === -1 ? mediaDefault.option : mediaList[index].option);
          });
        } // Otherwise return nothing.


        this._currentMediaIndices = indices;
        return result;
      }
    };

    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
      var timelineOptions = [];
      var mediaList = [];
      var mediaDefault;
      var baseOption; // Compatible with ec2.

      var timelineOpt = rawOption.timeline;

      if (rawOption.baseOption) {
        baseOption = rawOption.baseOption;
      } // For timeline


      if (timelineOpt || rawOption.options) {
        baseOption = baseOption || {};
        timelineOptions = (rawOption.options || []).slice();
      } // For media query


      if (rawOption.media) {
        baseOption = baseOption || {};
        var media = rawOption.media;
        each$6(media, function (singleMedia) {
          if (singleMedia && singleMedia.option) {
            if (singleMedia.query) {
              mediaList.push(singleMedia);
            } else if (!mediaDefault) {
              // Use the first media default.
              mediaDefault = singleMedia;
            }
          }
        });
      } // For normal option


      if (!baseOption) {
        baseOption = rawOption;
      } // Set timelineOpt to baseOption in ec3,
      // which is convenient for merge option.


      if (!baseOption.timeline) {
        baseOption.timeline = timelineOpt;
      } // Preprocess.


      each$6([baseOption].concat(timelineOptions).concat(util.map(mediaList, function (media) {
        return media.option;
      })), function (option) {
        each$6(optionPreprocessorFuncs, function (preProcess) {
          preProcess(option, isNew);
        });
      });
      return {
        baseOption: baseOption,
        timelineOptions: timelineOptions,
        mediaDefault: mediaDefault,
        mediaList: mediaList
      };
    }
    /**
     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
     * Support: width, height, aspectRatio
     * Can use max or min as prefix.
     */


    function applyMediaQuery(query, ecWidth, ecHeight) {
      var realMap = {
        width: ecWidth,
        height: ecHeight,
        aspectratio: ecWidth / ecHeight // lowser case for convenientce.

      };
      var applicatable = true;
      util.each(query, function (value, attr) {
        var matched = attr.match(QUERY_REG);

        if (!matched || !matched[1] || !matched[2]) {
          return;
        }

        var operator = matched[1];
        var realAttr = matched[2].toLowerCase();

        if (!compare(realMap[realAttr], value, operator)) {
          applicatable = false;
        }
      });
      return applicatable;
    }

    function compare(real, expect, operator) {
      if (operator === 'min') {
        return real >= expect;
      } else if (operator === 'max') {
        return real <= expect;
      } else {
        // Equals
        return real === expect;
      }
    }

    function indicesEquals(indices1, indices2) {
      // indices is always order by asc and has only finite number.
      return indices1.join(',') === indices2.join(',');
    }
    /**
     * Consider case:
     * `chart.setOption(opt1);`
     * Then user do some interaction like dataZoom, dataView changing.
     * `chart.setOption(opt2);`
     * Then user press 'reset button' in toolbox.
     *
     * After doing that all of the interaction effects should be reset, the
     * chart should be the same as the result of invoke
     * `chart.setOption(opt1); chart.setOption(opt2);`.
     *
     * Although it is not able ensure that
     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
     * `chart.setOption(merge(opt1, opt2));` exactly,
     * this might be the only simple way to implement that feature.
     *
     * MEMO: We've considered some other approaches:
     * 1. Each model handle its self restoration but not uniform treatment.
     *     (Too complex in logic and error-prone)
     * 2. Use a shadow ecModel. (Performace expensive)
     */


    function mergeOption(oldOption, newOption) {
      newOption = newOption || {};
      each$6(newOption, function (newCptOpt, mainType) {
        if (newCptOpt == null) {
          return;
        }

        var oldCptOpt = oldOption[mainType];

        if (!Component.hasClass(mainType)) {
          oldOption[mainType] = merge$3(oldCptOpt, newCptOpt, true);
        } else {
          newCptOpt = model.normalizeToArray(newCptOpt);
          oldCptOpt = model.normalizeToArray(oldCptOpt);
          var mapResult = model.mappingToExists(oldCptOpt, newCptOpt);
          oldOption[mainType] = map$3(mapResult, function (item) {
            return item.option && item.exist ? merge$3(item.exist, item.option, true) : item.exist || item.option;
          });
        }
      });
    }

    var _default$10 = OptionManager;
    var OptionManager_1 = _default$10;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var each$7 = util.each;
    var isObject$7 = util.isObject;
    var POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];

    function compatEC2ItemStyle(opt) {
      var itemStyleOpt = opt && opt.itemStyle;

      if (!itemStyleOpt) {
        return;
      }

      for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
        var styleName = POSSIBLE_STYLES[i];
        var normalItemStyleOpt = itemStyleOpt.normal;
        var emphasisItemStyleOpt = itemStyleOpt.emphasis;

        if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
          opt[styleName] = opt[styleName] || {};

          if (!opt[styleName].normal) {
            opt[styleName].normal = normalItemStyleOpt[styleName];
          } else {
            util.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
          }

          normalItemStyleOpt[styleName] = null;
        }

        if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
          opt[styleName] = opt[styleName] || {};

          if (!opt[styleName].emphasis) {
            opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
          } else {
            util.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
          }

          emphasisItemStyleOpt[styleName] = null;
        }
      }
    }

    function convertNormalEmphasis(opt, optType, useExtend) {
      if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
        var normalOpt = opt[optType].normal;
        var emphasisOpt = opt[optType].emphasis;

        if (normalOpt) {
          // Timeline controlStyle has other properties besides normal and emphasis
          if (useExtend) {
            opt[optType].normal = opt[optType].emphasis = null;
            util.defaults(opt[optType], normalOpt);
          } else {
            opt[optType] = normalOpt;
          }
        }

        if (emphasisOpt) {
          opt.emphasis = opt.emphasis || {};
          opt.emphasis[optType] = emphasisOpt;
        }
      }
    }

    function removeEC3NormalStatus(opt) {
      convertNormalEmphasis(opt, 'itemStyle');
      convertNormalEmphasis(opt, 'lineStyle');
      convertNormalEmphasis(opt, 'areaStyle');
      convertNormalEmphasis(opt, 'label');
      convertNormalEmphasis(opt, 'labelLine'); // treemap

      convertNormalEmphasis(opt, 'upperLabel'); // graph

      convertNormalEmphasis(opt, 'edgeLabel');
    }

    function compatTextStyle(opt, propName) {
      // Check whether is not object (string\null\undefined ...)
      var labelOptSingle = isObject$7(opt) && opt[propName];
      var textStyle = isObject$7(labelOptSingle) && labelOptSingle.textStyle;

      if (textStyle) {
        for (var i = 0, len = model.TEXT_STYLE_OPTIONS.length; i < len; i++) {
          var propName = model.TEXT_STYLE_OPTIONS[i];

          if (textStyle.hasOwnProperty(propName)) {
            labelOptSingle[propName] = textStyle[propName];
          }
        }
      }
    }

    function compatEC3CommonStyles(opt) {
      if (opt) {
        removeEC3NormalStatus(opt);
        compatTextStyle(opt, 'label');
        opt.emphasis && compatTextStyle(opt.emphasis, 'label');
      }
    }

    function processSeries(seriesOpt) {
      if (!isObject$7(seriesOpt)) {
        return;
      }

      compatEC2ItemStyle(seriesOpt);
      removeEC3NormalStatus(seriesOpt);
      compatTextStyle(seriesOpt, 'label'); // treemap

      compatTextStyle(seriesOpt, 'upperLabel'); // graph

      compatTextStyle(seriesOpt, 'edgeLabel');

      if (seriesOpt.emphasis) {
        compatTextStyle(seriesOpt.emphasis, 'label'); // treemap

        compatTextStyle(seriesOpt.emphasis, 'upperLabel'); // graph

        compatTextStyle(seriesOpt.emphasis, 'edgeLabel');
      }

      var markPoint = seriesOpt.markPoint;

      if (markPoint) {
        compatEC2ItemStyle(markPoint);
        compatEC3CommonStyles(markPoint);
      }

      var markLine = seriesOpt.markLine;

      if (markLine) {
        compatEC2ItemStyle(markLine);
        compatEC3CommonStyles(markLine);
      }

      var markArea = seriesOpt.markArea;

      if (markArea) {
        compatEC3CommonStyles(markArea);
      }

      var data = seriesOpt.data; // Break with ec3: if `setOption` again, there may be no `type` in option,
      // then the backward compat based on option type will not be performed.

      if (seriesOpt.type === 'graph') {
        data = data || seriesOpt.nodes;
        var edgeData = seriesOpt.links || seriesOpt.edges;

        if (edgeData && !util.isTypedArray(edgeData)) {
          for (var i = 0; i < edgeData.length; i++) {
            compatEC3CommonStyles(edgeData[i]);
          }
        }

        util.each(seriesOpt.categories, function (opt) {
          removeEC3NormalStatus(opt);
        });
      }

      if (data && !util.isTypedArray(data)) {
        for (var i = 0; i < data.length; i++) {
          compatEC3CommonStyles(data[i]);
        }
      } // mark point data


      var markPoint = seriesOpt.markPoint;

      if (markPoint && markPoint.data) {
        var mpData = markPoint.data;

        for (var i = 0; i < mpData.length; i++) {
          compatEC3CommonStyles(mpData[i]);
        }
      } // mark line data


      var markLine = seriesOpt.markLine;

      if (markLine && markLine.data) {
        var mlData = markLine.data;

        for (var i = 0; i < mlData.length; i++) {
          if (util.isArray(mlData[i])) {
            compatEC3CommonStyles(mlData[i][0]);
            compatEC3CommonStyles(mlData[i][1]);
          } else {
            compatEC3CommonStyles(mlData[i]);
          }
        }
      } // Series


      if (seriesOpt.type === 'gauge') {
        compatTextStyle(seriesOpt, 'axisLabel');
        compatTextStyle(seriesOpt, 'title');
        compatTextStyle(seriesOpt, 'detail');
      } else if (seriesOpt.type === 'treemap') {
        convertNormalEmphasis(seriesOpt.breadcrumb, 'itemStyle');
        util.each(seriesOpt.levels, function (opt) {
          removeEC3NormalStatus(opt);
        });
      } else if (seriesOpt.type === 'tree') {
        removeEC3NormalStatus(seriesOpt.leaves);
      } // sunburst starts from ec4, so it does not need to compat levels.

    }

    function toArr(o) {
      return util.isArray(o) ? o : o ? [o] : [];
    }

    function toObj(o) {
      return (util.isArray(o) ? o[0] : o) || {};
    }

    function _default$11(option, isTheme) {
      each$7(toArr(option.series), function (seriesOpt) {
        isObject$7(seriesOpt) && processSeries(seriesOpt);
      });
      var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];
      isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');
      each$7(axes, function (axisName) {
        each$7(toArr(option[axisName]), function (axisOpt) {
          if (axisOpt) {
            compatTextStyle(axisOpt, 'axisLabel');
            compatTextStyle(axisOpt.axisPointer, 'label');
          }
        });
      });
      each$7(toArr(option.parallel), function (parallelOpt) {
        var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
        compatTextStyle(parallelAxisDefault, 'axisLabel');
        compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');
      });
      each$7(toArr(option.calendar), function (calendarOpt) {
        convertNormalEmphasis(calendarOpt, 'itemStyle');
        compatTextStyle(calendarOpt, 'dayLabel');
        compatTextStyle(calendarOpt, 'monthLabel');
        compatTextStyle(calendarOpt, 'yearLabel');
      }); // radar.name.textStyle

      each$7(toArr(option.radar), function (radarOpt) {
        compatTextStyle(radarOpt, 'name');
      });
      each$7(toArr(option.geo), function (geoOpt) {
        if (isObject$7(geoOpt)) {
          compatEC3CommonStyles(geoOpt);
          each$7(toArr(geoOpt.regions), function (regionObj) {
            compatEC3CommonStyles(regionObj);
          });
        }
      });
      each$7(toArr(option.timeline), function (timelineOpt) {
        compatEC3CommonStyles(timelineOpt);
        convertNormalEmphasis(timelineOpt, 'label');
        convertNormalEmphasis(timelineOpt, 'itemStyle');
        convertNormalEmphasis(timelineOpt, 'controlStyle', true);
        var data = timelineOpt.data;
        util.isArray(data) && util.each(data, function (item) {
          if (util.isObject(item)) {
            convertNormalEmphasis(item, 'label');
            convertNormalEmphasis(item, 'itemStyle');
          }
        });
      });
      each$7(toArr(option.toolbox), function (toolboxOpt) {
        convertNormalEmphasis(toolboxOpt, 'iconStyle');
        each$7(toolboxOpt.feature, function (featureOpt) {
          convertNormalEmphasis(featureOpt, 'iconStyle');
        });
      });
      compatTextStyle(toObj(option.axisPointer), 'label');
      compatTextStyle(toObj(option.tooltip).axisPointer, 'label');
    }

    var compatStyle = _default$11;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var each$8 = util.each;
    var isArray$5 = util.isArray;
    var isObject$8 = util.isObject;





    var normalizeToArray$2 = model.normalizeToArray;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // Compatitable with 2.0
    function get$1(opt, path) {
      path = path.split(',');
      var obj = opt;

      for (var i = 0; i < path.length; i++) {
        obj = obj && obj[path[i]];

        if (obj == null) {
          break;
        }
      }

      return obj;
    }

    function set$1(opt, path, val, overwrite) {
      path = path.split(',');
      var obj = opt;
      var key;

      for (var i = 0; i < path.length - 1; i++) {
        key = path[i];

        if (obj[key] == null) {
          obj[key] = {};
        }

        obj = obj[key];
      }

      if (overwrite || obj[path[i]] == null) {
        obj[path[i]] = val;
      }
    }

    function compatLayoutProperties(option) {
      each$8(LAYOUT_PROPERTIES, function (prop) {
        if (prop[0] in option && !(prop[1] in option)) {
          option[prop[1]] = option[prop[0]];
        }
      });
    }

    var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];
    var COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];

    function _default$12(option, isTheme) {
      compatStyle(option, isTheme); // Make sure series array for model initialization.

      option.series = normalizeToArray$2(option.series);
      each$8(option.series, function (seriesOpt) {
        if (!isObject$8(seriesOpt)) {
          return;
        }

        var seriesType = seriesOpt.type;

        if (seriesType === 'line') {
          if (seriesOpt.clipOverflow != null) {
            seriesOpt.clip = seriesOpt.clipOverflow;
          }
        } else if (seriesType === 'pie' || seriesType === 'gauge') {
          if (seriesOpt.clockWise != null) {
            seriesOpt.clockwise = seriesOpt.clockWise;
          }
        } else if (seriesType === 'gauge') {
          var pointerColor = get$1(seriesOpt, 'pointer.color');
          pointerColor != null && set$1(seriesOpt, 'itemStyle.color', pointerColor);
        }

        compatLayoutProperties(seriesOpt);
      }); // dataRange has changed to visualMap

      if (option.dataRange) {
        option.visualMap = option.dataRange;
      }

      each$8(COMPATITABLE_COMPONENTS, function (componentName) {
        var options = option[componentName];

        if (options) {
          if (!isArray$5(options)) {
            options = [options];
          }

          each$8(options, function (option) {
            compatLayoutProperties(option);
          });
        }
      });
    }

    var backwardCompat = _default$12;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var createHashMap$4 = util.createHashMap;
    var each$9 = util.each;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // (1) [Caution]: the logic is correct based on the premises:
    //     data processing stage is blocked in stream.
    //     See <module:echarts/stream/Scheduler#performDataProcessorTasks>
    // (2) Only register once when import repeatly.
    //     Should be executed after series filtered and before stack calculation.
    function _default$13(ecModel) {
      var stackInfoMap = createHashMap$4();
      ecModel.eachSeries(function (seriesModel) {
        var stack = seriesModel.get('stack'); // Compatibal: when `stack` is set as '', do not stack.

        if (stack) {
          var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
          var data = seriesModel.getData();
          var stackInfo = {
            // Used for calculate axis extent automatically.
            stackResultDimension: data.getCalculationInfo('stackResultDimension'),
            stackedOverDimension: data.getCalculationInfo('stackedOverDimension'),
            stackedDimension: data.getCalculationInfo('stackedDimension'),
            stackedByDimension: data.getCalculationInfo('stackedByDimension'),
            isStackedByIndex: data.getCalculationInfo('isStackedByIndex'),
            data: data,
            seriesModel: seriesModel
          }; // If stacked on axis that do not support data stack.

          if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
            return;
          }

          stackInfoList.length && data.setCalculationInfo('stackedOnSeries', stackInfoList[stackInfoList.length - 1].seriesModel);
          stackInfoList.push(stackInfo);
        }
      });
      stackInfoMap.each(calculateStack);
    }

    function calculateStack(stackInfoList) {
      each$9(stackInfoList, function (targetStackInfo, idxInStack) {
        var resultVal = [];
        var resultNaN = [NaN, NaN];
        var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
        var targetData = targetStackInfo.data;
        var isStackedByIndex = targetStackInfo.isStackedByIndex; // Should not write on raw data, because stack series model list changes
        // depending on legend selection.

        var newData = targetData.map(dims, function (v0, v1, dataIndex) {
          var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex); // Consider `connectNulls` of line area, if value is NaN, stackedOver
          // should also be NaN, to draw a appropriate belt area.

          if (isNaN(sum)) {
            return resultNaN;
          }

          var byValue;
          var stackedDataRawIndex;

          if (isStackedByIndex) {
            stackedDataRawIndex = targetData.getRawIndex(dataIndex);
          } else {
            byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
          } // If stackOver is NaN, chart view will render point on value start.


          var stackedOver = NaN;

          for (var j = idxInStack - 1; j >= 0; j--) {
            var stackInfo = stackInfoList[j]; // Has been optimized by inverted indices on `stackedByDimension`.

            if (!isStackedByIndex) {
              stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
            }

            if (stackedDataRawIndex >= 0) {
              var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex); // Considering positive stack, negative stack and empty data

              if (sum >= 0 && val > 0 || // Positive stack
              sum <= 0 && val < 0 // Negative stack
              ) {
                  sum += val;
                  stackedOver = val;
                  break;
                }
            }
          }

          resultVal[0] = sum;
          resultVal[1] = stackedOver;
          return resultVal;
        });
        targetData.hostModel.setData(newData); // Update for consequent calculation

        targetStackInfo.data = newData;
      });
    }

    var dataStack = _default$13;

    var extend$5 = util.extend;
    var each$a = util.each;
    var isObject$9 = util.isObject;



    var getDataItemValue$2 = model.getDataItemValue;
    var isDataItemOption$1 = model.isDataItemOption;



    var parseDate$1 = number.parseDate;





    var SOURCE_FORMAT_TYPED_ARRAY$3 = sourceType.SOURCE_FORMAT_TYPED_ARRAY;
    var SOURCE_FORMAT_ARRAY_ROWS$2 = sourceType.SOURCE_FORMAT_ARRAY_ROWS;
    var SOURCE_FORMAT_ORIGINAL$3 = sourceType.SOURCE_FORMAT_ORIGINAL;
    var SOURCE_FORMAT_OBJECT_ROWS$2 = sourceType.SOURCE_FORMAT_OBJECT_ROWS;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // TODO
    // ??? refactor? check the outer usage of data provider.
    // merge with defaultDimValueGetter?

    /**
     * If normal array used, mutable chunk size is supported.
     * If typed array used, chunk size must be fixed.
     */
    function DefaultDataProvider(source, dimSize) {
      if (!Source_1.isInstance(source)) {
        source = Source_1.seriesDataToSource(source);
      }

      this._source = source;
      var data = this._data = source.data;
      var sourceFormat = source.sourceFormat; // Typed array. TODO IE10+?

      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY$3) {
        this._offset = 0;
        this._dimSize = dimSize;
        this._data = data;
      }

      var methods = providerMethods[sourceFormat === SOURCE_FORMAT_ARRAY_ROWS$2 ? sourceFormat + '_' + source.seriesLayoutBy : sourceFormat];
      extend$5(this, methods);
    }

    var providerProto = DefaultDataProvider.prototype; // If data is pure without style configuration

    providerProto.pure = false; // If data is persistent and will not be released after use.

    providerProto.persistent = true; // ???! FIXME legacy data provider do not has method getSource

    providerProto.getSource = function () {
      return this._source;
    };

    var providerMethods = {
      'arrayRows_column': {
        pure: true,
        count: function () {
          return Math.max(0, this._data.length - this._source.startIndex);
        },
        getItem: function (idx) {
          return this._data[idx + this._source.startIndex];
        },
        appendData: appendDataSimply
      },
      'arrayRows_row': {
        pure: true,
        count: function () {
          var row = this._data[0];
          return row ? Math.max(0, row.length - this._source.startIndex) : 0;
        },
        getItem: function (idx) {
          idx += this._source.startIndex;
          var item = [];
          var data = this._data;

          for (var i = 0; i < data.length; i++) {
            var row = data[i];
            item.push(row ? row[idx] : null);
          }

          return item;
        },
        appendData: function () {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      },
      'objectRows': {
        pure: true,
        count: countSimply,
        getItem: getItemSimply,
        appendData: appendDataSimply
      },
      'keyedColumns': {
        pure: true,
        count: function () {
          var dimName = this._source.dimensionsDefine[0].name;
          var col = this._data[dimName];
          return col ? col.length : 0;
        },
        getItem: function (idx) {
          var item = [];
          var dims = this._source.dimensionsDefine;

          for (var i = 0; i < dims.length; i++) {
            var col = this._data[dims[i].name];
            item.push(col ? col[idx] : null);
          }

          return item;
        },
        appendData: function (newData) {
          var data = this._data;
          each$a(newData, function (newCol, key) {
            var oldCol = data[key] || (data[key] = []);

            for (var i = 0; i < (newCol || []).length; i++) {
              oldCol.push(newCol[i]);
            }
          });
        }
      },
      'original': {
        count: countSimply,
        getItem: getItemSimply,
        appendData: appendDataSimply
      },
      'typedArray': {
        persistent: false,
        pure: true,
        count: function () {
          return this._data ? this._data.length / this._dimSize : 0;
        },
        getItem: function (idx, out) {
          idx = idx - this._offset;
          out = out || [];
          var offset = this._dimSize * idx;

          for (var i = 0; i < this._dimSize; i++) {
            out[i] = this._data[offset + i];
          }

          return out;
        },
        appendData: function (newData) {
          this._data = newData;
        },
        // Clean self if data is already used.
        clean: function () {
          // PENDING
          this._offset += this.count();
          this._data = null;
        }
      }
    };

    function countSimply() {
      return this._data.length;
    }

    function getItemSimply(idx) {
      return this._data[idx];
    }

    function appendDataSimply(newData) {
      for (var i = 0; i < newData.length; i++) {
        this._data.push(newData[i]);
      }
    }

    var rawValueGetters = {
      arrayRows: getRawValueSimply,
      objectRows: function (dataItem, dataIndex, dimIndex, dimName) {
        return dimIndex != null ? dataItem[dimName] : dataItem;
      },
      keyedColumns: getRawValueSimply,
      original: function (dataItem, dataIndex, dimIndex, dimName) {
        // FIXME
        // In some case (markpoint in geo (geo-map.html)), dataItem
        // is {coord: [...]}
        var value = getDataItemValue$2(dataItem);
        return dimIndex == null || !(value instanceof Array) ? value : value[dimIndex];
      },
      typedArray: getRawValueSimply
    };

    function getRawValueSimply(dataItem, dataIndex, dimIndex, dimName) {
      return dimIndex != null ? dataItem[dimIndex] : dataItem;
    }

    var defaultDimValueGetters = {
      arrayRows: getDimValueSimply,
      objectRows: function (dataItem, dimName, dataIndex, dimIndex) {
        return converDataValue(dataItem[dimName], this._dimensionInfos[dimName]);
      },
      keyedColumns: getDimValueSimply,
      original: function (dataItem, dimName, dataIndex, dimIndex) {
        // Performance sensitive, do not use modelUtil.getDataItemValue.
        // If dataItem is an plain object with no value field, the var `value`
        // will be assigned with the object, but it will be tread correctly
        // in the `convertDataValue`.
        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value); // If any dataItem is like { value: 10 }

        if (!this._rawData.pure && isDataItemOption$1(dataItem)) {
          this.hasItemOption = true;
        }

        return converDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.
        : value, this._dimensionInfos[dimName]);
      },
      typedArray: function (dataItem, dimName, dataIndex, dimIndex) {
        return dataItem[dimIndex];
      }
    };

    function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {
      return converDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);
    }
    /**
     * This helper method convert value in data.
     * @param {string|number|Date} value
     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.
     *        If "dimInfo.ordinalParseAndSave", ordinal value can be parsed.
     */


    function converDataValue(value, dimInfo) {
      // Performance sensitive.
      var dimType = dimInfo && dimInfo.type;

      if (dimType === 'ordinal') {
        // If given value is a category string
        var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
        return ordinalMeta ? ordinalMeta.parseAndCollect(value) : value;
      }

      if (dimType === 'time' // spead up when using timestamp
      && typeof value !== 'number' && value != null && value !== '-') {
        value = +parseDate$1(value);
      } // dimType defaults 'number'.
      // If dimType is not ordinal and value is null or undefined or NaN or '-',
      // parse to NaN.


      return value == null || value === '' ? NaN // If string (like '-'), using '+' parse to NaN
      // If object, also parse to NaN
      : +value;
    } // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,
    // Consider persistent.
    // Caution: why use raw value to display on label or tooltip?
    // A reason is to avoid format. For example time value we do not know
    // how to format is expected. More over, if stack is used, calculated
    // value may be 0.91000000001, which have brings trouble to display.
    // TODO: consider how to treat null/undefined/NaN when display?

    /**
     * @param {module:echarts/data/List} data
     * @param {number} dataIndex
     * @param {string|number} [dim] dimName or dimIndex
     * @return {Array.<number>|string|number} can be null/undefined.
     */


    function retrieveRawValue(data, dataIndex, dim) {
      if (!data) {
        return;
      } // Consider data may be not persistent.


      var dataItem = data.getRawDataItem(dataIndex);

      if (dataItem == null) {
        return;
      }

      var sourceFormat = data.getProvider().getSource().sourceFormat;
      var dimName;
      var dimIndex;
      var dimInfo = data.getDimensionInfo(dim);

      if (dimInfo) {
        dimName = dimInfo.name;
        dimIndex = dimInfo.index;
      }

      return rawValueGetters[sourceFormat](dataItem, dataIndex, dimIndex, dimName);
    }
    /**
     * Compatible with some cases (in pie, map) like:
     * data: [{name: 'xx', value: 5, selected: true}, ...]
     * where only sourceFormat is 'original' and 'objectRows' supported.
     *
     * ??? TODO
     * Supported detail options in data item when using 'arrayRows'.
     *
     * @param {module:echarts/data/List} data
     * @param {number} dataIndex
     * @param {string} attr like 'selected'
     */


    function retrieveRawAttr(data, dataIndex, attr) {
      if (!data) {
        return;
      }

      var sourceFormat = data.getProvider().getSource().sourceFormat;

      if (sourceFormat !== SOURCE_FORMAT_ORIGINAL$3 && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS$2) {
        return;
      }

      var dataItem = data.getRawDataItem(dataIndex);

      if (sourceFormat === SOURCE_FORMAT_ORIGINAL$3 && !isObject$9(dataItem)) {
        dataItem = null;
      }

      if (dataItem) {
        return dataItem[attr];
      }
    }

    var DefaultDataProvider_1 = DefaultDataProvider;
    var defaultDimValueGetters_1 = defaultDimValueGetters;
    var retrieveRawValue_1 = retrieveRawValue;
    var retrieveRawAttr_1 = retrieveRawAttr;

    var dataProvider = {
    	DefaultDataProvider: DefaultDataProvider_1,
    	defaultDimValueGetters: defaultDimValueGetters_1,
    	retrieveRawValue: retrieveRawValue_1,
    	retrieveRawAttr: retrieveRawAttr_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var retrieveRawValue$1 = dataProvider.retrieveRawValue;



    var getTooltipMarker$1 = format$1.getTooltipMarker;
    var formatTpl$1 = format$1.formatTpl;



    var getTooltipRenderMode$1 = model.getTooltipRenderMode;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var DIMENSION_LABEL_REG = /\{@(.+?)\}/g; // PENDING A little ugly

    var _default$14 = {
      /**
       * Get params for formatter
       * @param {number} dataIndex
       * @param {string} [dataType]
       * @return {Object}
       */
      getDataParams: function (dataIndex, dataType) {
        var data = this.getData(dataType);
        var rawValue = this.getRawValue(dataIndex, dataType);
        var rawDataIndex = data.getRawIndex(dataIndex);
        var name = data.getName(dataIndex);
        var itemOpt = data.getRawDataItem(dataIndex);
        var color = data.getItemVisual(dataIndex, 'color');
        var borderColor = data.getItemVisual(dataIndex, 'borderColor');
        var tooltipModel = this.ecModel.getComponent('tooltip');
        var renderModeOption = tooltipModel && tooltipModel.get('renderMode');
        var renderMode = getTooltipRenderMode$1(renderModeOption);
        var mainType = this.mainType;
        var isSeries = mainType === 'series';
        var userOutput = data.userOutput;
        return {
          componentType: mainType,
          componentSubType: this.subType,
          componentIndex: this.componentIndex,
          seriesType: isSeries ? this.subType : null,
          seriesIndex: this.seriesIndex,
          seriesId: isSeries ? this.id : null,
          seriesName: isSeries ? this.name : null,
          name: name,
          dataIndex: rawDataIndex,
          data: itemOpt,
          dataType: dataType,
          value: rawValue,
          color: color,
          borderColor: borderColor,
          dimensionNames: userOutput ? userOutput.dimensionNames : null,
          encode: userOutput ? userOutput.encode : null,
          marker: getTooltipMarker$1({
            color: color,
            renderMode: renderMode
          }),
          // Param name list for mapping `a`, `b`, `c`, `d`, `e`
          $vars: ['seriesName', 'name', 'value']
        };
      },

      /**
       * Format label
       * @param {number} dataIndex
       * @param {string} [status='normal'] 'normal' or 'emphasis'
       * @param {string} [dataType]
       * @param {number} [dimIndex] Only used in some chart that
       *        use formatter in different dimensions, like radar.
       * @param {string} [labelProp='label']
       * @return {string} If not formatter, return null/undefined
       */
      getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {
        status = status || 'normal';
        var data = this.getData(dataType);
        var itemModel = data.getItemModel(dataIndex);
        var params = this.getDataParams(dataIndex, dataType);

        if (dimIndex != null && params.value instanceof Array) {
          params.value = params.value[dimIndex];
        }

        var formatter = itemModel.get(status === 'normal' ? [labelProp || 'label', 'formatter'] : [status, labelProp || 'label', 'formatter']);

        if (typeof formatter === 'function') {
          params.status = status;
          params.dimensionIndex = dimIndex;
          return formatter(params);
        } else if (typeof formatter === 'string') {
          var str = formatTpl$1(formatter, params); // Support 'aaa{@[3]}bbb{@product}ccc'.
          // Do not support '}' in dim name util have to.

          return str.replace(DIMENSION_LABEL_REG, function (origin, dim) {
            var len = dim.length;

            if (dim.charAt(0) === '[' && dim.charAt(len - 1) === ']') {
              dim = +dim.slice(1, len - 1); // Also: '[]' => 0
            }

            return retrieveRawValue$1(data, dataIndex, dim);
          });
        }
      },

      /**
       * Get raw value in option
       * @param {number} idx
       * @param {string} [dataType]
       * @return {Array|number|string}
       */
      getRawValue: function (idx, dataType) {
        return retrieveRawValue$1(this.getData(dataType), idx);
      },

      /**
       * Should be implemented.
       * @param {number} dataIndex
       * @param {boolean} [multipleSeries=false]
       * @param {number} [dataType]
       * @return {string} tooltip string
       */
      formatTooltip: function () {// Empty function
      }
    };
    var dataFormat = _default$14;

    var isArray$6 = util.isArray;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @param {Object} define
     * @return See the return of `createTask`.
     */
    function createTask(define) {
      return new Task(define);
    }
    /**
     * @constructor
     * @param {Object} define
     * @param {Function} define.reset Custom reset
     * @param {Function} [define.plan] Returns 'reset' indicate reset immediately.
     * @param {Function} [define.count] count is used to determin data task.
     * @param {Function} [define.onDirty] count is used to determin data task.
     */


    function Task(define) {
      define = define || {};
      this._reset = define.reset;
      this._plan = define.plan;
      this._count = define.count;
      this._onDirty = define.onDirty;
      this._dirty = true; // Context must be specified implicitly, to
      // avoid miss update context when model changed.

      this.context;
    }

    var taskProto = Task.prototype;
    /**
     * @param {Object} performArgs
     * @param {number} [performArgs.step] Specified step.
     * @param {number} [performArgs.skip] Skip customer perform call.
     * @param {number} [performArgs.modBy] Sampling window size.
     * @param {number} [performArgs.modDataCount] Sampling count.
     */

    taskProto.perform = function (performArgs) {
      var upTask = this._upstream;
      var skip = performArgs && performArgs.skip; // TODO some refactor.
      // Pull data. Must pull data each time, because context.data
      // may be updated by Series.setData.

      if (this._dirty && upTask) {
        var context = this.context;
        context.data = context.outputData = upTask.context.outputData;
      }

      if (this.__pipeline) {
        this.__pipeline.currentTask = this;
      }

      var planResult;

      if (this._plan && !skip) {
        planResult = this._plan(this.context);
      } // Support sharding by mod, which changes the render sequence and makes the rendered graphic
      // elements uniformed distributed when progress, especially when moving or zooming.


      var lastModBy = normalizeModBy(this._modBy);
      var lastModDataCount = this._modDataCount || 0;
      var modBy = normalizeModBy(performArgs && performArgs.modBy);
      var modDataCount = performArgs && performArgs.modDataCount || 0;

      if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
        planResult = 'reset';
      }

      function normalizeModBy(val) {
        !(val >= 1) && (val = 1); // jshint ignore:line

        return val;
      }

      var forceFirstProgress;

      if (this._dirty || planResult === 'reset') {
        this._dirty = false;
        forceFirstProgress = reset(this, skip);
      }

      this._modBy = modBy;
      this._modDataCount = modDataCount;
      var step = performArgs && performArgs.step;

      if (upTask) {
        this._dueEnd = upTask._outputDueEnd;
      } // DataTask or overallTask
      else {
          this._dueEnd = this._count ? this._count(this.context) : Infinity;
        } // Note: Stubs, that its host overall task let it has progress, has progress.
      // If no progress, pass index from upstream to downstream each time plan called.


      if (this._progress) {
        var start = this._dueIndex;
        var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);

        if (!skip && (forceFirstProgress || start < end)) {
          var progress = this._progress;

          if (isArray$6(progress)) {
            for (var i = 0; i < progress.length; i++) {
              doProgress(this, progress[i], start, end, modBy, modDataCount);
            }
          } else {
            doProgress(this, progress, start, end, modBy, modDataCount);
          }
        }

        this._dueIndex = end; // If no `outputDueEnd`, assume that output data and
        // input data is the same, so use `dueIndex` as `outputDueEnd`.

        var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;
        this._outputDueEnd = outputDueEnd;
      } else {
        // (1) Some overall task has no progress.
        // (2) Stubs, that its host overall task do not let it has progress, has no progress.
        // This should always be performed so it can be passed to downstream.
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      }

      return this.unfinished();
    };

    var iterator = function () {
      var end;
      var current;
      var modBy;
      var modDataCount;
      var winCount;
      var it = {
        reset: function (s, e, sStep, sCount) {
          current = s;
          end = e;
          modBy = sStep;
          modDataCount = sCount;
          winCount = Math.ceil(modDataCount / modBy);
          it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
        }
      };
      return it;

      function sequentialNext() {
        return current < end ? current++ : null;
      }

      function modNext() {
        var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
        var result = current >= end ? null : dataIndex < modDataCount ? dataIndex // If modDataCount is smaller than data.count() (consider `appendData` case),
        // Use normal linear rendering mode.
        : current;
        current++;
        return result;
      }
    }();

    taskProto.dirty = function () {
      this._dirty = true;
      this._onDirty && this._onDirty(this.context);
    };

    function doProgress(taskIns, progress, start, end, modBy, modDataCount) {
      iterator.reset(start, end, modBy, modDataCount);
      taskIns._callingProgress = progress;

      taskIns._callingProgress({
        start: start,
        end: end,
        count: end - start,
        next: iterator.next
      }, taskIns.context);
    }

    function reset(taskIns, skip) {
      taskIns._dueIndex = taskIns._outputDueEnd = taskIns._dueEnd = 0;
      taskIns._settedOutputEnd = null;
      var progress;
      var forceFirstProgress;

      if (!skip && taskIns._reset) {
        progress = taskIns._reset(taskIns.context);

        if (progress && progress.progress) {
          forceFirstProgress = progress.forceFirstProgress;
          progress = progress.progress;
        } // To simplify no progress checking, array must has item.


        if (isArray$6(progress) && !progress.length) {
          progress = null;
        }
      }

      taskIns._progress = progress;
      taskIns._modBy = taskIns._modDataCount = null;
      var downstream = taskIns._downstream;
      downstream && downstream.dirty();
      return forceFirstProgress;
    }
    /**
     * @return {boolean}
     */


    taskProto.unfinished = function () {
      return this._progress && this._dueIndex < this._dueEnd;
    };
    /**
     * @param {Object} downTask The downstream task.
     * @return {Object} The downstream task.
     */


    taskProto.pipe = function (downTask) {
      // If already downstream, do not dirty downTask.
      if (this._downstream !== downTask || this._dirty) {
        this._downstream = downTask;
        downTask._upstream = this;
        downTask.dirty();
      }
    };

    taskProto.dispose = function () {
      if (this._disposed) {
        return;
      }

      this._upstream && (this._upstream._downstream = null);
      this._downstream && (this._downstream._upstream = null);
      this._dirty = false;
      this._disposed = true;
    };

    taskProto.getUpstream = function () {
      return this._upstream;
    };

    taskProto.getDownstream = function () {
      return this._downstream;
    };

    taskProto.setOutputEnd = function (end) {
      // This only happend in dataTask, dataZoom, map, currently.
      // where dataZoom do not set end each time, but only set
      // when reset. So we should record the setted end, in case
      // that the stub of dataZoom perform again and earse the
      // setted end by upstream.
      this._outputDueEnd = this._settedOutputEnd = end;
    }; ///////////////////////////////////////////////////////////
    // For stream debug (Should be commented out after used!)
    // Usage: printTask(this, 'begin');
    // Usage: printTask(this, null, {someExtraProp});
    // function printTask(task, prefix, extra) {
    //     window.ecTaskUID == null && (window.ecTaskUID = 0);
    //     task.uidDebug == null && (task.uidDebug = `task_${window.ecTaskUID++}`);
    //     task.agent && task.agent.uidDebug == null && (task.agent.uidDebug = `task_${window.ecTaskUID++}`);
    //     var props = [];
    //     if (task.__pipeline) {
    //         var val = `${task.__idxInPipeline}/${task.__pipeline.tail.__idxInPipeline} ${task.agent ? '(stub)' : ''}`;
    //         props.push({text: 'idx', value: val});
    //     } else {
    //         var stubCount = 0;
    //         task.agentStubMap.each(() => stubCount++);
    //         props.push({text: 'idx', value: `overall (stubs: ${stubCount})`});
    //     }
    //     props.push({text: 'uid', value: task.uidDebug});
    //     if (task.__pipeline) {
    //         props.push({text: 'pid', value: task.__pipeline.id});
    //         task.agent && props.push(
    //             {text: 'stubFor', value: task.agent.uidDebug}
    //         );
    //     }
    //     props.push(
    //         {text: 'dirty', value: task._dirty},
    //         {text: 'dueIndex', value: task._dueIndex},
    //         {text: 'dueEnd', value: task._dueEnd},
    //         {text: 'outputDueEnd', value: task._outputDueEnd}
    //     );
    //     if (extra) {
    //         Object.keys(extra).forEach(key => {
    //             props.push({text: key, value: extra[key]});
    //         });
    //     }
    //     var args = ['color: blue'];
    //     var msg = `%c[${prefix || 'T'}] %c` + props.map(item => (
    //         args.push('color: black', 'color: red'),
    //         `${item.text}: %c${item.value}`
    //     )).join('%c, ');
    //     console.log.apply(console, [msg].concat(args));
    //     // console.log(this);
    // }


    var createTask_1 = createTask;

    var task = {
    	createTask: createTask_1
    };

    var formatTime$1 = format$1.formatTime;
    var encodeHTML$1 = format$1.encodeHTML;
    var addCommas$1 = format$1.addCommas;
    var getTooltipMarker$2 = format$1.getTooltipMarker;











    var getLayoutParams$1 = layout.getLayoutParams;
    var mergeLayoutParam$1 = layout.mergeLayoutParam;



    var createTask$1 = task.createTask;



    var prepareSource$1 = sourceHelper.prepareSource;
    var getSource$1 = sourceHelper.getSource;



    var retrieveRawValue$2 = dataProvider.retrieveRawValue;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var inner$4 = model.makeInner();
    var SeriesModel = Component.extend({
      type: 'series.__base__',

      /**
       * @readOnly
       */
      seriesIndex: 0,
      // coodinateSystem will be injected in the echarts/CoordinateSystem
      coordinateSystem: null,

      /**
       * @type {Object}
       * @protected
       */
      defaultOption: null,

      /**
       * legend visual provider to the legend component
       * @type {Object}
       */
      // PENDING
      legendVisualProvider: null,

      /**
       * Access path of color for visual
       */
      visualColorAccessPath: 'itemStyle.color',

      /**
       * Access path of borderColor for visual
       */
      visualBorderColorAccessPath: 'itemStyle.borderColor',

      /**
       * Support merge layout params.
       * Only support 'box' now (left/right/top/bottom/width/height).
       * @type {string|Object} Object can be {ignoreSize: true}
       * @readOnly
       */
      layoutMode: null,
      init: function (option, parentModel, ecModel, extraOpt) {
        /**
         * @type {number}
         * @readOnly
         */
        this.seriesIndex = this.componentIndex;
        this.dataTask = createTask$1({
          count: dataTaskCount,
          reset: dataTaskReset
        });
        this.dataTask.context = {
          model: this
        };
        this.mergeDefaultAndTheme(option, ecModel);
        prepareSource$1(this);
        var data = this.getInitialData(option, ecModel);
        wrapData(data, this);
        this.dataTask.context.data = data;

        /**
         * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}
         * @private
         */
        inner$4(this).dataBeforeProcessed = data; // If we reverse the order (make data firstly, and then make
        // dataBeforeProcessed by cloneShallow), cloneShallow will
        // cause data.graph.data !== data when using
        // module:echarts/data/Graph or module:echarts/data/Tree.
        // See module:echarts/data/helper/linkList
        // Theoretically, it is unreasonable to call `seriesModel.getData()` in the model
        // init or merge stage, because the data can be restored. So we do not `restoreData`
        // and `setData` here, which forbids calling `seriesModel.getData()` in this stage.
        // Call `seriesModel.getRawData()` instead.
        // this.restoreData();

        autoSeriesName(this);
      },

      /**
       * Util for merge default and theme to option
       * @param  {Object} option
       * @param  {module:echarts/model/Global} ecModel
       */
      mergeDefaultAndTheme: function (option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? getLayoutParams$1(option) : {}; // Backward compat: using subType on theme.
        // But if name duplicate between series subType
        // (for example: parallel) add component mainType,
        // add suffix 'Series'.

        var themeSubType = this.subType;

        if (Component.hasClass(themeSubType)) {
          themeSubType += 'Series';
        }

        util.merge(option, ecModel.getTheme().get(this.subType));
        util.merge(option, this.getDefaultOption()); // Default label emphasis `show`

        model.defaultEmphasis(option, 'label', ['show']);
        this.fillDataTextStyle(option.data);

        if (layoutMode) {
          mergeLayoutParam$1(option, inputPositionParams, layoutMode);
        }
      },
      mergeOption: function (newSeriesOption, ecModel) {
        // this.settingTask.dirty();
        newSeriesOption = util.merge(this.option, newSeriesOption, true);
        this.fillDataTextStyle(newSeriesOption.data);
        var layoutMode = this.layoutMode;

        if (layoutMode) {
          mergeLayoutParam$1(this.option, newSeriesOption, layoutMode);
        }

        prepareSource$1(this);
        var data = this.getInitialData(newSeriesOption, ecModel);
        wrapData(data, this);
        this.dataTask.dirty();
        this.dataTask.context.data = data;
        inner$4(this).dataBeforeProcessed = data;
        autoSeriesName(this);
      },
      fillDataTextStyle: function (data) {
        // Default data label emphasis `show`
        // FIXME Tree structure data ?
        // FIXME Performance ?
        if (data && !util.isTypedArray(data)) {
          var props = ['show'];

          for (var i = 0; i < data.length; i++) {
            if (data[i] && data[i].label) {
              model.defaultEmphasis(data[i], 'label', props);
            }
          }
        }
      },

      /**
       * Init a data structure from data related option in series
       * Must be overwritten
       */
      getInitialData: function () {},

      /**
       * Append data to list
       * @param {Object} params
       * @param {Array|TypedArray} params.data
       */
      appendData: function (params) {
        // FIXME ???
        // (1) If data from dataset, forbidden append.
        // (2) support append data of dataset.
        var data = this.getRawData();
        data.appendData(params.data);
      },

      /**
       * Consider some method like `filter`, `map` need make new data,
       * We should make sure that `seriesModel.getData()` get correct
       * data in the stream procedure. So we fetch data from upstream
       * each time `task.perform` called.
       * @param {string} [dataType]
       * @return {module:echarts/data/List}
       */
      getData: function (dataType) {
        var task = getCurrentTask(this);

        if (task) {
          var data = task.context.data;
          return dataType == null ? data : data.getLinkedData(dataType);
        } else {
          // When series is not alive (that may happen when click toolbox
          // restore or setOption with not merge mode), series data may
          // be still need to judge animation or something when graphic
          // elements want to know whether fade out.
          return inner$4(this).data;
        }
      },

      /**
       * @param {module:echarts/data/List} data
       */
      setData: function (data) {
        var task = getCurrentTask(this);

        if (task) {
          var context = task.context; // Consider case: filter, data sample.

          if (context.data !== data && task.modifyOutputEnd) {
            task.setOutputEnd(data.count());
          }

          context.outputData = data; // Caution: setData should update context.data,
          // Because getData may be called multiply in a
          // single stage and expect to get the data just
          // set. (For example, AxisProxy, x y both call
          // getData and setDate sequentially).
          // So the context.data should be fetched from
          // upstream each time when a stage starts to be
          // performed.

          if (task !== this.dataTask) {
            context.data = data;
          }
        }

        inner$4(this).data = data;
      },

      /**
       * @see {module:echarts/data/helper/sourceHelper#getSource}
       * @return {module:echarts/data/Source} source
       */
      getSource: function () {
        return getSource$1(this);
      },

      /**
       * Get data before processed
       * @return {module:echarts/data/List}
       */
      getRawData: function () {
        return inner$4(this).dataBeforeProcessed;
      },

      /**
       * Get base axis if has coordinate system and has axis.
       * By default use coordSys.getBaseAxis();
       * Can be overrided for some chart.
       * @return {type} description
       */
      getBaseAxis: function () {
        var coordSys = this.coordinateSystem;
        return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
      },
      // FIXME

      /**
       * Default tooltip formatter
       *
       * @param {number} dataIndex
       * @param {boolean} [multipleSeries=false]
       * @param {number} [dataType]
       * @param {string} [renderMode='html'] valid values: 'html' and 'richText'.
       *                                     'html' is used for rendering tooltip in extra DOM form, and the result
       *                                     string is used as DOM HTML content.
       *                                     'richText' is used for rendering tooltip in rich text form, for those where
       *                                     DOM operation is not supported.
       * @return {Object} formatted tooltip with `html` and `markers`
       */
      formatTooltip: function (dataIndex, multipleSeries, dataType, renderMode) {
        var series = this;
        renderMode = renderMode || 'html';
        var newLine = renderMode === 'html' ? '<br/>' : '\n';
        var isRichText = renderMode === 'richText';
        var markers = {};
        var markerId = 0;

        function formatArrayValue(value) {
          // ??? TODO refactor these logic.
          // check: category-no-encode-has-axis-data in dataset.html
          var vertially = util.reduce(value, function (vertially, val, idx) {
            var dimItem = data.getDimensionInfo(idx);
            return vertially |= dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
          }, 0);
          var result = [];
          tooltipDims.length ? util.each(tooltipDims, function (dim) {
            setEachItem(retrieveRawValue$2(data, dataIndex, dim), dim);
          }) // By default, all dims is used on tooltip.
          : util.each(value, setEachItem);

          function setEachItem(val, dim) {
            var dimInfo = data.getDimensionInfo(dim); // If `dimInfo.tooltip` is not set, show tooltip.

            if (!dimInfo || dimInfo.otherDims.tooltip === false) {
              return;
            }

            var dimType = dimInfo.type;
            var markName = 'sub' + series.seriesIndex + 'at' + markerId;
            var dimHead = getTooltipMarker$2({
              color: color,
              type: 'subItem',
              renderMode: renderMode,
              markerId: markName
            });
            var dimHeadStr = typeof dimHead === 'string' ? dimHead : dimHead.content;
            var valStr = (vertially ? dimHeadStr + encodeHTML$1(dimInfo.displayName || '-') + ': ' : '') + // FIXME should not format time for raw data?
            encodeHTML$1(dimType === 'ordinal' ? val + '' : dimType === 'time' ? multipleSeries ? '' : formatTime$1('yyyy/MM/dd hh:mm:ss', val) : addCommas$1(val));
            valStr && result.push(valStr);

            if (isRichText) {
              markers[markName] = color;
              ++markerId;
            }
          }

          var newLine = vertially ? isRichText ? '\n' : '<br/>' : '';
          var content = newLine + result.join(newLine || ', ');
          return {
            renderMode: renderMode,
            content: content,
            style: markers
          };
        }

        function formatSingleValue(val) {
          // return encodeHTML(addCommas(val));
          return {
            renderMode: renderMode,
            content: encodeHTML$1(addCommas$1(val)),
            style: markers
          };
        }

        var data = this.getData();
        var tooltipDims = data.mapDimension('defaultedTooltip', true);
        var tooltipDimLen = tooltipDims.length;
        var value = this.getRawValue(dataIndex);
        var isValueArr = util.isArray(value);
        var color = data.getItemVisual(dataIndex, 'color');

        if (util.isObject(color) && color.colorStops) {
          color = (color.colorStops[0] || {}).color;
        }

        color = color || 'transparent'; // Complicated rule for pretty tooltip.

        var formattedValue = tooltipDimLen > 1 || isValueArr && !tooltipDimLen ? formatArrayValue(value) : tooltipDimLen ? formatSingleValue(retrieveRawValue$2(data, dataIndex, tooltipDims[0])) : formatSingleValue(isValueArr ? value[0] : value);
        var content = formattedValue.content;
        var markName = series.seriesIndex + 'at' + markerId;
        var colorEl = getTooltipMarker$2({
          color: color,
          type: 'item',
          renderMode: renderMode,
          markerId: markName
        });
        markers[markName] = color;
        ++markerId;
        var name = data.getName(dataIndex);
        var seriesName = this.name;

        if (!model.isNameSpecified(this)) {
          seriesName = '';
        }

        seriesName = seriesName ? encodeHTML$1(seriesName) + (!multipleSeries ? newLine : ': ') : '';
        var colorStr = typeof colorEl === 'string' ? colorEl : colorEl.content;
        var html = !multipleSeries ? seriesName + colorStr + (name ? encodeHTML$1(name) + ': ' + content : content) : colorStr + seriesName + content;
        return {
          html: html,
          markers: markers
        };
      },

      /**
       * @return {boolean}
       */
      isAnimationEnabled: function () {
        if (env_1.node) {
          return false;
        }

        var animationEnabled = this.getShallow('animation');

        if (animationEnabled) {
          if (this.getData().count() > this.getShallow('animationThreshold')) {
            animationEnabled = false;
          }
        }

        return animationEnabled;
      },
      restoreData: function () {
        this.dataTask.dirty();
      },
      getColorFromPalette: function (name, scope, requestColorNum) {
        var ecModel = this.ecModel; // PENDING

        var color = colorPalette.getColorFromPalette.call(this, name, scope, requestColorNum);

        if (!color) {
          color = ecModel.getColorFromPalette(name, scope, requestColorNum);
        }

        return color;
      },

      /**
       * Use `data.mapDimension(coordDim, true)` instead.
       * @deprecated
       */
      coordDimToDataDim: function (coordDim) {
        return this.getRawData().mapDimension(coordDim, true);
      },

      /**
       * Get progressive rendering count each step
       * @return {number}
       */
      getProgressive: function () {
        return this.get('progressive');
      },

      /**
       * Get progressive rendering count each step
       * @return {number}
       */
      getProgressiveThreshold: function () {
        return this.get('progressiveThreshold');
      },

      /**
       * Get data indices for show tooltip content. See tooltip.
       * @abstract
       * @param {Array.<string>|string} dim
       * @param {Array.<number>} value
       * @param {module:echarts/coord/single/SingleAxis} baseAxis
       * @return {Object} {dataIndices, nestestValue}.
       */
      getAxisTooltipData: null,

      /**
       * See tooltip.
       * @abstract
       * @param {number} dataIndex
       * @return {Array.<number>} Point of tooltip. null/undefined can be returned.
       */
      getTooltipPosition: null,

      /**
       * @see {module:echarts/stream/Scheduler}
       */
      pipeTask: null,

      /**
       * Convinient for override in extended class.
       * @protected
       * @type {Function}
       */
      preventIncremental: null,

      /**
       * @public
       * @readOnly
       * @type {Object}
       */
      pipelineContext: null
    });
    util.mixin(SeriesModel, dataFormat);
    util.mixin(SeriesModel, colorPalette);
    /**
     * MUST be called after `prepareSource` called
     * Here we need to make auto series, especially for auto legend. But we
     * do not modify series.name in option to avoid side effects.
     */

    function autoSeriesName(seriesModel) {
      // User specified name has higher priority, otherwise it may cause
      // series can not be queried unexpectedly.
      var name = seriesModel.name;

      if (!model.isNameSpecified(seriesModel)) {
        seriesModel.name = getSeriesAutoName(seriesModel) || name;
      }
    }

    function getSeriesAutoName(seriesModel) {
      var data = seriesModel.getRawData();
      var dataDims = data.mapDimension('seriesName', true);
      var nameArr = [];
      util.each(dataDims, function (dataDim) {
        var dimInfo = data.getDimensionInfo(dataDim);
        dimInfo.displayName && nameArr.push(dimInfo.displayName);
      });
      return nameArr.join(' ');
    }

    function dataTaskCount(context) {
      return context.model.getRawData().count();
    }

    function dataTaskReset(context) {
      var seriesModel = context.model;
      seriesModel.setData(seriesModel.getRawData().cloneShallow());
      return dataTaskProgress;
    }

    function dataTaskProgress(param, context) {
      // Avoid repead cloneShallow when data just created in reset.
      if (context.outputData && param.end > context.outputData.count()) {
        context.model.getRawData().cloneShallow(context.outputData);
      }
    } // TODO refactor


    function wrapData(data, seriesModel) {
      util.each(data.CHANGABLE_METHODS, function (methodName) {
        data.wrapMethod(methodName, util.curry(onDataSelfChange, seriesModel));
      });
    }

    function onDataSelfChange(seriesModel) {
      var task = getCurrentTask(seriesModel);

      if (task) {
        // Consider case: filter, selectRange
        task.setOutputEnd(this.count());
      }
    }

    function getCurrentTask(seriesModel) {
      var scheduler = (seriesModel.ecModel || {}).scheduler;
      var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);

      if (pipeline) {
        // When pipline finished, the currrentTask keep the last
        // task (renderTask).
        var task = pipeline.currentTask;

        if (task) {
          var agentStubMap = task.agentStubMap;

          if (agentStubMap) {
            task = agentStubMap.get(seriesModel.uid);
          }
        }

        return task;
      }
    }

    var _default$15 = SeriesModel;
    var Series = _default$15;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var Component$1 = function () {
      /**
       * @type {module:zrender/container/Group}
       * @readOnly
       */
      this.group = new Group_1();
      /**
       * @type {string}
       * @readOnly
       */

      this.uid = component.getUID('viewComponent');
    };

    Component$1.prototype = {
      constructor: Component$1,
      init: function (ecModel, api) {},
      render: function (componentModel, ecModel, api, payload) {},
      dispose: function () {},

      /**
       * @param {string} eventType
       * @param {Object} query
       * @param {module:zrender/Element} targetEl
       * @param {Object} packedEvent
       * @return {boolen} Pass only when return `true`.
       */
      filterForExposedEvent: null
    };
    var componentProto = Component$1.prototype;

    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {// Do nothing;
    }; // Enable Component.extend.


    clazz.enableClassExtend(Component$1); // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

    clazz.enableClassManagement(Component$1, {
      registerWhenExtend: true
    });
    var _default$16 = Component$1;
    var Component_1 = _default$16;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var makeInner$5 = model.makeInner;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @return {string} If large mode changed, return string 'reset';
     */
    function _default$17() {
      var inner = makeInner$5();
      return function (seriesModel) {
        var fields = inner(seriesModel);
        var pipelineContext = seriesModel.pipelineContext;
        var originalLarge = fields.large;
        var originalProgressive = fields.progressiveRender; // FIXME: if the planner works on a filtered series, `pipelineContext` does not
        // exists. See #11611 . Probably we need to modify this structure, see the comment
        // on `performRawSeries` in `Schedular.js`.

        var large = fields.large = pipelineContext && pipelineContext.large;
        var progressive = fields.progressiveRender = pipelineContext && pipelineContext.progressiveRender;
        return !!(originalLarge ^ large || originalProgressive ^ progressive) && 'reset';
      };
    }

    var createRenderPlanner = _default$17;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var each$b = util.each;













    var createTask$2 = task.createTask;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var inner$5 = model.makeInner();
    var renderPlanner = createRenderPlanner();

    function Chart() {
      /**
       * @type {module:zrender/container/Group}
       * @readOnly
       */
      this.group = new Group_1();
      /**
       * @type {string}
       * @readOnly
       */

      this.uid = component.getUID('viewChart');
      this.renderTask = createTask$2({
        plan: renderTaskPlan,
        reset: renderTaskReset
      });
      this.renderTask.context = {
        view: this
      };
    }

    Chart.prototype = {
      type: 'chart',

      /**
       * Init the chart.
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       */
      init: function (ecModel, api) {},

      /**
       * Render the chart.
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       */
      render: function (seriesModel, ecModel, api, payload) {},

      /**
       * Highlight series or specified data item.
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       */
      highlight: function (seriesModel, ecModel, api, payload) {
        toggleHighlight(seriesModel.getData(), payload, 'emphasis');
      },

      /**
       * Downplay series or specified data item.
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       */
      downplay: function (seriesModel, ecModel, api, payload) {
        toggleHighlight(seriesModel.getData(), payload, 'normal');
      },

      /**
       * Remove self.
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       */
      remove: function (ecModel, api) {
        this.group.removeAll();
      },

      /**
       * Dispose self.
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       */
      dispose: function () {},

      /**
       * Rendering preparation in progressive mode.
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       */
      incrementalPrepareRender: null,

      /**
       * Render in progressive mode.
       * @param  {Object} params See taskParams in `stream/task.js`
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       */
      incrementalRender: null,

      /**
       * Update transform directly.
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       * @return {Object} {update: true}
       */
      updateTransform: null,

      /**
       * The view contains the given point.
       * @interface
       * @param {Array.<number>} point
       * @return {boolean}
       */
      // containPoint: function () {}

      /**
       * @param {string} eventType
       * @param {Object} query
       * @param {module:zrender/Element} targetEl
       * @param {Object} packedEvent
       * @return {boolen} Pass only when return `true`.
       */
      filterForExposedEvent: null
    };
    var chartProto = Chart.prototype;

    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {
      this.render(seriesModel, ecModel, api, payload);
    };
    /**
     * Set state of single element
     * @param {module:zrender/Element} el
     * @param {string} state 'normal'|'emphasis'
     * @param {number} highlightDigit
     */


    function elSetState(el, state, highlightDigit) {
      if (el) {
        el.trigger(state, highlightDigit);

        if (el.isGroup // Simple optimize.
        && !graphic.isHighDownDispatcher(el)) {
          for (var i = 0, len = el.childCount(); i < len; i++) {
            elSetState(el.childAt(i), state, highlightDigit);
          }
        }
      }
    }
    /**
     * @param {module:echarts/data/List} data
     * @param {Object} payload
     * @param {string} state 'normal'|'emphasis'
     */


    function toggleHighlight(data, payload, state) {
      var dataIndex = model.queryDataIndex(data, payload);
      var highlightDigit = payload && payload.highlightKey != null ? graphic.getHighlightDigit(payload.highlightKey) : null;

      if (dataIndex != null) {
        each$b(model.normalizeToArray(dataIndex), function (dataIdx) {
          elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
        });
      } else {
        data.eachItemGraphicEl(function (el) {
          elSetState(el, state, highlightDigit);
        });
      }
    } // Enable Chart.extend.


    clazz.enableClassExtend(Chart, ['dispose']); // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

    clazz.enableClassManagement(Chart, {
      registerWhenExtend: true
    });

    Chart.markUpdateMethod = function (payload, methodName) {
      inner$5(payload).updateMethod = methodName;
    };

    function renderTaskPlan(context) {
      return renderPlanner(context.model);
    }

    function renderTaskReset(context) {
      var seriesModel = context.model;
      var ecModel = context.ecModel;
      var api = context.api;
      var payload = context.payload; // ???! remove updateView updateVisual

      var progressiveRender = seriesModel.pipelineContext.progressiveRender;
      var view = context.view;
      var updateMethod = payload && inner$5(payload).updateMethod;
      var methodName = progressiveRender ? 'incrementalPrepareRender' : updateMethod && view[updateMethod] ? updateMethod // `appendData` is also supported when data amount
      // is less than progressive threshold.
      : 'render';

      if (methodName !== 'render') {
        view[methodName](seriesModel, ecModel, api, payload);
      }

      return progressMethodMap[methodName];
    }

    var progressMethodMap = {
      incrementalPrepareRender: {
        progress: function (params, context) {
          context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
        }
      },
      render: {
        // Put view.render in `progress` to support appendData. But in this case
        // view.render should not be called in reset, otherwise it will be called
        // twise. Use `forceFirstProgress` to make sure that view.render is called
        // in any cases.
        forceFirstProgress: true,
        progress: function (params, context) {
          context.view.render(context.model, context.ecModel, context.api, context.payload);
        }
      }
    };
    var _default$18 = Chart;
    var Chart_1 = _default$18;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var ORIGIN_METHOD = '\0__throttleOriginMethod';
    var RATE = '\0__throttleRate';
    var THROTTLE_TYPE = '\0__throttleType';
    /**
     * @public
     * @param {(Function)} fn
     * @param {number} [delay=0] Unit: ms.
     * @param {boolean} [debounce=false]
     *        true: If call interval less than `delay`, only the last call works.
     *        false: If call interval less than `delay, call works on fixed rate.
     * @return {(Function)} throttled fn.
     */

    function throttle(fn, delay, debounce) {
      var currCall;
      var lastCall = 0;
      var lastExec = 0;
      var timer = null;
      var diff;
      var scope;
      var args;
      var debounceNextCall;
      delay = delay || 0;

      function exec() {
        lastExec = new Date().getTime();
        timer = null;
        fn.apply(scope, args || []);
      }

      var cb = function () {
        currCall = new Date().getTime();
        scope = this;
        args = arguments;
        var thisDelay = debounceNextCall || delay;
        var thisDebounce = debounceNextCall || debounce;
        debounceNextCall = null;
        diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
        clearTimeout(timer); // Here we should make sure that: the `exec` SHOULD NOT be called later
        // than a new call of `cb`, that is, preserving the command order. Consider
        // calculating "scale rate" when roaming as an example. When a call of `cb`
        // happens, either the `exec` is called dierectly, or the call is delayed.
        // But the delayed call should never be later than next call of `cb`. Under
        // this assurance, we can simply update view state each time `dispatchAction`
        // triggered by user roaming, but not need to add extra code to avoid the
        // state being "rolled-back".

        if (thisDebounce) {
          timer = setTimeout(exec, thisDelay);
        } else {
          if (diff >= 0) {
            exec();
          } else {
            timer = setTimeout(exec, -diff);
          }
        }

        lastCall = currCall;
      };
      /**
       * Clear throttle.
       * @public
       */


      cb.clear = function () {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      };
      /**
       * Enable debounce once.
       */


      cb.debounceNextCall = function (debounceDelay) {
        debounceNextCall = debounceDelay;
      };

      return cb;
    }
    /**
     * Create throttle method or update throttle rate.
     *
     * @example
     * ComponentView.prototype.render = function () {
     *     ...
     *     throttle.createOrUpdate(
     *         this,
     *         '_dispatchAction',
     *         this.model.get('throttle'),
     *         'fixRate'
     *     );
     * };
     * ComponentView.prototype.remove = function () {
     *     throttle.clear(this, '_dispatchAction');
     * };
     * ComponentView.prototype.dispose = function () {
     *     throttle.clear(this, '_dispatchAction');
     * };
     *
     * @public
     * @param {Object} obj
     * @param {string} fnAttr
     * @param {number} [rate]
     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'
     * @return {Function} throttled function.
     */


    function createOrUpdate(obj, fnAttr, rate, throttleType) {
      var fn = obj[fnAttr];

      if (!fn) {
        return;
      }

      var originFn = fn[ORIGIN_METHOD] || fn;
      var lastThrottleType = fn[THROTTLE_TYPE];
      var lastRate = fn[RATE];

      if (lastRate !== rate || lastThrottleType !== throttleType) {
        if (rate == null || !throttleType) {
          return obj[fnAttr] = originFn;
        }

        fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');
        fn[ORIGIN_METHOD] = originFn;
        fn[THROTTLE_TYPE] = throttleType;
        fn[RATE] = rate;
      }

      return fn;
    }
    /**
     * Clear throttle. Example see throttle.createOrUpdate.
     *
     * @public
     * @param {Object} obj
     * @param {string} fnAttr
     */


    function clear(obj, fnAttr) {
      var fn = obj[fnAttr];

      if (fn && fn[ORIGIN_METHOD]) {
        obj[fnAttr] = fn[ORIGIN_METHOD];
      }
    }

    var throttle_2 = throttle;
    var createOrUpdate_1 = createOrUpdate;
    var clear_1 = clear;

    var throttle_1 = {
    	throttle: throttle_2,
    	createOrUpdate: createOrUpdate_1,
    	clear: clear_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    var isFunction$3 = util.isFunction;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var _default$19 = {
      createOnAllSeries: true,
      performRawSeries: true,
      reset: function (seriesModel, ecModel) {
        var data = seriesModel.getData();
        var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.color').split('.'); // Set in itemStyle

        var color = seriesModel.get(colorAccessPath);
        var colorCallback = isFunction$3(color) && !(color instanceof Gradient_1) ? color : null; // Default color

        if (!color || colorCallback) {
          color = seriesModel.getColorFromPalette( // TODO series count changed.
          seriesModel.name, null, ecModel.getSeriesCount());
        }

        data.setVisual('color', color);
        var borderColorAccessPath = (seriesModel.visualBorderColorAccessPath || 'itemStyle.borderColor').split('.');
        var borderColor = seriesModel.get(borderColorAccessPath);
        data.setVisual('borderColor', borderColor); // Only visible series has each data be visual encoded

        if (!ecModel.isSeriesFiltered(seriesModel)) {
          if (colorCallback) {
            data.each(function (idx) {
              data.setItemVisual(idx, 'color', colorCallback(seriesModel.getDataParams(idx)));
            });
          } // itemStyle in each data item


          var dataEach = function (data, idx) {
            var itemModel = data.getItemModel(idx);
            var color = itemModel.get(colorAccessPath, true);
            var borderColor = itemModel.get(borderColorAccessPath, true);

            if (color != null) {
              data.setItemVisual(idx, 'color', color);
            }

            if (borderColor != null) {
              data.setItemVisual(idx, 'borderColor', borderColor);
            }
          };

          return {
            dataEach: data.hasItemOption ? dataEach : null
          };
        }
      }
    };
    var seriesColor = _default$19;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Language: (Simplified) Chinese.
     */
    var _default$1a = {
      legend: {
        selector: {
          all: '全选',
          inverse: '反选'
        }
      },
      toolbox: {
        brush: {
          title: {
            rect: '矩形选择',
            polygon: '圈选',
            lineX: '横向选择',
            lineY: '纵向选择',
            keep: '保持选择',
            clear: '清除选择'
          }
        },
        dataView: {
          title: '数据视图',
          lang: ['数据视图', '关闭', '刷新']
        },
        dataZoom: {
          title: {
            zoom: '区域缩放',
            back: '区域缩放还原'
          }
        },
        magicType: {
          title: {
            line: '切换为折线图',
            bar: '切换为柱状图',
            stack: '切换为堆叠',
            tiled: '切换为平铺'
          }
        },
        restore: {
          title: '还原'
        },
        saveAsImage: {
          title: '保存为图片',
          lang: ['右键另存为图片']
        }
      },
      series: {
        typeNames: {
          pie: '饼图',
          bar: '柱状图',
          line: '折线图',
          scatter: '散点图',
          effectScatter: '涟漪散点图',
          radar: '雷达图',
          tree: '树图',
          treemap: '矩形树图',
          boxplot: '箱型图',
          candlestick: 'K线图',
          k: 'K线图',
          heatmap: '热力图',
          map: '地图',
          parallel: '平行坐标图',
          lines: '线图',
          graph: '关系图',
          sankey: '桑基图',
          funnel: '漏斗图',
          gauge: '仪表盘图',
          pictorialBar: '象形柱图',
          themeRiver: '主题河流图',
          sunburst: '旭日图'
        }
      },
      aria: {
        general: {
          withTitle: '这是一个关于“{title}”的图表。',
          withoutTitle: '这是一个图表，'
        },
        series: {
          single: {
            prefix: '',
            withName: '图表类型是{seriesType}，表示{seriesName}。',
            withoutName: '图表类型是{seriesType}。'
          },
          multiple: {
            prefix: '它由{seriesCount}个图表系列组成。',
            withName: '第{seriesId}个系列是一个表示{seriesName}的{seriesType}，',
            withoutName: '第{seriesId}个系列是一个{seriesType}，',
            separator: {
              middle: '；',
              end: '。'
            }
          }
        },
        data: {
          allData: '其数据是——',
          partialData: '其中，前{displayCnt}项是——',
          withName: '{name}的数据是{value}',
          withoutName: '{value}',
          separator: {
            middle: '，',
            end: ''
          }
        }
      }
    };
    var lang = _default$1a;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var retrieveRawValue$3 = dataProvider.retrieveRawValue;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function _default$1b(dom, ecModel) {
      var ariaModel = ecModel.getModel('aria');

      if (!ariaModel.get('show')) {
        return;
      } else if (ariaModel.get('description')) {
        dom.setAttribute('aria-label', ariaModel.get('description'));
        return;
      }

      var seriesCnt = 0;
      ecModel.eachSeries(function (seriesModel, idx) {
        ++seriesCnt;
      }, this);
      var maxDataCnt = ariaModel.get('data.maxCount') || 10;
      var maxSeriesCnt = ariaModel.get('series.maxCount') || 10;
      var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
      var ariaLabel;

      if (seriesCnt < 1) {
        // No series, no aria label
        return;
      } else {
        var title = getTitle();

        if (title) {
          ariaLabel = replace(getConfig('general.withTitle'), {
            title: title
          });
        } else {
          ariaLabel = getConfig('general.withoutTitle');
        }

        var seriesLabels = [];
        var prefix = seriesCnt > 1 ? 'series.multiple.prefix' : 'series.single.prefix';
        ariaLabel += replace(getConfig(prefix), {
          seriesCount: seriesCnt
        });
        ecModel.eachSeries(function (seriesModel, idx) {
          if (idx < displaySeriesCnt) {
            var seriesLabel;
            var seriesName = seriesModel.get('name');
            var seriesTpl = 'series.' + (seriesCnt > 1 ? 'multiple' : 'single') + '.';
            seriesLabel = getConfig(seriesName ? seriesTpl + 'withName' : seriesTpl + 'withoutName');
            seriesLabel = replace(seriesLabel, {
              seriesId: seriesModel.seriesIndex,
              seriesName: seriesModel.get('name'),
              seriesType: getSeriesTypeName(seriesModel.subType)
            });
            var data = seriesModel.getData();
            window.data = data;

            if (data.count() > maxDataCnt) {
              // Show part of data
              seriesLabel += replace(getConfig('data.partialData'), {
                displayCnt: maxDataCnt
              });
            } else {
              seriesLabel += getConfig('data.allData');
            }

            var dataLabels = [];

            for (var i = 0; i < data.count(); i++) {
              if (i < maxDataCnt) {
                var name = data.getName(i);
                var value = retrieveRawValue$3(data, i);
                dataLabels.push(replace(name ? getConfig('data.withName') : getConfig('data.withoutName'), {
                  name: name,
                  value: value
                }));
              }
            }

            seriesLabel += dataLabels.join(getConfig('data.separator.middle')) + getConfig('data.separator.end');
            seriesLabels.push(seriesLabel);
          }
        });
        ariaLabel += seriesLabels.join(getConfig('series.multiple.separator.middle')) + getConfig('series.multiple.separator.end');
        dom.setAttribute('aria-label', ariaLabel);
      }

      function replace(str, keyValues) {
        if (typeof str !== 'string') {
          return str;
        }

        var result = str;
        util.each(keyValues, function (value, key) {
          result = result.replace(new RegExp('\\{\\s*' + key + '\\s*\\}', 'g'), value);
        });
        return result;
      }

      function getConfig(path) {
        var userConfig = ariaModel.get(path);

        if (userConfig == null) {
          var pathArr = path.split('.');
          var result = lang.aria;

          for (var i = 0; i < pathArr.length; ++i) {
            result = result[pathArr[i]];
          }

          return result;
        } else {
          return userConfig;
        }
      }

      function getTitle() {
        var title = ecModel.getModel('title').option;

        if (title && title.length) {
          title = title[0];
        }

        return title && title.text;
      }

      function getSeriesTypeName(type) {
        return lang.series.typeNames[type] || '自定义图';
      }
    }

    var aria = _default$1b;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var PI$1 = Math.PI;
    /**
     * @param {module:echarts/ExtensionAPI} api
     * @param {Object} [opts]
     * @param {string} [opts.text]
     * @param {string} [opts.color]
     * @param {string} [opts.textColor]
     * @return {module:zrender/Element}
     */

    function _default$1c(api, opts) {
      opts = opts || {};
      util.defaults(opts, {
        text: 'loading',
        textColor: '#000',
        fontSize: '12px',
        maskColor: 'rgba(255, 255, 255, 0.8)',
        showSpinner: true,
        color: '#c23531',
        spinnerRadius: 10,
        lineWidth: 5,
        zlevel: 0
      });
      var group = new graphic.Group();
      var mask = new graphic.Rect({
        style: {
          fill: opts.maskColor
        },
        zlevel: opts.zlevel,
        z: 10000
      });
      group.add(mask);
      var font = opts.fontSize + ' sans-serif';
      var labelRect = new graphic.Rect({
        style: {
          fill: 'none',
          text: opts.text,
          font: font,
          textPosition: 'right',
          textDistance: 10,
          textFill: opts.textColor
        },
        zlevel: opts.zlevel,
        z: 10001
      });
      group.add(labelRect);

      if (opts.showSpinner) {
        var arc = new graphic.Arc({
          shape: {
            startAngle: -PI$1 / 2,
            endAngle: -PI$1 / 2 + 0.1,
            r: opts.spinnerRadius
          },
          style: {
            stroke: opts.color,
            lineCap: 'round',
            lineWidth: opts.lineWidth
          },
          zlevel: opts.zlevel,
          z: 10001
        });
        arc.animateShape(true).when(1000, {
          endAngle: PI$1 * 3 / 2
        }).start('circularInOut');
        arc.animateShape(true).when(1000, {
          startAngle: PI$1 * 3 / 2
        }).delay(300).start('circularInOut');
        group.add(arc);
      } // Inject resize


      group.resize = function () {
        var textWidth = text$1.getWidth(opts.text, font);
        var r = opts.showSpinner ? opts.spinnerRadius : 0; // cx = (containerWidth - arcDiameter - textDistance - textWidth) / 2
        // textDistance needs to be calculated when both animation and text exist

        var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 // only show the text
        - (opts.showSpinner ? 0 : textWidth / 2);
        var cy = api.getHeight() / 2;
        opts.showSpinner && arc.setShape({
          cx: cx,
          cy: cy
        });
        labelRect.setShape({
          x: cx - r,
          y: cy - r,
          width: r * 2,
          height: r * 2
        });
        mask.setShape({
          x: 0,
          y: 0,
          width: api.getWidth(),
          height: api.getHeight()
        });
      };

      group.resize();
      return group;
    }

    var _default_1 = _default$1c;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var each$c = util.each;
    var map$4 = util.map;
    var isFunction$4 = util.isFunction;
    var createHashMap$5 = util.createHashMap;
    var noop$2 = util.noop;



    var createTask$3 = task.createTask;



    var getUID$1 = component.getUID;







    var normalizeToArray$3 = model.normalizeToArray;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @module echarts/stream/Scheduler
     */

    /**
     * @constructor
     */
    function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {
      this.ecInstance = ecInstance;
      this.api = api;
      this.unfinished; // Fix current processors in case that in some rear cases that
      // processors might be registered after echarts instance created.
      // Register processors incrementally for a echarts instance is
      // not supported by this stream architecture.

      var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
      var visualHandlers = this._visualHandlers = visualHandlers.slice();
      this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
      /**
       * @private
       * @type {
       *     [handlerUID: string]: {
       *         seriesTaskMap?: {
       *             [seriesUID: string]: Task
       *         },
       *         overallTask?: Task
       *     }
       * }
       */

      this._stageTaskMap = createHashMap$5();
    }

    var proto = Scheduler.prototype;
    /**
     * @param {module:echarts/model/Global} ecModel
     * @param {Object} payload
     */

    proto.restoreData = function (ecModel, payload) {
      // TODO: Only restroe needed series and components, but not all components.
      // Currently `restoreData` of all of the series and component will be called.
      // But some independent components like `title`, `legend`, `graphic`, `toolbox`,
      // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,
      // and some components like coordinate system, axes, dataZoom, visualMap only
      // need their target series refresh.
      // (1) If we are implementing this feature some day, we should consider these cases:
      // if a data processor depends on a component (e.g., dataZoomProcessor depends
      // on the settings of `dataZoom`), it should be re-performed if the component
      // is modified by `setOption`.
      // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,
      // it should be re-performed when the result array of `getTargetSeries` changed.
      // We use `dependencies` to cover these issues.
      // (3) How to update target series when coordinate system related components modified.
      // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,
      // and this case all of the tasks will be set as dirty.
      ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also
      // depends on all of the series.
      // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks
      // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure
      // that the overall task is set as dirty and to be performed, otherwise it probably cause
      // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it
      // probably cause state chaos (consider `dataZoomProcessor`).

      this._stageTaskMap.each(function (taskRecord) {
        var overallTask = taskRecord.overallTask;
        overallTask && overallTask.dirty();
      });
    }; // If seriesModel provided, incremental threshold is check by series data.


    proto.getPerformArgs = function (task, isBlock) {
      // For overall task
      if (!task.__pipeline) {
        return;
      }

      var pipeline = this._pipelineMap.get(task.__pipeline.id);

      var pCtx = pipeline.context;
      var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
      var step = incremental ? pipeline.step : null;
      var modDataCount = pCtx && pCtx.modDataCount;
      var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
      return {
        step: step,
        modBy: modBy,
        modDataCount: modDataCount
      };
    };

    proto.getPipeline = function (pipelineId) {
      return this._pipelineMap.get(pipelineId);
    };
    /**
     * Current, progressive rendering starts from visual and layout.
     * Always detect render mode in the same stage, avoiding that incorrect
     * detection caused by data filtering.
     * Caution:
     * `updateStreamModes` use `seriesModel.getData()`.
     */


    proto.updateStreamModes = function (seriesModel, view) {
      var pipeline = this._pipelineMap.get(seriesModel.uid);

      var data = seriesModel.getData();
      var dataLen = data.count(); // `progressiveRender` means that can render progressively in each
      // animation frame. Note that some types of series do not provide
      // `view.incrementalPrepareRender` but support `chart.appendData`. We
      // use the term `incremental` but not `progressive` to describe the
      // case that `chart.appendData`.

      var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
      var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.
      // see `test/candlestick-large3.html`

      var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;
      seriesModel.pipelineContext = pipeline.context = {
        progressiveRender: progressiveRender,
        modDataCount: modDataCount,
        large: large
      };
    };

    proto.restorePipelines = function (ecModel) {
      var scheduler = this;
      var pipelineMap = scheduler._pipelineMap = createHashMap$5();
      ecModel.eachSeries(function (seriesModel) {
        var progressive = seriesModel.getProgressive();
        var pipelineId = seriesModel.uid;
        pipelineMap.set(pipelineId, {
          id: pipelineId,
          head: null,
          tail: null,
          threshold: seriesModel.getProgressiveThreshold(),
          progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
          blockIndex: -1,
          step: Math.round(progressive || 700),
          count: 0
        });
        pipe(scheduler, seriesModel, seriesModel.dataTask);
      });
    };

    proto.prepareStageTasks = function () {
      var stageTaskMap = this._stageTaskMap;
      var ecModel = this.ecInstance.getModel();
      var api = this.api;
      each$c(this._allHandlers, function (handler) {
        var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);
        handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);
        handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);
      }, this);
    };

    proto.prepareView = function (view, model, ecModel, api) {
      var renderTask = view.renderTask;
      var context = renderTask.context;
      context.model = model;
      context.ecModel = ecModel;
      context.api = api;
      renderTask.__block = !view.incrementalPrepareRender;
      pipe(this, model, renderTask);
    };

    proto.performDataProcessorTasks = function (ecModel, payload) {
      // If we do not use `block` here, it should be considered when to update modes.
      performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {
        block: true
      });
    }; // opt
    // opt.visualType: 'visual' or 'layout'
    // opt.setDirty


    proto.performVisualTasks = function (ecModel, payload, opt) {
      performStageTasks(this, this._visualHandlers, ecModel, payload, opt);
    };

    function performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {
      opt = opt || {};
      var unfinished;
      each$c(stageHandlers, function (stageHandler, idx) {
        if (opt.visualType && opt.visualType !== stageHandler.visualType) {
          return;
        }

        var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);

        var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
        var overallTask = stageHandlerRecord.overallTask;

        if (overallTask) {
          var overallNeedDirty;
          var agentStubMap = overallTask.agentStubMap;
          agentStubMap.each(function (stub) {
            if (needSetDirty(opt, stub)) {
              stub.dirty();
              overallNeedDirty = true;
            }
          });
          overallNeedDirty && overallTask.dirty();
          updatePayload(overallTask, payload);
          var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,
          // then execute the overall task. And stub will call seriesModel.setData,
          // which ensures that in the overallTask seriesModel.getData() will not
          // return incorrect data.

          agentStubMap.each(function (stub) {
            stub.perform(performArgs);
          });
          unfinished |= overallTask.perform(performArgs);
        } else if (seriesTaskMap) {
          seriesTaskMap.each(function (task, pipelineId) {
            if (needSetDirty(opt, task)) {
              task.dirty();
            }

            var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME
            // if intending to decalare `performRawSeries` in handlers, only
            // stream-independent (specifically, data item independent) operations can be
            // performed. Because is a series is filtered, most of the tasks will not
            // be performed. A stream-dependent operation probably cause wrong biz logic.
            // Perhaps we should not provide a separate callback for this case instead
            // of providing the config `performRawSeries`. The stream-dependent operaions
            // and stream-independent operations should better not be mixed.

            performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
            updatePayload(task, payload);
            unfinished |= task.perform(performArgs);
          });
        }
      });

      function needSetDirty(opt, task) {
        return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));
      }

      scheduler.unfinished |= unfinished;
    }

    proto.performSeriesTasks = function (ecModel) {
      var unfinished;
      ecModel.eachSeries(function (seriesModel) {
        // Progress to the end for dataInit and dataRestore.
        unfinished |= seriesModel.dataTask.perform();
      });
      this.unfinished |= unfinished;
    };

    proto.plan = function () {
      // Travel pipelines, check block.
      this._pipelineMap.each(function (pipeline) {
        var task = pipeline.tail;

        do {
          if (task.__block) {
            pipeline.blockIndex = task.__idxInPipeline;
            break;
          }

          task = task.getUpstream();
        } while (task);
      });
    };

    var updatePayload = proto.updatePayload = function (task, payload) {
      payload !== 'remain' && (task.context.payload = payload);
    };

    function createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
      var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap$5());
      var seriesType = stageHandler.seriesType;
      var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,
      // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,
      // it works but it may cause other irrelevant charts blocked.

      if (stageHandler.createOnAllSeries) {
        ecModel.eachRawSeries(create);
      } else if (seriesType) {
        ecModel.eachRawSeriesByType(seriesType, create);
      } else if (getTargetSeries) {
        getTargetSeries(ecModel, api).each(create);
      }

      function create(seriesModel) {
        var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.
        // Reuse original task instance.

        var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask$3({
          plan: seriesTaskPlan,
          reset: seriesTaskReset,
          count: seriesTaskCount
        }));
        task.context = {
          model: seriesModel,
          ecModel: ecModel,
          api: api,
          useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
          plan: stageHandler.plan,
          reset: stageHandler.reset,
          scheduler: scheduler
        };
        pipe(scheduler, seriesModel, task);
      } // Clear unused series tasks.


      var pipelineMap = scheduler._pipelineMap;
      seriesTaskMap.each(function (task, pipelineId) {
        if (!pipelineMap.get(pipelineId)) {
          task.dispose();
          seriesTaskMap.removeKey(pipelineId);
        }
      });
    }

    function createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
      var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.
      || createTask$3({
        reset: overallTaskReset
      });
      overallTask.context = {
        ecModel: ecModel,
        api: api,
        overallReset: stageHandler.overallReset,
        scheduler: scheduler
      }; // Reuse orignal stubs.

      var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap$5();
      var seriesType = stageHandler.seriesType;
      var getTargetSeries = stageHandler.getTargetSeries;
      var overallProgress = true;
      var modifyOutputEnd = stageHandler.modifyOutputEnd; // An overall task with seriesType detected or has `getTargetSeries`, we add
      // stub in each pipelines, it will set the overall task dirty when the pipeline
      // progress. Moreover, to avoid call the overall task each frame (too frequent),
      // we set the pipeline block.

      if (seriesType) {
        ecModel.eachRawSeriesByType(seriesType, createStub);
      } else if (getTargetSeries) {
        getTargetSeries(ecModel, api).each(createStub);
      } // Otherwise, (usually it is legancy case), the overall task will only be
      // executed when upstream dirty. Otherwise the progressive rendering of all
      // pipelines will be disabled unexpectedly. But it still needs stubs to receive
      // dirty info from upsteam.
      else {
          overallProgress = false;
          each$c(ecModel.getSeries(), createStub);
        }

      function createStub(seriesModel) {
        var pipelineId = seriesModel.uid;
        var stub = agentStubMap.get(pipelineId);

        if (!stub) {
          stub = agentStubMap.set(pipelineId, createTask$3({
            reset: stubReset,
            onDirty: stubOnDirty
          })); // When the result of `getTargetSeries` changed, the overallTask
          // should be set as dirty and re-performed.

          overallTask.dirty();
        }

        stub.context = {
          model: seriesModel,
          overallProgress: overallProgress,
          modifyOutputEnd: modifyOutputEnd
        };
        stub.agent = overallTask;
        stub.__block = overallProgress;
        pipe(scheduler, seriesModel, stub);
      } // Clear unused stubs.


      var pipelineMap = scheduler._pipelineMap;
      agentStubMap.each(function (stub, pipelineId) {
        if (!pipelineMap.get(pipelineId)) {
          stub.dispose(); // When the result of `getTargetSeries` changed, the overallTask
          // should be set as dirty and re-performed.

          overallTask.dirty();
          agentStubMap.removeKey(pipelineId);
        }
      });
    }

    function overallTaskReset(context) {
      context.overallReset(context.ecModel, context.api, context.payload);
    }

    function stubReset(context, upstreamContext) {
      return context.overallProgress && stubProgress;
    }

    function stubProgress() {
      this.agent.dirty();
      this.getDownstream().dirty();
    }

    function stubOnDirty() {
      this.agent && this.agent.dirty();
    }

    function seriesTaskPlan(context) {
      return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);
    }

    function seriesTaskReset(context) {
      if (context.useClearVisual) {
        context.data.clearAllVisual();
      }

      var resetDefines = context.resetDefines = normalizeToArray$3(context.reset(context.model, context.ecModel, context.api, context.payload));
      return resetDefines.length > 1 ? map$4(resetDefines, function (v, idx) {
        return makeSeriesTaskProgress(idx);
      }) : singleSeriesTaskProgress;
    }

    var singleSeriesTaskProgress = makeSeriesTaskProgress(0);

    function makeSeriesTaskProgress(resetDefineIdx) {
      return function (params, context) {
        var data = context.data;
        var resetDefine = context.resetDefines[resetDefineIdx];

        if (resetDefine && resetDefine.dataEach) {
          for (var i = params.start; i < params.end; i++) {
            resetDefine.dataEach(data, i);
          }
        } else if (resetDefine && resetDefine.progress) {
          resetDefine.progress(params, data);
        }
      };
    }

    function seriesTaskCount(context) {
      return context.data.count();
    }

    function pipe(scheduler, seriesModel, task) {
      var pipelineId = seriesModel.uid;

      var pipeline = scheduler._pipelineMap.get(pipelineId);

      !pipeline.head && (pipeline.head = task);
      pipeline.tail && pipeline.tail.pipe(task);
      pipeline.tail = task;
      task.__idxInPipeline = pipeline.count++;
      task.__pipeline = pipeline;
    }

    Scheduler.wrapStageHandler = function (stageHandler, visualType) {
      if (isFunction$4(stageHandler)) {
        stageHandler = {
          overallReset: stageHandler,
          seriesType: detectSeriseType(stageHandler)
        };
      }

      stageHandler.uid = getUID$1('stageHandler');
      visualType && (stageHandler.visualType = visualType);
      return stageHandler;
    };
    /**
     * Only some legacy stage handlers (usually in echarts extensions) are pure function.
     * To ensure that they can work normally, they should work in block mode, that is,
     * they should not be started util the previous tasks finished. So they cause the
     * progressive rendering disabled. We try to detect the series type, to narrow down
     * the block range to only the series type they concern, but not all series.
     */


    function detectSeriseType(legacyFunc) {
      seriesType = null;

      try {
        // Assume there is no async when calling `eachSeriesByType`.
        legacyFunc(ecModelMock, apiMock);
      } catch (e) {}

      return seriesType;
    }

    var ecModelMock = {};
    var apiMock = {};
    var seriesType;
    mockMethods(ecModelMock, Global);
    mockMethods(apiMock, ExtensionAPI_1);

    ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {
      seriesType = type;
    };

    ecModelMock.eachComponent = function (cond) {
      if (cond.mainType === 'series' && cond.subType) {
        seriesType = cond.subType;
      }
    };

    function mockMethods(target, Clz) {
      /* eslint-disable */
      for (var name in Clz.prototype) {
        // Do not use hasOwnProperty
        target[name] = noop$2;
      }
      /* eslint-enable */

    }

    var _default$1d = Scheduler;
    var Scheduler_1 = _default$1d;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var colorAll = ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF'];
    var _default$1e = {
      color: colorAll,
      colorLayer: [['#37A2DA', '#ffd85c', '#fd7b5f'], ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'], ['#37A2DA', '#32C5E9', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#e7bcf3', '#8378EA', '#96BFFF'], colorAll]
    };
    var light = _default$1e;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var contrastColor = '#eee';

    var axisCommon = function () {
      return {
        axisLine: {
          lineStyle: {
            color: contrastColor
          }
        },
        axisTick: {
          lineStyle: {
            color: contrastColor
          }
        },
        axisLabel: {
          textStyle: {
            color: contrastColor
          }
        },
        splitLine: {
          lineStyle: {
            type: 'dashed',
            color: '#aaa'
          }
        },
        splitArea: {
          areaStyle: {
            color: contrastColor
          }
        }
      };
    };

    var colorPalette$1 = ['#dd6b66', '#759aa0', '#e69d87', '#8dc1a9', '#ea7e53', '#eedd78', '#73a373', '#73b9bc', '#7289ab', '#91ca8c', '#f49f42'];
    var theme = {
      color: colorPalette$1,
      backgroundColor: '#333',
      tooltip: {
        axisPointer: {
          lineStyle: {
            color: contrastColor
          },
          crossStyle: {
            color: contrastColor
          },
          label: {
            color: '#000'
          }
        }
      },
      legend: {
        textStyle: {
          color: contrastColor
        }
      },
      textStyle: {
        color: contrastColor
      },
      title: {
        textStyle: {
          color: contrastColor
        }
      },
      toolbox: {
        iconStyle: {
          normal: {
            borderColor: contrastColor
          }
        }
      },
      dataZoom: {
        textStyle: {
          color: contrastColor
        }
      },
      visualMap: {
        textStyle: {
          color: contrastColor
        }
      },
      timeline: {
        lineStyle: {
          color: contrastColor
        },
        itemStyle: {
          normal: {
            color: colorPalette$1[1]
          }
        },
        label: {
          normal: {
            textStyle: {
              color: contrastColor
            }
          }
        },
        controlStyle: {
          normal: {
            color: contrastColor,
            borderColor: contrastColor
          }
        }
      },
      timeAxis: axisCommon(),
      logAxis: axisCommon(),
      valueAxis: axisCommon(),
      categoryAxis: axisCommon(),
      line: {
        symbol: 'circle'
      },
      graph: {
        color: colorPalette$1
      },
      gauge: {
        title: {
          textStyle: {
            color: contrastColor
          }
        }
      },
      candlestick: {
        itemStyle: {
          normal: {
            color: '#FD1050',
            color0: '#0CF49B',
            borderColor: '#FD1050',
            borderColor0: '#0CF49B'
          }
        }
      }
    };
    theme.categoryAxis.splitLine.show = false;
    var _default$1f = theme;
    var dark = _default$1f;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var detectSourceFormat$1 = sourceHelper.detectSourceFormat;



    var SERIES_LAYOUT_BY_COLUMN$2 = sourceType.SERIES_LAYOUT_BY_COLUMN;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * This module is imported by echarts directly.
     *
     * Notice:
     * Always keep this file exists for backward compatibility.
     * Because before 4.1.0, dataset is an optional component,
     * some users may import this module manually.
     */
    Component.extend({
      type: 'dataset',

      /**
       * @protected
       */
      defaultOption: {
        // 'row', 'column'
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN$2,
        // null/'auto': auto detect header, see "module:echarts/data/helper/sourceHelper"
        sourceHeader: null,
        dimensions: null,
        source: null
      },
      optionUpdated: function () {
        detectSourceFormat$1(this);
      }
    });
    Component_1.extend({
      type: 'dataset'
    });

    /**
     * 椭圆形状
     * @module zrender/graphic/shape/Ellipse
     */
    var _default$1g = Path_1.extend({
      type: 'ellipse',
      shape: {
        cx: 0,
        cy: 0,
        rx: 0,
        ry: 0
      },
      buildPath: function (ctx, shape) {
        var k = 0.5522848;
        var x = shape.cx;
        var y = shape.cy;
        var a = shape.rx;
        var b = shape.ry;
        var ox = a * k; // 水平控制点偏移量

        var oy = b * k; // 垂直控制点偏移量
        // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线

        ctx.moveTo(x - a, y);
        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
        ctx.closePath();
      }
    });

    var Ellipse = _default$1g;

    var createFromString$1 = path$1.createFromString;



    var isString$6 = util.isString;
    var extend$6 = util.extend;
    var defaults$2 = util.defaults;
    var trim$3 = util.trim;
    var each$d = util.each;
    // import RadialGradient from '../graphic/RadialGradient';
    // import Pattern from '../graphic/Pattern';
    // import * as vector from '../core/vector';
    // Most of the values can be separated by comma and/or white space.
    var DILIMITER_REG = /[\s,]+/;
    /**
     * For big svg string, this method might be time consuming.
     *
     * @param {string} svg xml string
     * @return {Object} xml root.
     */

    function parseXML(svg) {
      if (isString$6(svg)) {
        var parser = new DOMParser();
        svg = parser.parseFromString(svg, 'text/xml');
      } // Document node. If using $.get, doc node may be input.


      if (svg.nodeType === 9) {
        svg = svg.firstChild;
      } // nodeName of <!DOCTYPE svg> is also 'svg'.


      while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {
        svg = svg.nextSibling;
      }

      return svg;
    }

    function SVGParser() {
      this._defs = {};
      this._root = null;
      this._isDefine = false;
      this._isText = false;
    }

    SVGParser.prototype.parse = function (xml, opt) {
      opt = opt || {};
      var svg = parseXML(xml);

      if (!svg) {
        throw new Error('Illegal svg');
      }

      var root = new Group_1();
      this._root = root; // parse view port

      var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means "100%" of `opt.width/height`.
      // TODO: Other percent value not supported yet.

      var width = parseFloat(svg.getAttribute('width') || opt.width);
      var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.

      isNaN(width) && (width = null);
      isNaN(height) && (height = null); // Apply inline style on svg element.

      parseAttributes(svg, root, null, true);
      var child = svg.firstChild;

      while (child) {
        this._parseNode(child, root);

        child = child.nextSibling;
      }

      var viewBoxRect;
      var viewBoxTransform;

      if (viewBox) {
        var viewBoxArr = trim$3(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.

        if (viewBoxArr.length >= 4) {
          viewBoxRect = {
            x: parseFloat(viewBoxArr[0] || 0),
            y: parseFloat(viewBoxArr[1] || 0),
            width: parseFloat(viewBoxArr[2]),
            height: parseFloat(viewBoxArr[3])
          };
        }
      }

      if (viewBoxRect && width != null && height != null) {
        viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);

        if (!opt.ignoreViewBox) {
          // If set transform on the output group, it probably bring trouble when
          // some users only intend to show the clipped content inside the viewBox,
          // but not intend to transform the output group. So we keep the output
          // group no transform. If the user intend to use the viewBox as a
          // camera, just set `opt.ignoreViewBox` as `true` and set transfrom
          // manually according to the viewBox info in the output of this method.
          var elRoot = root;
          root = new Group_1();
          root.add(elRoot);
          elRoot.scale = viewBoxTransform.scale.slice();
          elRoot.position = viewBoxTransform.position.slice();
        }
      } // Some shapes might be overflow the viewport, which should be
      // clipped despite whether the viewBox is used, as the SVG does.


      if (!opt.ignoreRootClip && width != null && height != null) {
        root.setClipPath(new Rect({
          shape: {
            x: 0,
            y: 0,
            width: width,
            height: height
          }
        }));
      } // Set width/height on group just for output the viewport size.


      return {
        root: root,
        width: width,
        height: height,
        viewBoxRect: viewBoxRect,
        viewBoxTransform: viewBoxTransform
      };
    };

    SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {
      var nodeName = xmlNode.nodeName.toLowerCase(); // TODO
      // support <style>...</style> in svg, where nodeName is 'style',
      // CSS classes is defined globally wherever the style tags are declared.

      if (nodeName === 'defs') {
        // define flag
        this._isDefine = true;
      } else if (nodeName === 'text') {
        this._isText = true;
      }

      var el;

      if (this._isDefine) {
        var parser = defineParsers[nodeName];

        if (parser) {
          var def = parser.call(this, xmlNode);
          var id = xmlNode.getAttribute('id');

          if (id) {
            this._defs[id] = def;
          }
        }
      } else {
        var parser = nodeParsers[nodeName];

        if (parser) {
          el = parser.call(this, xmlNode, parentGroup);
          parentGroup.add(el);
        }
      }

      var child = xmlNode.firstChild;

      while (child) {
        if (child.nodeType === 1) {
          this._parseNode(child, el);
        } // Is text


        if (child.nodeType === 3 && this._isText) {
          this._parseText(child, el);
        }

        child = child.nextSibling;
      } // Quit define


      if (nodeName === 'defs') {
        this._isDefine = false;
      } else if (nodeName === 'text') {
        this._isText = false;
      }
    };

    SVGParser.prototype._parseText = function (xmlNode, parentGroup) {
      if (xmlNode.nodeType === 1) {
        var dx = xmlNode.getAttribute('dx') || 0;
        var dy = xmlNode.getAttribute('dy') || 0;
        this._textX += parseFloat(dx);
        this._textY += parseFloat(dy);
      }

      var text = new Text_1({
        style: {
          text: xmlNode.textContent,
          transformText: true
        },
        position: [this._textX || 0, this._textY || 0]
      });
      inheritStyle(parentGroup, text);
      parseAttributes(xmlNode, text, this._defs);
      var fontSize = text.style.fontSize;

      if (fontSize && fontSize < 9) {
        // PENDING
        text.style.fontSize = 9;
        text.scale = text.scale || [1, 1];
        text.scale[0] *= fontSize / 9;
        text.scale[1] *= fontSize / 9;
      }

      var rect = text.getBoundingRect();
      this._textX += rect.width;
      parentGroup.add(text);
      return text;
    };

    var nodeParsers = {
      'g': function (xmlNode, parentGroup) {
        var g = new Group_1();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defs);
        return g;
      },
      'rect': function (xmlNode, parentGroup) {
        var rect = new Rect();
        inheritStyle(parentGroup, rect);
        parseAttributes(xmlNode, rect, this._defs);
        rect.setShape({
          x: parseFloat(xmlNode.getAttribute('x') || 0),
          y: parseFloat(xmlNode.getAttribute('y') || 0),
          width: parseFloat(xmlNode.getAttribute('width') || 0),
          height: parseFloat(xmlNode.getAttribute('height') || 0)
        }); // console.log(xmlNode.getAttribute('transform'));
        // console.log(rect.transform);

        return rect;
      },
      'circle': function (xmlNode, parentGroup) {
        var circle = new Circle();
        inheritStyle(parentGroup, circle);
        parseAttributes(xmlNode, circle, this._defs);
        circle.setShape({
          cx: parseFloat(xmlNode.getAttribute('cx') || 0),
          cy: parseFloat(xmlNode.getAttribute('cy') || 0),
          r: parseFloat(xmlNode.getAttribute('r') || 0)
        });
        return circle;
      },
      'line': function (xmlNode, parentGroup) {
        var line = new Line();
        inheritStyle(parentGroup, line);
        parseAttributes(xmlNode, line, this._defs);
        line.setShape({
          x1: parseFloat(xmlNode.getAttribute('x1') || 0),
          y1: parseFloat(xmlNode.getAttribute('y1') || 0),
          x2: parseFloat(xmlNode.getAttribute('x2') || 0),
          y2: parseFloat(xmlNode.getAttribute('y2') || 0)
        });
        return line;
      },
      'ellipse': function (xmlNode, parentGroup) {
        var ellipse = new Ellipse();
        inheritStyle(parentGroup, ellipse);
        parseAttributes(xmlNode, ellipse, this._defs);
        ellipse.setShape({
          cx: parseFloat(xmlNode.getAttribute('cx') || 0),
          cy: parseFloat(xmlNode.getAttribute('cy') || 0),
          rx: parseFloat(xmlNode.getAttribute('rx') || 0),
          ry: parseFloat(xmlNode.getAttribute('ry') || 0)
        });
        return ellipse;
      },
      'polygon': function (xmlNode, parentGroup) {
        var points = xmlNode.getAttribute('points');

        if (points) {
          points = parsePoints(points);
        }

        var polygon = new Polygon({
          shape: {
            points: points || []
          }
        });
        inheritStyle(parentGroup, polygon);
        parseAttributes(xmlNode, polygon, this._defs);
        return polygon;
      },
      'polyline': function (xmlNode, parentGroup) {
        var path = new Path_1();
        inheritStyle(parentGroup, path);
        parseAttributes(xmlNode, path, this._defs);
        var points = xmlNode.getAttribute('points');

        if (points) {
          points = parsePoints(points);
        }

        var polyline = new Polyline({
          shape: {
            points: points || []
          }
        });
        return polyline;
      },
      'image': function (xmlNode, parentGroup) {
        var img = new Image$1();
        inheritStyle(parentGroup, img);
        parseAttributes(xmlNode, img, this._defs);
        img.setStyle({
          image: xmlNode.getAttribute('xlink:href'),
          x: xmlNode.getAttribute('x'),
          y: xmlNode.getAttribute('y'),
          width: xmlNode.getAttribute('width'),
          height: xmlNode.getAttribute('height')
        });
        return img;
      },
      'text': function (xmlNode, parentGroup) {
        var x = xmlNode.getAttribute('x') || 0;
        var y = xmlNode.getAttribute('y') || 0;
        var dx = xmlNode.getAttribute('dx') || 0;
        var dy = xmlNode.getAttribute('dy') || 0;
        this._textX = parseFloat(x) + parseFloat(dx);
        this._textY = parseFloat(y) + parseFloat(dy);
        var g = new Group_1();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defs);
        return g;
      },
      'tspan': function (xmlNode, parentGroup) {
        var x = xmlNode.getAttribute('x');
        var y = xmlNode.getAttribute('y');

        if (x != null) {
          // new offset x
          this._textX = parseFloat(x);
        }

        if (y != null) {
          // new offset y
          this._textY = parseFloat(y);
        }

        var dx = xmlNode.getAttribute('dx') || 0;
        var dy = xmlNode.getAttribute('dy') || 0;
        var g = new Group_1();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defs);
        this._textX += dx;
        this._textY += dy;
        return g;
      },
      'path': function (xmlNode, parentGroup) {
        // TODO svg fill rule
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule
        // path.style.globalCompositeOperation = 'xor';
        var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.

        var path = createFromString$1(d);
        inheritStyle(parentGroup, path);
        parseAttributes(xmlNode, path, this._defs);
        return path;
      }
    };
    var defineParsers = {
      'lineargradient': function (xmlNode) {
        var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);
        var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);
        var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);
        var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);
        var gradient = new LinearGradient_1(x1, y1, x2, y2);

        _parseGradientColorStops(xmlNode, gradient);

        return gradient;
      },
      'radialgradient': function (xmlNode) {}
    };

    function _parseGradientColorStops(xmlNode, gradient) {
      var stop = xmlNode.firstChild;

      while (stop) {
        if (stop.nodeType === 1) {
          var offset = stop.getAttribute('offset');

          if (offset.indexOf('%') > 0) {
            // percentage
            offset = parseInt(offset, 10) / 100;
          } else if (offset) {
            // number from 0 to 1
            offset = parseFloat(offset);
          } else {
            offset = 0;
          }

          var stopColor = stop.getAttribute('stop-color') || '#000000';
          gradient.addColorStop(offset, stopColor);
        }

        stop = stop.nextSibling;
      }
    }

    function inheritStyle(parent, child) {
      if (parent && parent.__inheritedStyle) {
        if (!child.__inheritedStyle) {
          child.__inheritedStyle = {};
        }

        defaults$2(child.__inheritedStyle, parent.__inheritedStyle);
      }
    }

    function parsePoints(pointsString) {
      var list = trim$3(pointsString).split(DILIMITER_REG);
      var points = [];

      for (var i = 0; i < list.length; i += 2) {
        var x = parseFloat(list[i]);
        var y = parseFloat(list[i + 1]);
        points.push([x, y]);
      }

      return points;
    }

    var attributesMap = {
      'fill': 'fill',
      'stroke': 'stroke',
      'stroke-width': 'lineWidth',
      'opacity': 'opacity',
      'fill-opacity': 'fillOpacity',
      'stroke-opacity': 'strokeOpacity',
      'stroke-dasharray': 'lineDash',
      'stroke-dashoffset': 'lineDashOffset',
      'stroke-linecap': 'lineCap',
      'stroke-linejoin': 'lineJoin',
      'stroke-miterlimit': 'miterLimit',
      'font-family': 'fontFamily',
      'font-size': 'fontSize',
      'font-style': 'fontStyle',
      'font-weight': 'fontWeight',
      'text-align': 'textAlign',
      'alignment-baseline': 'textBaseline'
    };

    function parseAttributes(xmlNode, el, defs, onlyInlineStyle) {
      var zrStyle = el.__inheritedStyle || {};
      var isTextEl = el.type === 'text'; // TODO Shadow

      if (xmlNode.nodeType === 1) {
        parseTransformAttribute(xmlNode, el);
        extend$6(zrStyle, parseStyleAttribute(xmlNode));

        if (!onlyInlineStyle) {
          for (var svgAttrName in attributesMap) {
            if (attributesMap.hasOwnProperty(svgAttrName)) {
              var attrValue = xmlNode.getAttribute(svgAttrName);

              if (attrValue != null) {
                zrStyle[attributesMap[svgAttrName]] = attrValue;
              }
            }
          }
        }
      }

      var elFillProp = isTextEl ? 'textFill' : 'fill';
      var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';
      el.style = el.style || new Style_1();
      var elStyle = el.style;
      zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));
      zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));
      each$d(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {
        var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;
        zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));
      });

      if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {
        zrStyle.textBaseline = 'alphabetic';
      }

      if (zrStyle.textBaseline === 'alphabetic') {
        zrStyle.textBaseline = 'bottom';
      }

      if (zrStyle.textAlign === 'start') {
        zrStyle.textAlign = 'left';
      }

      if (zrStyle.textAlign === 'end') {
        zrStyle.textAlign = 'right';
      }

      each$d(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {
        zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);
      });

      if (zrStyle.lineDash) {
        el.style.lineDash = trim$3(zrStyle.lineDash).split(DILIMITER_REG);
      }

      if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {
        // enable stroke
        el[elStrokeProp] = true;
      }

      el.__inheritedStyle = zrStyle;
    }

    var urlRegex = /url\(\s*#(.*?)\)/;

    function getPaint(str, defs) {
      // if (str === 'none') {
      //     return;
      // }
      var urlMatch = defs && str && str.match(urlRegex);

      if (urlMatch) {
        var url = trim$3(urlMatch[1]);
        var def = defs[url];
        return def;
      }

      return str;
    }

    var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;

    function parseTransformAttribute(xmlNode, node) {
      var transform = xmlNode.getAttribute('transform');

      if (transform) {
        transform = transform.replace(/,/g, ' ');
        var m = null;
        var transformOps = [];
        transform.replace(transformRegex, function (str, type, value) {
          transformOps.push(type, value);
        });

        for (var i = transformOps.length - 1; i > 0; i -= 2) {
          var value = transformOps[i];
          var type = transformOps[i - 1];
          m = m || matrix.create();

          switch (type) {
            case 'translate':
              value = trim$3(value).split(DILIMITER_REG);
              matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);
              break;

            case 'scale':
              value = trim$3(value).split(DILIMITER_REG);
              matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);
              break;

            case 'rotate':
              value = trim$3(value).split(DILIMITER_REG);
              matrix.rotate(m, m, parseFloat(value[0]));
              break;

            case 'skew':
              value = trim$3(value).split(DILIMITER_REG);
              console.warn('Skew transform is not supported yet');
              break;

            case 'matrix':
              var value = trim$3(value).split(DILIMITER_REG);
              m[0] = parseFloat(value[0]);
              m[1] = parseFloat(value[1]);
              m[2] = parseFloat(value[2]);
              m[3] = parseFloat(value[3]);
              m[4] = parseFloat(value[4]);
              m[5] = parseFloat(value[5]);
              break;
          }
        }

        node.setLocalTransform(m);
      }
    } // Value may contain space.


    var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;

    function parseStyleAttribute(xmlNode) {
      var style = xmlNode.getAttribute('style');
      var result = {};

      if (!style) {
        return result;
      }

      var styleList = {};
      styleRegex.lastIndex = 0;
      var styleRegResult;

      while ((styleRegResult = styleRegex.exec(style)) != null) {
        styleList[styleRegResult[1]] = styleRegResult[2];
      }

      for (var svgAttrName in attributesMap) {
        if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {
          result[attributesMap[svgAttrName]] = styleList[svgAttrName];
        }
      }

      return result;
    }
    /**
     * @param {Array.<number>} viewBoxRect
     * @param {number} width
     * @param {number} height
     * @return {Object} {scale, position}
     */


    function makeViewBoxTransform(viewBoxRect, width, height) {
      var scaleX = width / viewBoxRect.width;
      var scaleY = height / viewBoxRect.height;
      var scale = Math.min(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'

      var viewBoxScale = [scale, scale];
      var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];
      return {
        scale: viewBoxScale,
        position: viewBoxPosition
      };
    }
    /**
     * @param {string|XMLElement} xml
     * @param {Object} [opt]
     * @param {number} [opt.width] Default width if svg width not specified or is a percent value.
     * @param {number} [opt.height] Default height if svg height not specified or is a percent value.
     * @param {boolean} [opt.ignoreViewBox]
     * @param {boolean} [opt.ignoreRootClip]
     * @return {Object} result:
     * {
     *     root: Group, The root of the the result tree of zrender shapes,
     *     width: number, the viewport width of the SVG,
     *     height: number, the viewport height of the SVG,
     *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,
     *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.
     * }
     */


    function parseSVG(xml, opt) {
      var parser = new SVGParser();
      return parser.parse(xml, opt);
    }

    var parseXML_1 = parseXML;
    var makeViewBoxTransform_1 = makeViewBoxTransform;
    var parseSVG_2 = parseSVG;

    var parseSVG_1 = {
    	parseXML: parseXML_1,
    	makeViewBoxTransform: makeViewBoxTransform_1,
    	parseSVG: parseSVG_2
    };

    var createHashMap$6 = util.createHashMap;
    var isString$7 = util.isString;
    var isArray$7 = util.isArray;
    var each$e = util.each;



    var parseXML$1 = parseSVG_1.parseXML;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var storage = createHashMap$6(); // For minimize the code size of common echarts package,
    // do not put too much logic in this module.

    var _default$1h = {
      // The format of record: see `echarts.registerMap`.
      // Compatible with previous `echarts.registerMap`.
      registerMap: function (mapName, rawGeoJson, rawSpecialAreas) {
        var records;

        if (isArray$7(rawGeoJson)) {
          records = rawGeoJson;
        } else if (rawGeoJson.svg) {
          records = [{
            type: 'svg',
            source: rawGeoJson.svg,
            specialAreas: rawGeoJson.specialAreas
          }];
        } else {
          // Backward compatibility.
          if (rawGeoJson.geoJson && !rawGeoJson.features) {
            rawSpecialAreas = rawGeoJson.specialAreas;
            rawGeoJson = rawGeoJson.geoJson;
          }

          records = [{
            type: 'geoJSON',
            source: rawGeoJson,
            specialAreas: rawSpecialAreas
          }];
        }

        each$e(records, function (record) {
          var type = record.type;
          type === 'geoJson' && (type = record.type = 'geoJSON');
          var parse = parsers[type];
          parse(record);
        });
        return storage.set(mapName, records);
      },
      retrieveMap: function (mapName) {
        return storage.get(mapName);
      }
    };
    var parsers = {
      geoJSON: function (record) {
        var source = record.source;
        record.geoJSON = !isString$7(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();
      },
      // Only perform parse to XML object here, which might be time
      // consiming for large SVG.
      // Although convert XML to zrender element is also time consiming,
      // if we do it here, the clone of zrender elements has to be
      // required. So we do it once for each geo instance, util real
      // performance issues call for optimizing it.
      svg: function (record) {
        record.svgXML = parseXML$1(record.source);
      }
    };
    var mapDataStorage = _default$1h;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function defaultKeyGetter(item) {
      return item;
    }
    /**
     * @param {Array} oldArr
     * @param {Array} newArr
     * @param {Function} oldKeyGetter
     * @param {Function} newKeyGetter
     * @param {Object} [context] Can be visited by this.context in callback.
     */


    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {
      this._old = oldArr;
      this._new = newArr;
      this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
      this._newKeyGetter = newKeyGetter || defaultKeyGetter;
      this.context = context;
    }

    DataDiffer.prototype = {
      constructor: DataDiffer,

      /**
       * Callback function when add a data
       */
      add: function (func) {
        this._add = func;
        return this;
      },

      /**
       * Callback function when update a data
       */
      update: function (func) {
        this._update = func;
        return this;
      },

      /**
       * Callback function when remove a data
       */
      remove: function (func) {
        this._remove = func;
        return this;
      },
      execute: function () {
        var oldArr = this._old;
        var newArr = this._new;
        var oldDataIndexMap = {};
        var newDataIndexMap = {};
        var oldDataKeyArr = [];
        var newDataKeyArr = [];
        var i;
        initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);
        initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this);

        for (i = 0; i < oldArr.length; i++) {
          var key = oldDataKeyArr[i];
          var idx = newDataIndexMap[key]; // idx can never be empty array here. see 'set null' logic below.

          if (idx != null) {
            // Consider there is duplicate key (for example, use dataItem.name as key).
            // We should make sure every item in newArr and oldArr can be visited.
            var len = idx.length;

            if (len) {
              len === 1 && (newDataIndexMap[key] = null);
              idx = idx.shift();
            } else {
              newDataIndexMap[key] = null;
            }

            this._update && this._update(idx, i);
          } else {
            this._remove && this._remove(i);
          }
        }

        for (var i = 0; i < newDataKeyArr.length; i++) {
          var key = newDataKeyArr[i];

          if (newDataIndexMap.hasOwnProperty(key)) {
            var idx = newDataIndexMap[key];

            if (idx == null) {
              continue;
            } // idx can never be empty array here. see 'set null' logic above.


            if (!idx.length) {
              this._add && this._add(idx);
            } else {
              for (var j = 0, len = idx.length; j < len; j++) {
                this._add && this._add(idx[j]);
              }
            }
          }
        }
      }
    };

    function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {
      for (var i = 0; i < arr.length; i++) {
        // Add prefix to avoid conflict with Object.prototype.
        var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);
        var existence = map[key];

        if (existence == null) {
          keyArr.push(key);
          map[key] = i;
        } else {
          if (!existence.length) {
            map[key] = existence = [existence];
          }

          existence.push(i);
        }
      }
    }

    var _default$1i = DataDiffer;
    var DataDiffer_1 = _default$1i;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var each$f = util.each;
    var createHashMap$7 = util.createHashMap;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var OTHER_DIMENSIONS = createHashMap$7(['tooltip', 'label', 'itemName', 'itemId', 'seriesName']);

    function summarizeDimensions(data) {
      var summary = {};
      var encode = summary.encode = {};
      var notExtraCoordDimMap = createHashMap$7();
      var defaultedLabel = [];
      var defaultedTooltip = []; // See the comment of `List.js#userOutput`.

      var userOutput = summary.userOutput = {
        dimensionNames: data.dimensions.slice(),
        encode: {}
      };
      each$f(data.dimensions, function (dimName) {
        var dimItem = data.getDimensionInfo(dimName);
        var coordDim = dimItem.coordDim;

        if (coordDim) {
          var coordDimIndex = dimItem.coordDimIndex;
          getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;

          if (!dimItem.isExtraCoord) {
            notExtraCoordDimMap.set(coordDim, 1); // Use the last coord dim (and label friendly) as default label,
            // because when dataset is used, it is hard to guess which dimension
            // can be value dimension. If both show x, y on label is not look good,
            // and conventionally y axis is focused more.

            if (mayLabelDimType(dimItem.type)) {
              defaultedLabel[0] = dimName;
            } // User output encode do not contain generated coords.
            // And it only has index. User can use index to retrieve value from the raw item array.


            getOrCreateEncodeArr(userOutput.encode, coordDim)[coordDimIndex] = dimItem.index;
          }

          if (dimItem.defaultTooltip) {
            defaultedTooltip.push(dimName);
          }
        }

        OTHER_DIMENSIONS.each(function (v, otherDim) {
          var encodeArr = getOrCreateEncodeArr(encode, otherDim);
          var dimIndex = dimItem.otherDims[otherDim];

          if (dimIndex != null && dimIndex !== false) {
            encodeArr[dimIndex] = dimItem.name;
          }
        });
      });
      var dataDimsOnCoord = [];
      var encodeFirstDimNotExtra = {};
      notExtraCoordDimMap.each(function (v, coordDim) {
        var dimArr = encode[coordDim]; // ??? FIXME extra coord should not be set in dataDimsOnCoord.
        // But should fix the case that radar axes: simplify the logic
        // of `completeDimension`, remove `extraPrefix`.

        encodeFirstDimNotExtra[coordDim] = dimArr[0]; // Not necessary to remove duplicate, because a data
        // dim canot on more than one coordDim.

        dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
      });
      summary.dataDimsOnCoord = dataDimsOnCoord;
      summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
      var encodeLabel = encode.label; // FIXME `encode.label` is not recommanded, because formatter can not be set
      // in this way. Use label.formatter instead. May be remove this approach someday.

      if (encodeLabel && encodeLabel.length) {
        defaultedLabel = encodeLabel.slice();
      }

      var encodeTooltip = encode.tooltip;

      if (encodeTooltip && encodeTooltip.length) {
        defaultedTooltip = encodeTooltip.slice();
      } else if (!defaultedTooltip.length) {
        defaultedTooltip = defaultedLabel.slice();
      }

      encode.defaultedLabel = defaultedLabel;
      encode.defaultedTooltip = defaultedTooltip;
      return summary;
    }

    function getOrCreateEncodeArr(encode, dim) {
      if (!encode.hasOwnProperty(dim)) {
        encode[dim] = [];
      }

      return encode[dim];
    }

    function getDimensionTypeByAxis(axisType) {
      return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';
    }

    function mayLabelDimType(dimType) {
      // In most cases, ordinal and time do not suitable for label.
      // Ordinal info can be displayed on axis. Time is too long.
      return !(dimType === 'ordinal' || dimType === 'time');
    } // function findTheLastDimMayLabel(data) {
    //     // Get last value dim
    //     var dimensions = data.dimensions.slice();
    //     var valueType;
    //     var valueDim;
    //     while (dimensions.length && (
    //         valueDim = dimensions.pop(),
    //         valueType = data.getDimensionInfo(valueDim).type,
    //         valueType === 'ordinal' || valueType === 'time'
    //     )) {} // jshint ignore:line
    //     return valueDim;
    // }


    var OTHER_DIMENSIONS_1 = OTHER_DIMENSIONS;
    var summarizeDimensions_1 = summarizeDimensions;
    var getDimensionTypeByAxis_1 = getDimensionTypeByAxis;

    var dimensionHelper = {
    	OTHER_DIMENSIONS: OTHER_DIMENSIONS_1,
    	summarizeDimensions: summarizeDimensions_1,
    	getDimensionTypeByAxis: getDimensionTypeByAxis_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @class
     * @param {Object|DataDimensionInfo} [opt] All of the fields will be shallow copied.
     */
    function DataDimensionInfo(opt) {
      if (opt != null) {
        util.extend(this, opt);
      }
      /**
       * Dimension name.
       * Mandatory.
       * @type {string}
       */
      // this.name;

      /**
       * The origin name in dimsDef, see source helper.
       * If displayName given, the tooltip will displayed vertically.
       * Optional.
       * @type {string}
       */
      // this.displayName;

      /**
       * Which coordSys dimension this dimension mapped to.
       * A `coordDim` can be a "coordSysDim" that the coordSys required
       * (for example, an item in `coordSysDims` of `model/referHelper#CoordSysInfo`),
       * or an generated "extra coord name" if does not mapped to any "coordSysDim"
       * (That is determined by whether `isExtraCoord` is `true`).
       * Mandatory.
       * @type {string}
       */
      // this.coordDim;

      /**
       * The index of this dimension in `series.encode[coordDim]`.
       * Mandatory.
       * @type {number}
       */
      // this.coordDimIndex;

      /**
       * Dimension type. The enumerable values are the key of
       * `dataCtors` of `data/List`.
       * Optional.
       * @type {string}
       */
      // this.type;

      /**
       * This index of this dimension info in `data/List#_dimensionInfos`.
       * Mandatory after added to `data/List`.
       * @type {number}
       */
      // this.index;

      /**
       * The format of `otherDims` is:
       * ```js
       * {
       *     tooltip: number optional,
       *     label: number optional,
       *     itemName: number optional,
       *     seriesName: number optional,
       * }
       * ```
       *
       * A `series.encode` can specified these fields:
       * ```js
       * encode: {
       *     // "3, 1, 5" is the index of data dimension.
       *     tooltip: [3, 1, 5],
       *     label: [0, 3],
       *     ...
       * }
       * ```
       * `otherDims` is the parse result of the `series.encode` above, like:
       * ```js
       * // Suppose the index of this data dimension is `3`.
       * this.otherDims = {
       *     // `3` is at the index `0` of the `encode.tooltip`
       *     tooltip: 0,
       *     // `3` is at the index `1` of the `encode.tooltip`
       *     label: 1
       * };
       * ```
       *
       * This prop should never be `null`/`undefined` after initialized.
       * @type {Object}
       */


      this.otherDims = {};
      /**
       * Be `true` if this dimension is not mapped to any "coordSysDim" that the
       * "coordSys" required.
       * Mandatory.
       * @type {boolean}
       */
      // this.isExtraCoord;

      /**
       * @type {module:data/OrdinalMeta}
       */
      // this.ordinalMeta;

      /**
       * Whether to create inverted indices.
       * @type {boolean}
       */
      // this.createInvertedIndices;
    }
    var _default$1j = DataDimensionInfo;
    var DataDimensionInfo_1 = _default$1j;

    var defaultDimValueGetters$1 = dataProvider.defaultDimValueGetters;
    var DefaultDataProvider$1 = dataProvider.DefaultDataProvider;



    var summarizeDimensions$1 = dimensionHelper.summarizeDimensions;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /* global Float64Array, Int32Array, Uint32Array, Uint16Array */

    /**
     * List for data storage
     * @module echarts/data/List
     */
    var isObject$a = util.isObject;
    var UNDEFINED = 'undefined';
    var INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],
    // which will cause weird udpate animation.

    var ID_PREFIX = 'e\0\0';
    var dataCtors = {
      'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,
      'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,
      // Ordinal data type can be string or int
      'ordinal': Array,
      'number': Array,
      'time': Array
    }; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is
    // different from the Ctor of typed array.

    var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
    var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
    var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;

    function getIndicesCtor(list) {
      // The possible max value in this._indicies is always this._rawCount despite of filtering.
      return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
    }

    function cloneChunk(originalChunk) {
      var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.

      return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
    }

    var TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];
    var CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];

    function transferProperties(target, source) {
      util.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {
        if (source.hasOwnProperty(propName)) {
          target[propName] = source[propName];
        }
      });
      target.__wrappedMethods = source.__wrappedMethods;
      util.each(CLONE_PROPERTIES, function (propName) {
        target[propName] = util.clone(source[propName]);
      });
      target._calculationInfo = util.extend(source._calculationInfo);
    }
    /**
     * @constructor
     * @alias module:echarts/data/List
     *
     * @param {Array.<string|Object|module:data/DataDimensionInfo>} dimensions
     *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
     *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
     * @param {module:echarts/model/Model} hostModel
     */


    var List = function (dimensions, hostModel) {
      dimensions = dimensions || ['x', 'y'];
      var dimensionInfos = {};
      var dimensionNames = [];
      var invertedIndicesMap = {};

      for (var i = 0; i < dimensions.length; i++) {
        // Use the original dimensions[i], where other flag props may exists.
        var dimensionInfo = dimensions[i];

        if (util.isString(dimensionInfo)) {
          dimensionInfo = new DataDimensionInfo_1({
            name: dimensionInfo
          });
        } else if (!(dimensionInfo instanceof DataDimensionInfo_1)) {
          dimensionInfo = new DataDimensionInfo_1(dimensionInfo);
        }

        var dimensionName = dimensionInfo.name;
        dimensionInfo.type = dimensionInfo.type || 'float';

        if (!dimensionInfo.coordDim) {
          dimensionInfo.coordDim = dimensionName;
          dimensionInfo.coordDimIndex = 0;
        }

        dimensionInfo.otherDims = dimensionInfo.otherDims || {};
        dimensionNames.push(dimensionName);
        dimensionInfos[dimensionName] = dimensionInfo;
        dimensionInfo.index = i;

        if (dimensionInfo.createInvertedIndices) {
          invertedIndicesMap[dimensionName] = [];
        }
      }
      /**
       * @readOnly
       * @type {Array.<string>}
       */


      this.dimensions = dimensionNames;
      /**
       * Infomation of each data dimension, like data type.
       * @type {Object}
       */

      this._dimensionInfos = dimensionInfos;
      /**
       * @type {module:echarts/model/Model}
       */

      this.hostModel = hostModel;
      /**
       * @type {module:echarts/model/Model}
       */

      this.dataType;
      /**
       * Indices stores the indices of data subset after filtered.
       * This data subset will be used in chart.
       * @type {Array.<number>}
       * @readOnly
       */

      this._indices = null;
      this._count = 0;
      this._rawCount = 0;
      /**
       * Data storage
       * @type {Object.<key, Array.<TypedArray|Array>>}
       * @private
       */

      this._storage = {};
      /**
       * @type {Array.<string>}
       */

      this._nameList = [];
      /**
       * @type {Array.<string>}
       */

      this._idList = [];
      /**
       * Models of data option is stored sparse for optimizing memory cost
       * @type {Array.<module:echarts/model/Model>}
       * @private
       */

      this._optionModels = [];
      /**
       * Global visual properties after visual coding
       * @type {Object}
       * @private
       */

      this._visual = {};
      /**
       * Globel layout properties.
       * @type {Object}
       * @private
       */

      this._layout = {};
      /**
       * Item visual properties after visual coding
       * @type {Array.<Object>}
       * @private
       */

      this._itemVisuals = [];
      /**
       * Key: visual type, Value: boolean
       * @type {Object}
       * @readOnly
       */

      this.hasItemVisual = {};
      /**
       * Item layout properties after layout
       * @type {Array.<Object>}
       * @private
       */

      this._itemLayouts = [];
      /**
       * Graphic elemnents
       * @type {Array.<module:zrender/Element>}
       * @private
       */

      this._graphicEls = [];
      /**
       * Max size of each chunk.
       * @type {number}
       * @private
       */

      this._chunkSize = 1e5;
      /**
       * @type {number}
       * @private
       */

      this._chunkCount = 0;
      /**
       * @type {Array.<Array|Object>}
       * @private
       */

      this._rawData;
      /**
       * Raw extent will not be cloned, but only transfered.
       * It will not be calculated util needed.
       * key: dim,
       * value: {end: number, extent: Array.<number>}
       * @type {Object}
       * @private
       */

      this._rawExtent = {};
      /**
       * @type {Object}
       * @private
       */

      this._extent = {};
      /**
       * key: dim
       * value: extent
       * @type {Object}
       * @private
       */

      this._approximateExtent = {};
      /**
       * Cache summary info for fast visit. See "dimensionHelper".
       * @type {Object}
       * @private
       */

      this._dimensionsSummary = summarizeDimensions$1(this);
      /**
       * @type {Object.<Array|TypedArray>}
       * @private
       */

      this._invertedIndicesMap = invertedIndicesMap;
      /**
       * @type {Object}
       * @private
       */

      this._calculationInfo = {};
      /**
       * User output info of this data.
       * DO NOT use it in other places!
       *
       * When preparing user params for user callbacks, we have
       * to clone these inner data structures to prevent users
       * from modifying them to effect built-in logic. And for
       * performance consideration we make this `userOutput` to
       * avoid clone them too many times.
       *
       * @type {Object}
       * @readOnly
       */

      this.userOutput = this._dimensionsSummary.userOutput;
    };

    var listProto = List.prototype;
    listProto.type = 'list';
    /**
     * If each data item has it's own option
     * @type {boolean}
     */

    listProto.hasItemOption = true;
    /**
     * The meanings of the input parameter `dim`:
     *
     * + If dim is a number (e.g., `1`), it means the index of the dimension.
     *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.
     * + If dim is a number-like string (e.g., `"1"`):
     *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.
     *     + If not, it will be converted to a number, which means the index of the dimension.
     *        (why? because of the backward compatbility. We have been tolerating number-like string in
     *        dimension setting, although now it seems that it is not a good idea.)
     *     For example, `visualMap[i].dimension: "1"` is the same meaning as `visualMap[i].dimension: 1`,
     *     if no dimension name is defined as `"1"`.
     * + If dim is a not-number-like string, it means the concrete dim name.
     *   For example, it can be be default name `"x"`, `"y"`, `"z"`, `"lng"`, `"lat"`, `"angle"`, `"radius"`,
     *   or customized in `dimensions` property of option like `"age"`.
     *
     * Get dimension name
     * @param {string|number} dim See above.
     * @return {string} Concrete dim name.
     */

    listProto.getDimension = function (dim) {
      if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.
      || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {
        dim = this.dimensions[dim];
      }

      return dim;
    };
    /**
     * Get type and calculation info of particular dimension
     * @param {string|number} dim
     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
     */


    listProto.getDimensionInfo = function (dim) {
      // Do not clone, because there may be categories in dimInfo.
      return this._dimensionInfos[this.getDimension(dim)];
    };
    /**
     * @return {Array.<string>} concrete dimension name list on coord.
     */


    listProto.getDimensionsOnCoord = function () {
      return this._dimensionsSummary.dataDimsOnCoord.slice();
    };
    /**
     * @param {string} coordDim
     * @param {number} [idx] A coordDim may map to more than one data dim.
     *        If idx is `true`, return a array of all mapped dims.
     *        If idx is not specified, return the first dim not extra.
     * @return {string|Array.<string>} concrete data dim.
     *        If idx is number, and not found, return null/undefined.
     *        If idx is `true`, and not found, return empty array (always return array).
     */


    listProto.mapDimension = function (coordDim, idx) {
      var dimensionsSummary = this._dimensionsSummary;

      if (idx == null) {
        return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
      }

      var dims = dimensionsSummary.encode[coordDim];
      return idx === true // always return array if idx is `true`
      ? (dims || []).slice() : dims && dims[idx];
    };
    /**
     * Initialize from data
     * @param {Array.<Object|number|Array>} data source or data or data provider.
     * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and
     *        defualt label/tooltip.
     *        A name can be specified in encode.itemName,
     *        or dataItem.name (only for series option data),
     *        or provided in nameList from outside.
     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number
     */


    listProto.initData = function (data, nameList, dimValueGetter) {
      var notProvider = Source_1.isInstance(data) || util.isArrayLike(data);

      if (notProvider) {
        data = new DefaultDataProvider$1(data, this.dimensions.length);
      }

      this._rawData = data; // Clear

      this._storage = {};
      this._indices = null;
      this._nameList = nameList || [];
      this._idList = [];
      this._nameRepeatCount = {};

      if (!dimValueGetter) {
        this.hasItemOption = false;
      }
      /**
       * @readOnly
       */


      this.defaultDimValueGetter = defaultDimValueGetters$1[this._rawData.getSource().sourceFormat]; // Default dim value getter

      this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;
      this._dimValueGetterArrayRows = defaultDimValueGetters$1.arrayRows; // Reset raw extent.

      this._rawExtent = {};

      this._initDataFromProvider(0, data.count()); // If data has no item option.


      if (data.pure) {
        this.hasItemOption = false;
      }
    };

    listProto.getProvider = function () {
      return this._rawData;
    };
    /**
     * Caution: Can be only called on raw data (before `this._indices` created).
     */


    listProto.appendData = function (data) {
      var rawData = this._rawData;
      var start = this.count();
      rawData.appendData(data);
      var end = rawData.count();

      if (!rawData.persistent) {
        end += start;
      }

      this._initDataFromProvider(start, end);
    };
    /**
     * Caution: Can be only called on raw data (before `this._indices` created).
     * This method does not modify `rawData` (`dataProvider`), but only
     * add values to storage.
     *
     * The final count will be increased by `Math.max(values.length, names.length)`.
     *
     * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like
     *        [
     *            [12, 33, 44],
     *            [NaN, 43, 1],
     *            ['-', 'asdf', 0]
     *        ]
     *        Each item is exaclty cooresponding to a dimension.
     * @param {Array.<string>} [names]
     */


    listProto.appendValues = function (values, names) {
      var chunkSize = this._chunkSize;
      var storage = this._storage;
      var dimensions = this.dimensions;
      var dimLen = dimensions.length;
      var rawExtent = this._rawExtent;
      var start = this.count();
      var end = start + Math.max(values.length, names ? names.length : 0);
      var originalChunkCount = this._chunkCount;

      for (var i = 0; i < dimLen; i++) {
        var dim = dimensions[i];

        if (!rawExtent[dim]) {
          rawExtent[dim] = getInitialExtent();
        }

        if (!storage[dim]) {
          storage[dim] = [];
        }

        prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);
        this._chunkCount = storage[dim].length;
      }

      var emptyDataItem = new Array(dimLen);

      for (var idx = start; idx < end; idx++) {
        var sourceIdx = idx - start;
        var chunkIndex = Math.floor(idx / chunkSize);
        var chunkOffset = idx % chunkSize; // Store the data by dimensions

        for (var k = 0; k < dimLen; k++) {
          var dim = dimensions[k];

          var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);

          storage[dim][chunkIndex][chunkOffset] = val;
          var dimRawExtent = rawExtent[dim];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }

        if (names) {
          this._nameList[idx] = names[sourceIdx];
        }
      }

      this._rawCount = this._count = end; // Reset data extent

      this._extent = {};
      prepareInvertedIndex(this);
    };

    listProto._initDataFromProvider = function (start, end) {
      // Optimize.
      if (start >= end) {
        return;
      }

      var chunkSize = this._chunkSize;
      var rawData = this._rawData;
      var storage = this._storage;
      var dimensions = this.dimensions;
      var dimLen = dimensions.length;
      var dimensionInfoMap = this._dimensionInfos;
      var nameList = this._nameList;
      var idList = this._idList;
      var rawExtent = this._rawExtent;
      var nameRepeatCount = this._nameRepeatCount = {};
      var nameDimIdx;
      var originalChunkCount = this._chunkCount;

      for (var i = 0; i < dimLen; i++) {
        var dim = dimensions[i];

        if (!rawExtent[dim]) {
          rawExtent[dim] = getInitialExtent();
        }

        var dimInfo = dimensionInfoMap[dim];

        if (dimInfo.otherDims.itemName === 0) {
          nameDimIdx = this._nameDimIdx = i;
        }

        if (dimInfo.otherDims.itemId === 0) {
          this._idDimIdx = i;
        }

        if (!storage[dim]) {
          storage[dim] = [];
        }

        prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);
        this._chunkCount = storage[dim].length;
      }

      var dataItem = new Array(dimLen);

      for (var idx = start; idx < end; idx++) {
        // NOTICE: Try not to write things into dataItem
        dataItem = rawData.getItem(idx, dataItem); // Each data item is value
        // [1, 2]
        // 2
        // Bar chart, line chart which uses category axis
        // only gives the 'y' value. 'x' value is the indices of category
        // Use a tempValue to normalize the value to be a (x, y) value

        var chunkIndex = Math.floor(idx / chunkSize);
        var chunkOffset = idx % chunkSize; // Store the data by dimensions

        for (var k = 0; k < dimLen; k++) {
          var dim = dimensions[k];
          var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero

          var val = this._dimValueGetter(dataItem, dim, idx, k);

          dimStorage[chunkOffset] = val;
          var dimRawExtent = rawExtent[dim];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        } // ??? FIXME not check by pure but sourceFormat?
        // TODO refactor these logic.


        if (!rawData.pure) {
          var name = nameList[idx];

          if (dataItem && name == null) {
            // If dataItem is {name: ...}, it has highest priority.
            // That is appropriate for many common cases.
            if (dataItem.name != null) {
              // There is no other place to persistent dataItem.name,
              // so save it to nameList.
              nameList[idx] = name = dataItem.name;
            } else if (nameDimIdx != null) {
              var nameDim = dimensions[nameDimIdx];
              var nameDimChunk = storage[nameDim][chunkIndex];

              if (nameDimChunk) {
                name = nameDimChunk[chunkOffset];
                var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;

                if (ordinalMeta && ordinalMeta.categories.length) {
                  name = ordinalMeta.categories[name];
                }
              }
            }
          } // Try using the id in option
          // id or name is used on dynamical data, mapping old and new items.


          var id = dataItem == null ? null : dataItem.id;

          if (id == null && name != null) {
            // Use name as id and add counter to avoid same name
            nameRepeatCount[name] = nameRepeatCount[name] || 0;
            id = name;

            if (nameRepeatCount[name] > 0) {
              id += '__ec__' + nameRepeatCount[name];
            }

            nameRepeatCount[name]++;
          }

          id != null && (idList[idx] = id);
        }
      }

      if (!rawData.persistent && rawData.clean) {
        // Clean unused data if data source is typed array.
        rawData.clean();
      }

      this._rawCount = this._count = end; // Reset data extent

      this._extent = {};
      prepareInvertedIndex(this);
    };

    function prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {
      var DataCtor = dataCtors[dimInfo.type];
      var lastChunkIndex = chunkCount - 1;
      var dim = dimInfo.name;
      var resizeChunkArray = storage[dim][lastChunkIndex];

      if (resizeChunkArray && resizeChunkArray.length < chunkSize) {
        var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable
        // within the initial chunkSize.

        for (var j = 0; j < resizeChunkArray.length; j++) {
          newStore[j] = resizeChunkArray[j];
        }

        storage[dim][lastChunkIndex] = newStore;
      } // Create new chunks.


      for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {
        storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));
      }
    }

    function prepareInvertedIndex(list) {
      var invertedIndicesMap = list._invertedIndicesMap;
      util.each(invertedIndicesMap, function (invertedIndices, dim) {
        var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.

        var ordinalMeta = dimInfo.ordinalMeta;

        if (ordinalMeta) {
          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss
          // mapping to 0, we should set it as INDEX_NOT_FOUND.

          for (var i = 0; i < invertedIndices.length; i++) {
            invertedIndices[i] = INDEX_NOT_FOUND;
          }

          for (var i = 0; i < list._count; i++) {
            // Only support the case that all values are distinct.
            invertedIndices[list.get(dim, i)] = i;
          }
        }
      });
    }

    function getRawValueFromStore(list, dimIndex, rawIndex) {
      var val;

      if (dimIndex != null) {
        var chunkSize = list._chunkSize;
        var chunkIndex = Math.floor(rawIndex / chunkSize);
        var chunkOffset = rawIndex % chunkSize;
        var dim = list.dimensions[dimIndex];
        var chunk = list._storage[dim][chunkIndex];

        if (chunk) {
          val = chunk[chunkOffset];
          var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;

          if (ordinalMeta && ordinalMeta.categories.length) {
            val = ordinalMeta.categories[val];
          }
        }
      }

      return val;
    }
    /**
     * @return {number}
     */


    listProto.count = function () {
      return this._count;
    };

    listProto.getIndices = function () {
      var newIndices;
      var indices = this._indices;

      if (indices) {
        var Ctor = indices.constructor;
        var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.

        if (Ctor === Array) {
          newIndices = new Ctor(thisCount);

          for (var i = 0; i < thisCount; i++) {
            newIndices[i] = indices[i];
          }
        } else {
          newIndices = new Ctor(indices.buffer, 0, thisCount);
        }
      } else {
        var Ctor = getIndicesCtor(this);
        var newIndices = new Ctor(this.count());

        for (var i = 0; i < newIndices.length; i++) {
          newIndices[i] = i;
        }
      }

      return newIndices;
    };
    /**
     * Get value. Return NaN if idx is out of range.
     * @param {string} dim Dim must be concrete name.
     * @param {number} idx
     * @param {boolean} stack
     * @return {number}
     */


    listProto.get = function (dim, idx
    /*, stack */
    ) {
      if (!(idx >= 0 && idx < this._count)) {
        return NaN;
      }

      var storage = this._storage;

      if (!storage[dim]) {
        // TODO Warn ?
        return NaN;
      }

      idx = this.getRawIndex(idx);
      var chunkIndex = Math.floor(idx / this._chunkSize);
      var chunkOffset = idx % this._chunkSize;
      var chunkStore = storage[dim][chunkIndex];
      var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable
      // if (stack) {
      //     var dimensionInfo = this._dimensionInfos[dim];
      //     if (dimensionInfo && dimensionInfo.stackable) {
      //         var stackedOn = this.stackedOn;
      //         while (stackedOn) {
      //             // Get no stacked data of stacked on
      //             var stackedValue = stackedOn.get(dim, idx);
      //             // Considering positive stack, negative stack and empty data
      //             if ((value >= 0 && stackedValue > 0)  // Positive stack
      //                 || (value <= 0 && stackedValue < 0) // Negative stack
      //             ) {
      //                 value += stackedValue;
      //             }
      //             stackedOn = stackedOn.stackedOn;
      //         }
      //     }
      // }

      return value;
    };
    /**
     * @param {string} dim concrete dim
     * @param {number} rawIndex
     * @return {number|string}
     */


    listProto.getByRawIndex = function (dim, rawIdx) {
      if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
        return NaN;
      }

      var dimStore = this._storage[dim];

      if (!dimStore) {
        // TODO Warn ?
        return NaN;
      }

      var chunkIndex = Math.floor(rawIdx / this._chunkSize);
      var chunkOffset = rawIdx % this._chunkSize;
      var chunkStore = dimStore[chunkIndex];
      return chunkStore[chunkOffset];
    };
    /**
     * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).
     * Hack a much simpler _getFast
     * @private
     */


    listProto._getFast = function (dim, rawIdx) {
      var chunkIndex = Math.floor(rawIdx / this._chunkSize);
      var chunkOffset = rawIdx % this._chunkSize;
      var chunkStore = this._storage[dim][chunkIndex];
      return chunkStore[chunkOffset];
    };
    /**
     * Get value for multi dimensions.
     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.
     * @param {number} idx
     * @return {number}
     */


    listProto.getValues = function (dimensions, idx
    /*, stack */
    ) {
      var values = [];

      if (!util.isArray(dimensions)) {
        // stack = idx;
        idx = dimensions;
        dimensions = this.dimensions;
      }

      for (var i = 0, len = dimensions.length; i < len; i++) {
        values.push(this.get(dimensions[i], idx
        /*, stack */
        ));
      }

      return values;
    };
    /**
     * If value is NaN. Inlcuding '-'
     * Only check the coord dimensions.
     * @param {string} dim
     * @param {number} idx
     * @return {number}
     */


    listProto.hasValue = function (idx) {
      var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;

      for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {
        // Ordinal type originally can be string or number.
        // But when an ordinal type is used on coord, it can
        // not be string but only number. So we can also use isNaN.
        if (isNaN(this.get(dataDimsOnCoord[i], idx))) {
          return false;
        }
      }

      return true;
    };
    /**
     * Get extent of data in one dimension
     * @param {string} dim
     * @param {boolean} stack
     */


    listProto.getDataExtent = function (dim
    /*, stack */
    ) {
      // Make sure use concrete dim as cache name.
      dim = this.getDimension(dim);
      var dimData = this._storage[dim];
      var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));

      if (!dimData) {
        return initialExtent;
      } // Make more strict checkings to ensure hitting cache.


      var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');
      // var cacheName = dim;
      // Consider the most cases when using data zoom, `getDataExtent`
      // happened before filtering. We cache raw extent, which is not
      // necessary to be cleared and recalculated when restore data.

      var useRaw = !this._indices; // && !stack;

      var dimExtent;

      if (useRaw) {
        return this._rawExtent[dim].slice();
      }

      dimExtent = this._extent[dim];

      if (dimExtent) {
        return dimExtent.slice();
      }

      dimExtent = initialExtent;
      var min = dimExtent[0];
      var max = dimExtent[1];

      for (var i = 0; i < currEnd; i++) {
        // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));
        var value = this._getFast(dim, this.getRawIndex(i));

        value < min && (min = value);
        value > max && (max = value);
      }

      dimExtent = [min, max];
      this._extent[dim] = dimExtent;
      return dimExtent;
    };
    /**
     * Optimize for the scenario that data is filtered by a given extent.
     * Consider that if data amount is more than hundreds of thousand,
     * extent calculation will cost more than 10ms and the cache will
     * be erased because of the filtering.
     */


    listProto.getApproximateExtent = function (dim
    /*, stack */
    ) {
      dim = this.getDimension(dim);
      return this._approximateExtent[dim] || this.getDataExtent(dim
      /*, stack */
      );
    };

    listProto.setApproximateExtent = function (extent, dim
    /*, stack */
    ) {
      dim = this.getDimension(dim);
      this._approximateExtent[dim] = extent.slice();
    };
    /**
     * @param {string} key
     * @return {*}
     */


    listProto.getCalculationInfo = function (key) {
      return this._calculationInfo[key];
    };
    /**
     * @param {string|Object} key or k-v object
     * @param {*} [value]
     */


    listProto.setCalculationInfo = function (key, value) {
      isObject$a(key) ? util.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
    };
    /**
     * Get sum of data in one dimension
     * @param {string} dim
     */


    listProto.getSum = function (dim
    /*, stack */
    ) {
      var dimData = this._storage[dim];
      var sum = 0;

      if (dimData) {
        for (var i = 0, len = this.count(); i < len; i++) {
          var value = this.get(dim, i
          /*, stack */
          );

          if (!isNaN(value)) {
            sum += value;
          }
        }
      }

      return sum;
    };
    /**
     * Get median of data in one dimension
     * @param {string} dim
     */


    listProto.getMedian = function (dim
    /*, stack */
    ) {
      var dimDataArray = []; // map all data of one dimension

      this.each(dim, function (val, idx) {
        if (!isNaN(val)) {
          dimDataArray.push(val);
        }
      }); // TODO
      // Use quick select?
      // immutability & sort

      var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {
        return a - b;
      });
      var len = this.count(); // calculate median

      return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;
    }; // /**
    //  * Retreive the index with given value
    //  * @param {string} dim Concrete dimension.
    //  * @param {number} value
    //  * @return {number}
    //  */
    // Currently incorrect: should return dataIndex but not rawIndex.
    // Do not fix it until this method is to be used somewhere.
    // FIXME Precision of float value
    // listProto.indexOf = function (dim, value) {
    //     var storage = this._storage;
    //     var dimData = storage[dim];
    //     var chunkSize = this._chunkSize;
    //     if (dimData) {
    //         for (var i = 0, len = this.count(); i < len; i++) {
    //             var chunkIndex = Math.floor(i / chunkSize);
    //             var chunkOffset = i % chunkSize;
    //             if (dimData[chunkIndex][chunkOffset] === value) {
    //                 return i;
    //             }
    //         }
    //     }
    //     return -1;
    // };

    /**
     * Only support the dimension which inverted index created.
     * Do not support other cases until required.
     * @param {string} concrete dim
     * @param {number|string} value
     * @return {number} rawIndex
     */


    listProto.rawIndexOf = function (dim, value) {
      var invertedIndices = dim && this._invertedIndicesMap[dim];
      var rawIndex = invertedIndices[value];

      if (rawIndex == null || isNaN(rawIndex)) {
        return INDEX_NOT_FOUND;
      }

      return rawIndex;
    };
    /**
     * Retreive the index with given name
     * @param {number} idx
     * @param {number} name
     * @return {number}
     */


    listProto.indexOfName = function (name) {
      for (var i = 0, len = this.count(); i < len; i++) {
        if (this.getName(i) === name) {
          return i;
        }
      }

      return -1;
    };
    /**
     * Retreive the index with given raw data index
     * @param {number} idx
     * @param {number} name
     * @return {number}
     */


    listProto.indexOfRawIndex = function (rawIndex) {
      if (rawIndex >= this._rawCount || rawIndex < 0) {
        return -1;
      }

      if (!this._indices) {
        return rawIndex;
      } // Indices are ascending


      var indices = this._indices; // If rawIndex === dataIndex

      var rawDataIndex = indices[rawIndex];

      if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
        return rawIndex;
      }

      var left = 0;
      var right = this._count - 1;

      while (left <= right) {
        var mid = (left + right) / 2 | 0;

        if (indices[mid] < rawIndex) {
          left = mid + 1;
        } else if (indices[mid] > rawIndex) {
          right = mid - 1;
        } else {
          return mid;
        }
      }

      return -1;
    };
    /**
     * Retreive the index of nearest value
     * @param {string} dim
     * @param {number} value
     * @param {number} [maxDistance=Infinity]
     * @return {Array.<number>} If and only if multiple indices has
     *        the same value, they are put to the result.
     */


    listProto.indicesOfNearest = function (dim, value, maxDistance) {
      var storage = this._storage;
      var dimData = storage[dim];
      var nearestIndices = [];

      if (!dimData) {
        return nearestIndices;
      }

      if (maxDistance == null) {
        maxDistance = Infinity;
      }

      var minDist = Infinity;
      var minDiff = -1;
      var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/List.js`.

      for (var i = 0, len = this.count(); i < len; i++) {
        var diff = value - this.get(dim, i);
        var dist = Math.abs(diff);

        if (dist <= maxDistance) {
          // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,
          // we'd better not push both of them to `nearestIndices`, otherwise it is easy to
          // get more than one item in `nearestIndices` (more specifically, in `tooltip`).
          // So we chose the one that `diff >= 0` in this csae.
          // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them
          // should be push to `nearestIndices`.
          if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {
            minDist = dist;
            minDiff = diff;
            nearestIndicesLen = 0;
          }

          if (diff === minDiff) {
            nearestIndices[nearestIndicesLen++] = i;
          }
        }
      }

      nearestIndices.length = nearestIndicesLen;
      return nearestIndices;
    };
    /**
     * Get raw data index
     * @param {number} idx
     * @return {number}
     */


    listProto.getRawIndex = getRawIndexWithoutIndices;

    function getRawIndexWithoutIndices(idx) {
      return idx;
    }

    function getRawIndexWithIndices(idx) {
      if (idx < this._count && idx >= 0) {
        return this._indices[idx];
      }

      return -1;
    }
    /**
     * Get raw data item
     * @param {number} idx
     * @return {number}
     */


    listProto.getRawDataItem = function (idx) {
      if (!this._rawData.persistent) {
        var val = [];

        for (var i = 0; i < this.dimensions.length; i++) {
          var dim = this.dimensions[i];
          val.push(this.get(dim, idx));
        }

        return val;
      } else {
        return this._rawData.getItem(this.getRawIndex(idx));
      }
    };
    /**
     * @param {number} idx
     * @param {boolean} [notDefaultIdx=false]
     * @return {string}
     */


    listProto.getName = function (idx) {
      var rawIndex = this.getRawIndex(idx);
      return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';
    };
    /**
     * @param {number} idx
     * @param {boolean} [notDefaultIdx=false]
     * @return {string}
     */


    listProto.getId = function (idx) {
      return getId(this, this.getRawIndex(idx));
    };

    function getId(list, rawIndex) {
      var id = list._idList[rawIndex];

      if (id == null) {
        id = getRawValueFromStore(list, list._idDimIdx, rawIndex);
      }

      if (id == null) {
        // FIXME Check the usage in graph, should not use prefix.
        id = ID_PREFIX + rawIndex;
      }

      return id;
    }

    function normalizeDimensions(dimensions) {
      if (!util.isArray(dimensions)) {
        dimensions = [dimensions];
      }

      return dimensions;
    }
    /**
     * Data iteration
     * @param {string|Array.<string>}
     * @param {Function} cb
     * @param {*} [context=this]
     *
     * @example
     *  list.each('x', function (x, idx) {});
     *  list.each(['x', 'y'], function (x, y, idx) {});
     *  list.each(function (idx) {})
     */


    listProto.each = function (dims, cb, context, contextCompat) {

      if (!this._count) {
        return;
      }

      if (typeof dims === 'function') {
        contextCompat = context;
        context = cb;
        cb = dims;
        dims = [];
      } // contextCompat just for compat echarts3


      context = context || contextCompat || this;
      dims = util.map(normalizeDimensions(dims), this.getDimension, this);
      var dimSize = dims.length;

      for (var i = 0; i < this.count(); i++) {
        // Simple optimization
        switch (dimSize) {
          case 0:
            cb.call(context, i);
            break;

          case 1:
            cb.call(context, this.get(dims[0], i), i);
            break;

          case 2:
            cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);
            break;

          default:
            var k = 0;
            var value = [];

            for (; k < dimSize; k++) {
              value[k] = this.get(dims[k], i);
            } // Index


            value[k] = i;
            cb.apply(context, value);
        }
      }
    };
    /**
     * Data filter
     * @param {string|Array.<string>}
     * @param {Function} cb
     * @param {*} [context=this]
     */


    listProto.filterSelf = function (dimensions, cb, context, contextCompat) {

      if (!this._count) {
        return;
      }

      if (typeof dimensions === 'function') {
        contextCompat = context;
        context = cb;
        cb = dimensions;
        dimensions = [];
      } // contextCompat just for compat echarts3


      context = context || contextCompat || this;
      dimensions = util.map(normalizeDimensions(dimensions), this.getDimension, this);
      var count = this.count();
      var Ctor = getIndicesCtor(this);
      var newIndices = new Ctor(count);
      var value = [];
      var dimSize = dimensions.length;
      var offset = 0;
      var dim0 = dimensions[0];

      for (var i = 0; i < count; i++) {
        var keep;
        var rawIdx = this.getRawIndex(i); // Simple optimization

        if (dimSize === 0) {
          keep = cb.call(context, i);
        } else if (dimSize === 1) {
          var val = this._getFast(dim0, rawIdx);

          keep = cb.call(context, val, i);
        } else {
          for (var k = 0; k < dimSize; k++) {
            value[k] = this._getFast(dim0, rawIdx);
          }

          value[k] = i;
          keep = cb.apply(context, value);
        }

        if (keep) {
          newIndices[offset++] = rawIdx;
        }
      } // Set indices after filtered.


      if (offset < count) {
        this._indices = newIndices;
      }

      this._count = offset; // Reset data extent

      this._extent = {};
      this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      return this;
    };
    /**
     * Select data in range. (For optimization of filter)
     * (Manually inline code, support 5 million data filtering in data zoom.)
     */


    listProto.selectRange = function (range) {

      if (!this._count) {
        return;
      }

      var dimensions = [];

      for (var dim in range) {
        if (range.hasOwnProperty(dim)) {
          dimensions.push(dim);
        }
      }

      var dimSize = dimensions.length;

      if (!dimSize) {
        return;
      }

      var originalCount = this.count();
      var Ctor = getIndicesCtor(this);
      var newIndices = new Ctor(originalCount);
      var offset = 0;
      var dim0 = dimensions[0];
      var min = range[dim0][0];
      var max = range[dim0][1];
      var quickFinished = false;

      if (!this._indices) {
        // Extreme optimization for common case. About 2x faster in chrome.
        var idx = 0;

        if (dimSize === 1) {
          var dimStorage = this._storage[dimensions[0]];

          for (var k = 0; k < this._chunkCount; k++) {
            var chunkStorage = dimStorage[k];
            var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);

            for (var i = 0; i < len; i++) {
              var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty
              // value indicates the line should be broken. But for the case like
              // scatter plot, a data item with empty value will not be rendered,
              // but the axis extent may be effected if some other dim of the data
              // item has value. Fortunately it is not a significant negative effect.

              if (val >= min && val <= max || isNaN(val)) {
                newIndices[offset++] = idx;
              }

              idx++;
            }
          }

          quickFinished = true;
        } else if (dimSize === 2) {
          var dimStorage = this._storage[dim0];
          var dimStorage2 = this._storage[dimensions[1]];
          var min2 = range[dimensions[1]][0];
          var max2 = range[dimensions[1]][1];

          for (var k = 0; k < this._chunkCount; k++) {
            var chunkStorage = dimStorage[k];
            var chunkStorage2 = dimStorage2[k];
            var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);

            for (var i = 0; i < len; i++) {
              var val = chunkStorage[i];
              var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.

              if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {
                newIndices[offset++] = idx;
              }

              idx++;
            }
          }

          quickFinished = true;
        }
      }

      if (!quickFinished) {
        if (dimSize === 1) {
          for (var i = 0; i < originalCount; i++) {
            var rawIndex = this.getRawIndex(i);

            var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.


            if (val >= min && val <= max || isNaN(val)) {
              newIndices[offset++] = rawIndex;
            }
          }
        } else {
          for (var i = 0; i < originalCount; i++) {
            var keep = true;
            var rawIndex = this.getRawIndex(i);

            for (var k = 0; k < dimSize; k++) {
              var dimk = dimensions[k];

              var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.


              if (val < range[dimk][0] || val > range[dimk][1]) {
                keep = false;
              }
            }

            if (keep) {
              newIndices[offset++] = this.getRawIndex(i);
            }
          }
        }
      } // Set indices after filtered.


      if (offset < originalCount) {
        this._indices = newIndices;
      }

      this._count = offset; // Reset data extent

      this._extent = {};
      this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      return this;
    };
    /**
     * Data mapping to a plain array
     * @param {string|Array.<string>} [dimensions]
     * @param {Function} cb
     * @param {*} [context=this]
     * @return {Array}
     */


    listProto.mapArray = function (dimensions, cb, context, contextCompat) {

      if (typeof dimensions === 'function') {
        contextCompat = context;
        context = cb;
        cb = dimensions;
        dimensions = [];
      } // contextCompat just for compat echarts3


      context = context || contextCompat || this;
      var result = [];
      this.each(dimensions, function () {
        result.push(cb && cb.apply(this, arguments));
      }, context);
      return result;
    }; // Data in excludeDimensions is copied, otherwise transfered.


    function cloneListForMapAndSample(original, excludeDimensions) {
      var allDimensions = original.dimensions;
      var list = new List(util.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked

      transferProperties(list, original);
      var storage = list._storage = {};
      var originalStorage = original._storage; // Init storage

      for (var i = 0; i < allDimensions.length; i++) {
        var dim = allDimensions[i];

        if (originalStorage[dim]) {
          // Notice that we do not reset invertedIndicesMap here, becuase
          // there is no scenario of mapping or sampling ordinal dimension.
          if (util.indexOf(excludeDimensions, dim) >= 0) {
            storage[dim] = cloneDimStore(originalStorage[dim]);
            list._rawExtent[dim] = getInitialExtent();
            list._extent[dim] = null;
          } else {
            // Direct reference for other dimensions
            storage[dim] = originalStorage[dim];
          }
        }
      }

      return list;
    }

    function cloneDimStore(originalDimStore) {
      var newDimStore = new Array(originalDimStore.length);

      for (var j = 0; j < originalDimStore.length; j++) {
        newDimStore[j] = cloneChunk(originalDimStore[j]);
      }

      return newDimStore;
    }

    function getInitialExtent() {
      return [Infinity, -Infinity];
    }
    /**
     * Data mapping to a new List with given dimensions
     * @param {string|Array.<string>} dimensions
     * @param {Function} cb
     * @param {*} [context=this]
     * @return {Array}
     */


    listProto.map = function (dimensions, cb, context, contextCompat) {

      context = context || contextCompat || this;
      dimensions = util.map(normalizeDimensions(dimensions), this.getDimension, this);
      var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.
      // So we can reference to the same value

      list._indices = this._indices;
      list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      var storage = list._storage;
      var tmpRetValue = [];
      var chunkSize = this._chunkSize;
      var dimSize = dimensions.length;
      var dataCount = this.count();
      var values = [];
      var rawExtent = list._rawExtent;

      for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
        for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {
          values[dimIndex] = this.get(dimensions[dimIndex], dataIndex
          /*, stack */
          );
        }

        values[dimSize] = dataIndex;
        var retValue = cb && cb.apply(context, values);

        if (retValue != null) {
          // a number or string (in oridinal dimension)?
          if (typeof retValue !== 'object') {
            tmpRetValue[0] = retValue;
            retValue = tmpRetValue;
          }

          var rawIndex = this.getRawIndex(dataIndex);
          var chunkIndex = Math.floor(rawIndex / chunkSize);
          var chunkOffset = rawIndex % chunkSize;

          for (var i = 0; i < retValue.length; i++) {
            var dim = dimensions[i];
            var val = retValue[i];
            var rawExtentOnDim = rawExtent[dim];
            var dimStore = storage[dim];

            if (dimStore) {
              dimStore[chunkIndex][chunkOffset] = val;
            }

            if (val < rawExtentOnDim[0]) {
              rawExtentOnDim[0] = val;
            }

            if (val > rawExtentOnDim[1]) {
              rawExtentOnDim[1] = val;
            }
          }
        }
      }

      return list;
    };
    /**
     * Large data down sampling on given dimension
     * @param {string} dimension
     * @param {number} rate
     * @param {Function} sampleValue
     * @param {Function} sampleIndex Sample index for name and id
     */


    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {
      var list = cloneListForMapAndSample(this, [dimension]);
      var targetStorage = list._storage;
      var frameValues = [];
      var frameSize = Math.floor(1 / rate);
      var dimStore = targetStorage[dimension];
      var len = this.count();
      var chunkSize = this._chunkSize;
      var rawExtentOnDim = list._rawExtent[dimension];
      var newIndices = new (getIndicesCtor(this))(len);
      var offset = 0;

      for (var i = 0; i < len; i += frameSize) {
        // Last frame
        if (frameSize > len - i) {
          frameSize = len - i;
          frameValues.length = frameSize;
        }

        for (var k = 0; k < frameSize; k++) {
          var dataIdx = this.getRawIndex(i + k);
          var originalChunkIndex = Math.floor(dataIdx / chunkSize);
          var originalChunkOffset = dataIdx % chunkSize;
          frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];
        }

        var value = sampleValue(frameValues);
        var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));
        var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);
        var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data

        dimStore[sampleChunkIndex][sampleChunkOffset] = value;

        if (value < rawExtentOnDim[0]) {
          rawExtentOnDim[0] = value;
        }

        if (value > rawExtentOnDim[1]) {
          rawExtentOnDim[1] = value;
        }

        newIndices[offset++] = sampleFrameIdx;
      }

      list._count = offset;
      list._indices = newIndices;
      list.getRawIndex = getRawIndexWithIndices;
      return list;
    };
    /**
     * Get model of one data item.
     *
     * @param {number} idx
     */
    // FIXME Model proxy ?


    listProto.getItemModel = function (idx) {
      var hostModel = this.hostModel;
      return new Model_1(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);
    };
    /**
     * Create a data differ
     * @param {module:echarts/data/List} otherList
     * @return {module:echarts/data/DataDiffer}
     */


    listProto.diff = function (otherList) {
      var thisList = this;
      return new DataDiffer_1(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {
        return getId(otherList, idx);
      }, function (idx) {
        return getId(thisList, idx);
      });
    };
    /**
     * Get visual property.
     * @param {string} key
     */


    listProto.getVisual = function (key) {
      var visual = this._visual;
      return visual && visual[key];
    };
    /**
     * Set visual property
     * @param {string|Object} key
     * @param {*} [value]
     *
     * @example
     *  setVisual('color', color);
     *  setVisual({
     *      'color': color
     *  });
     */


    listProto.setVisual = function (key, val) {
      if (isObject$a(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            this.setVisual(name, key[name]);
          }
        }

        return;
      }

      this._visual = this._visual || {};
      this._visual[key] = val;
    };
    /**
     * Set layout property.
     * @param {string|Object} key
     * @param {*} [val]
     */


    listProto.setLayout = function (key, val) {
      if (isObject$a(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            this.setLayout(name, key[name]);
          }
        }

        return;
      }

      this._layout[key] = val;
    };
    /**
     * Get layout property.
     * @param  {string} key.
     * @return {*}
     */


    listProto.getLayout = function (key) {
      return this._layout[key];
    };
    /**
     * Get layout of single data item
     * @param {number} idx
     */


    listProto.getItemLayout = function (idx) {
      return this._itemLayouts[idx];
    };
    /**
     * Set layout of single data item
     * @param {number} idx
     * @param {Object} layout
     * @param {boolean=} [merge=false]
     */


    listProto.setItemLayout = function (idx, layout, merge) {
      this._itemLayouts[idx] = merge ? util.extend(this._itemLayouts[idx] || {}, layout) : layout;
    };
    /**
     * Clear all layout of single data item
     */


    listProto.clearItemLayouts = function () {
      this._itemLayouts.length = 0;
    };
    /**
     * Get visual property of single data item
     * @param {number} idx
     * @param {string} key
     * @param {boolean} [ignoreParent=false]
     */


    listProto.getItemVisual = function (idx, key, ignoreParent) {
      var itemVisual = this._itemVisuals[idx];
      var val = itemVisual && itemVisual[key];

      if (val == null && !ignoreParent) {
        // Use global visual property
        return this.getVisual(key);
      }

      return val;
    };
    /**
     * Set visual property of single data item
     *
     * @param {number} idx
     * @param {string|Object} key
     * @param {*} [value]
     *
     * @example
     *  setItemVisual(0, 'color', color);
     *  setItemVisual(0, {
     *      'color': color
     *  });
     */


    listProto.setItemVisual = function (idx, key, value) {
      var itemVisual = this._itemVisuals[idx] || {};
      var hasItemVisual = this.hasItemVisual;
      this._itemVisuals[idx] = itemVisual;

      if (isObject$a(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            itemVisual[name] = key[name];
            hasItemVisual[name] = true;
          }
        }

        return;
      }

      itemVisual[key] = value;
      hasItemVisual[key] = true;
    };
    /**
     * Clear itemVisuals and list visual.
     */


    listProto.clearAllVisual = function () {
      this._visual = {};
      this._itemVisuals = [];
      this.hasItemVisual = {};
    };

    var setItemDataAndSeriesIndex = function (child) {
      child.seriesIndex = this.seriesIndex;
      child.dataIndex = this.dataIndex;
      child.dataType = this.dataType;
    };
    /**
     * Set graphic element relative to data. It can be set as null
     * @param {number} idx
     * @param {module:zrender/Element} [el]
     */


    listProto.setItemGraphicEl = function (idx, el) {
      var hostModel = this.hostModel;

      if (el) {
        // Add data index and series index for indexing the data by element
        // Useful in tooltip
        el.dataIndex = idx;
        el.dataType = this.dataType;
        el.seriesIndex = hostModel && hostModel.seriesIndex;

        if (el.type === 'group') {
          el.traverse(setItemDataAndSeriesIndex, el);
        }
      }

      this._graphicEls[idx] = el;
    };
    /**
     * @param {number} idx
     * @return {module:zrender/Element}
     */


    listProto.getItemGraphicEl = function (idx) {
      return this._graphicEls[idx];
    };
    /**
     * @param {Function} cb
     * @param {*} context
     */


    listProto.eachItemGraphicEl = function (cb, context) {
      util.each(this._graphicEls, function (el, idx) {
        if (el) {
          cb && cb.call(context, el, idx);
        }
      });
    };
    /**
     * Shallow clone a new list except visual and layout properties, and graph elements.
     * New list only change the indices.
     */


    listProto.cloneShallow = function (list) {
      if (!list) {
        var dimensionInfoList = util.map(this.dimensions, this.getDimensionInfo, this);
        list = new List(dimensionInfoList, this.hostModel);
      } // FIXME


      list._storage = this._storage;
      transferProperties(list, this); // Clone will not change the data extent and indices

      if (this._indices) {
        var Ctor = this._indices.constructor;
        list._indices = new Ctor(this._indices);
      } else {
        list._indices = null;
      }

      list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      return list;
    };
    /**
     * Wrap some method to add more feature
     * @param {string} methodName
     * @param {Function} injectFunction
     */


    listProto.wrapMethod = function (methodName, injectFunction) {
      var originalMethod = this[methodName];

      if (typeof originalMethod !== 'function') {
        return;
      }

      this.__wrappedMethods = this.__wrappedMethods || [];

      this.__wrappedMethods.push(methodName);

      this[methodName] = function () {
        var res = originalMethod.apply(this, arguments);
        return injectFunction.apply(this, [res].concat(util.slice(arguments)));
      };
    }; // Methods that create a new list based on this list should be listed here.
    // Notice that those method should `RETURN` the new list.


    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.

    listProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];
    var _default$1k = List;
    var List_1 = _default$1k;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var createHashMap$8 = util.createHashMap;
    var each$g = util.each;
    var isString$8 = util.isString;
    var defaults$3 = util.defaults;
    var extend$7 = util.extend;
    var isObject$b = util.isObject;
    var clone$6 = util.clone;



    var normalizeToArray$4 = model.normalizeToArray;



    var guessOrdinal$1 = sourceHelper.guessOrdinal;
    var BE_ORDINAL$1 = sourceHelper.BE_ORDINAL;





    var OTHER_DIMENSIONS$1 = dimensionHelper.OTHER_DIMENSIONS;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @deprecated
     * Use `echarts/data/helper/createDimensions` instead.
     */

    /**
     * @see {module:echarts/test/ut/spec/data/completeDimensions}
     *
     * This method builds the relationship between:
     * + "what the coord sys or series requires (see `sysDims`)",
     * + "what the user defines (in `encode` and `dimensions`, see `opt.dimsDef` and `opt.encodeDef`)"
     * + "what the data source provids (see `source`)".
     *
     * Some guess strategy will be adapted if user does not define something.
     * If no 'value' dimension specified, the first no-named dimension will be
     * named as 'value'.
     *
     * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which
     *      provides not only dim template, but also default order.
     *      properties: 'name', 'type', 'displayName'.
     *      `name` of each item provides default coord name.
     *      [{dimsDef: [string|Object, ...]}, ...] dimsDef of sysDim item provides default dim name, and
     *                                    provide dims count that the sysDim required.
     *      [{ordinalMeta}] can be specified.
     * @param {module:echarts/data/Source|Array|Object} source or data (for compatibal with pervious)
     * @param {Object} [opt]
     * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions
     *      For example: ['asdf', {name, type}, ...].
     * @param {Object|HashMap} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}
     * @param {Function} [opt.encodeDefaulter] Called if no `opt.encodeDef` exists.
     *      If not specified, auto find the next available data dim.
     *      param source {module:data/Source}
     *      param dimCount {number}
     *      return {Object} encode Never be `null/undefined`.
     * @param {string} [opt.generateCoord] Generate coord dim with the given name.
     *      If not specified, extra dim names will be:
     *      'value', 'value0', 'value1', ...
     * @param {number} [opt.generateCoordCount] By default, the generated dim name is `generateCoord`.
     *      If `generateCoordCount` specified, the generated dim names will be:
     *      `generateCoord` + 0, `generateCoord` + 1, ...
     *      can be Infinity, indicate that use all of the remain columns.
     * @param {number} [opt.dimCount] If not specified, guess by the first data item.
     * @return {Array.<module:data/DataDimensionInfo>}
     */
    function completeDimensions(sysDims, source, opt) {
      if (!Source_1.isInstance(source)) {
        source = Source_1.seriesDataToSource(source);
      }

      opt = opt || {};
      sysDims = (sysDims || []).slice();
      var dimsDef = (opt.dimsDef || []).slice();
      var dataDimNameMap = createHashMap$8();
      var coordDimNameMap = createHashMap$8(); // var valueCandidate;

      var result = [];
      var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimCount); // Apply user defined dims (`name` and `type`) and init result.

      for (var i = 0; i < dimCount; i++) {
        var dimDefItem = dimsDef[i] = extend$7({}, isObject$b(dimsDef[i]) ? dimsDef[i] : {
          name: dimsDef[i]
        });
        var userDimName = dimDefItem.name;
        var resultItem = result[i] = new DataDimensionInfo_1(); // Name will be applied later for avoiding duplication.

        if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
          // Only if `series.dimensions` is defined in option
          // displayName, will be set, and dimension will be diplayed vertically in
          // tooltip by default.
          resultItem.name = resultItem.displayName = userDimName;
          dataDimNameMap.set(userDimName, i);
        }

        dimDefItem.type != null && (resultItem.type = dimDefItem.type);
        dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);
      }

      var encodeDef = opt.encodeDef;

      if (!encodeDef && opt.encodeDefaulter) {
        encodeDef = opt.encodeDefaulter(source, dimCount);
      }

      encodeDef = createHashMap$8(encodeDef); // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.

      encodeDef.each(function (dataDims, coordDim) {
        dataDims = normalizeToArray$4(dataDims).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is
        // `{encode: {x: -1, y: 1}}`. Should not filter anything in
        // this case.

        if (dataDims.length === 1 && !isString$8(dataDims[0]) && dataDims[0] < 0) {
          encodeDef.set(coordDim, false);
          return;
        }

        var validDataDims = encodeDef.set(coordDim, []);
        each$g(dataDims, function (resultDimIdx, idx) {
          // The input resultDimIdx can be dim name or index.
          isString$8(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));

          if (resultDimIdx != null && resultDimIdx < dimCount) {
            validDataDims[idx] = resultDimIdx;
            applyDim(result[resultDimIdx], coordDim, idx);
          }
        });
      }); // Apply templetes and default order from `sysDims`.

      var availDimIdx = 0;
      each$g(sysDims, function (sysDimItem, sysDimIndex) {
        var coordDim;
        var sysDimItem;
        var sysDimItemDimsDef;
        var sysDimItemOtherDims;

        if (isString$8(sysDimItem)) {
          coordDim = sysDimItem;
          sysDimItem = {};
        } else {
          coordDim = sysDimItem.name;
          var ordinalMeta = sysDimItem.ordinalMeta;
          sysDimItem.ordinalMeta = null;
          sysDimItem = clone$6(sysDimItem);
          sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.

          sysDimItemDimsDef = sysDimItem.dimsDef;
          sysDimItemOtherDims = sysDimItem.otherDims;
          sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
        }

        var dataDims = encodeDef.get(coordDim); // negative resultDimIdx means no need to mapping.

        if (dataDims === false) {
          return;
        }

        var dataDims = normalizeToArray$4(dataDims); // dimensions provides default dim sequences.

        if (!dataDims.length) {
          for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
            while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {
              availDimIdx++;
            }

            availDimIdx < result.length && dataDims.push(availDimIdx++);
          }
        } // Apply templates.


        each$g(dataDims, function (resultDimIdx, coordDimIndex) {
          var resultItem = result[resultDimIdx];
          applyDim(defaults$3(resultItem, sysDimItem), coordDim, coordDimIndex);

          if (resultItem.name == null && sysDimItemDimsDef) {
            var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
            !isObject$b(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
              name: sysDimItemDimsDefItem
            });
            resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;
            resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
          } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}


          sysDimItemOtherDims && defaults$3(resultItem.otherDims, sysDimItemOtherDims);
        });
      });

      function applyDim(resultItem, coordDim, coordDimIndex) {
        if (OTHER_DIMENSIONS$1.get(coordDim) != null) {
          resultItem.otherDims[coordDim] = coordDimIndex;
        } else {
          resultItem.coordDim = coordDim;
          resultItem.coordDimIndex = coordDimIndex;
          coordDimNameMap.set(coordDim, true);
        }
      } // Make sure the first extra dim is 'value'.


      var generateCoord = opt.generateCoord;
      var generateCoordCount = opt.generateCoordCount;
      var fromZero = generateCoordCount != null;
      generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
      var extra = generateCoord || 'value'; // Set dim `name` and other `coordDim` and other props.

      for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
        var resultItem = result[resultDimIdx] = result[resultDimIdx] || new DataDimensionInfo_1();
        var coordDim = resultItem.coordDim;

        if (coordDim == null) {
          resultItem.coordDim = genName(extra, coordDimNameMap, fromZero);
          resultItem.coordDimIndex = 0;

          if (!generateCoord || generateCoordCount <= 0) {
            resultItem.isExtraCoord = true;
          }

          generateCoordCount--;
        }

        resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));

        if (resultItem.type == null && (guessOrdinal$1(source, resultDimIdx, resultItem.name) === BE_ORDINAL$1.Must // Consider the case:
        // {
        //    dataset: {source: [
        //        ['2001', 123],
        //        ['2002', 456],
        //        ...
        //        ['The others', 987],
        //    ]},
        //    series: {type: 'pie'}
        // }
        // The first colum should better be treated as a "ordinal" although it
        // might not able to be detected as an "ordinal" by `guessOrdinal`.
        || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
          resultItem.type = 'ordinal';
        }
      }

      return result;
    } // ??? TODO
    // Originally detect dimCount by data[0]. Should we
    // optimize it to only by sysDims and dimensions and encode.
    // So only necessary dims will be initialized.
    // But
    // (1) custom series should be considered. where other dims
    // may be visited.
    // (2) sometimes user need to calcualte bubble size or use visualMap
    // on other dimensions besides coordSys needed.
    // So, dims that is not used by system, should be shared in storage?


    function getDimCount(source, sysDims, dimsDef, optDimCount) {
      // Note that the result dimCount should not small than columns count
      // of data, otherwise `dataDimNameMap` checking will be incorrect.
      var dimCount = Math.max(source.dimensionsDetectCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
      each$g(sysDims, function (sysDimItem) {
        var sysDimItemDimsDef = sysDimItem.dimsDef;
        sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));
      });
      return dimCount;
    }

    function genName(name, map, fromZero) {
      if (fromZero || map.get(name) != null) {
        var i = 0;

        while (map.get(name + i) != null) {
          i++;
        }

        name += i;
      }

      map.set(name, true);
      return name;
    }

    var _default$1l = completeDimensions;
    var completeDimensions_1 = _default$1l;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Substitute `completeDimensions`.
     * `completeDimensions` is to be deprecated.
     */

    /**
     * @param {module:echarts/data/Source|module:echarts/data/List} source or data.
     * @param {Object|Array} [opt]
     * @param {Array.<string|Object>} [opt.coordDimensions=[]]
     * @param {number} [opt.dimensionsCount]
     * @param {string} [opt.generateCoord]
     * @param {string} [opt.generateCoordCount]
     * @param {Array.<string|Object>} [opt.dimensionsDefine=source.dimensionsDefine] Overwrite source define.
     * @param {Object|HashMap} [opt.encodeDefine=source.encodeDefine] Overwrite source define.
     * @param {Function} [opt.encodeDefaulter] Make default encode if user not specified.
     * @return {Array.<Object>} dimensionsInfo
     */
    function _default$1m(source, opt) {
      opt = opt || {};
      return completeDimensions_1(opt.coordDimensions || [], source, {
        dimsDef: opt.dimensionsDefine || source.dimensionsDefine,
        encodeDef: opt.encodeDefine || source.encodeDefine,
        dimCount: opt.dimensionsCount,
        encodeDefaulter: opt.encodeDefaulter,
        generateCoord: opt.generateCoord,
        generateCoordCount: opt.generateCoordCount
      });
    }

    var createDimensions = _default$1m;

    var createHashMap$9 = util.createHashMap;
    var each$h = util.each;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Helper for model references.
     * There are many manners to refer axis/coordSys.
     */
    // TODO
    // merge relevant logic to this file?
    // check: "modelHelper" of tooltip and "BrushTargetManager".

    /**
     * @class
     * For example:
     * {
     *     coordSysName: 'cartesian2d',
     *     coordSysDims: ['x', 'y', ...],
     *     axisMap: HashMap({
     *         x: xAxisModel,
     *         y: yAxisModel
     *     }),
     *     categoryAxisMap: HashMap({
     *         x: xAxisModel,
     *         y: undefined
     *     }),
     *     // The index of the first category axis in `coordSysDims`.
     *     // `null/undefined` means no category axis exists.
     *     firstCategoryDimIndex: 1,
     *     // To replace user specified encode.
     * }
     */
    function CoordSysInfo(coordSysName) {
      /**
       * @type {string}
       */
      this.coordSysName = coordSysName;
      /**
       * @type {Array.<string>}
       */

      this.coordSysDims = [];
      /**
       * @type {module:zrender/core/util#HashMap}
       */

      this.axisMap = createHashMap$9();
      /**
       * @type {module:zrender/core/util#HashMap}
       */

      this.categoryAxisMap = createHashMap$9();
      /**
       * @type {number}
       */

      this.firstCategoryDimIndex = null;
    }
    /**
     * @return {module:model/referHelper#CoordSysInfo}
     */


    function getCoordSysInfoBySeries(seriesModel) {
      var coordSysName = seriesModel.get('coordinateSystem');
      var result = new CoordSysInfo(coordSysName);
      var fetch = fetchers[coordSysName];

      if (fetch) {
        fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
        return result;
      }
    }

    var fetchers = {
      cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {
        var xAxisModel = seriesModel.getReferringComponents('xAxis')[0];
        var yAxisModel = seriesModel.getReferringComponents('yAxis')[0];
        result.coordSysDims = ['x', 'y'];
        axisMap.set('x', xAxisModel);
        axisMap.set('y', yAxisModel);

        if (isCategory(xAxisModel)) {
          categoryAxisMap.set('x', xAxisModel);
          result.firstCategoryDimIndex = 0;
        }

        if (isCategory(yAxisModel)) {
          categoryAxisMap.set('y', yAxisModel);
          result.firstCategoryDimIndex == null & (result.firstCategoryDimIndex = 1);
        }
      },
      singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {
        var singleAxisModel = seriesModel.getReferringComponents('singleAxis')[0];
        result.coordSysDims = ['single'];
        axisMap.set('single', singleAxisModel);

        if (isCategory(singleAxisModel)) {
          categoryAxisMap.set('single', singleAxisModel);
          result.firstCategoryDimIndex = 0;
        }
      },
      polar: function (seriesModel, result, axisMap, categoryAxisMap) {
        var polarModel = seriesModel.getReferringComponents('polar')[0];
        var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
        var angleAxisModel = polarModel.findAxisModel('angleAxis');
        result.coordSysDims = ['radius', 'angle'];
        axisMap.set('radius', radiusAxisModel);
        axisMap.set('angle', angleAxisModel);

        if (isCategory(radiusAxisModel)) {
          categoryAxisMap.set('radius', radiusAxisModel);
          result.firstCategoryDimIndex = 0;
        }

        if (isCategory(angleAxisModel)) {
          categoryAxisMap.set('angle', angleAxisModel);
          result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
        }
      },
      geo: function (seriesModel, result, axisMap, categoryAxisMap) {
        result.coordSysDims = ['lng', 'lat'];
      },
      parallel: function (seriesModel, result, axisMap, categoryAxisMap) {
        var ecModel = seriesModel.ecModel;
        var parallelModel = ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));
        var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
        each$h(parallelModel.parallelAxisIndex, function (axisIndex, index) {
          var axisModel = ecModel.getComponent('parallelAxis', axisIndex);
          var axisDim = coordSysDims[index];
          axisMap.set(axisDim, axisModel);

          if (isCategory(axisModel) && result.firstCategoryDimIndex == null) {
            categoryAxisMap.set(axisDim, axisModel);
            result.firstCategoryDimIndex = index;
          }
        });
      }
    };

    function isCategory(axisModel) {
      return axisModel.get('type') === 'category';
    }

    var getCoordSysInfoBySeries_1 = getCoordSysInfoBySeries;

    var referHelper = {
    	getCoordSysInfoBySeries: getCoordSysInfoBySeries_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var each$i = util.each;
    var isString$9 = util.isString;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Note that it is too complicated to support 3d stack by value
     * (have to create two-dimension inverted index), so in 3d case
     * we just support that stacked by index.
     *
     * @param {module:echarts/model/Series} seriesModel
     * @param {Array.<string|Object>} dimensionInfoList The same as the input of <module:echarts/data/List>.
     *        The input dimensionInfoList will be modified.
     * @param {Object} [opt]
     * @param {boolean} [opt.stackedCoordDimension=''] Specify a coord dimension if needed.
     * @param {boolean} [opt.byIndex=false]
     * @return {Object} calculationInfo
     * {
     *     stackedDimension: string
     *     stackedByDimension: string
     *     isStackedByIndex: boolean
     *     stackedOverDimension: string
     *     stackResultDimension: string
     * }
     */
    function enableDataStack(seriesModel, dimensionInfoList, opt) {
      opt = opt || {};
      var byIndex = opt.byIndex;
      var stackedCoordDimension = opt.stackedCoordDimension; // Compatibal: when `stack` is set as '', do not stack.

      var mayStack = !!(seriesModel && seriesModel.get('stack'));
      var stackedByDimInfo;
      var stackedDimInfo;
      var stackResultDimension;
      var stackedOverDimension;
      each$i(dimensionInfoList, function (dimensionInfo, index) {
        if (isString$9(dimensionInfo)) {
          dimensionInfoList[index] = dimensionInfo = {
            name: dimensionInfo
          };
        }

        if (mayStack && !dimensionInfo.isExtraCoord) {
          // Find the first ordinal dimension as the stackedByDimInfo.
          if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
            stackedByDimInfo = dimensionInfo;
          } // Find the first stackable dimension as the stackedDimInfo.


          if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
            stackedDimInfo = dimensionInfo;
          }
        }
      });

      if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
        // Compatible with previous design, value axis (time axis) only stack by index.
        // It may make sense if the user provides elaborately constructed data.
        byIndex = true;
      } // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.
      // That put stack logic in List is for using conveniently in echarts extensions, but it
      // might not be a good way.


      if (stackedDimInfo) {
        // Use a weird name that not duplicated with other names.
        stackResultDimension = '__\0ecstackresult';
        stackedOverDimension = '__\0ecstackedover'; // Create inverted index to fast query index by value.

        if (stackedByDimInfo) {
          stackedByDimInfo.createInvertedIndices = true;
        }

        var stackedDimCoordDim = stackedDimInfo.coordDim;
        var stackedDimType = stackedDimInfo.type;
        var stackedDimCoordIndex = 0;
        each$i(dimensionInfoList, function (dimensionInfo) {
          if (dimensionInfo.coordDim === stackedDimCoordDim) {
            stackedDimCoordIndex++;
          }
        });
        dimensionInfoList.push({
          name: stackResultDimension,
          coordDim: stackedDimCoordDim,
          coordDimIndex: stackedDimCoordIndex,
          type: stackedDimType,
          isExtraCoord: true,
          isCalculationCoord: true
        });
        stackedDimCoordIndex++;
        dimensionInfoList.push({
          name: stackedOverDimension,
          // This dimension contains stack base (generally, 0), so do not set it as
          // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
          coordDim: stackedOverDimension,
          coordDimIndex: stackedDimCoordIndex,
          type: stackedDimType,
          isExtraCoord: true,
          isCalculationCoord: true
        });
      }

      return {
        stackedDimension: stackedDimInfo && stackedDimInfo.name,
        stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
        isStackedByIndex: byIndex,
        stackedOverDimension: stackedOverDimension,
        stackResultDimension: stackResultDimension
      };
    }
    /**
     * @param {module:echarts/data/List} data
     * @param {string} stackedDim
     */


    function isDimensionStacked(data, stackedDim
    /*, stackedByDim*/
    ) {
      // Each single series only maps to one pair of axis. So we do not need to
      // check stackByDim, whatever stacked by a dimension or stacked by index.
      return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension'); // && (
      //     stackedByDim != null
      //         ? stackedByDim === data.getCalculationInfo('stackedByDimension')
      //         : data.getCalculationInfo('isStackedByIndex')
      // );
    }
    /**
     * @param {module:echarts/data/List} data
     * @param {string} targetDim
     * @param {string} [stackedByDim] If not input this parameter, check whether
     *                                stacked by index.
     * @return {string} dimension
     */


    function getStackedDimension(data, targetDim) {
      return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;
    }

    var enableDataStack_1 = enableDataStack;
    var isDimensionStacked_1 = isDimensionStacked;
    var getStackedDimension_1 = getStackedDimension;

    var dataStackHelper = {
    	enableDataStack: enableDataStack_1,
    	isDimensionStacked: isDimensionStacked_1,
    	getStackedDimension: getStackedDimension_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    var SOURCE_FORMAT_ORIGINAL$4 = sourceType.SOURCE_FORMAT_ORIGINAL;



    var getDimensionTypeByAxis$1 = dimensionHelper.getDimensionTypeByAxis;



    var getDataItemValue$3 = model.getDataItemValue;





    var getCoordSysInfoBySeries$1 = referHelper.getCoordSysInfoBySeries;





    var enableDataStack$1 = dataStackHelper.enableDataStack;



    var makeSeriesEncodeForAxisCoordSys$1 = sourceHelper.makeSeriesEncodeForAxisCoordSys;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @param {module:echarts/data/Source|Array} source Or raw data.
     * @param {module:echarts/model/Series} seriesModel
     * @param {Object} [opt]
     * @param {string} [opt.generateCoord]
     * @param {boolean} [opt.useEncodeDefaulter]
     */
    function createListFromArray(source, seriesModel, opt) {
      opt = opt || {};

      if (!Source_1.isInstance(source)) {
        source = Source_1.seriesDataToSource(source);
      }

      var coordSysName = seriesModel.get('coordinateSystem');
      var registeredCoordSys = CoordinateSystem.get(coordSysName);
      var coordSysInfo = getCoordSysInfoBySeries$1(seriesModel);
      var coordSysDimDefs;

      if (coordSysInfo) {
        coordSysDimDefs = util.map(coordSysInfo.coordSysDims, function (dim) {
          var dimInfo = {
            name: dim
          };
          var axisModel = coordSysInfo.axisMap.get(dim);

          if (axisModel) {
            var axisType = axisModel.get('type');
            dimInfo.type = getDimensionTypeByAxis$1(axisType); // dimInfo.stackable = isStackable(axisType);
          }

          return dimInfo;
        });
      }

      if (!coordSysDimDefs) {
        // Get dimensions from registered coordinate system
        coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];
      }

      var dimInfoList = createDimensions(source, {
        coordDimensions: coordSysDimDefs,
        generateCoord: opt.generateCoord,
        encodeDefaulter: opt.useEncodeDefaulter ? util.curry(makeSeriesEncodeForAxisCoordSys$1, coordSysDimDefs, seriesModel) : null
      });
      var firstCategoryDimIndex;
      var hasNameEncode;
      coordSysInfo && util.each(dimInfoList, function (dimInfo, dimIndex) {
        var coordDim = dimInfo.coordDim;
        var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);

        if (categoryAxisModel) {
          if (firstCategoryDimIndex == null) {
            firstCategoryDimIndex = dimIndex;
          }

          dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
        }

        if (dimInfo.otherDims.itemName != null) {
          hasNameEncode = true;
        }
      });

      if (!hasNameEncode && firstCategoryDimIndex != null) {
        dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
      }

      var stackCalculationInfo = enableDataStack$1(seriesModel, dimInfoList);
      var list = new List_1(dimInfoList, seriesModel);
      list.setCalculationInfo(stackCalculationInfo);
      var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {
        // Use dataIndex as ordinal value in categoryAxis
        return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
      } : null;
      list.hasItemOption = false;
      list.initData(source, null, dimValueGetter);
      return list;
    }

    function isNeedCompleteOrdinalData(source) {
      if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL$4) {
        var sampleItem = firstDataNotNull(source.data || []);
        return sampleItem != null && !util.isArray(getDataItemValue$3(sampleItem));
      }
    }

    function firstDataNotNull(data) {
      var i = 0;

      while (i < data.length && data[i] == null) {
        i++;
      }

      return data[i];
    }

    var _default$1n = createListFromArray;
    var createListFromArray_1 = _default$1n;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * // Scale class management
     * @module echarts/scale/Scale
     */

    /**
     * @param {Object} [setting]
     */
    function Scale(setting) {
      this._setting = setting || {};
      /**
       * Extent
       * @type {Array.<number>}
       * @protected
       */

      this._extent = [Infinity, -Infinity];
      /**
       * Step is calculated in adjustExtent
       * @type {Array.<number>}
       * @protected
       */

      this._interval = 0;
      this.init && this.init.apply(this, arguments);
    }
    /**
     * Parse input val to valid inner number.
     * @param {*} val
     * @return {number}
     */


    Scale.prototype.parse = function (val) {
      // Notice: This would be a trap here, If the implementation
      // of this method depends on extent, and this method is used
      // before extent set (like in dataZoom), it would be wrong.
      // Nevertheless, parse does not depend on extent generally.
      return val;
    };

    Scale.prototype.getSetting = function (name) {
      return this._setting[name];
    };

    Scale.prototype.contain = function (val) {
      var extent = this._extent;
      return val >= extent[0] && val <= extent[1];
    };
    /**
     * Normalize value to linear [0, 1], return 0.5 if extent span is 0
     * @param {number} val
     * @return {number}
     */


    Scale.prototype.normalize = function (val) {
      var extent = this._extent;

      if (extent[1] === extent[0]) {
        return 0.5;
      }

      return (val - extent[0]) / (extent[1] - extent[0]);
    };
    /**
     * Scale normalized value
     * @param {number} val
     * @return {number}
     */


    Scale.prototype.scale = function (val) {
      var extent = this._extent;
      return val * (extent[1] - extent[0]) + extent[0];
    };
    /**
     * Set extent from data
     * @param {Array.<number>} other
     */


    Scale.prototype.unionExtent = function (other) {
      var extent = this._extent;
      other[0] < extent[0] && (extent[0] = other[0]);
      other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power
      // this.setExtent(extent[0], extent[1]);
    };
    /**
     * Set extent from data
     * @param {module:echarts/data/List} data
     * @param {string} dim
     */


    Scale.prototype.unionExtentFromData = function (data, dim) {
      this.unionExtent(data.getApproximateExtent(dim));
    };
    /**
     * Get extent
     * @return {Array.<number>}
     */


    Scale.prototype.getExtent = function () {
      return this._extent.slice();
    };
    /**
     * Set extent
     * @param {number} start
     * @param {number} end
     */


    Scale.prototype.setExtent = function (start, end) {
      var thisExtent = this._extent;

      if (!isNaN(start)) {
        thisExtent[0] = start;
      }

      if (!isNaN(end)) {
        thisExtent[1] = end;
      }
    };
    /**
     * When axis extent depends on data and no data exists,
     * axis ticks should not be drawn, which is named 'blank'.
     */


    Scale.prototype.isBlank = function () {
      return this._isBlank;
    },
    /**
     * When axis extent depends on data and no data exists,
     * axis ticks should not be drawn, which is named 'blank'.
     */
    Scale.prototype.setBlank = function (isBlank) {
      this._isBlank = isBlank;
    };
    /**
     * @abstract
     * @param {*} tick
     * @return {string} label of the tick.
     */

    Scale.prototype.getLabel = null;
    clazz.enableClassExtend(Scale);
    clazz.enableClassManagement(Scale, {
      registerWhenExtend: true
    });
    var _default$1o = Scale;
    var Scale_1 = _default$1o;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var createHashMap$a = util.createHashMap;
    var isObject$c = util.isObject;
    var map$5 = util.map;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @constructor
     * @param {Object} [opt]
     * @param {Object} [opt.categories=[]]
     * @param {Object} [opt.needCollect=false]
     * @param {Object} [opt.deduplication=false]
     */
    function OrdinalMeta(opt) {
      /**
       * @readOnly
       * @type {Array.<string>}
       */
      this.categories = opt.categories || [];
      /**
       * @private
       * @type {boolean}
       */

      this._needCollect = opt.needCollect;
      /**
       * @private
       * @type {boolean}
       */

      this._deduplication = opt.deduplication;
      /**
       * @private
       * @type {boolean}
       */

      this._map;
    }
    /**
     * @param {module:echarts/model/Model} axisModel
     * @return {module:echarts/data/OrdinalMeta}
     */


    OrdinalMeta.createByAxisModel = function (axisModel) {
      var option = axisModel.option;
      var data = option.data;
      var categories = data && map$5(data, getName);
      return new OrdinalMeta({
        categories: categories,
        needCollect: !categories,
        // deduplication is default in axis.
        deduplication: option.dedplication !== false
      });
    };

    var proto$1 = OrdinalMeta.prototype;
    /**
     * @param {string} category
     * @return {number} ordinal
     */

    proto$1.getOrdinal = function (category) {
      return getOrCreateMap(this).get(category);
    };
    /**
     * @param {*} category
     * @return {number} The ordinal. If not found, return NaN.
     */


    proto$1.parseAndCollect = function (category) {
      var index;
      var needCollect = this._needCollect; // The value of category dim can be the index of the given category set.
      // This feature is only supported when !needCollect, because we should
      // consider a common case: a value is 2017, which is a number but is
      // expected to be tread as a category. This case usually happen in dataset,
      // where it happent to be no need of the index feature.

      if (typeof category !== 'string' && !needCollect) {
        return category;
      } // Optimize for the scenario:
      // category is ['2012-01-01', '2012-01-02', ...], where the input
      // data has been ensured not duplicate and is large data.
      // Notice, if a dataset dimension provide categroies, usually echarts
      // should remove duplication except user tell echarts dont do that
      // (set axis.deduplication = false), because echarts do not know whether
      // the values in the category dimension has duplication (consider the
      // parallel-aqi example)


      if (needCollect && !this._deduplication) {
        index = this.categories.length;
        this.categories[index] = category;
        return index;
      }

      var map = getOrCreateMap(this);
      index = map.get(category);

      if (index == null) {
        if (needCollect) {
          index = this.categories.length;
          this.categories[index] = category;
          map.set(category, index);
        } else {
          index = NaN;
        }
      }

      return index;
    }; // Consider big data, do not create map until needed.


    function getOrCreateMap(ordinalMeta) {
      return ordinalMeta._map || (ordinalMeta._map = createHashMap$a(ordinalMeta.categories));
    }

    function getName(obj) {
      if (isObject$c(obj) && obj.value != null) {
        return obj.value;
      } else {
        return obj + '';
      }
    }

    var _default$1p = OrdinalMeta;
    var OrdinalMeta_1 = _default$1p;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Linear continuous scale
     * @module echarts/coord/scale/Ordinal
     *
     * http://en.wikipedia.org/wiki/Level_of_measurement
     */
    // FIXME only one data
    var scaleProto = Scale_1.prototype;
    var OrdinalScale = Scale_1.extend({
      type: 'ordinal',

      /**
       * @param {module:echarts/data/OrdianlMeta|Array.<string>} ordinalMeta
       */
      init: function (ordinalMeta, extent) {
        // Caution: Should not use instanceof, consider ec-extensions using
        // import approach to get OrdinalMeta class.
        if (!ordinalMeta || util.isArray(ordinalMeta)) {
          ordinalMeta = new OrdinalMeta_1({
            categories: ordinalMeta
          });
        }

        this._ordinalMeta = ordinalMeta;
        this._extent = extent || [0, ordinalMeta.categories.length - 1];
      },
      parse: function (val) {
        return typeof val === 'string' ? this._ordinalMeta.getOrdinal(val) // val might be float.
        : Math.round(val);
      },
      contain: function (rank) {
        rank = this.parse(rank);
        return scaleProto.contain.call(this, rank) && this._ordinalMeta.categories[rank] != null;
      },

      /**
       * Normalize given rank or name to linear [0, 1]
       * @param {number|string} [val]
       * @return {number}
       */
      normalize: function (val) {
        return scaleProto.normalize.call(this, this.parse(val));
      },
      scale: function (val) {
        return Math.round(scaleProto.scale.call(this, val));
      },

      /**
       * @return {Array}
       */
      getTicks: function () {
        var ticks = [];
        var extent = this._extent;
        var rank = extent[0];

        while (rank <= extent[1]) {
          ticks.push(rank);
          rank++;
        }

        return ticks;
      },

      /**
       * Get item on rank n
       * @param {number} n
       * @return {string}
       */
      getLabel: function (n) {
        if (!this.isBlank()) {
          // Note that if no data, ordinalMeta.categories is an empty array.
          return this._ordinalMeta.categories[n];
        }
      },

      /**
       * @return {number}
       */
      count: function () {
        return this._extent[1] - this._extent[0] + 1;
      },

      /**
       * @override
       */
      unionExtentFromData: function (data, dim) {
        this.unionExtent(data.getApproximateExtent(dim));
      },
      getOrdinalMeta: function () {
        return this._ordinalMeta;
      },
      niceTicks: util.noop,
      niceExtent: util.noop
    });
    /**
     * @return {module:echarts/scale/Time}
     */

    OrdinalScale.create = function () {
      return new OrdinalScale();
    };

    var _default$1q = OrdinalScale;
    var Ordinal = _default$1q;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * For testable.
     */
    var roundNumber = number.round;
    /**
     * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.
     *                                Should be extent[0] < extent[1].
     * @param {number} splitNumber splitNumber should be >= 1.
     * @param {number} [minInterval]
     * @param {number} [maxInterval]
     * @return {Object} {interval, intervalPrecision, niceTickExtent}
     */

    function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
      var result = {};
      var span = extent[1] - extent[0];
      var interval = result.interval = number.nice(span / splitNumber, true);

      if (minInterval != null && interval < minInterval) {
        interval = result.interval = minInterval;
      }

      if (maxInterval != null && interval > maxInterval) {
        interval = result.interval = maxInterval;
      } // Tow more digital for tick.


      var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent

      var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];
      fixExtent(niceTickExtent, extent);
      return result;
    }
    /**
     * @param {number} interval
     * @return {number} interval precision
     */


    function getIntervalPrecision(interval) {
      // Tow more digital for tick.
      return number.getPrecisionSafe(interval) + 2;
    }

    function clamp(niceTickExtent, idx, extent) {
      niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
    } // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.


    function fixExtent(niceTickExtent, extent) {
      !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
      !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
      clamp(niceTickExtent, 0, extent);
      clamp(niceTickExtent, 1, extent);

      if (niceTickExtent[0] > niceTickExtent[1]) {
        niceTickExtent[0] = niceTickExtent[1];
      }
    }

    var intervalScaleNiceTicks_1 = intervalScaleNiceTicks;
    var getIntervalPrecision_1 = getIntervalPrecision;
    var fixExtent_1 = fixExtent;

    var helper = {
    	intervalScaleNiceTicks: intervalScaleNiceTicks_1,
    	getIntervalPrecision: getIntervalPrecision_1,
    	fixExtent: fixExtent_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Interval scale
     * @module echarts/scale/Interval
     */
    var roundNumber$1 = number.round;
    /**
     * @alias module:echarts/coord/scale/Interval
     * @constructor
     */

    var IntervalScale = Scale_1.extend({
      type: 'interval',
      _interval: 0,
      _intervalPrecision: 2,
      setExtent: function (start, end) {
        var thisExtent = this._extent; //start,end may be a Number like '25',so...

        if (!isNaN(start)) {
          thisExtent[0] = parseFloat(start);
        }

        if (!isNaN(end)) {
          thisExtent[1] = parseFloat(end);
        }
      },
      unionExtent: function (other) {
        var extent = this._extent;
        other[0] < extent[0] && (extent[0] = other[0]);
        other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes

        IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
      },

      /**
       * Get interval
       */
      getInterval: function () {
        return this._interval;
      },

      /**
       * Set interval
       */
      setInterval: function (interval) {
        this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent
        // We assume user wan't to set both interval, min, max to get a better result

        this._niceExtent = this._extent.slice();
        this._intervalPrecision = helper.getIntervalPrecision(interval);
      },

      /**
       * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.
       * @return {Array.<number>}
       */
      getTicks: function (expandToNicedExtent) {
        var interval = this._interval;
        var extent = this._extent;
        var niceTickExtent = this._niceExtent;
        var intervalPrecision = this._intervalPrecision;
        var ticks = []; // If interval is 0, return [];

        if (!interval) {
          return ticks;
        } // Consider this case: using dataZoom toolbox, zoom and zoom.


        var safeLimit = 10000;

        if (extent[0] < niceTickExtent[0]) {
          if (expandToNicedExtent) {
            ticks.push(roundNumber$1(niceTickExtent[0] - interval, intervalPrecision));
          } else {
            ticks.push(extent[0]);
          }
        }

        var tick = niceTickExtent[0];

        while (tick <= niceTickExtent[1]) {
          ticks.push(tick); // Avoid rounding error

          tick = roundNumber$1(tick + interval, intervalPrecision);

          if (tick === ticks[ticks.length - 1]) {
            // Consider out of safe float point, e.g.,
            // -3711126.9907707 + 2e-10 === -3711126.9907707
            break;
          }

          if (ticks.length > safeLimit) {
            return [];
          }
        } // Consider this case: the last item of ticks is smaller
        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].


        var lastNiceTick = ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1];

        if (extent[1] > lastNiceTick) {
          if (expandToNicedExtent) {
            ticks.push(roundNumber$1(lastNiceTick + interval, intervalPrecision));
          } else {
            ticks.push(extent[1]);
          }
        }

        return ticks;
      },

      /**
       * @param {number} [splitNumber=5]
       * @return {Array.<Array.<number>>}
       */
      getMinorTicks: function (splitNumber) {
        var ticks = this.getTicks(true);
        var minorTicks = [];
        var extent = this.getExtent();

        for (var i = 1; i < ticks.length; i++) {
          var nextTick = ticks[i];
          var prevTick = ticks[i - 1];
          var count = 0;
          var minorTicksGroup = [];
          var interval = nextTick - prevTick;
          var minorInterval = interval / splitNumber;

          while (count < splitNumber - 1) {
            var minorTick = number.round(prevTick + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.

            if (minorTick > extent[0] && minorTick < extent[1]) {
              minorTicksGroup.push(minorTick);
            }

            count++;
          }

          minorTicks.push(minorTicksGroup);
        }

        return minorTicks;
      },

      /**
       * @param {number} data
       * @param {Object} [opt]
       * @param {number|string} [opt.precision] If 'auto', use nice presision.
       * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.
       * @return {string}
       */
      getLabel: function (data, opt) {
        if (data == null) {
          return '';
        }

        var precision = opt && opt.precision;

        if (precision == null) {
          precision = number.getPrecisionSafe(data) || 0;
        } else if (precision === 'auto') {
          // Should be more precise then tick.
          precision = this._intervalPrecision;
        } // (1) If `precision` is set, 12.005 should be display as '12.00500'.
        // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.


        data = roundNumber$1(data, precision, true);
        return format$1.addCommas(data);
      },

      /**
       * Update interval and extent of intervals for nice ticks
       *
       * @param {number} [splitNumber = 5] Desired number of ticks
       * @param {number} [minInterval]
       * @param {number} [maxInterval]
       */
      niceTicks: function (splitNumber, minInterval, maxInterval) {
        splitNumber = splitNumber || 5;
        var extent = this._extent;
        var span = extent[1] - extent[0];

        if (!isFinite(span)) {
          return;
        } // User may set axis min 0 and data are all negative
        // FIXME If it needs to reverse ?


        if (span < 0) {
          span = -span;
          extent.reverse();
        }

        var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
        this._intervalPrecision = result.intervalPrecision;
        this._interval = result.interval;
        this._niceExtent = result.niceTickExtent;
      },

      /**
       * Nice extent.
       * @param {Object} opt
       * @param {number} [opt.splitNumber = 5] Given approx tick number
       * @param {boolean} [opt.fixMin=false]
       * @param {boolean} [opt.fixMax=false]
       * @param {boolean} [opt.minInterval]
       * @param {boolean} [opt.maxInterval]
       */
      niceExtent: function (opt) {
        var extent = this._extent; // If extent start and end are same, expand them

        if (extent[0] === extent[1]) {
          if (extent[0] !== 0) {
            // Expand extent
            var expandSize = extent[0]; // In the fowllowing case
            //      Axis has been fixed max 100
            //      Plus data are all 100 and axis extent are [100, 100].
            // Extend to the both side will cause expanded max is larger than fixed max.
            // So only expand to the smaller side.

            if (!opt.fixMax) {
              extent[1] += expandSize / 2;
              extent[0] -= expandSize / 2;
            } else {
              extent[0] -= expandSize / 2;
            }
          } else {
            extent[1] = 1;
          }
        }

        var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]

        if (!isFinite(span)) {
          extent[0] = 0;
          extent[1] = 1;
        }

        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;

        var interval = this._interval;

        if (!opt.fixMin) {
          extent[0] = roundNumber$1(Math.floor(extent[0] / interval) * interval);
        }

        if (!opt.fixMax) {
          extent[1] = roundNumber$1(Math.ceil(extent[1] / interval) * interval);
        }
      }
    });
    /**
     * @return {module:echarts/scale/Time}
     */

    IntervalScale.create = function () {
      return new IntervalScale();
    };

    var _default$1r = IntervalScale;
    var Interval = _default$1r;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    var parsePercent$3 = number.parsePercent;



    var isDimensionStacked$1 = dataStackHelper.isDimensionStacked;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /* global Float32Array */
    var STACK_PREFIX = '__ec_stack_';
    var LARGE_BAR_MIN_WIDTH = 0.5;
    var LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;

    function getSeriesStackId(seriesModel) {
      return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;
    }

    function getAxisKey(axis) {
      return axis.dim + axis.index;
    }
    /**
     * @param {Object} opt
     * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.
     * @param {number} opt.count Positive interger.
     * @param {number} [opt.barWidth]
     * @param {number} [opt.barMaxWidth]
     * @param {number} [opt.barMinWidth]
     * @param {number} [opt.barGap]
     * @param {number} [opt.barCategoryGap]
     * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
     */


    function getLayoutOnAxis(opt) {
      var params = [];
      var baseAxis = opt.axis;
      var axisKey = 'axis0';

      if (baseAxis.type !== 'category') {
        return;
      }

      var bandWidth = baseAxis.getBandWidth();

      for (var i = 0; i < opt.count || 0; i++) {
        params.push(util.defaults({
          bandWidth: bandWidth,
          axisKey: axisKey,
          stackId: STACK_PREFIX + i
        }, opt));
      }

      var widthAndOffsets = doCalBarWidthAndOffset(params);
      var result = [];

      for (var i = 0; i < opt.count; i++) {
        var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
        item.offsetCenter = item.offset + item.width / 2;
        result.push(item);
      }

      return result;
    }

    function prepareLayoutBarSeries(seriesType, ecModel) {
      var seriesModels = [];
      ecModel.eachSeriesByType(seriesType, function (seriesModel) {
        // Check series coordinate, do layout for cartesian2d only
        if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {
          seriesModels.push(seriesModel);
        }
      });
      return seriesModels;
    }
    /**
     * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent
     * values.
     * This works for time axes, value axes, and log axes.
     * For a single time axis, return value is in the form like
     * {'x_0': [1000000]}.
     * The value of 1000000 is in milliseconds.
     */


    function getValueAxesMinGaps(barSeries) {
      /**
       * Map from axis.index to values.
       * For a single time axis, axisValues is in the form like
       * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.
       * Items in axisValues[x], e.g. 1495555200000, are time values of all
       * series.
       */
      var axisValues = {};
      util.each(barSeries, function (seriesModel) {
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();

        if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {
          return;
        }

        var data = seriesModel.getData();
        var key = baseAxis.dim + '_' + baseAxis.index;
        var dim = data.mapDimension(baseAxis.dim);

        for (var i = 0, cnt = data.count(); i < cnt; ++i) {
          var value = data.get(dim, i);

          if (!axisValues[key]) {
            // No previous data for the axis
            axisValues[key] = [value];
          } else {
            // No value in previous series
            axisValues[key].push(value);
          } // Ignore duplicated time values in the same axis

        }
      });
      var axisMinGaps = [];

      for (var key in axisValues) {
        if (axisValues.hasOwnProperty(key)) {
          var valuesInAxis = axisValues[key];

          if (valuesInAxis) {
            // Sort axis values into ascending order to calculate gaps
            valuesInAxis.sort(function (a, b) {
              return a - b;
            });
            var min = null;

            for (var j = 1; j < valuesInAxis.length; ++j) {
              var delta = valuesInAxis[j] - valuesInAxis[j - 1];

              if (delta > 0) {
                // Ignore 0 delta because they are of the same axis value
                min = min === null ? delta : Math.min(min, delta);
              }
            } // Set to null if only have one data


            axisMinGaps[key] = min;
          }
        }
      }

      return axisMinGaps;
    }

    function makeColumnLayout(barSeries) {
      var axisMinGaps = getValueAxesMinGaps(barSeries);
      var seriesInfoList = [];
      util.each(barSeries, function (seriesModel) {
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var axisExtent = baseAxis.getExtent();
        var bandWidth;

        if (baseAxis.type === 'category') {
          bandWidth = baseAxis.getBandWidth();
        } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {
          var key = baseAxis.dim + '_' + baseAxis.index;
          var minGap = axisMinGaps[key];
          var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
          var scale = baseAxis.scale.getExtent();
          var scaleSpan = Math.abs(scale[1] - scale[0]);
          bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value
        } else {
          var data = seriesModel.getData();
          bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
        }

        var barWidth = parsePercent$3(seriesModel.get('barWidth'), bandWidth);
        var barMaxWidth = parsePercent$3(seriesModel.get('barMaxWidth'), bandWidth);
        var barMinWidth = parsePercent$3( // barMinWidth by default is 1 in cartesian. Because in value axis,
        // the auto-calculated bar width might be less than 1.
        seriesModel.get('barMinWidth') || 1, bandWidth);
        var barGap = seriesModel.get('barGap');
        var barCategoryGap = seriesModel.get('barCategoryGap');
        seriesInfoList.push({
          bandWidth: bandWidth,
          barWidth: barWidth,
          barMaxWidth: barMaxWidth,
          barMinWidth: barMinWidth,
          barGap: barGap,
          barCategoryGap: barCategoryGap,
          axisKey: getAxisKey(baseAxis),
          stackId: getSeriesStackId(seriesModel)
        });
      });
      return doCalBarWidthAndOffset(seriesInfoList);
    }

    function doCalBarWidthAndOffset(seriesInfoList) {
      // Columns info on each category axis. Key is cartesian name
      var columnsMap = {};
      util.each(seriesInfoList, function (seriesInfo, idx) {
        var axisKey = seriesInfo.axisKey;
        var bandWidth = seriesInfo.bandWidth;
        var columnsOnAxis = columnsMap[axisKey] || {
          bandWidth: bandWidth,
          remainedWidth: bandWidth,
          autoWidthCount: 0,
          categoryGap: '20%',
          gap: '30%',
          stacks: {}
        };
        var stacks = columnsOnAxis.stacks;
        columnsMap[axisKey] = columnsOnAxis;
        var stackId = seriesInfo.stackId;

        if (!stacks[stackId]) {
          columnsOnAxis.autoWidthCount++;
        }

        stacks[stackId] = stacks[stackId] || {
          width: 0,
          maxWidth: 0
        }; // Caution: In a single coordinate system, these barGrid attributes
        // will be shared by series. Consider that they have default values,
        // only the attributes set on the last series will work.
        // Do not change this fact unless there will be a break change.

        var barWidth = seriesInfo.barWidth;

        if (barWidth && !stacks[stackId].width) {
          // See #6312, do not restrict width.
          stacks[stackId].width = barWidth;
          barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
          columnsOnAxis.remainedWidth -= barWidth;
        }

        var barMaxWidth = seriesInfo.barMaxWidth;
        barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
        var barMinWidth = seriesInfo.barMinWidth;
        barMinWidth && (stacks[stackId].minWidth = barMinWidth);
        var barGap = seriesInfo.barGap;
        barGap != null && (columnsOnAxis.gap = barGap);
        var barCategoryGap = seriesInfo.barCategoryGap;
        barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
      });
      var result = {};
      util.each(columnsMap, function (columnsOnAxis, coordSysName) {
        result[coordSysName] = {};
        var stacks = columnsOnAxis.stacks;
        var bandWidth = columnsOnAxis.bandWidth;
        var categoryGap = parsePercent$3(columnsOnAxis.categoryGap, bandWidth);
        var barGapPercent = parsePercent$3(columnsOnAxis.gap, 1);
        var remainedWidth = columnsOnAxis.remainedWidth;
        var autoWidthCount = columnsOnAxis.autoWidthCount;
        var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth

        util.each(stacks, function (column) {
          var maxWidth = column.maxWidth;
          var minWidth = column.minWidth;

          if (!column.width) {
            var finalWidth = autoWidth;

            if (maxWidth && maxWidth < finalWidth) {
              finalWidth = Math.min(maxWidth, remainedWidth);
            } // `minWidth` has higher priority. `minWidth` decide that wheter the
            // bar is able to be visible. So `minWidth` should not be restricted
            // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In
            // the extreme cases for `value` axis, bars are allowed to overlap
            // with each other if `minWidth` specified.


            if (minWidth && minWidth > finalWidth) {
              finalWidth = minWidth;
            }

            if (finalWidth !== autoWidth) {
              column.width = finalWidth;
              remainedWidth -= finalWidth + barGapPercent * finalWidth;
              autoWidthCount--;
            }
          } else {
            // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as
            // CSS does. Becuase barWidth can be a percent value, where
            // `barMaxWidth` can be used to restrict the final width.
            var finalWidth = column.width;

            if (maxWidth) {
              finalWidth = Math.min(finalWidth, maxWidth);
            } // `minWidth` has higher priority, as described above


            if (minWidth) {
              finalWidth = Math.max(finalWidth, minWidth);
            }

            column.width = finalWidth;
            remainedWidth -= finalWidth + barGapPercent * finalWidth;
            autoWidthCount--;
          }
        }); // Recalculate width again

        autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);
        var widthSum = 0;
        var lastColumn;
        util.each(stacks, function (column, idx) {
          if (!column.width) {
            column.width = autoWidth;
          }

          lastColumn = column;
          widthSum += column.width * (1 + barGapPercent);
        });

        if (lastColumn) {
          widthSum -= lastColumn.width * barGapPercent;
        }

        var offset = -widthSum / 2;
        util.each(stacks, function (column, stackId) {
          result[coordSysName][stackId] = result[coordSysName][stackId] || {
            bandWidth: bandWidth,
            offset: offset,
            width: column.width
          };
          offset += column.width * (1 + barGapPercent);
        });
      });
      return result;
    }
    /**
     * @param {Object} barWidthAndOffset The result of makeColumnLayout
     * @param {module:echarts/coord/Axis} axis
     * @param {module:echarts/model/Series} [seriesModel] If not provided, return all.
     * @return {Object} {stackId: {offset, width}} or {offset, width} if seriesModel provided.
     */


    function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
      if (barWidthAndOffset && axis) {
        var result = barWidthAndOffset[getAxisKey(axis)];

        if (result != null && seriesModel != null) {
          result = result[getSeriesStackId(seriesModel)];
        }

        return result;
      }
    }
    /**
     * @param {string} seriesType
     * @param {module:echarts/model/Global} ecModel
     */


    function layout$1(seriesType, ecModel) {
      var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);
      var barWidthAndOffset = makeColumnLayout(seriesModels);
      var lastStackCoords = {};
      util.each(seriesModels, function (seriesModel) {
        var data = seriesModel.getData();
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var stackId = getSeriesStackId(seriesModel);
        var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
        var columnOffset = columnLayoutInfo.offset;
        var columnWidth = columnLayoutInfo.width;
        var valueAxis = cartesian.getOtherAxis(baseAxis);
        var barMinHeight = seriesModel.get('barMinHeight') || 0;
        lastStackCoords[stackId] = lastStackCoords[stackId] || [];

        data.setLayout({
          bandWidth: columnLayoutInfo.bandWidth,
          offset: columnOffset,
          size: columnWidth
        });
        var valueDim = data.mapDimension(valueAxis.dim);
        var baseDim = data.mapDimension(baseAxis.dim);
        var stacked = isDimensionStacked$1(data, valueDim
        /*, baseDim*/
        );
        var isValueAxisH = valueAxis.isHorizontal();
        var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);

        for (var idx = 0, len = data.count(); idx < len; idx++) {
          var value = data.get(valueDim, idx);
          var baseValue = data.get(baseDim, idx);
          var sign = value >= 0 ? 'p' : 'n';
          var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in
          // stackResultDimension directly.

          if (stacked) {
            // Only ordinal axis can be stacked.
            if (!lastStackCoords[stackId][baseValue]) {
              lastStackCoords[stackId][baseValue] = {
                p: valueAxisStart,
                // Positive stack
                n: valueAxisStart // Negative stack

              };
            } // Should also consider #4243


            baseCoord = lastStackCoords[stackId][baseValue][sign];
          }

          var x;
          var y;
          var width;
          var height;

          if (isValueAxisH) {
            var coord = cartesian.dataToPoint([value, baseValue]);
            x = baseCoord;
            y = coord[1] + columnOffset;
            width = coord[0] - valueAxisStart;
            height = columnWidth;

            if (Math.abs(width) < barMinHeight) {
              width = (width < 0 ? -1 : 1) * barMinHeight;
            } // Ignore stack from NaN value


            if (!isNaN(width)) {
              stacked && (lastStackCoords[stackId][baseValue][sign] += width);
            }
          } else {
            var coord = cartesian.dataToPoint([baseValue, value]);
            x = coord[0] + columnOffset;
            y = baseCoord;
            width = columnWidth;
            height = coord[1] - valueAxisStart;

            if (Math.abs(height) < barMinHeight) {
              // Include zero to has a positive bar
              height = (height <= 0 ? -1 : 1) * barMinHeight;
            } // Ignore stack from NaN value


            if (!isNaN(height)) {
              stacked && (lastStackCoords[stackId][baseValue][sign] += height);
            }
          }

          data.setItemLayout(idx, {
            x: x,
            y: y,
            width: width,
            height: height
          });
        }
      }, this);
    } // TODO: Do not support stack in large mode yet.


    var largeLayout = {
      seriesType: 'bar',
      plan: createRenderPlanner(),
      reset: function (seriesModel) {
        if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {
          return;
        }

        var data = seriesModel.getData();
        var cartesian = seriesModel.coordinateSystem;
        var coordLayout = cartesian.grid.getRect();
        var baseAxis = cartesian.getBaseAxis();
        var valueAxis = cartesian.getOtherAxis(baseAxis);
        var valueDim = data.mapDimension(valueAxis.dim);
        var baseDim = data.mapDimension(baseAxis.dim);
        var valueAxisHorizontal = valueAxis.isHorizontal();
        var valueDimIdx = valueAxisHorizontal ? 0 : 1;
        var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;

        if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {
          // jshint ignore:line
          barWidth = LARGE_BAR_MIN_WIDTH;
        }

        return {
          progress: progress
        };

        function progress(params, data) {
          var count = params.count;
          var largePoints = new LargeArr(count * 2);
          var largeBackgroundPoints = new LargeArr(count * 2);
          var largeDataIndices = new LargeArr(count);
          var dataIndex;
          var coord = [];
          var valuePair = [];
          var pointsOffset = 0;
          var idxOffset = 0;

          while ((dataIndex = params.next()) != null) {
            valuePair[valueDimIdx] = data.get(valueDim, dataIndex);
            valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);
            coord = cartesian.dataToPoint(valuePair, null, coord); // Data index might not be in order, depends on `progressiveChunkMode`.

            largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];
            largePoints[pointsOffset++] = coord[0];
            largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;
            largePoints[pointsOffset++] = coord[1];
            largeDataIndices[idxOffset++] = dataIndex;
          }

          data.setLayout({
            largePoints: largePoints,
            largeDataIndices: largeDataIndices,
            largeBackgroundPoints: largeBackgroundPoints,
            barWidth: barWidth,
            valueAxisStart: getValueAxisStart(baseAxis, valueAxis),
            backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,
            valueAxisHorizontal: valueAxisHorizontal
          });
        }
      }
    };

    function isOnCartesian(seriesModel) {
      return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';
    }

    function isInLargeMode(seriesModel) {
      return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
    } // See cases in `test/bar-start.html` and `#7412`, `#8747`.


    function getValueAxisStart(baseAxis, valueAxis, stacked) {
      return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));
    }

    var getLayoutOnAxis_1 = getLayoutOnAxis;
    var prepareLayoutBarSeries_1 = prepareLayoutBarSeries;
    var makeColumnLayout_1 = makeColumnLayout;
    var retrieveColumnLayout_1 = retrieveColumnLayout;
    var layout_1 = layout$1;
    var largeLayout_1 = largeLayout;

    var barGrid = {
    	getLayoutOnAxis: getLayoutOnAxis_1,
    	prepareLayoutBarSeries: prepareLayoutBarSeries_1,
    	makeColumnLayout: makeColumnLayout_1,
    	retrieveColumnLayout: retrieveColumnLayout_1,
    	layout: layout_1,
    	largeLayout: largeLayout_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */











    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * A third-party license is embeded for some of the code in this file:
    * The "scaleLevels" was originally copied from "d3.js" with some
    * modifications made for this project.
    * (See more details in the comment on the definition of "scaleLevels" below.)
    * The use of the source code of this file is also subject to the terms
    * and consitions of the license of "d3.js" (BSD-3Clause, see
    * </licenses/LICENSE-d3>).
    */
    // [About UTC and local time zone]:
    // In most cases, `number.parseDate` will treat input data string as local time
    // (except time zone is specified in time string). And `format.formateTime` returns
    // local time by default. option.useUTC is false by default. This design have
    // concidered these common case:
    // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed
    // in local time by default.
    // (2) By default, the input data string (e.g., '2011-01-02') should be displayed
    // as its original time, without any time difference.
    var intervalScaleProto = Interval.prototype;
    var mathCeil = Math.ceil;
    var mathFloor = Math.floor;
    var ONE_SECOND = 1000;
    var ONE_MINUTE = ONE_SECOND * 60;
    var ONE_HOUR = ONE_MINUTE * 60;
    var ONE_DAY = ONE_HOUR * 24; // FIXME 公用？

    var bisect = function (a, x, lo, hi) {
      while (lo < hi) {
        var mid = lo + hi >>> 1;

        if (a[mid][1] < x) {
          lo = mid + 1;
        } else {
          hi = mid;
        }
      }

      return lo;
    };
    /**
     * @alias module:echarts/coord/scale/Time
     * @constructor
     */


    var TimeScale = Interval.extend({
      type: 'time',

      /**
       * @override
       */
      getLabel: function (val) {
        var stepLvl = this._stepLvl;
        var date = new Date(val);
        return format$1.formatTime(stepLvl[0], date, this.getSetting('useUTC'));
      },

      /**
       * @override
       */
      niceExtent: function (opt) {
        var extent = this._extent; // If extent start and end are same, expand them

        if (extent[0] === extent[1]) {
          // Expand extent
          extent[0] -= ONE_DAY;
          extent[1] += ONE_DAY;
        } // If there are no data and extent are [Infinity, -Infinity]


        if (extent[1] === -Infinity && extent[0] === Infinity) {
          var d = new Date();
          extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
          extent[0] = extent[1] - ONE_DAY;
        }

        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;

        var interval = this._interval;

        if (!opt.fixMin) {
          extent[0] = number.round(mathFloor(extent[0] / interval) * interval);
        }

        if (!opt.fixMax) {
          extent[1] = number.round(mathCeil(extent[1] / interval) * interval);
        }
      },

      /**
       * @override
       */
      niceTicks: function (approxTickNum, minInterval, maxInterval) {
        approxTickNum = approxTickNum || 10;
        var extent = this._extent;
        var span = extent[1] - extent[0];
        var approxInterval = span / approxTickNum;

        if (minInterval != null && approxInterval < minInterval) {
          approxInterval = minInterval;
        }

        if (maxInterval != null && approxInterval > maxInterval) {
          approxInterval = maxInterval;
        }

        var scaleLevelsLen = scaleLevels.length;
        var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
        var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
        var interval = level[1]; // Same with interval scale if span is much larger than 1 year

        if (level[0] === 'year') {
          var yearSpan = span / interval; // From "Nice Numbers for Graph Labels" of Graphic Gems
          // var niceYearSpan = numberUtil.nice(yearSpan, false);

          var yearStep = number.nice(yearSpan / approxTickNum, true);
          interval *= yearStep;
        }

        var timezoneOffset = this.getSetting('useUTC') ? 0 : new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 60 * 1000;
        var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];
        helper.fixExtent(niceExtent, extent);
        this._stepLvl = level; // Interval will be used in getTicks

        this._interval = interval;
        this._niceExtent = niceExtent;
      },
      parse: function (val) {
        // val might be float.
        return +number.parseDate(val);
      }
    });
    util.each(['contain', 'normalize'], function (methodName) {
      TimeScale.prototype[methodName] = function (val) {
        return intervalScaleProto[methodName].call(this, this.parse(val));
      };
    });
    /**
     * This implementation was originally copied from "d3.js"
     * <https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/time/scale.js>
     * with some modifications made for this program.
     * See the license statement at the head of this file.
     */

    var scaleLevels = [// Format              interval
    ['hh:mm:ss', ONE_SECOND], // 1s
    ['hh:mm:ss', ONE_SECOND * 5], // 5s
    ['hh:mm:ss', ONE_SECOND * 10], // 10s
    ['hh:mm:ss', ONE_SECOND * 15], // 15s
    ['hh:mm:ss', ONE_SECOND * 30], // 30s
    ['hh:mm\nMM-dd', ONE_MINUTE], // 1m
    ['hh:mm\nMM-dd', ONE_MINUTE * 5], // 5m
    ['hh:mm\nMM-dd', ONE_MINUTE * 10], // 10m
    ['hh:mm\nMM-dd', ONE_MINUTE * 15], // 15m
    ['hh:mm\nMM-dd', ONE_MINUTE * 30], // 30m
    ['hh:mm\nMM-dd', ONE_HOUR], // 1h
    ['hh:mm\nMM-dd', ONE_HOUR * 2], // 2h
    ['hh:mm\nMM-dd', ONE_HOUR * 6], // 6h
    ['hh:mm\nMM-dd', ONE_HOUR * 12], // 12h
    ['MM-dd\nyyyy', ONE_DAY], // 1d
    ['MM-dd\nyyyy', ONE_DAY * 2], // 2d
    ['MM-dd\nyyyy', ONE_DAY * 3], // 3d
    ['MM-dd\nyyyy', ONE_DAY * 4], // 4d
    ['MM-dd\nyyyy', ONE_DAY * 5], // 5d
    ['MM-dd\nyyyy', ONE_DAY * 6], // 6d
    ['week', ONE_DAY * 7], // 7d
    ['MM-dd\nyyyy', ONE_DAY * 10], // 10d
    ['week', ONE_DAY * 14], // 2w
    ['week', ONE_DAY * 21], // 3w
    ['month', ONE_DAY * 31], // 1M
    ['week', ONE_DAY * 42], // 6w
    ['month', ONE_DAY * 62], // 2M
    ['week', ONE_DAY * 70], // 10w
    ['quarter', ONE_DAY * 95], // 3M
    ['month', ONE_DAY * 31 * 4], // 4M
    ['month', ONE_DAY * 31 * 5], // 5M
    ['half-year', ONE_DAY * 380 / 2], // 6M
    ['month', ONE_DAY * 31 * 8], // 8M
    ['month', ONE_DAY * 31 * 10], // 10M
    ['year', ONE_DAY * 380] // 1Y
    ];
    /**
     * @param {module:echarts/model/Model}
     * @return {module:echarts/scale/Time}
     */

    TimeScale.create = function (model) {
      return new TimeScale({
        useUTC: model.ecModel.get('useUTC')
      });
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Log scale
     * @module echarts/scale/Log
     */
    // Use some method of IntervalScale
    var scaleProto$1 = Scale_1.prototype;
    var intervalScaleProto$1 = Interval.prototype;
    var getPrecisionSafe$1 = number.getPrecisionSafe;
    var roundingErrorFix = number.round;
    var mathFloor$1 = Math.floor;
    var mathCeil$1 = Math.ceil;
    var mathPow$1 = Math.pow;
    var mathLog = Math.log;
    var LogScale = Scale_1.extend({
      type: 'log',
      base: 10,
      $constructor: function () {
        Scale_1.apply(this, arguments);
        this._originalScale = new Interval();
      },

      /**
       * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.
       * @return {Array.<number>}
       */
      getTicks: function (expandToNicedExtent) {
        var originalScale = this._originalScale;
        var extent = this._extent;
        var originalExtent = originalScale.getExtent();
        return util.map(intervalScaleProto$1.getTicks.call(this, expandToNicedExtent), function (val) {
          var powVal = number.round(mathPow$1(this.base, val)); // Fix #4158

          powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
          powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
          return powVal;
        }, this);
      },

      /**
       * @param {number} splitNumber
       * @return {Array.<Array.<number>>}
       */
      getMinorTicks: intervalScaleProto$1.getMinorTicks,

      /**
       * @param {number} val
       * @return {string}
       */
      getLabel: intervalScaleProto$1.getLabel,

      /**
       * @param  {number} val
       * @return {number}
       */
      scale: function (val) {
        val = scaleProto$1.scale.call(this, val);
        return mathPow$1(this.base, val);
      },

      /**
       * @param {number} start
       * @param {number} end
       */
      setExtent: function (start, end) {
        var base = this.base;
        start = mathLog(start) / mathLog(base);
        end = mathLog(end) / mathLog(base);
        intervalScaleProto$1.setExtent.call(this, start, end);
      },

      /**
       * @return {number} end
       */
      getExtent: function () {
        var base = this.base;
        var extent = scaleProto$1.getExtent.call(this);
        extent[0] = mathPow$1(base, extent[0]);
        extent[1] = mathPow$1(base, extent[1]); // Fix #4158

        var originalScale = this._originalScale;
        var originalExtent = originalScale.getExtent();
        originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
        originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
        return extent;
      },

      /**
       * @param  {Array.<number>} extent
       */
      unionExtent: function (extent) {
        this._originalScale.unionExtent(extent);

        var base = this.base;
        extent[0] = mathLog(extent[0]) / mathLog(base);
        extent[1] = mathLog(extent[1]) / mathLog(base);
        scaleProto$1.unionExtent.call(this, extent);
      },

      /**
       * @override
       */
      unionExtentFromData: function (data, dim) {
        // TODO
        // filter value that <= 0
        this.unionExtent(data.getApproximateExtent(dim));
      },

      /**
       * Update interval and extent of intervals for nice ticks
       * @param  {number} [approxTickNum = 10] Given approx tick number
       */
      niceTicks: function (approxTickNum) {
        approxTickNum = approxTickNum || 10;
        var extent = this._extent;
        var span = extent[1] - extent[0];

        if (span === Infinity || span <= 0) {
          return;
        }

        var interval = number.quantity(span);
        var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.

        if (err <= 0.5) {
          interval *= 10;
        } // Interval should be integer


        while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
          interval *= 10;
        }

        var niceExtent = [number.round(mathCeil$1(extent[0] / interval) * interval), number.round(mathFloor$1(extent[1] / interval) * interval)];
        this._interval = interval;
        this._niceExtent = niceExtent;
      },

      /**
       * Nice extent.
       * @override
       */
      niceExtent: function (opt) {
        intervalScaleProto$1.niceExtent.call(this, opt);
        var originalScale = this._originalScale;
        originalScale.__fixMin = opt.fixMin;
        originalScale.__fixMax = opt.fixMax;
      }
    });
    util.each(['contain', 'normalize'], function (methodName) {
      LogScale.prototype[methodName] = function (val) {
        val = mathLog(val) / mathLog(this.base);
        return scaleProto$1[methodName].call(this, val);
      };
    });

    LogScale.create = function () {
      return new LogScale();
    };

    function fixRoundingError(val, originalVal) {
      return roundingErrorFix(val, getPrecisionSafe$1(originalVal));
    }

    var prepareLayoutBarSeries$1 = barGrid.prepareLayoutBarSeries;
    var makeColumnLayout$1 = barGrid.makeColumnLayout;
    var retrieveColumnLayout$1 = barGrid.retrieveColumnLayout;







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Get axis scale extent before niced.
     * Item of returned array can only be number (including Infinity and NaN).
     */
    function getScaleExtent(scale, model) {
      var scaleType = scale.type;
      var min = model.getMin();
      var max = model.getMax();
      var originalExtent = scale.getExtent();
      var axisDataLen;
      var boundaryGap;
      var span;

      if (scaleType === 'ordinal') {
        axisDataLen = model.getCategories().length;
      } else {
        boundaryGap = model.get('boundaryGap');

        if (!util.isArray(boundaryGap)) {
          boundaryGap = [boundaryGap || 0, boundaryGap || 0];
        }

        if (typeof boundaryGap[0] === 'boolean') {
          boundaryGap = [0, 0];
        }

        boundaryGap[0] = number.parsePercent(boundaryGap[0], 1);
        boundaryGap[1] = number.parsePercent(boundaryGap[1], 1);
        span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);
      } // Notice: When min/max is not set (that is, when there are null/undefined,
      // which is the most common case), these cases should be ensured:
      // (1) For 'ordinal', show all axis.data.
      // (2) For others:
      //      + `boundaryGap` is applied (if min/max set, boundaryGap is
      //      disabled).
      //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should
      //      be the result that originalExtent enlarged by boundaryGap.
      // (3) If no data, it should be ensured that `scale.setBlank` is set.
      // FIXME
      // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?
      // (2) When `needCrossZero` and all data is positive/negative, should it be ensured
      // that the results processed by boundaryGap are positive/negative?


      if (min === 'dataMin') {
        min = originalExtent[0];
      } else if (typeof min === 'function') {
        min = min({
          min: originalExtent[0],
          max: originalExtent[1]
        });
      }

      if (max === 'dataMax') {
        max = originalExtent[1];
      } else if (typeof max === 'function') {
        max = max({
          min: originalExtent[0],
          max: originalExtent[1]
        });
      }

      var fixMin = min != null;
      var fixMax = max != null;

      if (min == null) {
        min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;
      }

      if (max == null) {
        max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;
      }

      (min == null || !isFinite(min)) && (min = NaN);
      (max == null || !isFinite(max)) && (max = NaN);
      scale.setBlank(util.eqNaN(min) || util.eqNaN(max) || scaleType === 'ordinal' && !scale.getOrdinalMeta().categories.length); // Evaluate if axis needs cross zero

      if (model.getNeedCrossZero()) {
        // Axis is over zero and min is not set
        if (min > 0 && max > 0 && !fixMin) {
          min = 0;
        } // Axis is under zero and max is not set


        if (min < 0 && max < 0 && !fixMax) {
          max = 0;
        }
      } // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis
      // is base axis
      // FIXME
      // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.
      // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?
      //     Should not depend on series type `bar`?
      // (3) Fix that might overlap when using dataZoom.
      // (4) Consider other chart types using `barGrid`?
      // See #6728, #4862, `test/bar-overflow-time-plot.html`


      var ecModel = model.ecModel;

      if (ecModel && scaleType === 'time'
      /*|| scaleType === 'interval' */
      ) {
        var barSeriesModels = prepareLayoutBarSeries$1('bar', ecModel);
        var isBaseAxisAndHasBarSeries;
        util.each(barSeriesModels, function (seriesModel) {
          isBaseAxisAndHasBarSeries |= seriesModel.getBaseAxis() === model.axis;
        });

        if (isBaseAxisAndHasBarSeries) {
          // Calculate placement of bars on axis
          var barWidthAndOffset = makeColumnLayout$1(barSeriesModels); // Adjust axis min and max to account for overflow

          var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);
          min = adjustedScale.min;
          max = adjustedScale.max;
        }
      }

      return {
        extent: [min, max],
        // "fix" means "fixed", the value should not be
        // changed in the subsequent steps.
        fixMin: fixMin,
        fixMax: fixMax
      };
    }

    function adjustScaleForOverflow(min, max, model, barWidthAndOffset) {
      // Get Axis Length
      var axisExtent = model.axis.getExtent();
      var axisLength = axisExtent[1] - axisExtent[0]; // Get bars on current base axis and calculate min and max overflow

      var barsOnCurrentAxis = retrieveColumnLayout$1(barWidthAndOffset, model.axis);

      if (barsOnCurrentAxis === undefined) {
        return {
          min: min,
          max: max
        };
      }

      var minOverflow = Infinity;
      util.each(barsOnCurrentAxis, function (item) {
        minOverflow = Math.min(item.offset, minOverflow);
      });
      var maxOverflow = -Infinity;
      util.each(barsOnCurrentAxis, function (item) {
        maxOverflow = Math.max(item.offset + item.width, maxOverflow);
      });
      minOverflow = Math.abs(minOverflow);
      maxOverflow = Math.abs(maxOverflow);
      var totalOverFlow = minOverflow + maxOverflow; // Calulate required buffer based on old range and overflow

      var oldRange = max - min;
      var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
      var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
      max += overflowBuffer * (maxOverflow / totalOverFlow);
      min -= overflowBuffer * (minOverflow / totalOverFlow);
      return {
        min: min,
        max: max
      };
    }

    function niceScaleExtent(scale, model) {
      var extentInfo = getScaleExtent(scale, model);
      var extent = extentInfo.extent;
      var splitNumber = model.get('splitNumber');

      if (scale.type === 'log') {
        scale.base = model.get('logBase');
      }

      var scaleType = scale.type;
      scale.setExtent(extent[0], extent[1]);
      scale.niceExtent({
        splitNumber: splitNumber,
        fixMin: extentInfo.fixMin,
        fixMax: extentInfo.fixMax,
        minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,
        maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null
      }); // If some one specified the min, max. And the default calculated interval
      // is not good enough. He can specify the interval. It is often appeared
      // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
      // to be 60.
      // FIXME

      var interval = model.get('interval');

      if (interval != null) {
        scale.setInterval && scale.setInterval(interval);
      }
    }
    /**
     * @param {module:echarts/model/Model} model
     * @param {string} [axisType] Default retrieve from model.type
     * @return {module:echarts/scale/*}
     */


    function createScaleByModel(model, axisType) {
      axisType = axisType || model.get('type');

      if (axisType) {
        switch (axisType) {
          // Buildin scale
          case 'category':
            return new Ordinal(model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(), [Infinity, -Infinity]);

          case 'value':
            return new Interval();
          // Extended scale, like time and log

          default:
            return (Scale_1.getClass(axisType) || Interval).create(model);
        }
      }
    }
    /**
     * Check if the axis corss 0
     */


    function ifAxisCrossZero(axis) {
      var dataExtent = axis.scale.getExtent();
      var min = dataExtent[0];
      var max = dataExtent[1];
      return !(min > 0 && max > 0 || min < 0 && max < 0);
    }
    /**
     * @param {module:echarts/coord/Axis} axis
     * @return {Function} Label formatter function.
     *         param: {number} tickValue,
     *         param: {number} idx, the index in all ticks.
     *                         If category axis, this param is not requied.
     *         return: {string} label string.
     */


    function makeLabelFormatter(axis) {
      var labelFormatter = axis.getLabelModel().get('formatter');
      var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;

      if (typeof labelFormatter === 'string') {
        labelFormatter = function (tpl) {
          return function (val) {
            // For category axis, get raw value; for numeric axis,
            // get foramtted label like '1,333,444'.
            val = axis.scale.getLabel(val);
            return tpl.replace('{value}', val != null ? val : '');
          };
        }(labelFormatter); // Consider empty array


        return labelFormatter;
      } else if (typeof labelFormatter === 'function') {
        return function (tickValue, idx) {
          // The original intention of `idx` is "the index of the tick in all ticks".
          // But the previous implementation of category axis do not consider the
          // `axisLabel.interval`, which cause that, for example, the `interval` is
          // `1`, then the ticks "name5", "name7", "name9" are displayed, where the
          // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep
          // the definition here for back compatibility.
          if (categoryTickStart != null) {
            idx = tickValue - categoryTickStart;
          }

          return labelFormatter(getAxisRawValue(axis, tickValue), idx);
        };
      } else {
        return function (tick) {
          return axis.scale.getLabel(tick);
        };
      }
    }

    function getAxisRawValue(axis, value) {
      // In category axis with data zoom, tick is not the original
      // index of axis.data. So tick should not be exposed to user
      // in category axis.
      return axis.type === 'category' ? axis.scale.getLabel(value) : value;
    }
    /**
     * @param {module:echarts/coord/Axis} axis
     * @return {module:zrender/core/BoundingRect} Be null/undefined if no labels.
     */


    function estimateLabelUnionRect(axis) {
      var axisModel = axis.model;
      var scale = axis.scale;

      if (!axisModel.get('axisLabel.show') || scale.isBlank()) {
        return;
      }

      var isCategory = axis.type === 'category';
      var realNumberScaleTicks;
      var tickCount;
      var categoryScaleExtent = scale.getExtent(); // Optimize for large category data, avoid call `getTicks()`.

      if (isCategory) {
        tickCount = scale.count();
      } else {
        realNumberScaleTicks = scale.getTicks();
        tickCount = realNumberScaleTicks.length;
      }

      var axisLabelModel = axis.getLabelModel();
      var labelFormatter = makeLabelFormatter(axis);
      var rect;
      var step = 1; // Simple optimization for large amount of labels

      if (tickCount > 40) {
        step = Math.ceil(tickCount / 40);
      }

      for (var i = 0; i < tickCount; i += step) {
        var tickValue = realNumberScaleTicks ? realNumberScaleTicks[i] : categoryScaleExtent[0] + i;
        var label = labelFormatter(tickValue);
        var unrotatedSingleRect = axisLabelModel.getTextRect(label);
        var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);
        rect ? rect.union(singleRect) : rect = singleRect;
      }

      return rect;
    }

    function rotateTextRect(textRect, rotate) {
      var rotateRadians = rotate * Math.PI / 180;
      var boundingBox = textRect.plain();
      var beforeWidth = boundingBox.width;
      var beforeHeight = boundingBox.height;
      var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);
      var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);
      var rotatedRect = new BoundingRect_1(boundingBox.x, boundingBox.y, afterWidth, afterHeight);
      return rotatedRect;
    }
    /**
     * @param {module:echarts/src/model/Model} model axisLabelModel or axisTickModel
     * @return {number|String} Can be null|'auto'|number|function
     */


    function getOptionCategoryInterval(model) {
      var interval = model.get('interval');
      return interval == null ? 'auto' : interval;
    }
    /**
     * Set `categoryInterval` as 0 implicitly indicates that
     * show all labels reguardless of overlap.
     * @param {Object} axis axisModel.axis
     * @return {boolean}
     */


    function shouldShowAllLabels(axis) {
      return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;
    }

    var getScaleExtent_1 = getScaleExtent;
    var niceScaleExtent_1 = niceScaleExtent;
    var createScaleByModel_1 = createScaleByModel;
    var ifAxisCrossZero_1 = ifAxisCrossZero;
    var makeLabelFormatter_1 = makeLabelFormatter;
    var getAxisRawValue_1 = getAxisRawValue;
    var estimateLabelUnionRect_1 = estimateLabelUnionRect;
    var getOptionCategoryInterval_1 = getOptionCategoryInterval;
    var shouldShowAllLabels_1 = shouldShowAllLabels;

    var axisHelper = {
    	getScaleExtent: getScaleExtent_1,
    	niceScaleExtent: niceScaleExtent_1,
    	createScaleByModel: createScaleByModel_1,
    	ifAxisCrossZero: ifAxisCrossZero_1,
    	makeLabelFormatter: makeLabelFormatter_1,
    	getAxisRawValue: getAxisRawValue_1,
    	estimateLabelUnionRect: estimateLabelUnionRect_1,
    	getOptionCategoryInterval: getOptionCategoryInterval_1,
    	shouldShowAllLabels: shouldShowAllLabels_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // import * as axisHelper from './axisHelper';
    var _default$1s = {
      /**
       * @param {boolean} origin
       * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN
       */
      getMin: function (origin) {
        var option = this.option;
        var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;

        if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !util.eqNaN(min)) {
          min = this.axis.scale.parse(min);
        }

        return min;
      },

      /**
       * @param {boolean} origin
       * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN
       */
      getMax: function (origin) {
        var option = this.option;
        var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;

        if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !util.eqNaN(max)) {
          max = this.axis.scale.parse(max);
        }

        return max;
      },

      /**
       * @return {boolean}
       */
      getNeedCrossZero: function () {
        var option = this.option;
        return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;
      },

      /**
       * Should be implemented by each axis model if necessary.
       * @return {module:echarts/model/Component} coordinate system model
       */
      getCoordSysModel: util.noop,

      /**
       * @param {number} rangeStart Can only be finite number or null/undefined or NaN.
       * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.
       */
      setRange: function (rangeStart, rangeEnd) {
        this.option.rangeStart = rangeStart;
        this.option.rangeEnd = rangeEnd;
      },

      /**
       * Reset range
       */
      resetRange: function () {
        // rangeStart and rangeEnd is readonly.
        this.option.rangeStart = this.option.rangeEnd = null;
      }
    };
    var axisModelCommonMixin = _default$1s;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    var calculateTextPosition$1 = text$1.calculateTextPosition;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // Symbol factory

    /**
     * Triangle shape
     * @inner
     */
    var Triangle = graphic.extendShape({
      type: 'triangle',
      shape: {
        cx: 0,
        cy: 0,
        width: 0,
        height: 0
      },
      buildPath: function (path, shape) {
        var cx = shape.cx;
        var cy = shape.cy;
        var width = shape.width / 2;
        var height = shape.height / 2;
        path.moveTo(cx, cy - height);
        path.lineTo(cx + width, cy + height);
        path.lineTo(cx - width, cy + height);
        path.closePath();
      }
    });
    /**
     * Diamond shape
     * @inner
     */

    var Diamond = graphic.extendShape({
      type: 'diamond',
      shape: {
        cx: 0,
        cy: 0,
        width: 0,
        height: 0
      },
      buildPath: function (path, shape) {
        var cx = shape.cx;
        var cy = shape.cy;
        var width = shape.width / 2;
        var height = shape.height / 2;
        path.moveTo(cx, cy - height);
        path.lineTo(cx + width, cy);
        path.lineTo(cx, cy + height);
        path.lineTo(cx - width, cy);
        path.closePath();
      }
    });
    /**
     * Pin shape
     * @inner
     */

    var Pin = graphic.extendShape({
      type: 'pin',
      shape: {
        // x, y on the cusp
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      buildPath: function (path, shape) {
        var x = shape.x;
        var y = shape.y;
        var w = shape.width / 5 * 3; // Height must be larger than width

        var h = Math.max(w, shape.height);
        var r = w / 2; // Dist on y with tangent point and circle center

        var dy = r * r / (h - r);
        var cy = y - h + r + dy;
        var angle = Math.asin(dy / r); // Dist on x with tangent point and circle center

        var dx = Math.cos(angle) * r;
        var tanX = Math.sin(angle);
        var tanY = Math.cos(angle);
        var cpLen = r * 0.6;
        var cpLen2 = r * 0.7;
        path.moveTo(x - dx, cy + dy);
        path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
        path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
        path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
        path.closePath();
      }
    });
    /**
     * Arrow shape
     * @inner
     */

    var Arrow = graphic.extendShape({
      type: 'arrow',
      shape: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      buildPath: function (ctx, shape) {
        var height = shape.height;
        var width = shape.width;
        var x = shape.x;
        var y = shape.y;
        var dx = width / 3 * 2;
        ctx.moveTo(x, y);
        ctx.lineTo(x + dx, y + height);
        ctx.lineTo(x, y + height / 4 * 3);
        ctx.lineTo(x - dx, y + height);
        ctx.lineTo(x, y);
        ctx.closePath();
      }
    });
    /**
     * Map of path contructors
     * @type {Object.<string, module:zrender/graphic/Path>}
     */

    var symbolCtors = {
      line: graphic.Line,
      rect: graphic.Rect,
      roundRect: graphic.Rect,
      square: graphic.Rect,
      circle: graphic.Circle,
      diamond: Diamond,
      pin: Pin,
      arrow: Arrow,
      triangle: Triangle
    };
    var symbolShapeMakers = {
      line: function (x, y, w, h, shape) {
        // FIXME
        shape.x1 = x;
        shape.y1 = y + h / 2;
        shape.x2 = x + w;
        shape.y2 = y + h / 2;
      },
      rect: function (x, y, w, h, shape) {
        shape.x = x;
        shape.y = y;
        shape.width = w;
        shape.height = h;
      },
      roundRect: function (x, y, w, h, shape) {
        shape.x = x;
        shape.y = y;
        shape.width = w;
        shape.height = h;
        shape.r = Math.min(w, h) / 4;
      },
      square: function (x, y, w, h, shape) {
        var size = Math.min(w, h);
        shape.x = x;
        shape.y = y;
        shape.width = size;
        shape.height = size;
      },
      circle: function (x, y, w, h, shape) {
        // Put circle in the center of square
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.r = Math.min(w, h) / 2;
      },
      diamond: function (x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.width = w;
        shape.height = h;
      },
      pin: function (x, y, w, h, shape) {
        shape.x = x + w / 2;
        shape.y = y + h / 2;
        shape.width = w;
        shape.height = h;
      },
      arrow: function (x, y, w, h, shape) {
        shape.x = x + w / 2;
        shape.y = y + h / 2;
        shape.width = w;
        shape.height = h;
      },
      triangle: function (x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.width = w;
        shape.height = h;
      }
    };
    var symbolBuildProxies = {};
    util.each(symbolCtors, function (Ctor, name) {
      symbolBuildProxies[name] = new Ctor();
    });
    var SymbolClz = graphic.extendShape({
      type: 'symbol',
      shape: {
        symbolType: '',
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      calculateTextPosition: function (out, style, rect) {
        var res = calculateTextPosition$1(out, style, rect);
        var shape = this.shape;

        if (shape && shape.symbolType === 'pin' && style.textPosition === 'inside') {
          res.y = rect.y + rect.height * 0.4;
        }

        return res;
      },
      buildPath: function (ctx, shape, inBundle) {
        var symbolType = shape.symbolType;

        if (symbolType !== 'none') {
          var proxySymbol = symbolBuildProxies[symbolType];

          if (!proxySymbol) {
            // Default rect
            symbolType = 'rect';
            proxySymbol = symbolBuildProxies[symbolType];
          }

          symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
          proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
        }
      }
    }); // Provide setColor helper method to avoid determine if set the fill or stroke outside

    function symbolPathSetColor(color, innerColor) {
      if (this.type !== 'image') {
        var symbolStyle = this.style;
        var symbolShape = this.shape;

        if (symbolShape && symbolShape.symbolType === 'line') {
          symbolStyle.stroke = color;
        } else if (this.__isEmptyBrush) {
          symbolStyle.stroke = color;
          symbolStyle.fill = innerColor || '#fff';
        } else {
          // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
          symbolStyle.fill && (symbolStyle.fill = color);
          symbolStyle.stroke && (symbolStyle.stroke = color);
        }

        this.dirty(false);
      }
    }
    /**
     * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
     * @param {string} symbolType
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @param {string} color
     * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,
     *                            for path and image only.
     */


    function createSymbol(symbolType, x, y, w, h, color, keepAspect) {
      // TODO Support image object, DynamicImage.
      var isEmpty = symbolType.indexOf('empty') === 0;

      if (isEmpty) {
        symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
      }

      var symbolPath;

      if (symbolType.indexOf('image://') === 0) {
        symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect_1(x, y, w, h), keepAspect ? 'center' : 'cover');
      } else if (symbolType.indexOf('path://') === 0) {
        symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect_1(x, y, w, h), keepAspect ? 'center' : 'cover');
      } else {
        symbolPath = new SymbolClz({
          shape: {
            symbolType: symbolType,
            x: x,
            y: y,
            width: w,
            height: h
          }
        });
      }

      symbolPath.__isEmptyBrush = isEmpty;
      symbolPath.setColor = symbolPathSetColor;
      symbolPath.setColor(color);
      return symbolPath;
    }

    var createSymbol_1 = createSymbol;

    var symbol = {
    	createSymbol: createSymbol_1
    };

    var getLayoutRect_1$1 = layout.getLayoutRect;



    var enableDataStack$2 = dataStackHelper.enableDataStack;
    var isDimensionStacked$2 = dataStackHelper.isDimensionStacked;
    var getStackedDimension$1 = dataStackHelper.getStackedDimension;



    var completeDimensions$1 = completeDimensions_1;



    var createDimensions$1 = createDimensions;



    var createSymbol$1 = symbol.createSymbol;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // import createGraphFromNodeEdge from './chart/helper/createGraphFromNodeEdge';

    /**
     * Create a muti dimension List structure from seriesModel.
     * @param  {module:echarts/model/Model} seriesModel
     * @return {module:echarts/data/List} list
     */
    function createList(seriesModel) {
      return createListFromArray_1(seriesModel.getSource(), seriesModel);
    } // export function createGraph(seriesModel) {
    //     var nodes = seriesModel.get('data');
    //     var links = seriesModel.get('links');
    //     return createGraphFromNodeEdge(nodes, links, seriesModel);
    // }


    var dataStack$1 = {
      isDimensionStacked: isDimensionStacked$2,
      enableDataStack: enableDataStack$2,
      getStackedDimension: getStackedDimension$1
    };
    /**
     * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
     * @param {string} symbolDesc
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @param {string} color
     */

    /**
     * Create scale
     * @param {Array.<number>} dataExtent
     * @param {Object|module:echarts/Model} option
     */
    function createScale(dataExtent, option) {
      var axisModel = option;

      if (!Model_1.isInstance(option)) {
        axisModel = new Model_1(option);
        util.mixin(axisModel, axisModelCommonMixin);
      }

      var scale = axisHelper.createScaleByModel(axisModel);
      scale.setExtent(dataExtent[0], dataExtent[1]);
      axisHelper.niceScaleExtent(scale, axisModel);
      return scale;
    }
    /**
     * Mixin common methods to axis model,
     *
     * Inlcude methods
     * `getFormattedLabels() => Array.<string>`
     * `getCategories() => Array.<string>`
     * `getMin(origin: boolean) => number`
     * `getMax(origin: boolean) => number`
     * `getNeedCrossZero() => boolean`
     * `setRange(start: number, end: number)`
     * `resetRange()`
     */


    function mixinAxisModelCommonMethods(Model) {
      util.mixin(Model, axisModelCommonMixin);
    }

    var createList_1 = createList;
    var dataStack_1 = dataStack$1;
    var createScale_1 = createScale;
    var mixinAxisModelCommonMethods_1 = mixinAxisModelCommonMethods;

    var helper$1 = {
    	getLayoutRect: getLayoutRect_1$1,
    	completeDimensions: completeDimensions$1,
    	createDimensions: createDimensions$1,
    	createSymbol: createSymbol$1,
    	createList: createList_1,
    	dataStack: dataStack_1,
    	createScale: createScale_1,
    	mixinAxisModelCommonMethods: mixinAxisModelCommonMethods_1
    };

    var EPSILON$3 = 1e-8;

    function isAroundEqual$1(a, b) {
      return Math.abs(a - b) < EPSILON$3;
    }

    function contain$1(points, x, y) {
      var w = 0;
      var p = points[0];

      if (!p) {
        return false;
      }

      for (var i = 1; i < points.length; i++) {
        var p2 = points[i];
        w += windingLine_1(p[0], p[1], p2[0], p2[1], x, y);
        p = p2;
      } // Close polygon


      var p0 = points[0];

      if (!isAroundEqual$1(p[0], p0[0]) || !isAroundEqual$1(p[1], p0[1])) {
        w += windingLine_1(p[0], p[1], p0[0], p0[1], x, y);
      }

      return w !== 0;
    }

    var contain_1$1 = contain$1;

    var polygon = {
    	contain: contain_1$1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @module echarts/coord/geo/Region
     */

    /**
     * @param {string|Region} name
     * @param {Array} geometries
     * @param {Array.<number>} cp
     */
    function Region(name, geometries, cp) {
      /**
       * @type {string}
       * @readOnly
       */
      this.name = name;
      /**
       * @type {Array.<Array>}
       * @readOnly
       */

      this.geometries = geometries;

      if (!cp) {
        var rect = this.getBoundingRect();
        cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      } else {
        cp = [cp[0], cp[1]];
      }
      /**
       * @type {Array.<number>}
       */


      this.center = cp;
    }

    Region.prototype = {
      constructor: Region,
      properties: null,

      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getBoundingRect: function () {
        var rect = this._rect;

        if (rect) {
          return rect;
        }

        var MAX_NUMBER = Number.MAX_VALUE;
        var min = [MAX_NUMBER, MAX_NUMBER];
        var max = [-MAX_NUMBER, -MAX_NUMBER];
        var min2 = [];
        var max2 = [];
        var geometries = this.geometries;

        for (var i = 0; i < geometries.length; i++) {
          // Only support polygon
          if (geometries[i].type !== 'polygon') {
            continue;
          } // Doesn't consider hole


          var exterior = geometries[i].exterior;
          bbox.fromPoints(exterior, min2, max2);
          vector.min(min, min, min2);
          vector.max(max, max, max2);
        } // No data


        if (i === 0) {
          min[0] = min[1] = max[0] = max[1] = 0;
        }

        return this._rect = new BoundingRect_1(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },

      /**
       * @param {<Array.<number>} coord
       * @return {boolean}
       */
      contain: function (coord) {
        var rect = this.getBoundingRect();
        var geometries = this.geometries;

        if (!rect.contain(coord[0], coord[1])) {
          return false;
        }

        loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {
          // Only support polygon.
          if (geometries[i].type !== 'polygon') {
            continue;
          }

          var exterior = geometries[i].exterior;
          var interiors = geometries[i].interiors;

          if (polygon.contain(exterior, coord[0], coord[1])) {
            // Not in the region if point is in the hole.
            for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
              if (polygon.contain(interiors[k])) {
                continue loopGeo;
              }
            }

            return true;
          }
        }

        return false;
      },
      transformTo: function (x, y, width, height) {
        var rect = this.getBoundingRect();
        var aspect = rect.width / rect.height;

        if (!width) {
          width = aspect * height;
        } else if (!height) {
          height = width / aspect;
        }

        var target = new BoundingRect_1(x, y, width, height);
        var transform = rect.calculateTransform(target);
        var geometries = this.geometries;

        for (var i = 0; i < geometries.length; i++) {
          // Only support polygon.
          if (geometries[i].type !== 'polygon') {
            continue;
          }

          var exterior = geometries[i].exterior;
          var interiors = geometries[i].interiors;

          for (var p = 0; p < exterior.length; p++) {
            vector.applyTransform(exterior[p], exterior[p], transform);
          }

          for (var h = 0; h < (interiors ? interiors.length : 0); h++) {
            for (var p = 0; p < interiors[h].length; p++) {
              vector.applyTransform(interiors[h][p], interiors[h][p], transform);
            }
          }
        }

        rect = this._rect;
        rect.copy(target); // Update center

        this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      },
      cloneShallow: function (name) {
        name == null && (name = this.name);
        var newRegion = new Region(name, this.geometries, this.center);
        newRegion._rect = this._rect;
        newRegion.transformTo = null; // Simply avoid to be called.

        return newRegion;
      }
    };
    var _default$1t = Region;
    var Region_1 = _default$1t;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Parse and decode geo json
     * @module echarts/coord/geo/parseGeoJson
     */
    function decode(json) {
      if (!json.UTF8Encoding) {
        return json;
      }

      var encodeScale = json.UTF8Scale;

      if (encodeScale == null) {
        encodeScale = 1024;
      }

      var features = json.features;

      for (var f = 0; f < features.length; f++) {
        var feature = features[f];
        var geometry = feature.geometry;
        var coordinates = geometry.coordinates;
        var encodeOffsets = geometry.encodeOffsets;

        for (var c = 0; c < coordinates.length; c++) {
          var coordinate = coordinates[c];

          if (geometry.type === 'Polygon') {
            coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);
          } else if (geometry.type === 'MultiPolygon') {
            for (var c2 = 0; c2 < coordinate.length; c2++) {
              var polygon = coordinate[c2];
              coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);
            }
          }
        }
      } // Has been decoded


      json.UTF8Encoding = false;
      return json;
    }

    function decodePolygon(coordinate, encodeOffsets, encodeScale) {
      var result = [];
      var prevX = encodeOffsets[0];
      var prevY = encodeOffsets[1];

      for (var i = 0; i < coordinate.length; i += 2) {
        var x = coordinate.charCodeAt(i) - 64;
        var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding

        x = x >> 1 ^ -(x & 1);
        y = y >> 1 ^ -(y & 1); // Delta deocding

        x += prevX;
        y += prevY;
        prevX = x;
        prevY = y; // Dequantize

        result.push([x / encodeScale, y / encodeScale]);
      }

      return result;
    }
    /**
     * @alias module:echarts/coord/geo/parseGeoJson
     * @param {Object} geoJson
     * @param {string} nameProperty
     * @return {module:zrender/container/Group}
     */


    function _default$1u(geoJson, nameProperty) {
      decode(geoJson);
      return util.map(util.filter(geoJson.features, function (featureObj) {
        // Output of mapshaper may have geometry null
        return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
      }), function (featureObj) {
        var properties = featureObj.properties;
        var geo = featureObj.geometry;
        var coordinates = geo.coordinates;
        var geometries = [];

        if (geo.type === 'Polygon') {
          geometries.push({
            type: 'polygon',
            // According to the GeoJSON specification.
            // First must be exterior, and the rest are all interior(holes).
            exterior: coordinates[0],
            interiors: coordinates.slice(1)
          });
        }

        if (geo.type === 'MultiPolygon') {
          util.each(coordinates, function (item) {
            if (item[0]) {
              geometries.push({
                type: 'polygon',
                exterior: item[0],
                interiors: item.slice(1)
              });
            }
          });
        }

        var region = new Region_1(properties[nameProperty || 'name'], geometries, properties.cp);
        region.properties = properties;
        return region;
      });
    }

    var parseGeoJson = _default$1u;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var makeInner$6 = model.makeInner;



    var makeLabelFormatter$1 = axisHelper.makeLabelFormatter;
    var getOptionCategoryInterval$1 = axisHelper.getOptionCategoryInterval;
    var shouldShowAllLabels$1 = axisHelper.shouldShowAllLabels;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var inner$6 = makeInner$6();
    /**
     * @param {module:echats/coord/Axis} axis
     * @return {Object} {
     *     labels: [{
     *         formattedLabel: string,
     *         rawLabel: string,
     *         tickValue: number
     *     }, ...],
     *     labelCategoryInterval: number
     * }
     */

    function createAxisLabels(axis) {
      // Only ordinal scale support tick interval
      return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
    }
    /**
     * @param {module:echats/coord/Axis} axis
     * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.
     * @return {Object} {
     *     ticks: Array.<number>
     *     tickCategoryInterval: number
     * }
     */


    function createAxisTicks(axis, tickModel) {
      // Only ordinal scale support tick interval
      return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {
        ticks: axis.scale.getTicks()
      };
    }

    function makeCategoryLabels(axis) {
      var labelModel = axis.getLabelModel();
      var result = makeCategoryLabelsActually(axis, labelModel);
      return !labelModel.get('show') || axis.scale.isBlank() ? {
        labels: [],
        labelCategoryInterval: result.labelCategoryInterval
      } : result;
    }

    function makeCategoryLabelsActually(axis, labelModel) {
      var labelsCache = getListCache(axis, 'labels');
      var optionLabelInterval = getOptionCategoryInterval$1(labelModel);
      var result = listCacheGet(labelsCache, optionLabelInterval);

      if (result) {
        return result;
      }

      var labels;
      var numericLabelInterval;

      if (util.isFunction(optionLabelInterval)) {
        labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
      } else {
        numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;
        labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
      } // Cache to avoid calling interval function repeatly.


      return listCacheSet(labelsCache, optionLabelInterval, {
        labels: labels,
        labelCategoryInterval: numericLabelInterval
      });
    }

    function makeCategoryTicks(axis, tickModel) {
      var ticksCache = getListCache(axis, 'ticks');
      var optionTickInterval = getOptionCategoryInterval$1(tickModel);
      var result = listCacheGet(ticksCache, optionTickInterval);

      if (result) {
        return result;
      }

      var ticks;
      var tickCategoryInterval; // Optimize for the case that large category data and no label displayed,
      // we should not return all ticks.

      if (!tickModel.get('show') || axis.scale.isBlank()) {
        ticks = [];
      }

      if (util.isFunction(optionTickInterval)) {
        ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
      } // Always use label interval by default despite label show. Consider this
      // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows
      // labels. `splitLine` and `axisTick` should be consistent in this case.
      else if (optionTickInterval === 'auto') {
          var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
          tickCategoryInterval = labelsResult.labelCategoryInterval;
          ticks = util.map(labelsResult.labels, function (labelItem) {
            return labelItem.tickValue;
          });
        } else {
          tickCategoryInterval = optionTickInterval;
          ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
        } // Cache to avoid calling interval function repeatly.


      return listCacheSet(ticksCache, optionTickInterval, {
        ticks: ticks,
        tickCategoryInterval: tickCategoryInterval
      });
    }

    function makeRealNumberLabels(axis) {
      var ticks = axis.scale.getTicks();
      var labelFormatter = makeLabelFormatter$1(axis);
      return {
        labels: util.map(ticks, function (tickValue, idx) {
          return {
            formattedLabel: labelFormatter(tickValue, idx),
            rawLabel: axis.scale.getLabel(tickValue),
            tickValue: tickValue
          };
        })
      };
    } // Large category data calculation is performence sensitive, and ticks and label
    // probably be fetched by multiple times. So we cache the result.
    // axis is created each time during a ec process, so we do not need to clear cache.


    function getListCache(axis, prop) {
      // Because key can be funciton, and cache size always be small, we use array cache.
      return inner$6(axis)[prop] || (inner$6(axis)[prop] = []);
    }

    function listCacheGet(cache, key) {
      for (var i = 0; i < cache.length; i++) {
        if (cache[i].key === key) {
          return cache[i].value;
        }
      }
    }

    function listCacheSet(cache, key, value) {
      cache.push({
        key: key,
        value: value
      });
      return value;
    }

    function makeAutoCategoryInterval(axis) {
      var result = inner$6(axis).autoInterval;
      return result != null ? result : inner$6(axis).autoInterval = axis.calculateCategoryInterval();
    }
    /**
     * Calculate interval for category axis ticks and labels.
     * To get precise result, at least one of `getRotate` and `isHorizontal`
     * should be implemented in axis.
     */


    function calculateCategoryInterval(axis) {
      var params = fetchAutoCategoryIntervalCalculationParams(axis);
      var labelFormatter = makeLabelFormatter$1(axis);
      var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
      var ordinalScale = axis.scale;
      var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:
      // avoid generating a long array by `getTicks`
      // in large category data case.

      var tickCount = ordinalScale.count();

      if (ordinalExtent[1] - ordinalExtent[0] < 1) {
        return 0;
      }

      var step = 1; // Simple optimization. Empirical value: tick count should less than 40.

      if (tickCount > 40) {
        step = Math.max(1, Math.floor(tickCount / 40));
      }

      var tickValue = ordinalExtent[0];
      var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
      var unitW = Math.abs(unitSpan * Math.cos(rotation));
      var unitH = Math.abs(unitSpan * Math.sin(rotation));
      var maxW = 0;
      var maxH = 0; // Caution: Performance sensitive for large category data.
      // Consider dataZoom, we should make appropriate step to avoid O(n) loop.

      for (; tickValue <= ordinalExtent[1]; tickValue += step) {
        var width = 0;
        var height = 0; // Not precise, do not consider align and vertical align
        // and each distance from axis line yet.

        var rect = text$1.getBoundingRect(labelFormatter(tickValue), params.font, 'center', 'top'); // Magic number

        width = rect.width * 1.3;
        height = rect.height * 1.3; // Min size, void long loop.

        maxW = Math.max(maxW, width, 7);
        maxH = Math.max(maxH, height, 7);
      }

      var dw = maxW / unitW;
      var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.

      isNaN(dw) && (dw = Infinity);
      isNaN(dh) && (dh = Infinity);
      var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
      var cache = inner$6(axis.model);
      var axisExtent = axis.getExtent();
      var lastAutoInterval = cache.lastAutoInterval;
      var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,
      // otherwise the calculated interval might jitter when the zoom
      // window size is close to the interval-changing size.
      // For example, if all of the axis labels are `a, b, c, d, e, f, g`.
      // The jitter will cause that sometimes the displayed labels are
      // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).

      if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical
      // point is not the same when zooming in or zooming out.
      && lastAutoInterval > interval // If the axis change is caused by chart resize, the cache should not
      // be used. Otherwise some hiden labels might not be shown again.
      && cache.axisExtend0 === axisExtent[0] && cache.axisExtend1 === axisExtent[1]) {
        interval = lastAutoInterval;
      } // Only update cache if cache not used, otherwise the
      // changing of interval is too insensitive.
      else {
          cache.lastTickCount = tickCount;
          cache.lastAutoInterval = interval;
          cache.axisExtend0 = axisExtent[0];
          cache.axisExtend1 = axisExtent[1];
        }

      return interval;
    }

    function fetchAutoCategoryIntervalCalculationParams(axis) {
      var labelModel = axis.getLabelModel();
      return {
        axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
        labelRotate: labelModel.get('rotate') || 0,
        font: labelModel.getFont()
      };
    }

    function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
      var labelFormatter = makeLabelFormatter$1(axis);
      var ordinalScale = axis.scale;
      var ordinalExtent = ordinalScale.getExtent();
      var labelModel = axis.getLabelModel();
      var result = []; // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...

      var step = Math.max((categoryInterval || 0) + 1, 1);
      var startTick = ordinalExtent[0];
      var tickCount = ordinalScale.count(); // Calculate start tick based on zero if possible to keep label consistent
      // while zooming and moving while interval > 0. Otherwise the selection
      // of displayable ticks and symbols probably keep changing.
      // 3 is empirical value.

      if (startTick !== 0 && step > 1 && tickCount / step > 2) {
        startTick = Math.round(Math.ceil(startTick / step) * step);
      } // (1) Only add min max label here but leave overlap checking
      // to render stage, which also ensure the returned list
      // suitable for splitLine and splitArea rendering.
      // (2) Scales except category always contain min max label so
      // do not need to perform this process.


      var showAllLabel = shouldShowAllLabels$1(axis);
      var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;
      var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;

      if (includeMinLabel && startTick !== ordinalExtent[0]) {
        addItem(ordinalExtent[0]);
      } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.


      var tickValue = startTick;

      for (; tickValue <= ordinalExtent[1]; tickValue += step) {
        addItem(tickValue);
      }

      if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
        addItem(ordinalExtent[1]);
      }

      function addItem(tVal) {
        result.push(onlyTick ? tVal : {
          formattedLabel: labelFormatter(tVal),
          rawLabel: ordinalScale.getLabel(tVal),
          tickValue: tVal
        });
      }

      return result;
    } // When interval is function, the result `false` means ignore the tick.
    // It is time consuming for large category data.


    function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
      var ordinalScale = axis.scale;
      var labelFormatter = makeLabelFormatter$1(axis);
      var result = [];
      util.each(ordinalScale.getTicks(), function (tickValue) {
        var rawLabel = ordinalScale.getLabel(tickValue);

        if (categoryInterval(tickValue, rawLabel)) {
          result.push(onlyTick ? tickValue : {
            formattedLabel: labelFormatter(tickValue),
            rawLabel: rawLabel,
            tickValue: tickValue
          });
        }
      });
      return result;
    }

    var createAxisLabels_1 = createAxisLabels;
    var createAxisTicks_1 = createAxisTicks;
    var calculateCategoryInterval_1 = calculateCategoryInterval;

    var axisTickLabelBuilder = {
    	createAxisLabels: createAxisLabels_1,
    	createAxisTicks: createAxisTicks_1,
    	calculateCategoryInterval: calculateCategoryInterval_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var each$j = util.each;
    var map$6 = util.map;



    var linearMap$1 = number.linearMap;
    var getPixelPrecision$1 = number.getPixelPrecision;
    var round$2 = number.round;



    var createAxisTicks$1 = axisTickLabelBuilder.createAxisTicks;
    var createAxisLabels$1 = axisTickLabelBuilder.createAxisLabels;
    var calculateCategoryInterval$1 = axisTickLabelBuilder.calculateCategoryInterval;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var NORMALIZED_EXTENT = [0, 1];
    /**
     * Base class of Axis.
     * @constructor
     */

    var Axis = function (dim, scale, extent) {
      /**
       * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'.
       * @type {string}
       */
      this.dim = dim;
      /**
       * Axis scale
       * @type {module:echarts/coord/scale/*}
       */

      this.scale = scale;
      /**
       * @type {Array.<number>}
       * @private
       */

      this._extent = extent || [0, 0];
      /**
       * @type {boolean}
       */

      this.inverse = false;
      /**
       * Usually true when axis has a ordinal scale
       * @type {boolean}
       */

      this.onBand = false;
    };

    Axis.prototype = {
      constructor: Axis,

      /**
       * If axis extent contain given coord
       * @param {number} coord
       * @return {boolean}
       */
      contain: function (coord) {
        var extent = this._extent;
        var min = Math.min(extent[0], extent[1]);
        var max = Math.max(extent[0], extent[1]);
        return coord >= min && coord <= max;
      },

      /**
       * If axis extent contain given data
       * @param {number} data
       * @return {boolean}
       */
      containData: function (data) {
        return this.scale.contain(data);
      },

      /**
       * Get coord extent.
       * @return {Array.<number>}
       */
      getExtent: function () {
        return this._extent.slice();
      },

      /**
       * Get precision used for formatting
       * @param {Array.<number>} [dataExtent]
       * @return {number}
       */
      getPixelPrecision: function (dataExtent) {
        return getPixelPrecision$1(dataExtent || this.scale.getExtent(), this._extent);
      },

      /**
       * Set coord extent
       * @param {number} start
       * @param {number} end
       */
      setExtent: function (start, end) {
        var extent = this._extent;
        extent[0] = start;
        extent[1] = end;
      },

      /**
       * Convert data to coord. Data is the rank if it has an ordinal scale
       * @param {number} data
       * @param  {boolean} clamp
       * @return {number}
       */
      dataToCoord: function (data, clamp) {
        var extent = this._extent;
        var scale = this.scale;
        data = scale.normalize(data);

        if (this.onBand && scale.type === 'ordinal') {
          extent = extent.slice();
          fixExtentWithBands(extent, scale.count());
        }

        return linearMap$1(data, NORMALIZED_EXTENT, extent, clamp);
      },

      /**
       * Convert coord to data. Data is the rank if it has an ordinal scale
       * @param {number} coord
       * @param  {boolean} clamp
       * @return {number}
       */
      coordToData: function (coord, clamp) {
        var extent = this._extent;
        var scale = this.scale;

        if (this.onBand && scale.type === 'ordinal') {
          extent = extent.slice();
          fixExtentWithBands(extent, scale.count());
        }

        var t = linearMap$1(coord, extent, NORMALIZED_EXTENT, clamp);
        return this.scale.scale(t);
      },

      /**
       * Convert pixel point to data in axis
       * @param {Array.<number>} point
       * @param  {boolean} clamp
       * @return {number} data
       */
      pointToData: function (point, clamp) {// Should be implemented in derived class if necessary.
      },

      /**
       * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
       * `axis.getTicksCoords` considers `onBand`, which is used by
       * `boundaryGap:true` of category axis and splitLine and splitArea.
       * @param {Object} [opt]
       * @param {Model} [opt.tickModel=axis.model.getModel('axisTick')]
       * @param {boolean} [opt.clamp] If `true`, the first and the last
       *        tick must be at the axis end points. Otherwise, clip ticks
       *        that outside the axis extent.
       * @return {Array.<Object>} [{
       *     coord: ...,
       *     tickValue: ...
       * }, ...]
       */
      getTicksCoords: function (opt) {
        opt = opt || {};
        var tickModel = opt.tickModel || this.getTickModel();
        var result = createAxisTicks$1(this, tickModel);
        var ticks = result.ticks;
        var ticksCoords = map$6(ticks, function (tickValue) {
          return {
            coord: this.dataToCoord(tickValue),
            tickValue: tickValue
          };
        }, this);
        var alignWithLabel = tickModel.get('alignWithLabel');
        fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
        return ticksCoords;
      },

      /**
       * @return {Array.<Array.<Object>>} [{ coord: ..., tickValue: ...}]
       */
      getMinorTicksCoords: function () {
        if (this.scale.type === 'ordinal') {
          // Category axis doesn't support minor ticks
          return [];
        }

        var minorTickModel = this.model.getModel('minorTick');
        var splitNumber = minorTickModel.get('splitNumber'); // Protection.

        if (!(splitNumber > 0 && splitNumber < 100)) {
          splitNumber = 5;
        }

        var minorTicks = this.scale.getMinorTicks(splitNumber);
        var minorTicksCoords = map$6(minorTicks, function (minorTicksGroup) {
          return map$6(minorTicksGroup, function (minorTick) {
            return {
              coord: this.dataToCoord(minorTick),
              tickValue: minorTick
            };
          }, this);
        }, this);
        return minorTicksCoords;
      },

      /**
       * @return {Array.<Object>} [{
       *     formattedLabel: string,
       *     rawLabel: axis.scale.getLabel(tickValue)
       *     tickValue: number
       * }, ...]
       */
      getViewLabels: function () {
        return createAxisLabels$1(this).labels;
      },

      /**
       * @return {module:echarts/coord/model/Model}
       */
      getLabelModel: function () {
        return this.model.getModel('axisLabel');
      },

      /**
       * Notice here we only get the default tick model. For splitLine
       * or splitArea, we should pass the splitLineModel or splitAreaModel
       * manually when calling `getTicksCoords`.
       * In GL, this method may be overrided to:
       * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
       * @return {module:echarts/coord/model/Model}
       */
      getTickModel: function () {
        return this.model.getModel('axisTick');
      },

      /**
       * Get width of band
       * @return {number}
       */
      getBandWidth: function () {
        var axisExtent = this._extent;
        var dataExtent = this.scale.getExtent();
        var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.

        len === 0 && (len = 1);
        var size = Math.abs(axisExtent[1] - axisExtent[0]);
        return Math.abs(size) / len;
      },

      /**
       * @abstract
       * @return {boolean} Is horizontal
       */
      isHorizontal: null,

      /**
       * @abstract
       * @return {number} Get axis rotate, by degree.
       */
      getRotate: null,

      /**
       * Only be called in category axis.
       * Can be overrided, consider other axes like in 3D.
       * @return {number} Auto interval for cateogry axis tick and label
       */
      calculateCategoryInterval: function () {
        return calculateCategoryInterval$1(this);
      }
    };

    function fixExtentWithBands(extent, nTick) {
      var size = extent[1] - extent[0];
      var len = nTick;
      var margin = size / len / 2;
      extent[0] += margin;
      extent[1] -= margin;
    } // If axis has labels [1, 2, 3, 4]. Bands on the axis are
    // |---1---|---2---|---3---|---4---|.
    // So the displayed ticks and splitLine/splitArea should between
    // each data item, otherwise cause misleading (e.g., split tow bars
    // of a single data item when there are two bar series).
    // Also consider if tickCategoryInterval > 0 and onBand, ticks and
    // splitLine/spliteArea should layout appropriately corresponding
    // to displayed labels. (So we should not use `getBandWidth` in this
    // case).


    function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {
      var ticksLen = ticksCoords.length;

      if (!axis.onBand || alignWithLabel || !ticksLen) {
        return;
      }

      var axisExtent = axis.getExtent();
      var last;
      var diffSize;

      if (ticksLen === 1) {
        ticksCoords[0].coord = axisExtent[0];
        last = ticksCoords[1] = {
          coord: axisExtent[0]
        };
      } else {
        var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
        var shift = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
        each$j(ticksCoords, function (ticksItem) {
          ticksItem.coord -= shift / 2;
        });
        var dataExtent = axis.scale.getExtent();
        diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
        last = {
          coord: ticksCoords[ticksLen - 1].coord + shift * diffSize
        };
        ticksCoords.push(last);
      }

      var inverse = axisExtent[0] > axisExtent[1]; // Handling clamp.

      if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
        clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
      }

      if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {
        ticksCoords.unshift({
          coord: axisExtent[0]
        });
      }

      if (littleThan(axisExtent[1], last.coord)) {
        clamp ? last.coord = axisExtent[1] : ticksCoords.pop();
      }

      if (clamp && littleThan(last.coord, axisExtent[1])) {
        ticksCoords.push({
          coord: axisExtent[1]
        });
      }

      function littleThan(a, b) {
        // Avoid rounding error cause calculated tick coord different with extent.
        // It may cause an extra unecessary tick added.
        a = round$2(a);
        b = round$2(b);
        return inverse ? a > b : a < b;
      }
    }

    var _default$1v = Axis;
    var Axis_1 = _default$1v;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var zrender_1 = zrender;



    var matrix_1 = matrix;



    var vector_1 = vector;





    var color$1 = color;





    var number$1 = number;



    var format$2 = format$1;
    var throttle_1$1 = throttle_1.throttle;



    var helper$2 = helper$1;



    var parseGeoJSON_1 = parseGeoJson;



    var List$1 = List_1;



    var Model$1 = Model_1;



    var Axis$1 = Axis_1;



    var env$1 = env_1;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Do not mount those modules on 'src/echarts' for better tree shaking.
     */
    var parseGeoJson$1 = parseGeoJson;
    var ecUtil = {};
    util.each(['map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults', 'clone', 'merge'], function (name) {
      ecUtil[name] = util[name];
    });
    var graphic$1 = {};
    util.each(['extendShape', 'extendPath', 'makePath', 'makeImage', 'mergePath', 'resizePath', 'createIcon', 'setHoverStyle', 'setLabelStyle', 'setTextStyle', 'setText', 'getFont', 'updateProps', 'initProps', 'getTransform', 'clipPointsByRect', 'clipRectByRect', 'registerShape', 'getShapeClass', 'Group', 'Image', 'Text', 'Circle', 'Sector', 'Ring', 'Polygon', 'Polyline', 'Rect', 'Line', 'BezierCurve', 'Arc', 'IncrementalDisplayable', 'CompoundPath', 'LinearGradient', 'RadialGradient', 'BoundingRect'], function (name) {
      graphic$1[name] = graphic[name];
    });
    var parseGeoJson_1 = parseGeoJson$1;
    var util$2 = ecUtil;
    var graphic_1 = graphic$1;

    var _export = {
    	zrender: zrender_1,
    	matrix: matrix_1,
    	vector: vector_1,
    	color: color$1,
    	number: number$1,
    	format: format$2,
    	throttle: throttle_1$1,
    	helper: helper$2,
    	parseGeoJSON: parseGeoJSON_1,
    	List: List$1,
    	Model: Model$1,
    	Axis: Axis$1,
    	env: env$1,
    	parseGeoJson: parseGeoJson_1,
    	util: util$2,
    	graphic: graphic_1
    };

    var echarts = createCommonjsModule(function (module, exports) {







































    var throttle = throttle_1.throttle;

















    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var assert = util.assert;
    var each = util.each;
    var isFunction = util.isFunction;
    var isObject = util.isObject;
    var parseClassType = Component.parseClassType;
    var version = '4.8.0';
    var dependencies = {
      zrender: '4.3.1'
    };
    var TEST_FRAME_REMAIN_TIME = 1;
    var PRIORITY_PROCESSOR_FILTER = 1000;
    var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
    var PRIORITY_PROCESSOR_DATASTACK = 900;
    var PRIORITY_PROCESSOR_STATISTIC = 5000;
    var PRIORITY_VISUAL_LAYOUT = 1000;
    var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
    var PRIORITY_VISUAL_GLOBAL = 2000;
    var PRIORITY_VISUAL_CHART = 3000;
    var PRIORITY_VISUAL_POST_CHART_LAYOUT = 3500;
    var PRIORITY_VISUAL_COMPONENT = 4000; // FIXME
    // necessary?

    var PRIORITY_VISUAL_BRUSH = 5000;
    var PRIORITY = {
      PROCESSOR: {
        FILTER: PRIORITY_PROCESSOR_FILTER,
        SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
        STATISTIC: PRIORITY_PROCESSOR_STATISTIC
      },
      VISUAL: {
        LAYOUT: PRIORITY_VISUAL_LAYOUT,
        PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
        GLOBAL: PRIORITY_VISUAL_GLOBAL,
        CHART: PRIORITY_VISUAL_CHART,
        POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
        COMPONENT: PRIORITY_VISUAL_COMPONENT,
        BRUSH: PRIORITY_VISUAL_BRUSH
      }
    }; // Main process have three entries: `setOption`, `dispatchAction` and `resize`,
    // where they must not be invoked nestedly, except the only case: invoke
    // dispatchAction with updateMethod "none" in main process.
    // This flag is used to carry out this rule.
    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).

    var IN_MAIN_PROCESS = '__flagInMainProcess';
    var OPTION_UPDATED = '__optionUpdated';
    var ACTION_REG = /^[a-zA-Z0-9_]+$/;

    function createRegisterEventWithLowercaseName(method, ignoreDisposed) {
      return function (eventName, handler, context) {
        if (!ignoreDisposed && this._disposed) {
          disposedWarning(this.id);
          return;
        } // Event name is all lowercase


        eventName = eventName && eventName.toLowerCase();
        Eventful_1.prototype[method].call(this, eventName, handler, context);
      };
    }
    /**
     * @module echarts~MessageCenter
     */


    function MessageCenter() {
      Eventful_1.call(this);
    }

    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on', true);
    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off', true);
    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one', true);
    util.mixin(MessageCenter, Eventful_1);
    /**
     * @module echarts~ECharts
     */

    function ECharts(dom, theme, opts) {
      opts = opts || {}; // Get theme by name

      if (typeof theme === 'string') {
        theme = themeStorage[theme];
      }
      /**
       * @type {string}
       */


      this.id;
      /**
       * Group id
       * @type {string}
       */

      this.group;
      /**
       * @type {HTMLElement}
       * @private
       */

      this._dom = dom;
      var defaultRenderer = 'canvas';

      /**
       * @type {module:zrender/ZRender}
       * @private
       */
      var zr = this._zr = zrender.init(dom, {
        renderer: opts.renderer || defaultRenderer,
        devicePixelRatio: opts.devicePixelRatio,
        width: opts.width,
        height: opts.height
      });
      /**
       * Expect 60 fps.
       * @type {Function}
       * @private
       */

      this._throttledZrFlush = throttle(util.bind(zr.flush, zr), 17);
      var theme = util.clone(theme);
      theme && backwardCompat(theme, true);
      /**
       * @type {Object}
       * @private
       */

      this._theme = theme;
      /**
       * @type {Array.<module:echarts/view/Chart>}
       * @private
       */

      this._chartsViews = [];
      /**
       * @type {Object.<string, module:echarts/view/Chart>}
       * @private
       */

      this._chartsMap = {};
      /**
       * @type {Array.<module:echarts/view/Component>}
       * @private
       */

      this._componentsViews = [];
      /**
       * @type {Object.<string, module:echarts/view/Component>}
       * @private
       */

      this._componentsMap = {};
      /**
       * @type {module:echarts/CoordinateSystem}
       * @private
       */

      this._coordSysMgr = new CoordinateSystem();
      /**
       * @type {module:echarts/ExtensionAPI}
       * @private
       */

      var api = this._api = createExtensionAPI(this); // Sort on demand

      function prioritySortFunc(a, b) {
        return a.__prio - b.__prio;
      }

      timsort(visualFuncs, prioritySortFunc);
      timsort(dataProcessorFuncs, prioritySortFunc);
      /**
       * @type {module:echarts/stream/Scheduler}
       */

      this._scheduler = new Scheduler_1(this, api, dataProcessorFuncs, visualFuncs);
      Eventful_1.call(this, this._ecEventProcessor = new EventProcessor());
      /**
       * @type {module:echarts~MessageCenter}
       * @private
       */

      this._messageCenter = new MessageCenter(); // Init mouse events

      this._initEvents(); // In case some people write `window.onresize = chart.resize`


      this.resize = util.bind(this.resize, this); // Can't dispatch action during rendering procedure

      this._pendingActions = [];
      zr.animation.on('frame', this._onframe, this);
      bindRenderedEvent(zr, this); // ECharts instance can be used as value.

      util.setAsPrimitive(this);
    }

    var echartsProto = ECharts.prototype;

    echartsProto._onframe = function () {
      if (this._disposed) {
        return;
      }

      var scheduler = this._scheduler; // Lazy update

      if (this[OPTION_UPDATED]) {
        var silent = this[OPTION_UPDATED].silent;
        this[IN_MAIN_PROCESS] = true;
        prepare(this);
        updateMethods.update.call(this);
        this[IN_MAIN_PROCESS] = false;
        this[OPTION_UPDATED] = false;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      } // Avoid do both lazy update and progress in one frame.
      else if (scheduler.unfinished) {
          // Stream progress.
          var remainTime = TEST_FRAME_REMAIN_TIME;
          var ecModel = this._model;
          var api = this._api;
          scheduler.unfinished = false;

          do {
            var startTime = +new Date();
            scheduler.performSeriesTasks(ecModel); // Currently dataProcessorFuncs do not check threshold.

            scheduler.performDataProcessorTasks(ecModel);
            updateStreamModes(this, ecModel); // Do not update coordinate system here. Because that coord system update in
            // each frame is not a good user experience. So we follow the rule that
            // the extent of the coordinate system is determin in the first frame (the
            // frame is executed immedietely after task reset.
            // this._coordSysMgr.update(ecModel, api);
            // console.log('--- ec frame visual ---', remainTime);

            scheduler.performVisualTasks(ecModel);
            renderSeries(this, this._model, api, 'remain');
            remainTime -= +new Date() - startTime;
          } while (remainTime > 0 && scheduler.unfinished); // Call flush explicitly for trigger finished event.


          if (!scheduler.unfinished) {
            this._zr.flush();
          } // Else, zr flushing be ensue within the same frame,
          // because zr flushing is after onframe event.

        }
    };
    /**
     * @return {HTMLElement}
     */


    echartsProto.getDom = function () {
      return this._dom;
    };
    /**
     * @return {module:zrender~ZRender}
     */


    echartsProto.getZr = function () {
      return this._zr;
    };
    /**
     * Usage:
     * chart.setOption(option, notMerge, lazyUpdate);
     * chart.setOption(option, {
     *     notMerge: ...,
     *     lazyUpdate: ...,
     *     silent: ...
     * });
     *
     * @param {Object} option
     * @param {Object|boolean} [opts] opts or notMerge.
     * @param {boolean} [opts.notMerge=false]
     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.
     */


    echartsProto.setOption = function (option, notMerge, lazyUpdate) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      var silent;

      if (isObject(notMerge)) {
        lazyUpdate = notMerge.lazyUpdate;
        silent = notMerge.silent;
        notMerge = notMerge.notMerge;
      }

      this[IN_MAIN_PROCESS] = true;

      if (!this._model || notMerge) {
        var optionManager = new OptionManager_1(this._api);
        var theme = this._theme;
        var ecModel = this._model = new Global();
        ecModel.scheduler = this._scheduler;
        ecModel.init(null, null, theme, optionManager);
      }

      this._model.setOption(option, optionPreprocessorFuncs);

      if (lazyUpdate) {
        this[OPTION_UPDATED] = {
          silent: silent
        };
        this[IN_MAIN_PROCESS] = false;
      } else {
        prepare(this);
        updateMethods.update.call(this); // Ensure zr refresh sychronously, and then pixel in canvas can be
        // fetched after `setOption`.

        this._zr.flush();

        this[OPTION_UPDATED] = false;
        this[IN_MAIN_PROCESS] = false;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      }
    };
    /**
     * @DEPRECATED
     */


    echartsProto.setTheme = function () {
      console.error('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
    };
    /**
     * @return {module:echarts/model/Global}
     */


    echartsProto.getModel = function () {
      return this._model;
    };
    /**
     * @return {Object}
     */


    echartsProto.getOption = function () {
      return this._model && this._model.getOption();
    };
    /**
     * @return {number}
     */


    echartsProto.getWidth = function () {
      return this._zr.getWidth();
    };
    /**
     * @return {number}
     */


    echartsProto.getHeight = function () {
      return this._zr.getHeight();
    };
    /**
     * @return {number}
     */


    echartsProto.getDevicePixelRatio = function () {
      return this._zr.painter.dpr || window.devicePixelRatio || 1;
    };
    /**
     * Get canvas which has all thing rendered
     * @param {Object} opts
     * @param {string} [opts.backgroundColor]
     * @return {string}
     */


    echartsProto.getRenderedCanvas = function (opts) {
      if (!env_1.canvasSupported) {
        return;
      }

      opts = opts || {};
      opts.pixelRatio = opts.pixelRatio || 1;
      opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');
      var zr = this._zr; // var list = zr.storage.getDisplayList();
      // Stop animations
      // Never works before in init animation, so remove it.
      // zrUtil.each(list, function (el) {
      //     el.stopAnimation(true);
      // });

      return zr.painter.getRenderedCanvas(opts);
    };
    /**
     * Get svg data url
     * @return {string}
     */


    echartsProto.getSvgDataURL = function () {
      if (!env_1.svgSupported) {
        return;
      }

      var zr = this._zr;
      var list = zr.storage.getDisplayList(); // Stop animations

      util.each(list, function (el) {
        el.stopAnimation(true);
      });
      return zr.painter.toDataURL();
    };
    /**
     * @return {string}
     * @param {Object} opts
     * @param {string} [opts.type='png']
     * @param {string} [opts.pixelRatio=1]
     * @param {string} [opts.backgroundColor]
     * @param {string} [opts.excludeComponents]
     */


    echartsProto.getDataURL = function (opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      opts = opts || {};
      var excludeComponents = opts.excludeComponents;
      var ecModel = this._model;
      var excludesComponentViews = [];
      var self = this;
      each(excludeComponents, function (componentType) {
        ecModel.eachComponent({
          mainType: componentType
        }, function (component) {
          var view = self._componentsMap[component.__viewId];

          if (!view.group.ignore) {
            excludesComponentViews.push(view);
            view.group.ignore = true;
          }
        });
      });
      var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataURL() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));
      each(excludesComponentViews, function (view) {
        view.group.ignore = false;
      });
      return url;
    };
    /**
     * @return {string}
     * @param {Object} opts
     * @param {string} [opts.type='png']
     * @param {string} [opts.pixelRatio=1]
     * @param {string} [opts.backgroundColor]
     */


    echartsProto.getConnectedDataURL = function (opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      if (!env_1.canvasSupported) {
        return;
      }

      var isSvg = opts.type === 'svg';
      var groupId = this.group;
      var mathMin = Math.min;
      var mathMax = Math.max;
      var MAX_NUMBER = Infinity;

      if (connectedGroups[groupId]) {
        var left = MAX_NUMBER;
        var top = MAX_NUMBER;
        var right = -MAX_NUMBER;
        var bottom = -MAX_NUMBER;
        var canvasList = [];
        var dpr = opts && opts.pixelRatio || 1;
        util.each(instances, function (chart, id) {
          if (chart.group === groupId) {
            var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.getRenderedCanvas(util.clone(opts));
            var boundingRect = chart.getDom().getBoundingClientRect();
            left = mathMin(boundingRect.left, left);
            top = mathMin(boundingRect.top, top);
            right = mathMax(boundingRect.right, right);
            bottom = mathMax(boundingRect.bottom, bottom);
            canvasList.push({
              dom: canvas,
              left: boundingRect.left,
              top: boundingRect.top
            });
          }
        });
        left *= dpr;
        top *= dpr;
        right *= dpr;
        bottom *= dpr;
        var width = right - left;
        var height = bottom - top;
        var targetCanvas = util.createCanvas();
        var zr = zrender.init(targetCanvas, {
          renderer: isSvg ? 'svg' : 'canvas'
        });
        zr.resize({
          width: width,
          height: height
        });

        if (isSvg) {
          var content = '';
          each(canvasList, function (item) {
            var x = item.left - left;
            var y = item.top - top;
            content += '<g transform="translate(' + x + ',' + y + ')">' + item.dom + '</g>';
          });
          zr.painter.getSvgRoot().innerHTML = content;

          if (opts.connectedBackgroundColor) {
            zr.painter.setBackgroundColor(opts.connectedBackgroundColor);
          }

          zr.refreshImmediately();
          return zr.painter.toDataURL();
        } else {
          // Background between the charts
          if (opts.connectedBackgroundColor) {
            zr.add(new graphic.Rect({
              shape: {
                x: 0,
                y: 0,
                width: width,
                height: height
              },
              style: {
                fill: opts.connectedBackgroundColor
              }
            }));
          }

          each(canvasList, function (item) {
            var img = new graphic.Image({
              style: {
                x: item.left * dpr - left,
                y: item.top * dpr - top,
                image: item.dom
              }
            });
            zr.add(img);
          });
          zr.refreshImmediately();
          return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
        }
      } else {
        return this.getDataURL(opts);
      }
    };
    /**
     * Convert from logical coordinate system to pixel coordinate system.
     * See CoordinateSystem#convertToPixel.
     * @param {string|Object} finder
     *        If string, e.g., 'geo', means {geoIndex: 0}.
     *        If Object, could contain some of these properties below:
     *        {
     *            seriesIndex / seriesId / seriesName,
     *            geoIndex / geoId, geoName,
     *            bmapIndex / bmapId / bmapName,
     *            xAxisIndex / xAxisId / xAxisName,
     *            yAxisIndex / yAxisId / yAxisName,
     *            gridIndex / gridId / gridName,
     *            ... (can be extended)
     *        }
     * @param {Array|number} value
     * @return {Array|number} result
     */


    echartsProto.convertToPixel = util.curry(doConvertPixel, 'convertToPixel');
    /**
     * Convert from pixel coordinate system to logical coordinate system.
     * See CoordinateSystem#convertFromPixel.
     * @param {string|Object} finder
     *        If string, e.g., 'geo', means {geoIndex: 0}.
     *        If Object, could contain some of these properties below:
     *        {
     *            seriesIndex / seriesId / seriesName,
     *            geoIndex / geoId / geoName,
     *            bmapIndex / bmapId / bmapName,
     *            xAxisIndex / xAxisId / xAxisName,
     *            yAxisIndex / yAxisId / yAxisName
     *            gridIndex / gridId / gridName,
     *            ... (can be extended)
     *        }
     * @param {Array|number} value
     * @return {Array|number} result
     */

    echartsProto.convertFromPixel = util.curry(doConvertPixel, 'convertFromPixel');

    function doConvertPixel(methodName, finder, value) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      var ecModel = this._model;

      var coordSysList = this._coordSysMgr.getCoordinateSystems();

      var result;
      finder = model.parseFinder(ecModel, finder);

      for (var i = 0; i < coordSysList.length; i++) {
        var coordSys = coordSysList[i];

        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {
          return result;
        }
      }
    }
    /**
     * Is the specified coordinate systems or components contain the given pixel point.
     * @param {string|Object} finder
     *        If string, e.g., 'geo', means {geoIndex: 0}.
     *        If Object, could contain some of these properties below:
     *        {
     *            seriesIndex / seriesId / seriesName,
     *            geoIndex / geoId / geoName,
     *            bmapIndex / bmapId / bmapName,
     *            xAxisIndex / xAxisId / xAxisName,
     *            yAxisIndex / yAxisId / yAxisName,
     *            gridIndex / gridId / gridName,
     *            ... (can be extended)
     *        }
     * @param {Array|number} value
     * @return {boolean} result
     */


    echartsProto.containPixel = function (finder, value) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      var ecModel = this._model;
      var result;
      finder = model.parseFinder(ecModel, finder);
      util.each(finder, function (models, key) {
        key.indexOf('Models') >= 0 && util.each(models, function (model) {
          var coordSys = model.coordinateSystem;

          if (coordSys && coordSys.containPoint) {
            result |= !!coordSys.containPoint(value);
          } else if (key === 'seriesModels') {
            var view = this._chartsMap[model.__viewId];

            if (view && view.containPoint) {
              result |= view.containPoint(value, model);
            }
          }
        }, this);
      }, this);
      return !!result;
    };
    /**
     * Get visual from series or data.
     * @param {string|Object} finder
     *        If string, e.g., 'series', means {seriesIndex: 0}.
     *        If Object, could contain some of these properties below:
     *        {
     *            seriesIndex / seriesId / seriesName,
     *            dataIndex / dataIndexInside
     *        }
     *        If dataIndex is not specified, series visual will be fetched,
     *        but not data item visual.
     *        If all of seriesIndex, seriesId, seriesName are not specified,
     *        visual will be fetched from first series.
     * @param {string} visualType 'color', 'symbol', 'symbolSize'
     */


    echartsProto.getVisual = function (finder, visualType) {
      var ecModel = this._model;
      finder = model.parseFinder(ecModel, finder, {
        defaultMainType: 'series'
      });
      var seriesModel = finder.seriesModel;
      var data = seriesModel.getData();
      var dataIndexInside = finder.hasOwnProperty('dataIndexInside') ? finder.dataIndexInside : finder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(finder.dataIndex) : null;
      return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);
    };
    /**
     * Get view of corresponding component model
     * @param  {module:echarts/model/Component} componentModel
     * @return {module:echarts/view/Component}
     */


    echartsProto.getViewOfComponentModel = function (componentModel) {
      return this._componentsMap[componentModel.__viewId];
    };
    /**
     * Get view of corresponding series model
     * @param  {module:echarts/model/Series} seriesModel
     * @return {module:echarts/view/Chart}
     */


    echartsProto.getViewOfSeriesModel = function (seriesModel) {
      return this._chartsMap[seriesModel.__viewId];
    };

    var updateMethods = {
      prepareAndUpdate: function (payload) {
        prepare(this);
        updateMethods.update.call(this, payload);
      },

      /**
       * @param {Object} payload
       * @private
       */
      update: function (payload) {
        // console.profile && console.profile('update');
        var ecModel = this._model;
        var api = this._api;
        var zr = this._zr;
        var coordSysMgr = this._coordSysMgr;
        var scheduler = this._scheduler; // update before setOption

        if (!ecModel) {
          return;
        }

        scheduler.restoreData(ecModel, payload);
        scheduler.performSeriesTasks(ecModel); // TODO
        // Save total ecModel here for undo/redo (after restoring data and before processing data).
        // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
        // Create new coordinate system each update
        // In LineView may save the old coordinate system and use it to get the orignal point

        coordSysMgr.create(ecModel, api);
        scheduler.performDataProcessorTasks(ecModel, payload); // Current stream render is not supported in data process. So we can update
        // stream modes after data processing, where the filtered data is used to
        // deteming whether use progressive rendering.

        updateStreamModes(this, ecModel); // We update stream modes before coordinate system updated, then the modes info
        // can be fetched when coord sys updating (consider the barGrid extent fix). But
        // the drawback is the full coord info can not be fetched. Fortunately this full
        // coord is not requied in stream mode updater currently.

        coordSysMgr.update(ecModel, api);
        clearColorPalette(ecModel);
        scheduler.performVisualTasks(ecModel, payload);
        render(this, ecModel, api, payload); // Set background

        var backgroundColor = ecModel.get('backgroundColor') || 'transparent'; // In IE8

        if (!env_1.canvasSupported) {
          var colorArr = color.parse(backgroundColor);
          backgroundColor = color.stringify(colorArr, 'rgb');

          if (colorArr[3] === 0) {
            backgroundColor = 'transparent';
          }
        } else {
          zr.setBackgroundColor(backgroundColor);
        }

        performPostUpdateFuncs(ecModel, api); // console.profile && console.profileEnd('update');
      },

      /**
       * @param {Object} payload
       * @private
       */
      updateTransform: function (payload) {
        var ecModel = this._model;
        var ecIns = this;
        var api = this._api; // update before setOption

        if (!ecModel) {
          return;
        } // ChartView.markUpdateMethod(payload, 'updateTransform');


        var componentDirtyList = [];
        ecModel.eachComponent(function (componentType, componentModel) {
          var componentView = ecIns.getViewOfComponentModel(componentModel);

          if (componentView && componentView.__alive) {
            if (componentView.updateTransform) {
              var result = componentView.updateTransform(componentModel, ecModel, api, payload);
              result && result.update && componentDirtyList.push(componentView);
            } else {
              componentDirtyList.push(componentView);
            }
          }
        });
        var seriesDirtyMap = util.createHashMap();
        ecModel.eachSeries(function (seriesModel) {
          var chartView = ecIns._chartsMap[seriesModel.__viewId];

          if (chartView.updateTransform) {
            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
          } else {
            seriesDirtyMap.set(seriesModel.uid, 1);
          }
        });
        clearColorPalette(ecModel); // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
        // this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);

        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true,
          dirtyMap: seriesDirtyMap
        }); // Currently, not call render of components. Geo render cost a lot.
        // renderComponents(ecIns, ecModel, api, payload, componentDirtyList);


        renderSeries(ecIns, ecModel, api, payload, seriesDirtyMap);
        performPostUpdateFuncs(ecModel, this._api);
      },

      /**
       * @param {Object} payload
       * @private
       */
      updateView: function (payload) {
        var ecModel = this._model; // update before setOption

        if (!ecModel) {
          return;
        }

        Chart_1.markUpdateMethod(payload, 'updateView');
        clearColorPalette(ecModel); // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.

        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true
        });

        render(this, this._model, this._api, payload);
        performPostUpdateFuncs(ecModel, this._api);
      },

      /**
       * @param {Object} payload
       * @private
       */
      updateVisual: function (payload) {
        updateMethods.update.call(this, payload); // var ecModel = this._model;
        // // update before setOption
        // if (!ecModel) {
        //     return;
        // }
        // ChartView.markUpdateMethod(payload, 'updateVisual');
        // clearColorPalette(ecModel);
        // // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
        // this._scheduler.performVisualTasks(ecModel, payload, {visualType: 'visual', setDirty: true});
        // render(this, this._model, this._api, payload);
        // performPostUpdateFuncs(ecModel, this._api);
      },

      /**
       * @param {Object} payload
       * @private
       */
      updateLayout: function (payload) {
        updateMethods.update.call(this, payload); // var ecModel = this._model;
        // // update before setOption
        // if (!ecModel) {
        //     return;
        // }
        // ChartView.markUpdateMethod(payload, 'updateLayout');
        // // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
        // // this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);
        // this._scheduler.performVisualTasks(ecModel, payload, {setDirty: true});
        // render(this, this._model, this._api, payload);
        // performPostUpdateFuncs(ecModel, this._api);
      }
    };

    function prepare(ecIns) {
      var ecModel = ecIns._model;
      var scheduler = ecIns._scheduler;
      scheduler.restorePipelines(ecModel);
      scheduler.prepareStageTasks();
      prepareView(ecIns, 'component', ecModel, scheduler);
      prepareView(ecIns, 'chart', ecModel, scheduler);
      scheduler.plan();
    }
    /**
     * @private
     */


    function updateDirectly(ecIns, method, payload, mainType, subType) {
      var ecModel = ecIns._model; // broadcast

      if (!mainType) {
        // FIXME
        // Chart will not be update directly here, except set dirty.
        // But there is no such scenario now.
        each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);
        return;
      }

      var query = {};
      query[mainType + 'Id'] = payload[mainType + 'Id'];
      query[mainType + 'Index'] = payload[mainType + 'Index'];
      query[mainType + 'Name'] = payload[mainType + 'Name'];
      var condition = {
        mainType: mainType,
        query: query
      };
      subType && (condition.subType = subType); // subType may be '' by parseClassType;

      var excludeSeriesId = payload.excludeSeriesId;

      if (excludeSeriesId != null) {
        excludeSeriesId = util.createHashMap(model.normalizeToArray(excludeSeriesId));
      } // If dispatchAction before setOption, do nothing.


      ecModel && ecModel.eachComponent(condition, function (model) {
        if (!excludeSeriesId || excludeSeriesId.get(model.id) == null) {
          callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);
        }
      }, ecIns);

      function callView(view) {
        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
      }
    }
    /**
     * Resize the chart
     * @param {Object} opts
     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
     * @param {boolean} [opts.silent=false]
     */


    echartsProto.resize = function (opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      this._zr.resize(opts);

      var ecModel = this._model; // Resize loading effect

      this._loadingFX && this._loadingFX.resize();

      if (!ecModel) {
        return;
      }

      var optionChanged = ecModel.resetOption('media');
      var silent = opts && opts.silent;
      this[IN_MAIN_PROCESS] = true;
      optionChanged && prepare(this);
      updateMethods.update.call(this);
      this[IN_MAIN_PROCESS] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    };

    function updateStreamModes(ecIns, ecModel) {
      var chartsMap = ecIns._chartsMap;
      var scheduler = ecIns._scheduler;
      ecModel.eachSeries(function (seriesModel) {
        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
      });
    }
    /**
     * Show loading effect
     * @param  {string} [name='default']
     * @param  {Object} [cfg]
     */


    echartsProto.showLoading = function (name, cfg) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      if (isObject(name)) {
        cfg = name;
        name = '';
      }

      name = name || 'default';
      this.hideLoading();

      if (!loadingEffects[name]) {
        return;
      }

      var el = loadingEffects[name](this._api, cfg);
      var zr = this._zr;
      this._loadingFX = el;
      zr.add(el);
    };
    /**
     * Hide loading effect
     */


    echartsProto.hideLoading = function () {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      this._loadingFX && this._zr.remove(this._loadingFX);
      this._loadingFX = null;
    };
    /**
     * @param {Object} eventObj
     * @return {Object}
     */


    echartsProto.makeActionFromEvent = function (eventObj) {
      var payload = util.extend({}, eventObj);
      payload.type = eventActionMap[eventObj.type];
      return payload;
    };
    /**
     * @pubilc
     * @param {Object} payload
     * @param {string} [payload.type] Action type
     * @param {Object|boolean} [opt] If pass boolean, means opt.silent
     * @param {boolean} [opt.silent=false] Whether trigger events.
     * @param {boolean} [opt.flush=undefined]
     *                  true: Flush immediately, and then pixel in canvas can be fetched
     *                      immediately. Caution: it might affect performance.
     *                  false: Not flush.
     *                  undefined: Auto decide whether perform flush.
     */


    echartsProto.dispatchAction = function (payload, opt) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      if (!isObject(opt)) {
        opt = {
          silent: !!opt
        };
      }

      if (!actions[payload.type]) {
        return;
      } // Avoid dispatch action before setOption. Especially in `connect`.


      if (!this._model) {
        return;
      } // May dispatchAction in rendering procedure


      if (this[IN_MAIN_PROCESS]) {
        this._pendingActions.push(payload);

        return;
      }

      doDispatchAction.call(this, payload, opt.silent);

      if (opt.flush) {
        this._zr.flush(true);
      } else if (opt.flush !== false && env_1.browser.weChat) {
        // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`
        // hang when sliding page (on touch event), which cause that zr does not
        // refresh util user interaction finished, which is not expected.
        // But `dispatchAction` may be called too frequently when pan on touch
        // screen, which impacts performance if do not throttle them.
        this._throttledZrFlush();
      }

      flushPendingActions.call(this, opt.silent);
      triggerUpdatedEvent.call(this, opt.silent);
    };

    function doDispatchAction(payload, silent) {
      var payloadType = payload.type;
      var escapeConnect = payload.escapeConnect;
      var actionWrap = actions[payloadType];
      var actionInfo = actionWrap.actionInfo;
      var cptType = (actionInfo.update || 'update').split(':');
      var updateMethod = cptType.pop();
      cptType = cptType[0] != null && parseClassType(cptType[0]);
      this[IN_MAIN_PROCESS] = true;
      var payloads = [payload];
      var batched = false; // Batch action

      if (payload.batch) {
        batched = true;
        payloads = util.map(payload.batch, function (item) {
          item = util.defaults(util.extend({}, item), payload);
          item.batch = null;
          return item;
        });
      }

      var eventObjBatch = [];
      var eventObj;
      var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';
      each(payloads, function (batchItem) {
        // Action can specify the event by return it.
        eventObj = actionWrap.action(batchItem, this._model, this._api); // Emit event outside

        eventObj = eventObj || util.extend({}, batchItem); // Convert type to eventType

        eventObj.type = actionInfo.event || eventObj.type;
        eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual.

        if (isHighDown) {
          // method, payload, mainType, subType
          updateDirectly(this, updateMethod, batchItem, 'series');
        } else if (cptType) {
          updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
        }
      }, this);

      if (updateMethod !== 'none' && !isHighDown && !cptType) {
        // Still dirty
        if (this[OPTION_UPDATED]) {
          // FIXME Pass payload ?
          prepare(this);
          updateMethods.update.call(this, payload);
          this[OPTION_UPDATED] = false;
        } else {
          updateMethods[updateMethod].call(this, payload);
        }
      } // Follow the rule of action batch


      if (batched) {
        eventObj = {
          type: actionInfo.event || payloadType,
          escapeConnect: escapeConnect,
          batch: eventObjBatch
        };
      } else {
        eventObj = eventObjBatch[0];
      }

      this[IN_MAIN_PROCESS] = false;
      !silent && this._messageCenter.trigger(eventObj.type, eventObj);
    }

    function flushPendingActions(silent) {
      var pendingActions = this._pendingActions;

      while (pendingActions.length) {
        var payload = pendingActions.shift();
        doDispatchAction.call(this, payload, silent);
      }
    }

    function triggerUpdatedEvent(silent) {
      !silent && this.trigger('updated');
    }
    /**
     * Event `rendered` is triggered when zr
     * rendered. It is useful for realtime
     * snapshot (reflect animation).
     *
     * Event `finished` is triggered when:
     * (1) zrender rendering finished.
     * (2) initial animation finished.
     * (3) progressive rendering finished.
     * (4) no pending action.
     * (5) no delayed setOption needs to be processed.
     */


    function bindRenderedEvent(zr, ecIns) {
      zr.on('rendered', function () {
        ecIns.trigger('rendered'); // The `finished` event should not be triggered repeatly,
        // so it should only be triggered when rendering indeed happend
        // in zrender. (Consider the case that dipatchAction is keep
        // triggering when mouse move).

        if ( // Although zr is dirty if initial animation is not finished
        // and this checking is called on frame, we also check
        // animation finished for robustness.
        zr.animation.isFinished() && !ecIns[OPTION_UPDATED] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
          ecIns.trigger('finished');
        }
      });
    }
    /**
     * @param {Object} params
     * @param {number} params.seriesIndex
     * @param {Array|TypedArray} params.data
     */


    echartsProto.appendData = function (params) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      var seriesIndex = params.seriesIndex;
      var ecModel = this.getModel();
      var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
      seriesModel.appendData(params); // Note: `appendData` does not support that update extent of coordinate
      // system, util some scenario require that. In the expected usage of
      // `appendData`, the initial extent of coordinate system should better
      // be fixed by axis `min`/`max` setting or initial data, otherwise if
      // the extent changed while `appendData`, the location of the painted
      // graphic elements have to be changed, which make the usage of
      // `appendData` meaningless.

      this._scheduler.unfinished = true;
    };
    /**
     * Register event
     * @method
     */


    echartsProto.on = createRegisterEventWithLowercaseName('on', false);
    echartsProto.off = createRegisterEventWithLowercaseName('off', false);
    echartsProto.one = createRegisterEventWithLowercaseName('one', false);
    /**
     * Prepare view instances of charts and components
     * @param  {module:echarts/model/Global} ecModel
     * @private
     */

    function prepareView(ecIns, type, ecModel, scheduler) {
      var isComponent = type === 'component';
      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
      var zr = ecIns._zr;
      var api = ecIns._api;

      for (var i = 0; i < viewList.length; i++) {
        viewList[i].__alive = false;
      }

      isComponent ? ecModel.eachComponent(function (componentType, model) {
        componentType !== 'series' && doPrepare(model);
      }) : ecModel.eachSeries(doPrepare);

      function doPrepare(model) {
        // Consider: id same and type changed.
        var viewId = '_ec_' + model.id + '_' + model.type;
        var view = viewMap[viewId];

        if (!view) {
          var classType = parseClassType(model.type);
          var Clazz = isComponent ? Component_1.getClass(classType.main, classType.sub) : Chart_1.getClass(classType.sub);
          view = new Clazz();
          view.init(ecModel, api);
          viewMap[viewId] = view;
          viewList.push(view);
          zr.add(view.group);
        }

        model.__viewId = view.__id = viewId;
        view.__alive = true;
        view.__model = model;
        view.group.__ecComponentInfo = {
          mainType: model.mainType,
          index: model.componentIndex
        };
        !isComponent && scheduler.prepareView(view, model, ecModel, api);
      }

      for (var i = 0; i < viewList.length;) {
        var view = viewList[i];

        if (!view.__alive) {
          !isComponent && view.renderTask.dispose();
          zr.remove(view.group);
          view.dispose(ecModel, api);
          viewList.splice(i, 1);
          delete viewMap[view.__id];
          view.__id = view.group.__ecComponentInfo = null;
        } else {
          i++;
        }
      }
    } // /**
    //  * Encode visual infomation from data after data processing
    //  *
    //  * @param {module:echarts/model/Global} ecModel
    //  * @param {object} layout
    //  * @param {boolean} [layoutFilter] `true`: only layout,
    //  *                                 `false`: only not layout,
    //  *                                 `null`/`undefined`: all.
    //  * @param {string} taskBaseTag
    //  * @private
    //  */
    // function startVisualEncoding(ecIns, ecModel, api, payload, layoutFilter) {
    //     each(visualFuncs, function (visual, index) {
    //         var isLayout = visual.isLayout;
    //         if (layoutFilter == null
    //             || (layoutFilter === false && !isLayout)
    //             || (layoutFilter === true && isLayout)
    //         ) {
    //             visual.func(ecModel, api, payload);
    //         }
    //     });
    // }


    function clearColorPalette(ecModel) {
      ecModel.clearColorPalette();
      ecModel.eachSeries(function (seriesModel) {
        seriesModel.clearColorPalette();
      });
    }

    function render(ecIns, ecModel, api, payload) {
      renderComponents(ecIns, ecModel, api, payload);
      each(ecIns._chartsViews, function (chart) {
        chart.__alive = false;
      });
      renderSeries(ecIns, ecModel, api, payload); // Remove groups of unrendered charts

      each(ecIns._chartsViews, function (chart) {
        if (!chart.__alive) {
          chart.remove(ecModel, api);
        }
      });
    }

    function renderComponents(ecIns, ecModel, api, payload, dirtyList) {
      each(dirtyList || ecIns._componentsViews, function (componentView) {
        var componentModel = componentView.__model;
        componentView.render(componentModel, ecModel, api, payload);
        updateZ(componentModel, componentView);
      });
    }
    /**
     * Render each chart and component
     * @private
     */


    function renderSeries(ecIns, ecModel, api, payload, dirtyMap) {
      // Render all charts
      var scheduler = ecIns._scheduler;
      var unfinished;
      ecModel.eachSeries(function (seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        chartView.__alive = true;
        var renderTask = chartView.renderTask;
        scheduler.updatePayload(renderTask, payload);

        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
          renderTask.dirty();
        }

        unfinished |= renderTask.perform(scheduler.getPerformArgs(renderTask));
        chartView.group.silent = !!seriesModel.get('silent');
        updateZ(seriesModel, chartView);
        updateBlend(seriesModel, chartView);
      });
      scheduler.unfinished |= unfinished; // If use hover layer

      updateHoverLayerStatus(ecIns, ecModel); // Add aria

      aria(ecIns._zr.dom, ecModel);
    }

    function performPostUpdateFuncs(ecModel, api) {
      each(postUpdateFuncs, function (func) {
        func(ecModel, api);
      });
    }

    var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];
    /**
     * @private
     */

    echartsProto._initEvents = function () {
      each(MOUSE_EVENT_NAMES, function (eveName) {
        var handler = function (e) {
          var ecModel = this.getModel();
          var el = e.target;
          var params;
          var isGlobalOut = eveName === 'globalout'; // no e.target when 'globalout'.

          if (isGlobalOut) {
            params = {};
          } else if (el && el.dataIndex != null) {
            var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
            params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType, el) || {};
          } // If element has custom eventData of components
          else if (el && el.eventData) {
              params = util.extend({}, el.eventData);
            } // Contract: if params prepared in mouse event,
          // these properties must be specified:
          // {
          //    componentType: string (component main type)
          //    componentIndex: number
          // }
          // Otherwise event query can not work.


          if (params) {
            var componentType = params.componentType;
            var componentIndex = params.componentIndex; // Special handling for historic reason: when trigger by
            // markLine/markPoint/markArea, the componentType is
            // 'markLine'/'markPoint'/'markArea', but we should better
            // enable them to be queried by seriesIndex, since their
            // option is set in each series.

            if (componentType === 'markLine' || componentType === 'markPoint' || componentType === 'markArea') {
              componentType = 'series';
              componentIndex = params.seriesIndex;
            }

            var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
            var view = model && this[model.mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId];
            params.event = e;
            params.type = eveName;
            this._ecEventProcessor.eventInfo = {
              targetEl: el,
              packedEvent: params,
              model: model,
              view: view
            };
            this.trigger(eveName, params);
          }
        }; // Consider that some component (like tooltip, brush, ...)
        // register zr event handler, but user event handler might
        // do anything, such as call `setOption` or `dispatchAction`,
        // which probably update any of the content and probably
        // cause problem if it is called previous other inner handlers.


        handler.zrEventfulCallAtLast = true;

        this._zr.on(eveName, handler, this);
      }, this);
      each(eventActionMap, function (actionType, eventType) {
        this._messageCenter.on(eventType, function (event) {
          this.trigger(eventType, event);
        }, this);
      }, this);
    };
    /**
     * @return {boolean}
     */


    echartsProto.isDisposed = function () {
      return this._disposed;
    };
    /**
     * Clear
     */


    echartsProto.clear = function () {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      this.setOption({
        series: []
      }, true);
    };
    /**
     * Dispose instance
     */


    echartsProto.dispose = function () {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }

      this._disposed = true;
      model.setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, '');
      var api = this._api;
      var ecModel = this._model;
      each(this._componentsViews, function (component) {
        component.dispose(ecModel, api);
      });
      each(this._chartsViews, function (chart) {
        chart.dispose(ecModel, api);
      }); // Dispose after all views disposed

      this._zr.dispose();

      delete instances[this.id];
    };

    util.mixin(ECharts, Eventful_1);

    function disposedWarning(id) {}

    function updateHoverLayerStatus(ecIns, ecModel) {
      var zr = ecIns._zr;
      var storage = zr.storage;
      var elCount = 0;
      storage.traverse(function (el) {
        elCount++;
      });

      if (elCount > ecModel.get('hoverLayerThreshold') && !env_1.node) {
        ecModel.eachSeries(function (seriesModel) {
          if (seriesModel.preventUsingHoverLayer) {
            return;
          }

          var chartView = ecIns._chartsMap[seriesModel.__viewId];

          if (chartView.__alive) {
            chartView.group.traverse(function (el) {
              // Don't switch back.
              el.useHoverLayer = true;
            });
          }
        });
      }
    }
    /**
     * Update chart progressive and blend.
     * @param {module:echarts/model/Series|module:echarts/model/Component} model
     * @param {module:echarts/view/Component|module:echarts/view/Chart} view
     */


    function updateBlend(seriesModel, chartView) {
      var blendMode = seriesModel.get('blendMode') || null;
      chartView.group.traverse(function (el) {
        // FIXME marker and other components
        if (!el.isGroup) {
          // Only set if blendMode is changed. In case element is incremental and don't wan't to rerender.
          if (el.style.blend !== blendMode) {
            el.setStyle('blend', blendMode);
          }
        }

        if (el.eachPendingDisplayable) {
          el.eachPendingDisplayable(function (displayable) {
            displayable.setStyle('blend', blendMode);
          });
        }
      });
    }
    /**
     * @param {module:echarts/model/Series|module:echarts/model/Component} model
     * @param {module:echarts/view/Component|module:echarts/view/Chart} view
     */


    function updateZ(model, view) {
      var z = model.get('z');
      var zlevel = model.get('zlevel'); // Set z and zlevel

      view.group.traverse(function (el) {
        if (el.type !== 'group') {
          z != null && (el.z = z);
          zlevel != null && (el.zlevel = zlevel);
        }
      });
    }

    function createExtensionAPI(ecInstance) {
      var coordSysMgr = ecInstance._coordSysMgr;
      return util.extend(new ExtensionAPI_1(ecInstance), {
        // Inject methods
        getCoordinateSystems: util.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),
        getComponentByElement: function (el) {
          while (el) {
            var modelInfo = el.__ecComponentInfo;

            if (modelInfo != null) {
              return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);
            }

            el = el.parent;
          }
        }
      });
    }
    /**
     * @class
     * Usage of query:
     * `chart.on('click', query, handler);`
     * The `query` can be:
     * + The component type query string, only `mainType` or `mainType.subType`,
     *   like: 'xAxis', 'series', 'xAxis.category' or 'series.line'.
     * + The component query object, like:
     *   `{seriesIndex: 2}`, `{seriesName: 'xx'}`, `{seriesId: 'some'}`,
     *   `{xAxisIndex: 2}`, `{xAxisName: 'xx'}`, `{xAxisId: 'some'}`.
     * + The data query object, like:
     *   `{dataIndex: 123}`, `{dataType: 'link'}`, `{name: 'some'}`.
     * + The other query object (cmponent customized query), like:
     *   `{element: 'some'}` (only available in custom series).
     *
     * Caveat: If a prop in the `query` object is `null/undefined`, it is the
     * same as there is no such prop in the `query` object.
     */


    function EventProcessor() {
      // These info required: targetEl, packedEvent, model, view
      this.eventInfo;
    }

    EventProcessor.prototype = {
      constructor: EventProcessor,
      normalizeQuery: function (query) {
        var cptQuery = {};
        var dataQuery = {};
        var otherQuery = {}; // `query` is `mainType` or `mainType.subType` of component.

        if (util.isString(query)) {
          var condCptType = parseClassType(query); // `.main` and `.sub` may be ''.

          cptQuery.mainType = condCptType.main || null;
          cptQuery.subType = condCptType.sub || null;
        } // `query` is an object, convert to {mainType, index, name, id}.
        else {
            // `xxxIndex`, `xxxName`, `xxxId`, `name`, `dataIndex`, `dataType` is reserved,
            // can not be used in `compomentModel.filterForExposedEvent`.
            var suffixes = ['Index', 'Name', 'Id'];
            var dataKeys = {
              name: 1,
              dataIndex: 1,
              dataType: 1
            };
            util.each(query, function (val, key) {
              var reserved = false;

              for (var i = 0; i < suffixes.length; i++) {
                var propSuffix = suffixes[i];
                var suffixPos = key.lastIndexOf(propSuffix);

                if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
                  var mainType = key.slice(0, suffixPos); // Consider `dataIndex`.

                  if (mainType !== 'data') {
                    cptQuery.mainType = mainType;
                    cptQuery[propSuffix.toLowerCase()] = val;
                    reserved = true;
                  }
                }
              }

              if (dataKeys.hasOwnProperty(key)) {
                dataQuery[key] = val;
                reserved = true;
              }

              if (!reserved) {
                otherQuery[key] = val;
              }
            });
          }

        return {
          cptQuery: cptQuery,
          dataQuery: dataQuery,
          otherQuery: otherQuery
        };
      },
      filter: function (eventType, query, args) {
        // They should be assigned before each trigger call.
        var eventInfo = this.eventInfo;

        if (!eventInfo) {
          return true;
        }

        var targetEl = eventInfo.targetEl;
        var packedEvent = eventInfo.packedEvent;
        var model = eventInfo.model;
        var view = eventInfo.view; // For event like 'globalout'.

        if (!model || !view) {
          return true;
        }

        var cptQuery = query.cptQuery;
        var dataQuery = query.dataQuery;
        return check(cptQuery, model, 'mainType') && check(cptQuery, model, 'subType') && check(cptQuery, model, 'index', 'componentIndex') && check(cptQuery, model, 'name') && check(cptQuery, model, 'id') && check(dataQuery, packedEvent, 'name') && check(dataQuery, packedEvent, 'dataIndex') && check(dataQuery, packedEvent, 'dataType') && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));

        function check(query, host, prop, propOnHost) {
          return query[prop] == null || host[propOnHost || prop] === query[prop];
        }
      },
      afterTrigger: function () {
        // Make sure the eventInfo wont be used in next trigger.
        this.eventInfo = null;
      }
    };
    /**
     * @type {Object} key: actionType.
     * @inner
     */

    var actions = {};
    /**
     * Map eventType to actionType
     * @type {Object}
     */

    var eventActionMap = {};
    /**
     * Data processor functions of each stage
     * @type {Array.<Object.<string, Function>>}
     * @inner
     */

    var dataProcessorFuncs = [];
    /**
     * @type {Array.<Function>}
     * @inner
     */

    var optionPreprocessorFuncs = [];
    /**
     * @type {Array.<Function>}
     * @inner
     */

    var postUpdateFuncs = [];
    /**
     * Visual encoding functions of each stage
     * @type {Array.<Object.<string, Function>>}
     */

    var visualFuncs = [];
    /**
     * Theme storage
     * @type {Object.<key, Object>}
     */

    var themeStorage = {};
    /**
     * Loading effects
     */

    var loadingEffects = {};
    var instances = {};
    var connectedGroups = {};
    var idBase = new Date() - 0;
    var groupIdBase = new Date() - 0;
    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';

    function enableConnect(chart) {
      var STATUS_PENDING = 0;
      var STATUS_UPDATING = 1;
      var STATUS_UPDATED = 2;
      var STATUS_KEY = '__connectUpdateStatus';

      function updateConnectedChartsStatus(charts, status) {
        for (var i = 0; i < charts.length; i++) {
          var otherChart = charts[i];
          otherChart[STATUS_KEY] = status;
        }
      }

      each(eventActionMap, function (actionType, eventType) {
        chart._messageCenter.on(eventType, function (event) {
          if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
            if (event && event.escapeConnect) {
              return;
            }

            var action = chart.makeActionFromEvent(event);
            var otherCharts = [];
            each(instances, function (otherChart) {
              if (otherChart !== chart && otherChart.group === chart.group) {
                otherCharts.push(otherChart);
              }
            });
            updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
            each(otherCharts, function (otherChart) {
              if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
                otherChart.dispatchAction(action);
              }
            });
            updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
          }
        });
      });
    }
    /**
     * @param {HTMLElement} dom
     * @param {Object} [theme]
     * @param {Object} opts
     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default
     * @param {string} [opts.renderer] Can choose 'canvas' or 'svg' to render the chart.
     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.
     *                              Can be 'auto' (the same as null/undefined)
     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.
     *                               Can be 'auto' (the same as null/undefined)
     */


    function init(dom, theme, opts) {
      var existInstance = getInstanceByDom(dom);

      if (existInstance) {
        return existInstance;
      }

      var chart = new ECharts(dom, theme, opts);
      chart.id = 'ec_' + idBase++;
      instances[chart.id] = chart;
      model.setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
      enableConnect(chart);
      return chart;
    }
    /**
     * @return {string|Array.<module:echarts~ECharts>} groupId
     */


    function connect(groupId) {
      // Is array of charts
      if (util.isArray(groupId)) {
        var charts = groupId;
        groupId = null; // If any chart has group

        each(charts, function (chart) {
          if (chart.group != null) {
            groupId = chart.group;
          }
        });
        groupId = groupId || 'g_' + groupIdBase++;
        each(charts, function (chart) {
          chart.group = groupId;
        });
      }

      connectedGroups[groupId] = true;
      return groupId;
    }
    /**
     * @DEPRECATED
     * @return {string} groupId
     */


    function disConnect(groupId) {
      connectedGroups[groupId] = false;
    }
    /**
     * @return {string} groupId
     */


    var disconnect = disConnect;
    /**
     * Dispose a chart instance
     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart
     */

    function dispose(chart) {
      if (typeof chart === 'string') {
        chart = instances[chart];
      } else if (!(chart instanceof ECharts)) {
        // Try to treat as dom
        chart = getInstanceByDom(chart);
      }

      if (chart instanceof ECharts && !chart.isDisposed()) {
        chart.dispose();
      }
    }
    /**
     * @param  {HTMLElement} dom
     * @return {echarts~ECharts}
     */


    function getInstanceByDom(dom) {
      return instances[model.getAttribute(dom, DOM_ATTRIBUTE_KEY)];
    }
    /**
     * @param {string} key
     * @return {echarts~ECharts}
     */


    function getInstanceById(key) {
      return instances[key];
    }
    /**
     * Register theme
     */


    function registerTheme(name, theme) {
      themeStorage[name] = theme;
    }
    /**
     * Register option preprocessor
     * @param {Function} preprocessorFunc
     */


    function registerPreprocessor(preprocessorFunc) {
      optionPreprocessorFuncs.push(preprocessorFunc);
    }
    /**
     * @param {number} [priority=1000]
     * @param {Object|Function} processor
     */


    function registerProcessor(priority, processor) {
      normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_FILTER);
    }
    /**
     * Register postUpdater
     * @param {Function} postUpdateFunc
     */


    function registerPostUpdate(postUpdateFunc) {
      postUpdateFuncs.push(postUpdateFunc);
    }
    /**
     * Usage:
     * registerAction('someAction', 'someEvent', function () { ... });
     * registerAction('someAction', function () { ... });
     * registerAction(
     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},
     *     function () { ... }
     * );
     *
     * @param {(string|Object)} actionInfo
     * @param {string} actionInfo.type
     * @param {string} [actionInfo.event]
     * @param {string} [actionInfo.update]
     * @param {string} [eventName]
     * @param {Function} action
     */


    function registerAction(actionInfo, eventName, action) {
      if (typeof eventName === 'function') {
        action = eventName;
        eventName = '';
      }

      var actionType = isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
        event: eventName
      }][0]; // Event name is all lowercase

      actionInfo.event = (actionInfo.event || actionType).toLowerCase();
      eventName = actionInfo.event; // Validate action type and event name.

      assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));

      if (!actions[actionType]) {
        actions[actionType] = {
          action: action,
          actionInfo: actionInfo
        };
      }

      eventActionMap[eventName] = actionType;
    }
    /**
     * @param {string} type
     * @param {*} CoordinateSystem
     */


    function registerCoordinateSystem(type, CoordinateSystem$1) {
      CoordinateSystem.register(type, CoordinateSystem$1);
    }
    /**
     * Get dimensions of specified coordinate system.
     * @param {string} type
     * @return {Array.<string|Object>}
     */


    function getCoordinateSystemDimensions(type) {
      var coordSysCreator = CoordinateSystem.get(type);

      if (coordSysCreator) {
        return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
      }
    }
    /**
     * Layout is a special stage of visual encoding
     * Most visual encoding like color are common for different chart
     * But each chart has it's own layout algorithm
     *
     * @param {number} [priority=1000]
     * @param {Function} layoutTask
     */


    function registerLayout(priority, layoutTask) {
      normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, 'layout');
    }
    /**
     * @param {number} [priority=3000]
     * @param {module:echarts/stream/Task} visualTask
     */


    function registerVisual(priority, visualTask) {
      normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, 'visual');
    }
    /**
     * @param {Object|Function} fn: {seriesType, createOnAllSeries, performRawSeries, reset}
     */


    function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
      if (isFunction(priority) || isObject(priority)) {
        fn = priority;
        priority = defaultPriority;
      }

      var stageHandler = Scheduler_1.wrapStageHandler(fn, visualType);
      stageHandler.__prio = priority;
      stageHandler.__raw = fn;
      targetList.push(stageHandler);
      return stageHandler;
    }
    /**
     * @param {string} name
     */


    function registerLoading(name, loadingFx) {
      loadingEffects[name] = loadingFx;
    }
    /**
     * @param {Object} opts
     * @param {string} [superClass]
     */


    function extendComponentModel(opts
    /*, superClass*/
    ) {
      // var Clazz = ComponentModel;
      // if (superClass) {
      //     var classType = parseClassType(superClass);
      //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
      // }
      return Component.extend(opts);
    }
    /**
     * @param {Object} opts
     * @param {string} [superClass]
     */


    function extendComponentView(opts
    /*, superClass*/
    ) {
      // var Clazz = ComponentView;
      // if (superClass) {
      //     var classType = parseClassType(superClass);
      //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);
      // }
      return Component_1.extend(opts);
    }
    /**
     * @param {Object} opts
     * @param {string} [superClass]
     */


    function extendSeriesModel(opts
    /*, superClass*/
    ) {
      // var Clazz = SeriesModel;
      // if (superClass) {
      //     superClass = 'series.' + superClass.replace('series.', '');
      //     var classType = parseClassType(superClass);
      //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
      // }
      return Series.extend(opts);
    }
    /**
     * @param {Object} opts
     * @param {string} [superClass]
     */


    function extendChartView(opts
    /*, superClass*/
    ) {
      // var Clazz = ChartView;
      // if (superClass) {
      //     superClass = superClass.replace('series.', '');
      //     var classType = parseClassType(superClass);
      //     Clazz = ChartView.getClass(classType.main, true);
      // }
      return Chart_1.extend(opts);
    }
    /**
     * ZRender need a canvas context to do measureText.
     * But in node environment canvas may be created by node-canvas.
     * So we need to specify how to create a canvas instead of using document.createElement('canvas')
     *
     * Be careful of using it in the browser.
     *
     * @param {Function} creator
     * @example
     *     var Canvas = require('canvas');
     *     var echarts = require('echarts');
     *     echarts.setCanvasCreator(function () {
     *         // Small size is enough.
     *         return new Canvas(32, 32);
     *     });
     */


    function setCanvasCreator(creator) {
      util.$override('createCanvas', creator);
    }
    /**
     * @param {string} mapName
     * @param {Array.<Object>|Object|string} geoJson
     * @param {Object} [specialAreas]
     *
     * @example GeoJSON
     *     $.get('USA.json', function (geoJson) {
     *         echarts.registerMap('USA', geoJson);
     *         // Or
     *         echarts.registerMap('USA', {
     *             geoJson: geoJson,
     *             specialAreas: {}
     *         })
     *     });
     *
     *     $.get('airport.svg', function (svg) {
     *         echarts.registerMap('airport', {
     *             svg: svg
     *         }
     *     });
     *
     *     echarts.registerMap('eu', [
     *         {svg: eu-topographic.svg},
     *         {geoJSON: eu.json}
     *     ])
     */


    function registerMap(mapName, geoJson, specialAreas) {
      mapDataStorage.registerMap(mapName, geoJson, specialAreas);
    }
    /**
     * @param {string} mapName
     * @return {Object}
     */


    function getMap(mapName) {
      // For backward compatibility, only return the first one.
      var records = mapDataStorage.retrieveMap(mapName);
      return records && records[0] && {
        geoJson: records[0].geoJSON,
        specialAreas: records[0].specialAreas
      };
    }

    registerVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);
    registerPreprocessor(backwardCompat);
    registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
    registerLoading('default', _default_1); // Default actions

    registerAction({
      type: 'highlight',
      event: 'highlight',
      update: 'highlight'
    }, util.noop);
    registerAction({
      type: 'downplay',
      event: 'downplay',
      update: 'downplay'
    }, util.noop); // Default theme

    registerTheme('light', light);
    registerTheme('dark', dark); // For backward compatibility, where the namespace `dataTool` will
    // be mounted on `echarts` is the extension `dataTool` is imported.

    var dataTool = {};
    exports.version = version;
    exports.dependencies = dependencies;
    exports.PRIORITY = PRIORITY;
    exports.init = init;
    exports.connect = connect;
    exports.disConnect = disConnect;
    exports.disconnect = disconnect;
    exports.dispose = dispose;
    exports.getInstanceByDom = getInstanceByDom;
    exports.getInstanceById = getInstanceById;
    exports.registerTheme = registerTheme;
    exports.registerPreprocessor = registerPreprocessor;
    exports.registerProcessor = registerProcessor;
    exports.registerPostUpdate = registerPostUpdate;
    exports.registerAction = registerAction;
    exports.registerCoordinateSystem = registerCoordinateSystem;
    exports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;
    exports.registerLayout = registerLayout;
    exports.registerVisual = registerVisual;
    exports.registerLoading = registerLoading;
    exports.extendComponentModel = extendComponentModel;
    exports.extendComponentView = extendComponentView;
    exports.extendSeriesModel = extendSeriesModel;
    exports.extendChartView = extendChartView;
    exports.setCanvasCreator = setCanvasCreator;
    exports.registerMap = registerMap;
    exports.getMap = getMap;
    exports.dataTool = dataTool;

    (function () {
        for (var key in _export) {
            if (_export.hasOwnProperty(key)) {
                exports[key] = _export[key];
            }
        }
    })();
    });
    var echarts_1 = echarts.version;
    var echarts_2 = echarts.dependencies;
    var echarts_3 = echarts.PRIORITY;
    var echarts_4 = echarts.init;
    var echarts_5 = echarts.connect;
    var echarts_6 = echarts.disConnect;
    var echarts_7 = echarts.disconnect;
    var echarts_8 = echarts.dispose;
    var echarts_9 = echarts.getInstanceByDom;
    var echarts_10 = echarts.getInstanceById;
    var echarts_11 = echarts.registerTheme;
    var echarts_12 = echarts.registerPreprocessor;
    var echarts_13 = echarts.registerProcessor;
    var echarts_14 = echarts.registerPostUpdate;
    var echarts_15 = echarts.registerAction;
    var echarts_16 = echarts.registerCoordinateSystem;
    var echarts_17 = echarts.getCoordinateSystemDimensions;
    var echarts_18 = echarts.registerLayout;
    var echarts_19 = echarts.registerVisual;
    var echarts_20 = echarts.registerLoading;
    var echarts_21 = echarts.extendComponentModel;
    var echarts_22 = echarts.extendComponentView;
    var echarts_23 = echarts.extendSeriesModel;
    var echarts_24 = echarts.extendChartView;
    var echarts_25 = echarts.setCanvasCreator;
    var echarts_26 = echarts.registerMap;
    var echarts_27 = echarts.getMap;
    var echarts_28 = echarts.dataTool;

    /* src\components\Chart\Chart.svelte generated by Svelte v3.22.3 */
    const file$C = "src\\components\\Chart\\Chart.svelte";

    function create_fragment$F(ctx) {
    	let div;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[9]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_style(div, "height", "100%");
    			set_style(div, "width", "100%");
    			add_location(div, file$C, 70, 0, 1367);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[10](div);
    			if (remount) dispose();
    			dispose = listen_dev(window, "resize", /*onwindowresize*/ ctx[9]);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[10](null);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getHorizontalMarkLine(value, label) {
    	return {
    		data: [
    			{
    				xAxis: 0,
    				yAxis: value,
    				symbol: "none",
    				lineStyle: { normal: { color: "#ec663c" } },
    				label: {
    					normal: {
    						show: true,
    						position: "end",
    						formatter: label
    					}
    				}
    			}
    		]
    	};
    }

    function instance_1($$self, $$props, $$invalidate) {
    	let $drawerVisible;
    	validate_store(visible, "drawerVisible");
    	component_subscribe($$self, visible, $$value => $$invalidate(7, $drawerVisible = $$value));
    	const dispatch = createEventDispatcher();
    	let element;
    	let instance;
    	let width;

    	onMount(async () => {
    		instance = echarts.init(element);
    	});

    	onDestroy(() => {
    		if (instance) {
    			instance.dispose();
    		}
    	});

    	function getInstance() {
    		return instance;
    	}

    	function getElement() {
    		return element;
    	}

    	function update() {
    		dispatch("render", instance);
    	}

    	function resize() {
    		if (!instance) {
    			return;
    		}

    		instance.resize();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Chart> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Chart", $$slots, []);

    	function onwindowresize() {
    		$$invalidate(1, width = window.innerWidth);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(0, element = $$value);
    		});
    	}

    	$$self.$capture_state = () => ({
    		getHorizontalMarkLine,
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		drawerVisible: visible,
    		echarts,
    		dispatch,
    		element,
    		instance,
    		width,
    		getInstance,
    		getElement,
    		update,
    		resize,
    		$drawerVisible
    	});

    	$$self.$inject_state = $$props => {
    		if ("element" in $$props) $$invalidate(0, element = $$props.element);
    		if ("instance" in $$props) instance = $$props.instance;
    		if ("width" in $$props) $$invalidate(1, width = $$props.width);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*width, $drawerVisible*/ 130) {
    			 width & $drawerVisible & resize();
    		}
    	};

    	return [
    		element,
    		width,
    		getInstance,
    		getElement,
    		update,
    		resize,
    		instance,
    		$drawerVisible,
    		dispatch,
    		onwindowresize,
    		div_binding
    	];
    }

    class Chart$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance_1, create_fragment$F, safe_not_equal, {
    			getInstance: 2,
    			getElement: 3,
    			update: 4,
    			resize: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Chart",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get getInstance() {
    		return this.$$.ctx[2];
    	}

    	set getInstance(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getElement() {
    		return this.$$.ctx[3];
    	}

    	set getElement(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get update() {
    		return this.$$.ctx[4];
    	}

    	set update(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resize() {
    		return this.$$.ctx[5];
    	}

    	set resize(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Cartesian coordinate system
     * @module  echarts/coord/Cartesian
     *
     */
    function dimAxisMapper(dim) {
      return this._axes[dim];
    }
    /**
     * @alias module:echarts/coord/Cartesian
     * @constructor
     */


    var Cartesian = function (name) {
      this._axes = {};
      this._dimList = [];
      /**
       * @type {string}
       */

      this.name = name || '';
    };

    Cartesian.prototype = {
      constructor: Cartesian,
      type: 'cartesian',

      /**
       * Get axis
       * @param  {number|string} dim
       * @return {module:echarts/coord/Cartesian~Axis}
       */
      getAxis: function (dim) {
        return this._axes[dim];
      },

      /**
       * Get axes list
       * @return {Array.<module:echarts/coord/Cartesian~Axis>}
       */
      getAxes: function () {
        return util.map(this._dimList, dimAxisMapper, this);
      },

      /**
       * Get axes list by given scale type
       */
      getAxesByScale: function (scaleType) {
        scaleType = scaleType.toLowerCase();
        return util.filter(this.getAxes(), function (axis) {
          return axis.scale.type === scaleType;
        });
      },

      /**
       * Add axis
       * @param {module:echarts/coord/Cartesian.Axis}
       */
      addAxis: function (axis) {
        var dim = axis.dim;
        this._axes[dim] = axis;

        this._dimList.push(dim);
      },

      /**
       * Convert data to coord in nd space
       * @param {Array.<number>|Object.<string, number>} val
       * @return {Array.<number>|Object.<string, number>}
       */
      dataToCoord: function (val) {
        return this._dataCoordConvert(val, 'dataToCoord');
      },

      /**
       * Convert coord in nd space to data
       * @param  {Array.<number>|Object.<string, number>} val
       * @return {Array.<number>|Object.<string, number>}
       */
      coordToData: function (val) {
        return this._dataCoordConvert(val, 'coordToData');
      },
      _dataCoordConvert: function (input, method) {
        var dimList = this._dimList;
        var output = input instanceof Array ? [] : {};

        for (var i = 0; i < dimList.length; i++) {
          var dim = dimList[i];
          var axis = this._axes[dim];
          output[dim] = axis[method](input[dim]);
        }

        return output;
      }
    };
    var _default$1w = Cartesian;
    var Cartesian_1 = _default$1w;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function Cartesian2D(name) {
      Cartesian_1.call(this, name);
    }

    Cartesian2D.prototype = {
      constructor: Cartesian2D,
      type: 'cartesian2d',

      /**
       * @type {Array.<string>}
       * @readOnly
       */
      dimensions: ['x', 'y'],

      /**
       * Base axis will be used on stacking.
       *
       * @return {module:echarts/coord/cartesian/Axis2D}
       */
      getBaseAxis: function () {
        return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
      },

      /**
       * If contain point
       * @param {Array.<number>} point
       * @return {boolean}
       */
      containPoint: function (point) {
        var axisX = this.getAxis('x');
        var axisY = this.getAxis('y');
        return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
      },

      /**
       * If contain data
       * @param {Array.<number>} data
       * @return {boolean}
       */
      containData: function (data) {
        return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
      },

      /**
       * @param {Array.<number>} data
       * @param {Array.<number>} out
       * @return {Array.<number>}
       */
      dataToPoint: function (data, reserved, out) {
        var xAxis = this.getAxis('x');
        var yAxis = this.getAxis('y');
        out = out || [];
        out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));
        out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));
        return out;
      },

      /**
       * @param {Array.<number>} data
       * @param {Array.<number>} out
       * @return {Array.<number>}
       */
      clampData: function (data, out) {
        var xScale = this.getAxis('x').scale;
        var yScale = this.getAxis('y').scale;
        var xAxisExtent = xScale.getExtent();
        var yAxisExtent = yScale.getExtent();
        var x = xScale.parse(data[0]);
        var y = yScale.parse(data[1]);
        out = out || [];
        out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
        out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
        return out;
      },

      /**
       * @param {Array.<number>} point
       * @param {Array.<number>} out
       * @return {Array.<number>}
       */
      pointToData: function (point, out) {
        var xAxis = this.getAxis('x');
        var yAxis = this.getAxis('y');
        out = out || [];
        out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));
        out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));
        return out;
      },

      /**
       * Get other axis
       * @param {module:echarts/coord/cartesian/Axis2D} axis
       */
      getOtherAxis: function (axis) {
        return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
      },

      /**
       * Get rect area of cartesian.
       * Area will have a contain function to determine if a point is in the coordinate system.
       * @return {BoundingRect}
       */
      getArea: function () {
        var xExtent = this.getAxis('x').getGlobalExtent();
        var yExtent = this.getAxis('y').getGlobalExtent();
        var x = Math.min(xExtent[0], xExtent[1]);
        var y = Math.min(yExtent[0], yExtent[1]);
        var width = Math.max(xExtent[0], xExtent[1]) - x;
        var height = Math.max(yExtent[0], yExtent[1]) - y;
        var rect = new BoundingRect_1(x, y, width, height);
        return rect;
      }
    };
    util.inherits(Cartesian2D, Cartesian_1);
    var _default$1x = Cartesian2D;
    var Cartesian2D_1 = _default$1x;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Extend axis 2d
     * @constructor module:echarts/coord/cartesian/Axis2D
     * @extends {module:echarts/coord/cartesian/Axis}
     * @param {string} dim
     * @param {*} scale
     * @param {Array.<number>} coordExtent
     * @param {string} axisType
     * @param {string} position
     */
    var Axis2D = function (dim, scale, coordExtent, axisType, position) {
      Axis_1.call(this, dim, scale, coordExtent);
      /**
       * Axis type
       *  - 'category'
       *  - 'value'
       *  - 'time'
       *  - 'log'
       * @type {string}
       */

      this.type = axisType || 'value';
      /**
       * Axis position
       *  - 'top'
       *  - 'bottom'
       *  - 'left'
       *  - 'right'
       */

      this.position = position || 'bottom';
    };

    Axis2D.prototype = {
      constructor: Axis2D,

      /**
       * Index of axis, can be used as key
       */
      index: 0,

      /**
       * Implemented in <module:echarts/coord/cartesian/Grid>.
       * @return {Array.<module:echarts/coord/cartesian/Axis2D>}
       *         If not on zero of other axis, return null/undefined.
       *         If no axes, return an empty array.
       */
      getAxesOnZeroOf: null,

      /**
       * Axis model
       * @param {module:echarts/coord/cartesian/AxisModel}
       */
      model: null,
      isHorizontal: function () {
        var position = this.position;
        return position === 'top' || position === 'bottom';
      },

      /**
       * Each item cooresponds to this.getExtent(), which
       * means globalExtent[0] may greater than globalExtent[1],
       * unless `asc` is input.
       *
       * @param {boolean} [asc]
       * @return {Array.<number>}
       */
      getGlobalExtent: function (asc) {
        var ret = this.getExtent();
        ret[0] = this.toGlobalCoord(ret[0]);
        ret[1] = this.toGlobalCoord(ret[1]);
        asc && ret[0] > ret[1] && ret.reverse();
        return ret;
      },
      getOtherAxis: function () {
        this.grid.getOtherAxis();
      },

      /**
       * @override
       */
      pointToData: function (point, clamp) {
        return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);
      },

      /**
       * Transform global coord to local coord,
       * i.e. var localCoord = axis.toLocalCoord(80);
       * designate by module:echarts/coord/cartesian/Grid.
       * @type {Function}
       */
      toLocalCoord: null,

      /**
       * Transform global coord to local coord,
       * i.e. var globalCoord = axis.toLocalCoord(40);
       * designate by module:echarts/coord/cartesian/Grid.
       * @type {Function}
       */
      toGlobalCoord: null
    };
    util.inherits(Axis2D, Axis_1);
    var _default$1y = Axis2D;
    var Axis2D_1 = _default$1y;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var defaultOption = {
      show: true,
      zlevel: 0,
      z: 0,
      // Inverse the axis.
      inverse: false,
      // Axis name displayed.
      name: '',
      // 'start' | 'middle' | 'end'
      nameLocation: 'end',
      // By degree. By defualt auto rotate by nameLocation.
      nameRotate: null,
      nameTruncate: {
        maxWidth: null,
        ellipsis: '...',
        placeholder: '.'
      },
      // Use global text style by default.
      nameTextStyle: {},
      // The gap between axisName and axisLine.
      nameGap: 15,
      // Default `false` to support tooltip.
      silent: false,
      // Default `false` to avoid legacy user event listener fail.
      triggerEvent: false,
      tooltip: {
        show: false
      },
      axisPointer: {},
      axisLine: {
        show: true,
        onZero: true,
        onZeroAxisIndex: null,
        lineStyle: {
          color: '#333',
          width: 1,
          type: 'solid'
        },
        // The arrow at both ends the the axis.
        symbol: ['none', 'none'],
        symbolSize: [10, 15]
      },
      axisTick: {
        show: true,
        // Whether axisTick is inside the grid or outside the grid.
        inside: false,
        // The length of axisTick.
        length: 5,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: true,
        // Whether axisLabel is inside the grid or outside the grid.
        inside: false,
        rotate: 0,
        // true | false | null/undefined (auto)
        showMinLabel: null,
        // true | false | null/undefined (auto)
        showMaxLabel: null,
        margin: 8,
        // formatter: null,
        fontSize: 12
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: ['#ccc'],
          width: 1,
          type: 'solid'
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']
        }
      }
    };
    var axisDefault = {};
    axisDefault.categoryAxis = util.merge({
      // The gap at both ends of the axis. For categoryAxis, boolean.
      boundaryGap: true,
      // Set false to faster category collection.
      // Only usefull in the case like: category is
      // ['2012-01-01', '2012-01-02', ...], where the input
      // data has been ensured not duplicate and is large data.
      // null means "auto":
      // if axis.data provided, do not deduplication,
      // else do deduplication.
      deduplication: null,
      // splitArea: {
      // show: false
      // },
      splitLine: {
        show: false
      },
      axisTick: {
        // If tick is align with label when boundaryGap is true
        alignWithLabel: false,
        interval: 'auto'
      },
      axisLabel: {
        interval: 'auto'
      }
    }, defaultOption);
    axisDefault.valueAxis = util.merge({
      // The gap at both ends of the axis. For value axis, [GAP, GAP], where
      // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)
      boundaryGap: [0, 0],
      // TODO
      // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
      // Min value of the axis. can be:
      // + a number
      // + 'dataMin': use the min value in data.
      // + null/undefined: auto decide min value (consider pretty look and boundaryGap).
      // min: null,
      // Max value of the axis. can be:
      // + a number
      // + 'dataMax': use the max value in data.
      // + null/undefined: auto decide max value (consider pretty look and boundaryGap).
      // max: null,
      // Readonly prop, specifies start value of the range when using data zoom.
      // rangeStart: null
      // Readonly prop, specifies end value of the range when using data zoom.
      // rangeEnd: null
      // Optional value can be:
      // + `false`: always include value 0.
      // + `true`: the extent do not consider value 0.
      // scale: false,
      // AxisTick and axisLabel and splitLine are caculated based on splitNumber.
      splitNumber: 5,
      // Interval specifies the span of the ticks is mandatorily.
      // interval: null
      // Specify min interval when auto calculate tick interval.
      // minInterval: null
      // Specify max interval when auto calculate tick interval.
      // maxInterval: null
      minorTick: {
        // Minor tick, not available for cateogry axis.
        show: false,
        // Split number of minor ticks. The value should be in range of (0, 100)
        splitNumber: 5,
        // Lenght of minor tick
        length: 3,
        // Same inside with axisTick
        // Line style
        lineStyle: {// Default to be same with axisTick
        }
      },
      minorSplitLine: {
        show: false,
        lineStyle: {
          color: '#eee',
          width: 1
        }
      }
    }, defaultOption);
    axisDefault.timeAxis = util.defaults({
      scale: true,
      min: 'dataMin',
      max: 'dataMax'
    }, axisDefault.valueAxis);
    axisDefault.logAxis = util.defaults({
      scale: true,
      logBase: 10
    }, axisDefault.valueAxis);
    var _default$1z = axisDefault;
    var axisDefault_1 = _default$1z;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    var getLayoutParams$2 = layout.getLayoutParams;
    var mergeLayoutParam$2 = layout.mergeLayoutParam;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // FIXME axisType is fixed ?
    var AXIS_TYPES = ['value', 'category', 'time', 'log'];
    /**
     * Generate sub axis model class
     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
     * @param {module:echarts/model/Component} BaseAxisModelClass
     * @param {Function} axisTypeDefaulter
     * @param {Object} [extraDefaultOption]
     */

    function _default$1A(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
      util.each(AXIS_TYPES, function (axisType) {
        BaseAxisModelClass.extend({
          /**
           * @readOnly
           */
          type: axisName + 'Axis.' + axisType,
          mergeDefaultAndTheme: function (option, ecModel) {
            var layoutMode = this.layoutMode;
            var inputPositionParams = layoutMode ? getLayoutParams$2(option) : {};
            var themeModel = ecModel.getTheme();
            util.merge(option, themeModel.get(axisType + 'Axis'));
            util.merge(option, this.getDefaultOption());
            option.type = axisTypeDefaulter(axisName, option);

            if (layoutMode) {
              mergeLayoutParam$2(option, inputPositionParams, layoutMode);
            }
          },

          /**
           * @override
           */
          optionUpdated: function () {
            var thisOption = this.option;

            if (thisOption.type === 'category') {
              this.__ordinalMeta = OrdinalMeta_1.createByAxisModel(this);
            }
          },

          /**
           * Should not be called before all of 'getInitailData' finished.
           * Because categories are collected during initializing data.
           */
          getCategories: function (rawData) {
            var option = this.option; // FIXME
            // warning if called before all of 'getInitailData' finished.

            if (option.type === 'category') {
              if (rawData) {
                return option.data;
              }

              return this.__ordinalMeta.categories;
            }
          },
          getOrdinalMeta: function () {
            return this.__ordinalMeta;
          },
          defaultOption: util.mergeAll([{}, axisDefault_1[axisType + 'Axis'], extraDefaultOption], true)
        });
      });
      Component.registerSubTypeDefaulter(axisName + 'Axis', util.curry(axisTypeDefaulter, axisName));
    }

    var axisModelCreator = _default$1A;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var AxisModel = Component.extend({
      type: 'cartesian2dAxis',

      /**
       * @type {module:echarts/coord/cartesian/Axis2D}
       */
      axis: null,

      /**
       * @override
       */
      init: function () {
        AxisModel.superApply(this, 'init', arguments);
        this.resetRange();
      },

      /**
       * @override
       */
      mergeOption: function () {
        AxisModel.superApply(this, 'mergeOption', arguments);
        this.resetRange();
      },

      /**
       * @override
       */
      restoreData: function () {
        AxisModel.superApply(this, 'restoreData', arguments);
        this.resetRange();
      },

      /**
       * @override
       * @return {module:echarts/model/Component}
       */
      getCoordSysModel: function () {
        return this.ecModel.queryComponents({
          mainType: 'grid',
          index: this.option.gridIndex,
          id: this.option.gridId
        })[0];
      }
    });

    function getAxisType(axisDim, option) {
      // Default axis with data is category axis
      return option.type || (option.data ? 'category' : 'value');
    }

    util.merge(AxisModel.prototype, axisModelCommonMixin);
    var extraOption = {
      // gridIndex: 0,
      // gridId: '',
      // Offset is for multiple axis on the same position
      offset: 0
    };
    axisModelCreator('x', AxisModel, getAxisType, extraOption);
    axisModelCreator('y', AxisModel, getAxisType, extraOption);

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // Grid 是在有直角坐标系的时候必须要存在的
    // 所以这里也要被 Cartesian2D 依赖
    var _default$1B = Component.extend({
      type: 'grid',
      dependencies: ['xAxis', 'yAxis'],
      layoutMode: 'box',

      /**
       * @type {module:echarts/coord/cartesian/Grid}
       */
      coordinateSystem: null,
      defaultOption: {
        show: false,
        zlevel: 0,
        z: 0,
        left: '10%',
        top: 60,
        right: '10%',
        bottom: 60,
        // If grid size contain label
        containLabel: false,
        // width: {totalWidth} - left - right,
        // height: {totalHeight} - top - bottom,
        backgroundColor: 'rgba(0,0,0,0)',
        borderWidth: 1,
        borderColor: '#ccc'
      }
    });

    var isObject$d = util.isObject;
    var each$k = util.each;
    var map$7 = util.map;
    var indexOf$3 = util.indexOf;



    var getLayoutRect$1 = layout.getLayoutRect;



    var createScaleByModel$1 = axisHelper.createScaleByModel;
    var ifAxisCrossZero$1 = axisHelper.ifAxisCrossZero;
    var niceScaleExtent$1 = axisHelper.niceScaleExtent;
    var estimateLabelUnionRect$1 = axisHelper.estimateLabelUnionRect;









    var getStackedDimension$2 = dataStackHelper.getStackedDimension;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Grid is a region which contains at most 4 cartesian systems
     *
     * TODO Default cartesian
     */
    // Depends on GridModel, AxisModel, which performs preprocess.

    /**
     * Check if the axis is used in the specified grid
     * @inner
     */
    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
      return axisModel.getCoordSysModel() === gridModel;
    }

    function Grid(gridModel, ecModel, api) {
      /**
       * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
       * @private
       */
      this._coordsMap = {};
      /**
       * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
       * @private
       */

      this._coordsList = [];
      /**
       * @type {Object.<string, Array.<module:echarts/coord/cartesian/Axis2D>>}
       * @private
       */

      this._axesMap = {};
      /**
       * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
       * @private
       */

      this._axesList = [];

      this._initCartesian(gridModel, ecModel, api);

      this.model = gridModel;
    }

    var gridProto = Grid.prototype;
    gridProto.type = 'grid';
    gridProto.axisPointerEnabled = true;

    gridProto.getRect = function () {
      return this._rect;
    };

    gridProto.update = function (ecModel, api) {
      var axesMap = this._axesMap;

      this._updateScale(ecModel, this.model);

      each$k(axesMap.x, function (xAxis) {
        niceScaleExtent$1(xAxis.scale, xAxis.model);
      });
      each$k(axesMap.y, function (yAxis) {
        niceScaleExtent$1(yAxis.scale, yAxis.model);
      }); // Key: axisDim_axisIndex, value: boolean, whether onZero target.

      var onZeroRecords = {};
      each$k(axesMap.x, function (xAxis) {
        fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);
      });
      each$k(axesMap.y, function (yAxis) {
        fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);
      }); // Resize again if containLabel is enabled
      // FIXME It may cause getting wrong grid size in data processing stage

      this.resize(this.model, api);
    };

    function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
      axis.getAxesOnZeroOf = function () {
        // TODO: onZero of multiple axes.
        return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
      }; // onZero can not be enabled in these two situations:
      // 1. When any other axis is a category axis.
      // 2. When no axis is cross 0 point.


      var otherAxes = axesMap[otherAxisDim];
      var otherAxisOnZeroOf;
      var axisModel = axis.model;
      var onZero = axisModel.get('axisLine.onZero');
      var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');

      if (!onZero) {
        return;
      } // If target axis is specified.


      if (onZeroAxisIndex != null) {
        if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
          otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
        }
      } else {
        // Find the first available other axis.
        for (var idx in otherAxes) {
          if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,
          // if both onZero, the two Y axes overlap.
          && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
            otherAxisOnZeroOf = otherAxes[idx];
            break;
          }
        }
      }

      if (otherAxisOnZeroOf) {
        onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
      }

      function getOnZeroRecordKey(axis) {
        return axis.dim + '_' + axis.index;
      }
    }

    function canOnZeroToAxis(axis) {
      return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero$1(axis);
    }
    /**
     * Resize the grid
     * @param {module:echarts/coord/cartesian/GridModel} gridModel
     * @param {module:echarts/ExtensionAPI} api
     */


    gridProto.resize = function (gridModel, api, ignoreContainLabel) {
      var gridRect = getLayoutRect$1(gridModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
      this._rect = gridRect;
      var axesList = this._axesList;
      adjustAxes(); // Minus label size

      if (!ignoreContainLabel && gridModel.get('containLabel')) {
        each$k(axesList, function (axis) {
          if (!axis.model.get('axisLabel.inside')) {
            var labelUnionRect = estimateLabelUnionRect$1(axis);

            if (labelUnionRect) {
              var dim = axis.isHorizontal() ? 'height' : 'width';
              var margin = axis.model.get('axisLabel.margin');
              gridRect[dim] -= labelUnionRect[dim] + margin;

              if (axis.position === 'top') {
                gridRect.y += labelUnionRect.height + margin;
              } else if (axis.position === 'left') {
                gridRect.x += labelUnionRect.width + margin;
              }
            }
          }
        });
        adjustAxes();
      }

      function adjustAxes() {
        each$k(axesList, function (axis) {
          var isHorizontal = axis.isHorizontal();
          var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
          var idx = axis.inverse ? 1 : 0;
          axis.setExtent(extent[idx], extent[1 - idx]);
          updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
        });
      }
    };
    /**
     * @param {string} axisType
     * @param {number} [axisIndex]
     */


    gridProto.getAxis = function (axisType, axisIndex) {
      var axesMapOnDim = this._axesMap[axisType];

      if (axesMapOnDim != null) {
        if (axisIndex == null) {
          // Find first axis
          for (var name in axesMapOnDim) {
            if (axesMapOnDim.hasOwnProperty(name)) {
              return axesMapOnDim[name];
            }
          }
        }

        return axesMapOnDim[axisIndex];
      }
    };
    /**
     * @return {Array.<module:echarts/coord/Axis>}
     */


    gridProto.getAxes = function () {
      return this._axesList.slice();
    };
    /**
     * Usage:
     *      grid.getCartesian(xAxisIndex, yAxisIndex);
     *      grid.getCartesian(xAxisIndex);
     *      grid.getCartesian(null, yAxisIndex);
     *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});
     *
     * @param {number|Object} [xAxisIndex]
     * @param {number} [yAxisIndex]
     */


    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {
      if (xAxisIndex != null && yAxisIndex != null) {
        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
        return this._coordsMap[key];
      }

      if (isObject$d(xAxisIndex)) {
        yAxisIndex = xAxisIndex.yAxisIndex;
        xAxisIndex = xAxisIndex.xAxisIndex;
      } // When only xAxisIndex or yAxisIndex given, find its first cartesian.


      for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
        if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
          return coordList[i];
        }
      }
    };

    gridProto.getCartesians = function () {
      return this._coordsList.slice();
    };
    /**
     * @implements
     * see {module:echarts/CoodinateSystem}
     */


    gridProto.convertToPixel = function (ecModel, finder, value) {
      var target = this._findConvertTarget(ecModel, finder);

      return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
    };
    /**
     * @implements
     * see {module:echarts/CoodinateSystem}
     */


    gridProto.convertFromPixel = function (ecModel, finder, value) {
      var target = this._findConvertTarget(ecModel, finder);

      return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
    };
    /**
     * @inner
     */


    gridProto._findConvertTarget = function (ecModel, finder) {
      var seriesModel = finder.seriesModel;
      var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];
      var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];
      var gridModel = finder.gridModel;
      var coordsList = this._coordsList;
      var cartesian;
      var axis;

      if (seriesModel) {
        cartesian = seriesModel.coordinateSystem;
        indexOf$3(coordsList, cartesian) < 0 && (cartesian = null);
      } else if (xAxisModel && yAxisModel) {
        cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      } else if (xAxisModel) {
        axis = this.getAxis('x', xAxisModel.componentIndex);
      } else if (yAxisModel) {
        axis = this.getAxis('y', yAxisModel.componentIndex);
      } // Lowest priority.
      else if (gridModel) {
          var grid = gridModel.coordinateSystem;

          if (grid === this) {
            cartesian = this._coordsList[0];
          }
        }

      return {
        cartesian: cartesian,
        axis: axis
      };
    };
    /**
     * @implements
     * see {module:echarts/CoodinateSystem}
     */


    gridProto.containPoint = function (point) {
      var coord = this._coordsList[0];

      if (coord) {
        return coord.containPoint(point);
      }
    };
    /**
     * Initialize cartesian coordinate systems
     * @private
     */


    gridProto._initCartesian = function (gridModel, ecModel, api) {
      var axisPositionUsed = {
        left: false,
        right: false,
        top: false,
        bottom: false
      };
      var axesMap = {
        x: {},
        y: {}
      };
      var axesCount = {
        x: 0,
        y: 0
      }; /// Create axis

      ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
      ecModel.eachComponent('yAxis', createAxisCreator('y'), this);

      if (!axesCount.x || !axesCount.y) {
        // Roll back when there no either x or y axis
        this._axesMap = {};
        this._axesList = [];
        return;
      }

      this._axesMap = axesMap; /// Create cartesian2d

      each$k(axesMap.x, function (xAxis, xAxisIndex) {
        each$k(axesMap.y, function (yAxis, yAxisIndex) {
          var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
          var cartesian = new Cartesian2D_1(key);
          cartesian.grid = this;
          cartesian.model = gridModel;
          this._coordsMap[key] = cartesian;

          this._coordsList.push(cartesian);

          cartesian.addAxis(xAxis);
          cartesian.addAxis(yAxis);
        }, this);
      }, this);

      function createAxisCreator(axisType) {
        return function (axisModel, idx) {
          if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
            return;
          }

          var axisPosition = axisModel.get('position');

          if (axisType === 'x') {
            // Fix position
            if (axisPosition !== 'top' && axisPosition !== 'bottom') {
              // Default bottom of X
              axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';
            }
          } else {
            // Fix position
            if (axisPosition !== 'left' && axisPosition !== 'right') {
              // Default left of Y
              axisPosition = axisPositionUsed.left ? 'right' : 'left';
            }
          }

          axisPositionUsed[axisPosition] = true;
          var axis = new Axis2D_1(axisType, createScaleByModel$1(axisModel), [0, 0], axisModel.get('type'), axisPosition);
          var isCategory = axis.type === 'category';
          axis.onBand = isCategory && axisModel.get('boundaryGap');
          axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel

          axisModel.axis = axis; // Inject axisModel into axis

          axis.model = axisModel; // Inject grid info axis

          axis.grid = this; // Index of axis, can be used as key

          axis.index = idx;

          this._axesList.push(axis);

          axesMap[axisType][idx] = axis;
          axesCount[axisType]++;
        };
      }
    };
    /**
     * Update cartesian properties from series
     * @param  {module:echarts/model/Option} option
     * @private
     */


    gridProto._updateScale = function (ecModel, gridModel) {
      // Reset scale
      each$k(this._axesList, function (axis) {
        axis.scale.setExtent(Infinity, -Infinity);
      });
      ecModel.eachSeries(function (seriesModel) {
        if (isCartesian2D(seriesModel)) {
          var axesModels = findAxesModels(seriesModel);
          var xAxisModel = axesModels[0];
          var yAxisModel = axesModels[1];

          if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
            return;
          }

          var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
          var data = seriesModel.getData();
          var xAxis = cartesian.getAxis('x');
          var yAxis = cartesian.getAxis('y');

          if (data.type === 'list') {
            unionExtent(data, xAxis);
            unionExtent(data, yAxis);
          }
        }
      }, this);

      function unionExtent(data, axis, seriesModel) {
        each$k(data.mapDimension(axis.dim, true), function (dim) {
          axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension
          // is [0.1, 0.5], the extent of the `stackResultDimension`
          // is [7, 9], the final extent should not include [0.1, 0.5].
          data, getStackedDimension$2(data, dim));
        });
      }
    };
    /**
     * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined
     * @return {Object} {baseAxes: [], otherAxes: []}
     */


    gridProto.getTooltipAxes = function (dim) {
      var baseAxes = [];
      var otherAxes = [];
      each$k(this.getCartesians(), function (cartesian) {
        var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
        var otherAxis = cartesian.getOtherAxis(baseAxis);
        indexOf$3(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
        indexOf$3(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
      });
      return {
        baseAxes: baseAxes,
        otherAxes: otherAxes
      };
    };
    /**
     * @inner
     */


    function updateAxisTransform(axis, coordBase) {
      var axisExtent = axis.getExtent();
      var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform

      axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
        return coord + coordBase;
      } : function (coord) {
        return axisExtentSum - coord + coordBase;
      };
      axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
        return coord - coordBase;
      } : function (coord) {
        return axisExtentSum - coord + coordBase;
      };
    }

    var axesTypes = ['xAxis', 'yAxis'];
    /**
     * @inner
     */

    function findAxesModels(seriesModel, ecModel) {
      return map$7(axesTypes, function (axisType) {
        var axisModel = seriesModel.getReferringComponents(axisType)[0];
        return axisModel;
      });
    }
    /**
     * @inner
     */


    function isCartesian2D(seriesModel) {
      return seriesModel.get('coordinateSystem') === 'cartesian2d';
    }

    Grid.create = function (ecModel, api) {
      var grids = [];
      ecModel.eachComponent('grid', function (gridModel, idx) {
        var grid = new Grid(gridModel, ecModel, api);
        grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize
        // should be performed in create stage.

        grid.resize(gridModel, api, true);
        gridModel.coordinateSystem = grid;
        grids.push(grid);
      }); // Inject the coordinateSystems into seriesModel

      ecModel.eachSeries(function (seriesModel) {
        if (!isCartesian2D(seriesModel)) {
          return;
        }

        var axesModels = findAxesModels(seriesModel);
        var xAxisModel = axesModels[0];
        var yAxisModel = axesModels[1];
        var gridModel = xAxisModel.getCoordSysModel();
        var grid = gridModel.coordinateSystem;
        seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      });
      return grids;
    }; // For deciding which dimensions to use when creating list data


    Grid.dimensions = Grid.prototype.dimensions = Cartesian2D_1.prototype.dimensions;
    CoordinateSystem.register('cartesian2d', Grid);

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var _default$1C = Series.extend({
      type: 'series.__base_bar__',
      getInitialData: function (option, ecModel) {
        return createListFromArray_1(this.getSource(), this, {
          useEncodeDefaulter: true
        });
      },
      getMarkerPosition: function (value) {
        var coordSys = this.coordinateSystem;

        if (coordSys) {
          // PENDING if clamp ?
          var pt = coordSys.dataToPoint(coordSys.clampData(value));
          var data = this.getData();
          var offset = data.getLayout('offset');
          var size = data.getLayout('size');
          var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
          pt[offsetIndex] += offset + size / 2;
          return pt;
        }

        return [NaN, NaN];
      },
      defaultOption: {
        zlevel: 0,
        // 一级层叠
        z: 2,
        // 二级层叠
        coordinateSystem: 'cartesian2d',
        legendHoverLink: true,
        // stack: null
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // 最小高度改为0
        barMinHeight: 0,
        // 最小角度为0，仅对极坐标系下的柱状图有效
        barMinAngle: 0,
        // cursor: null,
        large: false,
        largeThreshold: 400,
        progressive: 3e3,
        progressiveChunkMode: 'mod',
        // barMaxWidth: null,
        // In cartesian, the default value is 1. Otherwise null.
        // barMinWidth: null,
        // 默认自适应
        // barWidth: null,
        // 柱间距离，默认为柱形宽度的30%，可设固定值
        // barGap: '30%',
        // 类目间柱形距离，默认为类目间距的20%，可设固定值
        // barCategoryGap: '20%',
        // label: {
        //      show: false
        // },
        itemStyle: {},
        emphasis: {}
      }
    });

    var BaseBarSeries = _default$1C;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var _default$1D = BaseBarSeries.extend({
      type: 'series.bar',
      dependencies: ['grid', 'polar'],
      brushSelector: 'rect',

      /**
       * @override
       */
      getProgressive: function () {
        // Do not support progressive in normal mode.
        return this.get('large') ? this.get('progressive') : false;
      },

      /**
       * @override
       */
      getProgressiveThreshold: function () {
        // Do not support progressive in normal mode.
        var progressiveThreshold = this.get('progressiveThreshold');
        var largeThreshold = this.get('largeThreshold');

        if (largeThreshold > progressiveThreshold) {
          progressiveThreshold = largeThreshold;
        }

        return progressiveThreshold;
      },
      defaultOption: {
        // If clipped
        // Only available on cartesian2d
        clip: true,
        // If use caps on two sides of bars
        // Only available on tangential polar bar
        roundCap: false,
        showBackground: false,
        backgroundStyle: {
          color: 'rgba(180, 180, 180, 0.2)',
          borderColor: null,
          borderWidth: 0,
          borderType: 'solid',
          borderRadius: 0,
          shadowBlur: 0,
          shadowColor: null,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          opacity: 1
        }
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var retrieveRawValue$4 = dataProvider.retrieveRawValue;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @param {module:echarts/data/List} data
     * @param {number} dataIndex
     * @return {string} label string. Not null/undefined
     */
    function getDefaultLabel(data, dataIndex) {
      var labelDims = data.mapDimension('defaultedLabel', true);
      var len = labelDims.length; // Simple optimization (in lots of cases, label dims length is 1)

      if (len === 1) {
        return retrieveRawValue$4(data, dataIndex, labelDims[0]);
      } else if (len) {
        var vals = [];

        for (var i = 0; i < labelDims.length; i++) {
          var val = retrieveRawValue$4(data, dataIndex, labelDims[i]);
          vals.push(val);
        }

        return vals.join(' ');
      }
    }

    var getDefaultLabel_1 = getDefaultLabel;

    var labelHelper = {
    	getDefaultLabel: getDefaultLabel_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    var getDefaultLabel$1 = labelHelper.getDefaultLabel;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {
      var labelModel = itemModel.getModel('label');
      var hoverLabelModel = itemModel.getModel('emphasis.label');
      graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {
        labelFetcher: seriesModel,
        labelDataIndex: dataIndex,
        defaultText: getDefaultLabel$1(seriesModel.getData(), dataIndex),
        isRectText: true,
        autoColor: color
      });
      fixPosition(normalStyle);
      fixPosition(hoverStyle);
    }

    function fixPosition(style, labelPositionOutside) {
      if (style.textPosition === 'outside') {
        style.textPosition = labelPositionOutside;
      }
    }

    var setLabel_1 = setLabel;

    var helper$3 = {
    	setLabel: setLabel_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2
    ['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
    var _default$1E = {
      getBarItemStyle: function (excludes) {
        var style = getBarItemStyle(this, excludes);

        if (this.getBorderLineDash) {
          var lineDash = this.getBorderLineDash();
          lineDash && (style.lineDash = lineDash);
        }

        return style;
      }
    };
    var barItemStyle = _default$1E;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    var round$3 = number.round;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function createGridClipPath(cartesian, hasAnimation, seriesModel) {
      var rect = cartesian.getArea();
      var isHorizontal = cartesian.getBaseAxis().isHorizontal();
      var x = rect.x;
      var y = rect.y;
      var width = rect.width;
      var height = rect.height;
      var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand the clip path a bit to avoid the border is clipped and looks thinner

      x -= lineWidth / 2;
      y -= lineWidth / 2;
      width += lineWidth;
      height += lineWidth; // fix: https://github.com/apache/incubator-echarts/issues/11369

      x = Math.floor(x);
      width = Math.round(width);
      var clipPath = new graphic.Rect({
        shape: {
          x: x,
          y: y,
          width: width,
          height: height
        }
      });

      if (hasAnimation) {
        clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;
        graphic.initProps(clipPath, {
          shape: {
            width: width,
            height: height
          }
        }, seriesModel);
      }

      return clipPath;
    }

    function createPolarClipPath(polar, hasAnimation, seriesModel) {
      var sectorArea = polar.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.

      var clipPath = new graphic.Sector({
        shape: {
          cx: round$3(polar.cx, 1),
          cy: round$3(polar.cy, 1),
          r0: round$3(sectorArea.r0, 1),
          r: round$3(sectorArea.r, 1),
          startAngle: sectorArea.startAngle,
          endAngle: sectorArea.endAngle,
          clockwise: sectorArea.clockwise
        }
      });

      if (hasAnimation) {
        clipPath.shape.endAngle = sectorArea.startAngle;
        graphic.initProps(clipPath, {
          shape: {
            endAngle: sectorArea.endAngle
          }
        }, seriesModel);
      }

      return clipPath;
    }

    function createClipPath(coordSys, hasAnimation, seriesModel) {
      if (!coordSys) {
        return null;
      } else if (coordSys.type === 'polar') {
        return createPolarClipPath(coordSys, hasAnimation, seriesModel);
      } else if (coordSys.type === 'cartesian2d') {
        return createGridClipPath(coordSys, hasAnimation, seriesModel);
      }

      return null;
    }

    var createGridClipPath_1 = createGridClipPath;
    var createPolarClipPath_1 = createPolarClipPath;
    var createClipPath_1 = createClipPath;

    var createClipPathFromCoordSys = {
    	createGridClipPath: createGridClipPath_1,
    	createPolarClipPath: createPolarClipPath_1,
    	createClipPath: createClipPath_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var extendShape$1 = graphic.extendShape;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Sausage: similar to sector, but have half circle on both sides
     * @public
     */
    var _default$1F = extendShape$1({
      type: 'sausage',
      shape: {
        cx: 0,
        cy: 0,
        r0: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      buildPath: function (ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r0 = Math.max(shape.r0 || 0, 0);
        var r = Math.max(shape.r, 0);
        var dr = (r - r0) * 0.5;
        var rCenter = r0 + dr;
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitStartX = Math.cos(startAngle);
        var unitStartY = Math.sin(startAngle);
        var unitEndX = Math.cos(endAngle);
        var unitEndY = Math.sin(endAngle);
        var lessThanCircle = clockwise ? endAngle - startAngle < Math.PI * 2 : startAngle - endAngle < Math.PI * 2;

        if (lessThanCircle) {
          ctx.moveTo(unitStartX * r0 + x, unitStartY * r0 + y);
          ctx.arc(unitStartX * rCenter + x, unitStartY * rCenter + y, dr, -Math.PI + startAngle, startAngle, !clockwise);
        }

        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
        ctx.moveTo(unitEndX * r + x, unitEndY * r + y);
        ctx.arc(unitEndX * rCenter + x, unitEndY * rCenter + y, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);

        if (r0 !== 0) {
          ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
          ctx.moveTo(unitStartX * r0 + x, unitEndY * r0 + y);
        }

        ctx.closePath();
      }
    });

    var sausage = _default$1F;

    var setLabel$1 = helper$3.setLabel;











    var throttle$1 = throttle_1.throttle;



    var createClipPath$1 = createClipPathFromCoordSys.createClipPath;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'barBorderWidth'];
    var _eventPos = [0, 0]; // FIXME
    // Just for compatible with ec2.

    util.extend(Model_1.prototype, barItemStyle);

    function getClipArea(coord, data) {
      var coordSysClipArea = coord.getArea && coord.getArea();

      if (coord.type === 'cartesian2d') {
        var baseAxis = coord.getBaseAxis(); // When boundaryGap is false or using time axis. bar may exceed the grid.
        // We should not clip this part.
        // See test/bar2.html

        if (baseAxis.type !== 'category' || !baseAxis.onBand) {
          var expandWidth = data.getLayout('bandWidth');

          if (baseAxis.isHorizontal()) {
            coordSysClipArea.x -= expandWidth;
            coordSysClipArea.width += expandWidth * 2;
          } else {
            coordSysClipArea.y -= expandWidth;
            coordSysClipArea.height += expandWidth * 2;
          }
        }
      }

      return coordSysClipArea;
    }

    var _default$1G = echarts.extendChartView({
      type: 'bar',
      render: function (seriesModel, ecModel, api) {
        this._updateDrawMode(seriesModel);

        var coordinateSystemType = seriesModel.get('coordinateSystem');

        if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
          this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api);
        }

        return this.group;
      },
      incrementalPrepareRender: function (seriesModel, ecModel, api) {
        this._clear();

        this._updateDrawMode(seriesModel);
      },
      incrementalRender: function (params, seriesModel, ecModel, api) {
        // Do not support progressive in normal mode.
        this._incrementalRenderLarge(params, seriesModel);
      },
      _updateDrawMode: function (seriesModel) {
        var isLargeDraw = seriesModel.pipelineContext.large;

        if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
          this._isLargeDraw = isLargeDraw;

          this._clear();
        }
      },
      _renderNormal: function (seriesModel, ecModel, api) {
        var group = this.group;
        var data = seriesModel.getData();
        var oldData = this._data;
        var coord = seriesModel.coordinateSystem;
        var baseAxis = coord.getBaseAxis();
        var isHorizontalOrRadial;

        if (coord.type === 'cartesian2d') {
          isHorizontalOrRadial = baseAxis.isHorizontal();
        } else if (coord.type === 'polar') {
          isHorizontalOrRadial = baseAxis.dim === 'angle';
        }

        var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
        var needsClip = seriesModel.get('clip', true);
        var coordSysClipArea = getClipArea(coord, data); // If there is clipPath created in large mode. Remove it.

        group.removeClipPath(); // We don't use clipPath in normal mode because we needs a perfect animation
        // And don't want the label are clipped.

        var roundCap = seriesModel.get('roundCap', true);
        var drawBackground = seriesModel.get('showBackground', true);
        var backgroundModel = seriesModel.getModel('backgroundStyle');
        var barBorderRadius = backgroundModel.get('barBorderRadius') || 0;
        var bgEls = [];
        var oldBgEls = this._backgroundEls || [];
        data.diff(oldData).add(function (dataIndex) {
          var itemModel = data.getItemModel(dataIndex);
          var layout = getLayout[coord.type](data, dataIndex, itemModel);

          if (drawBackground) {
            var bgLayout = getLayout[coord.type](data, dataIndex);
            var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
            bgEl.useStyle(backgroundModel.getBarItemStyle()); // Only cartesian2d support borderRadius.

            if (coord.type === 'cartesian2d') {
              bgEl.setShape('r', barBorderRadius);
            }

            bgEls[dataIndex] = bgEl;
          } // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in "axisProxy".


          if (!data.hasValue(dataIndex)) {
            return;
          }

          if (needsClip) {
            // Clip will modify the layout params.
            // And return a boolean to determine if the shape are fully clipped.
            var isClipped = clip[coord.type](coordSysClipArea, layout);

            if (isClipped) {
              group.remove(el);
              return;
            }
          }

          var el = elementCreator[coord.type](dataIndex, layout, isHorizontalOrRadial, animationModel, false, roundCap);
          data.setItemGraphicEl(dataIndex, el);
          group.add(el);
          updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
        }).update(function (newIndex, oldIndex) {
          var itemModel = data.getItemModel(newIndex);
          var layout = getLayout[coord.type](data, newIndex, itemModel);

          if (drawBackground) {
            var bgEl = oldBgEls[oldIndex];
            bgEl.useStyle(backgroundModel.getBarItemStyle()); // Only cartesian2d support borderRadius.

            if (coord.type === 'cartesian2d') {
              bgEl.setShape('r', barBorderRadius);
            }

            bgEls[newIndex] = bgEl;
            var bgLayout = getLayout[coord.type](data, newIndex);
            var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
            graphic.updateProps(bgEl, {
              shape: shape
            }, animationModel, newIndex);
          }

          var el = oldData.getItemGraphicEl(oldIndex);

          if (!data.hasValue(newIndex)) {
            group.remove(el);
            return;
          }

          if (needsClip) {
            var isClipped = clip[coord.type](coordSysClipArea, layout);

            if (isClipped) {
              group.remove(el);
              return;
            }
          }

          if (el) {
            graphic.updateProps(el, {
              shape: layout
            }, animationModel, newIndex);
          } else {
            el = elementCreator[coord.type](newIndex, layout, isHorizontalOrRadial, animationModel, true, roundCap);
          }

          data.setItemGraphicEl(newIndex, el); // Add back

          group.add(el);
          updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
        }).remove(function (dataIndex) {
          var el = oldData.getItemGraphicEl(dataIndex);

          if (coord.type === 'cartesian2d') {
            el && removeRect(dataIndex, animationModel, el);
          } else {
            el && removeSector(dataIndex, animationModel, el);
          }
        }).execute();
        var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group_1());
        bgGroup.removeAll();

        for (var i = 0; i < bgEls.length; ++i) {
          bgGroup.add(bgEls[i]);
        }

        group.add(bgGroup);
        this._backgroundEls = bgEls;
        this._data = data;
      },
      _renderLarge: function (seriesModel, ecModel, api) {
        this._clear();

        createLarge(seriesModel, this.group); // Use clipPath in large mode.

        var clipPath = seriesModel.get('clip', true) ? createClipPath$1(seriesModel.coordinateSystem, false, seriesModel) : null;

        if (clipPath) {
          this.group.setClipPath(clipPath);
        } else {
          this.group.removeClipPath();
        }
      },
      _incrementalRenderLarge: function (params, seriesModel) {
        this._removeBackground();

        createLarge(seriesModel, this.group, true);
      },
      dispose: util.noop,
      remove: function (ecModel) {
        this._clear(ecModel);
      },
      _clear: function (ecModel) {
        var group = this.group;
        var data = this._data;

        if (ecModel && ecModel.get('animation') && data && !this._isLargeDraw) {
          this._removeBackground();

          this._backgroundEls = [];
          data.eachItemGraphicEl(function (el) {
            if (el.type === 'sector') {
              removeSector(el.dataIndex, ecModel, el);
            } else {
              removeRect(el.dataIndex, ecModel, el);
            }
          });
        } else {
          group.removeAll();
        }

        this._data = null;
      },
      _removeBackground: function () {
        this.group.remove(this._backgroundGroup);
        this._backgroundGroup = null;
      }
    });

    var mathMax$4 = Math.max;
    var mathMin$4 = Math.min;
    var clip = {
      cartesian2d: function (coordSysBoundingRect, layout) {
        var signWidth = layout.width < 0 ? -1 : 1;
        var signHeight = layout.height < 0 ? -1 : 1; // Needs positive width and height

        if (signWidth < 0) {
          layout.x += layout.width;
          layout.width = -layout.width;
        }

        if (signHeight < 0) {
          layout.y += layout.height;
          layout.height = -layout.height;
        }

        var x = mathMax$4(layout.x, coordSysBoundingRect.x);
        var x2 = mathMin$4(layout.x + layout.width, coordSysBoundingRect.x + coordSysBoundingRect.width);
        var y = mathMax$4(layout.y, coordSysBoundingRect.y);
        var y2 = mathMin$4(layout.y + layout.height, coordSysBoundingRect.y + coordSysBoundingRect.height);
        layout.x = x;
        layout.y = y;
        layout.width = x2 - x;
        layout.height = y2 - y;
        var clipped = layout.width < 0 || layout.height < 0; // Reverse back

        if (signWidth < 0) {
          layout.x += layout.width;
          layout.width = -layout.width;
        }

        if (signHeight < 0) {
          layout.y += layout.height;
          layout.height = -layout.height;
        }

        return clipped;
      },
      polar: function (coordSysClipArea) {
        return false;
      }
    };
    var elementCreator = {
      cartesian2d: function (dataIndex, layout, isHorizontal, animationModel, isUpdate) {
        var rect = new graphic.Rect({
          shape: util.extend({}, layout),
          z2: 1
        });
        rect.name = 'item'; // Animation

        if (animationModel) {
          var rectShape = rect.shape;
          var animateProperty = isHorizontal ? 'height' : 'width';
          var animateTarget = {};
          rectShape[animateProperty] = 0;
          animateTarget[animateProperty] = layout[animateProperty];
          graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {
            shape: animateTarget
          }, animationModel, dataIndex);
        }

        return rect;
      },
      polar: function (dataIndex, layout, isRadial, animationModel, isUpdate, roundCap) {
        // Keep the same logic with bar in catesion: use end value to control
        // direction. Notice that if clockwise is true (by default), the sector
        // will always draw clockwisely, no matter whether endAngle is greater
        // or less than startAngle.
        var clockwise = layout.startAngle < layout.endAngle;
        var ShapeClass = !isRadial && roundCap ? sausage : graphic.Sector;
        var sector = new ShapeClass({
          shape: util.defaults({
            clockwise: clockwise
          }, layout),
          z2: 1
        });
        sector.name = 'item'; // Animation

        if (animationModel) {
          var sectorShape = sector.shape;
          var animateProperty = isRadial ? 'r' : 'endAngle';
          var animateTarget = {};
          sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
          animateTarget[animateProperty] = layout[animateProperty];
          graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {
            shape: animateTarget
          }, animationModel, dataIndex);
        }

        return sector;
      }
    };

    function removeRect(dataIndex, animationModel, el) {
      // Not show text when animating
      el.style.text = null;
      graphic.updateProps(el, {
        shape: {
          width: 0
        }
      }, animationModel, dataIndex, function () {
        el.parent && el.parent.remove(el);
      });
    }

    function removeSector(dataIndex, animationModel, el) {
      // Not show text when animating
      el.style.text = null;
      graphic.updateProps(el, {
        shape: {
          r: el.shape.r0
        }
      }, animationModel, dataIndex, function () {
        el.parent && el.parent.remove(el);
      });
    }

    var getLayout = {
      // itemModel is only used to get borderWidth, which is not needed
      // when calculating bar background layout.
      cartesian2d: function (data, dataIndex, itemModel) {
        var layout = data.getItemLayout(dataIndex);
        var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0; // fix layout with lineWidth

        var signX = layout.width > 0 ? 1 : -1;
        var signY = layout.height > 0 ? 1 : -1;
        return {
          x: layout.x + signX * fixedLineWidth / 2,
          y: layout.y + signY * fixedLineWidth / 2,
          width: layout.width - signX * fixedLineWidth,
          height: layout.height - signY * fixedLineWidth
        };
      },
      polar: function (data, dataIndex, itemModel) {
        var layout = data.getItemLayout(dataIndex);
        return {
          cx: layout.cx,
          cy: layout.cy,
          r0: layout.r0,
          r: layout.r,
          startAngle: layout.startAngle,
          endAngle: layout.endAngle
        };
      }
    };

    function isZeroOnPolar(layout) {
      return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;
    }

    function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
      var color = data.getItemVisual(dataIndex, 'color');
      var opacity = data.getItemVisual(dataIndex, 'opacity');
      var stroke = data.getVisual('borderColor');
      var itemStyleModel = itemModel.getModel('itemStyle');
      var hoverStyle = itemModel.getModel('emphasis.itemStyle').getBarItemStyle();

      if (!isPolar) {
        el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);
      }

      el.useStyle(util.defaults({
        stroke: isZeroOnPolar(layout) ? 'none' : stroke,
        fill: isZeroOnPolar(layout) ? 'none' : color,
        opacity: opacity
      }, itemStyleModel.getBarItemStyle()));
      var cursorStyle = itemModel.getShallow('cursor');
      cursorStyle && el.attr('cursor', cursorStyle);
      var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';

      if (!isPolar) {
        setLabel$1(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);
      }

      if (isZeroOnPolar(layout)) {
        hoverStyle.fill = hoverStyle.stroke = 'none';
      }

      graphic.setHoverStyle(el, hoverStyle);
    } // In case width or height are too small.


    function getLineWidth(itemModel, rawLayout) {
      var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0; // width or height may be NaN for empty data

      var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
      var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
      return Math.min(lineWidth, width, height);
    }

    var LargePath = Path_1.extend({
      type: 'largeBar',
      shape: {
        points: []
      },
      buildPath: function (ctx, shape) {
        // Drawing lines is more efficient than drawing
        // a whole line or drawing rects.
        var points = shape.points;
        var startPoint = this.__startPoint;
        var baseDimIdx = this.__baseDimIdx;

        for (var i = 0; i < points.length; i += 2) {
          startPoint[baseDimIdx] = points[i + baseDimIdx];
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(points[i], points[i + 1]);
        }
      }
    });

    function createLarge(seriesModel, group, incremental) {
      // TODO support polar
      var data = seriesModel.getData();
      var startPoint = [];
      var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;
      startPoint[1 - baseDimIdx] = data.getLayout('valueAxisStart');
      var largeDataIndices = data.getLayout('largeDataIndices');
      var barWidth = data.getLayout('barWidth');
      var backgroundModel = seriesModel.getModel('backgroundStyle');
      var drawBackground = seriesModel.get('showBackground', true);

      if (drawBackground) {
        var points = data.getLayout('largeBackgroundPoints');
        var backgroundStartPoint = [];
        backgroundStartPoint[1 - baseDimIdx] = data.getLayout('backgroundStart');
        var bgEl = new LargePath({
          shape: {
            points: points
          },
          incremental: !!incremental,
          __startPoint: backgroundStartPoint,
          __baseDimIdx: baseDimIdx,
          __largeDataIndices: largeDataIndices,
          __barWidth: barWidth,
          silent: true,
          z2: 0
        });
        setLargeBackgroundStyle(bgEl, backgroundModel, data);
        group.add(bgEl);
      }

      var el = new LargePath({
        shape: {
          points: data.getLayout('largePoints')
        },
        incremental: !!incremental,
        __startPoint: startPoint,
        __baseDimIdx: baseDimIdx,
        __largeDataIndices: largeDataIndices,
        __barWidth: barWidth
      });
      group.add(el);
      setLargeStyle(el, seriesModel, data); // Enable tooltip and user mouse/touch event handlers.

      el.seriesIndex = seriesModel.seriesIndex;

      if (!seriesModel.get('silent')) {
        el.on('mousedown', largePathUpdateDataIndex);
        el.on('mousemove', largePathUpdateDataIndex);
      }
    } // Use throttle to avoid frequently traverse to find dataIndex.


    var largePathUpdateDataIndex = throttle$1(function (event) {
      var largePath = this;
      var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
      largePath.dataIndex = dataIndex >= 0 ? dataIndex : null;
    }, 30, false);

    function largePathFindDataIndex(largePath, x, y) {
      var baseDimIdx = largePath.__baseDimIdx;
      var valueDimIdx = 1 - baseDimIdx;
      var points = largePath.shape.points;
      var largeDataIndices = largePath.__largeDataIndices;
      var barWidthHalf = Math.abs(largePath.__barWidth / 2);
      var startValueVal = largePath.__startPoint[valueDimIdx];
      _eventPos[0] = x;
      _eventPos[1] = y;
      var pointerBaseVal = _eventPos[baseDimIdx];
      var pointerValueVal = _eventPos[1 - baseDimIdx];
      var baseLowerBound = pointerBaseVal - barWidthHalf;
      var baseUpperBound = pointerBaseVal + barWidthHalf;

      for (var i = 0, len = points.length / 2; i < len; i++) {
        var ii = i * 2;
        var barBaseVal = points[ii + baseDimIdx];
        var barValueVal = points[ii + valueDimIdx];

        if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {
          return largeDataIndices[i];
        }
      }

      return -1;
    }

    function setLargeStyle(el, seriesModel, data) {
      var borderColor = data.getVisual('borderColor') || data.getVisual('color');
      var itemStyle = seriesModel.getModel('itemStyle').getItemStyle(['color', 'borderColor']);
      el.useStyle(itemStyle);
      el.style.fill = null;
      el.style.stroke = borderColor;
      el.style.lineWidth = data.getLayout('barWidth');
    }

    function setLargeBackgroundStyle(el, backgroundModel, data) {
      var borderColor = backgroundModel.get('borderColor') || backgroundModel.get('color');
      var itemStyle = backgroundModel.getItemStyle(['color', 'borderColor']);
      el.useStyle(itemStyle);
      el.style.fill = null;
      el.style.stroke = borderColor;
      el.style.lineWidth = data.getLayout('barWidth');
    }

    function createBackgroundShape(isHorizontalOrRadial, layout, coord) {
      var coordLayout;
      var isPolar = coord.type === 'polar';

      if (isPolar) {
        coordLayout = coord.getArea();
      } else {
        coordLayout = coord.grid.getRect();
      }

      if (isPolar) {
        return {
          cx: coordLayout.cx,
          cy: coordLayout.cy,
          r0: isHorizontalOrRadial ? coordLayout.r0 : layout.r0,
          r: isHorizontalOrRadial ? coordLayout.r : layout.r,
          startAngle: isHorizontalOrRadial ? layout.startAngle : 0,
          endAngle: isHorizontalOrRadial ? layout.endAngle : Math.PI * 2
        };
      } else {
        return {
          x: isHorizontalOrRadial ? layout.x : coordLayout.x,
          y: isHorizontalOrRadial ? coordLayout.y : layout.y,
          width: isHorizontalOrRadial ? layout.width : coordLayout.width,
          height: isHorizontalOrRadial ? coordLayout.height : layout.height
        };
      }
    }

    function createBackgroundEl(coord, isHorizontalOrRadial, layout) {
      var ElementClz = coord.type === 'polar' ? graphic.Sector : graphic.Rect;
      return new ElementClz({
        shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),
        silent: true,
        z2: 0
      });
    }

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var retrieve$1 = util.retrieve;
    var defaults$4 = util.defaults;
    var extend$8 = util.extend;
    var each$l = util.each;









    var isRadianAroundZero$1 = number.isRadianAroundZero;
    var remRadian$1 = number.remRadian;



    var createSymbol$2 = symbol.createSymbol;





    var v2ApplyTransform$2 = vector.applyTransform;



    var shouldShowAllLabels$2 = axisHelper.shouldShowAllLabels;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var PI$2 = Math.PI;
    /**
     * A final axis is translated and rotated from a "standard axis".
     * So opt.position and opt.rotation is required.
     *
     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
     * for example: (0, 0) ------------> (0, 50)
     *
     * nameDirection or tickDirection or labelDirection is 1 means tick
     * or label is below the standard axis, whereas is -1 means above
     * the standard axis. labelOffset means offset between label and axis,
     * which is useful when 'onZero', where axisLabel is in the grid and
     * label in outside grid.
     *
     * Tips: like always,
     * positive rotation represents anticlockwise, and negative rotation
     * represents clockwise.
     * The direction of position coordinate is the same as the direction
     * of screen coordinate.
     *
     * Do not need to consider axis 'inverse', which is auto processed by
     * axis extent.
     *
     * @param {module:zrender/container/Group} group
     * @param {Object} axisModel
     * @param {Object} opt Standard axis parameters.
     * @param {Array.<number>} opt.position [x, y]
     * @param {number} opt.rotation by radian
     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.
     * @param {number} [opt.tickDirection=1] 1 or -1
     * @param {number} [opt.labelDirection=1] 1 or -1
     * @param {number} [opt.labelOffset=0] Usefull when onZero.
     * @param {string} [opt.axisLabelShow] default get from axisModel.
     * @param {string} [opt.axisName] default get from axisModel.
     * @param {number} [opt.axisNameAvailableWidth]
     * @param {number} [opt.labelRotate] by degree, default get from axisModel.
     * @param {number} [opt.strokeContainThreshold] Default label interval when label
     * @param {number} [opt.nameTruncateMaxWidth]
     */

    var AxisBuilder = function (axisModel, opt) {
      /**
       * @readOnly
       */
      this.opt = opt;
      /**
       * @readOnly
       */

      this.axisModel = axisModel; // Default value

      defaults$4(opt, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: true
      });
      /**
       * @readOnly
       */

      this.group = new graphic.Group(); // FIXME Not use a seperate text group?

      var dumbGroup = new graphic.Group({
        position: opt.position.slice(),
        rotation: opt.rotation
      }); // this.group.add(dumbGroup);
      // this._dumbGroup = dumbGroup;

      dumbGroup.updateTransform();
      this._transform = dumbGroup.transform;
      this._dumbGroup = dumbGroup;
    };

    AxisBuilder.prototype = {
      constructor: AxisBuilder,
      hasBuilder: function (name) {
        return !!builders[name];
      },
      add: function (name) {
        builders[name].call(this);
      },
      getGroup: function () {
        return this.group;
      }
    };
    var builders = {
      /**
       * @private
       */
      axisLine: function () {
        var opt = this.opt;
        var axisModel = this.axisModel;

        if (!axisModel.get('axisLine.show')) {
          return;
        }

        var extent = this.axisModel.axis.getExtent();
        var matrix = this._transform;
        var pt1 = [extent[0], 0];
        var pt2 = [extent[1], 0];

        if (matrix) {
          v2ApplyTransform$2(pt1, pt1, matrix);
          v2ApplyTransform$2(pt2, pt2, matrix);
        }

        var lineStyle = extend$8({
          lineCap: 'round'
        }, axisModel.getModel('axisLine.lineStyle').getLineStyle());
        this.group.add(new graphic.Line({
          // Id for animation
          anid: 'line',
          subPixelOptimize: true,
          shape: {
            x1: pt1[0],
            y1: pt1[1],
            x2: pt2[0],
            y2: pt2[1]
          },
          style: lineStyle,
          strokeContainThreshold: opt.strokeContainThreshold || 5,
          silent: true,
          z2: 1
        }));
        var arrows = axisModel.get('axisLine.symbol');
        var arrowSize = axisModel.get('axisLine.symbolSize');
        var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;

        if (typeof arrowOffset === 'number') {
          arrowOffset = [arrowOffset, arrowOffset];
        }

        if (arrows != null) {
          if (typeof arrows === 'string') {
            // Use the same arrow for start and end point
            arrows = [arrows, arrows];
          }

          if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {
            // Use the same size for width and height
            arrowSize = [arrowSize, arrowSize];
          }

          var symbolWidth = arrowSize[0];
          var symbolHeight = arrowSize[1];
          each$l([{
            rotate: opt.rotation + Math.PI / 2,
            offset: arrowOffset[0],
            r: 0
          }, {
            rotate: opt.rotation - Math.PI / 2,
            offset: arrowOffset[1],
            r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
          }], function (point, index) {
            if (arrows[index] !== 'none' && arrows[index] != null) {
              var symbol = createSymbol$2(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset

              var r = point.r + point.offset;
              var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];
              symbol.attr({
                rotation: point.rotate,
                position: pos,
                silent: true,
                z2: 11
              });
              this.group.add(symbol);
            }
          }, this);
        }
      },

      /**
       * @private
       */
      axisTickLabel: function () {
        var axisModel = this.axisModel;
        var opt = this.opt;
        var ticksEls = buildAxisMajorTicks(this, axisModel, opt);
        var labelEls = buildAxisLabel(this, axisModel, opt);
        fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
        buildAxisMinorTicks(this, axisModel, opt);
      },

      /**
       * @private
       */
      axisName: function () {
        var opt = this.opt;
        var axisModel = this.axisModel;
        var name = retrieve$1(opt.axisName, axisModel.get('name'));

        if (!name) {
          return;
        }

        var nameLocation = axisModel.get('nameLocation');
        var nameDirection = opt.nameDirection;
        var textStyleModel = axisModel.getModel('nameTextStyle');
        var gap = axisModel.get('nameGap') || 0;
        var extent = this.axisModel.axis.getExtent();
        var gapSignal = extent[0] > extent[1] ? -1 : 1;
        var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'
        // Reuse labelOffset.
        isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];
        var labelLayout;
        var nameRotation = axisModel.get('nameRotate');

        if (nameRotation != null) {
          nameRotation = nameRotation * PI$2 / 180; // To radian.
        }

        var axisNameAvailableWidth;

        if (isNameLocationCenter(nameLocation)) {
          labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
          nameDirection);
        } else {
          labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);
          axisNameAvailableWidth = opt.axisNameAvailableWidth;

          if (axisNameAvailableWidth != null) {
            axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
            !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
          }
        }

        var textFont = textStyleModel.getFont();
        var truncateOpt = axisModel.get('nameTruncate', true) || {};
        var ellipsis = truncateOpt.ellipsis;
        var maxWidth = retrieve$1(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME
        // truncate rich text? (consider performance)

        var truncatedText = ellipsis != null && maxWidth != null ? format$1.truncateText(name, maxWidth, textFont, ellipsis, {
          minChar: 2,
          placeholder: truncateOpt.placeholder
        }) : name;
        var tooltipOpt = axisModel.get('tooltip', true);
        var mainType = axisModel.mainType;
        var formatterParams = {
          componentType: mainType,
          name: name,
          $vars: ['name']
        };
        formatterParams[mainType + 'Index'] = axisModel.componentIndex;
        var textEl = new graphic.Text({
          // Id for animation
          anid: 'name',
          __fullText: name,
          __truncatedText: truncatedText,
          position: pos,
          rotation: labelLayout.rotation,
          silent: isLabelSilent(axisModel),
          z2: 1,
          tooltip: tooltipOpt && tooltipOpt.show ? extend$8({
            content: name,
            formatter: function () {
              return name;
            },
            formatterParams: formatterParams
          }, tooltipOpt) : null
        });
        graphic.setTextStyle(textEl.style, textStyleModel, {
          text: truncatedText,
          textFont: textFont,
          textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),
          textAlign: textStyleModel.get('align') || labelLayout.textAlign,
          textVerticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign
        });

        if (axisModel.get('triggerEvent')) {
          textEl.eventData = makeAxisEventDataBase(axisModel);
          textEl.eventData.targetType = 'axisName';
          textEl.eventData.name = name;
        } // FIXME


        this._dumbGroup.add(textEl);

        textEl.updateTransform();
        this.group.add(textEl);
        textEl.decomposeTransform();
      }
    };

    var makeAxisEventDataBase = AxisBuilder.makeAxisEventDataBase = function (axisModel) {
      var eventData = {
        componentType: axisModel.mainType,
        componentIndex: axisModel.componentIndex
      };
      eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
      return eventData;
    };
    /**
     * @public
     * @static
     * @param {Object} opt
     * @param {number} axisRotation in radian
     * @param {number} textRotation in radian
     * @param {number} direction
     * @return {Object} {
     *  rotation, // according to axis
     *  textAlign,
     *  textVerticalAlign
     * }
     */


    var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
      var rotationDiff = remRadian$1(textRotation - axisRotation);
      var textAlign;
      var textVerticalAlign;

      if (isRadianAroundZero$1(rotationDiff)) {
        // Label is parallel with axis line.
        textVerticalAlign = direction > 0 ? 'top' : 'bottom';
        textAlign = 'center';
      } else if (isRadianAroundZero$1(rotationDiff - PI$2)) {
        // Label is inverse parallel with axis line.
        textVerticalAlign = direction > 0 ? 'bottom' : 'top';
        textAlign = 'center';
      } else {
        textVerticalAlign = 'middle';

        if (rotationDiff > 0 && rotationDiff < PI$2) {
          textAlign = direction > 0 ? 'right' : 'left';
        } else {
          textAlign = direction > 0 ? 'left' : 'right';
        }
      }

      return {
        rotation: rotationDiff,
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
      };
    };

    function endTextLayout(opt, textPosition, textRotate, extent) {
      var rotationDiff = remRadian$1(textRotate - opt.rotation);
      var textAlign;
      var textVerticalAlign;
      var inverse = extent[0] > extent[1];
      var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;

      if (isRadianAroundZero$1(rotationDiff - PI$2 / 2)) {
        textVerticalAlign = onLeft ? 'bottom' : 'top';
        textAlign = 'center';
      } else if (isRadianAroundZero$1(rotationDiff - PI$2 * 1.5)) {
        textVerticalAlign = onLeft ? 'top' : 'bottom';
        textAlign = 'center';
      } else {
        textVerticalAlign = 'middle';

        if (rotationDiff < PI$2 * 1.5 && rotationDiff > PI$2 / 2) {
          textAlign = onLeft ? 'left' : 'right';
        } else {
          textAlign = onLeft ? 'right' : 'left';
        }
      }

      return {
        rotation: rotationDiff,
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
      };
    }

    var isLabelSilent = AxisBuilder.isLabelSilent = function (axisModel) {
      var tooltipOpt = axisModel.get('tooltip');
      return axisModel.get('silent') // Consider mouse cursor, add these restrictions.
      || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);
    };

    function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
      if (shouldShowAllLabels$2(axisModel.axis)) {
        return;
      } // If min or max are user set, we need to check
      // If the tick on min(max) are overlap on their neighbour tick
      // If they are overlapped, we need to hide the min(max) tick label


      var showMinLabel = axisModel.get('axisLabel.showMinLabel');
      var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME
      // Have not consider onBand yet, where tick els is more than label els.

      labelEls = labelEls || [];
      tickEls = tickEls || [];
      var firstLabel = labelEls[0];
      var nextLabel = labelEls[1];
      var lastLabel = labelEls[labelEls.length - 1];
      var prevLabel = labelEls[labelEls.length - 2];
      var firstTick = tickEls[0];
      var nextTick = tickEls[1];
      var lastTick = tickEls[tickEls.length - 1];
      var prevTick = tickEls[tickEls.length - 2];

      if (showMinLabel === false) {
        ignoreEl(firstLabel);
        ignoreEl(firstTick);
      } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
        if (showMinLabel) {
          ignoreEl(nextLabel);
          ignoreEl(nextTick);
        } else {
          ignoreEl(firstLabel);
          ignoreEl(firstTick);
        }
      }

      if (showMaxLabel === false) {
        ignoreEl(lastLabel);
        ignoreEl(lastTick);
      } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
        if (showMaxLabel) {
          ignoreEl(prevLabel);
          ignoreEl(prevTick);
        } else {
          ignoreEl(lastLabel);
          ignoreEl(lastTick);
        }
      }
    }

    function ignoreEl(el) {
      el && (el.ignore = true);
    }

    function isTwoLabelOverlapped(current, next, labelLayout) {
      // current and next has the same rotation.
      var firstRect = current && current.getBoundingRect().clone();
      var nextRect = next && next.getBoundingRect().clone();

      if (!firstRect || !nextRect) {
        return;
      } // When checking intersect of two rotated labels, we use mRotationBack
      // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.


      var mRotationBack = matrix.identity([]);
      matrix.rotate(mRotationBack, mRotationBack, -current.rotation);
      firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));
      nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));
      return firstRect.intersect(nextRect);
    }

    function isNameLocationCenter(nameLocation) {
      return nameLocation === 'middle' || nameLocation === 'center';
    }

    function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, aniid) {
      var tickEls = [];
      var pt1 = [];
      var pt2 = [];

      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = ticksCoords[i].coord;
        pt1[0] = tickCoord;
        pt1[1] = 0;
        pt2[0] = tickCoord;
        pt2[1] = tickEndCoord;

        if (tickTransform) {
          v2ApplyTransform$2(pt1, pt1, tickTransform);
          v2ApplyTransform$2(pt2, pt2, tickTransform);
        } // Tick line, Not use group transform to have better line draw


        var tickEl = new graphic.Line({
          // Id for animation
          anid: aniid + '_' + ticksCoords[i].tickValue,
          subPixelOptimize: true,
          shape: {
            x1: pt1[0],
            y1: pt1[1],
            x2: pt2[0],
            y2: pt2[1]
          },
          style: tickLineStyle,
          z2: 2,
          silent: true
        });
        tickEls.push(tickEl);
      }

      return tickEls;
    }

    function buildAxisMajorTicks(axisBuilder, axisModel, opt) {
      var axis = axisModel.axis;
      var tickModel = axisModel.getModel('axisTick');

      if (!tickModel.get('show') || axis.scale.isBlank()) {
        return;
      }

      var lineStyleModel = tickModel.getModel('lineStyle');
      var tickEndCoord = opt.tickDirection * tickModel.get('length');
      var ticksCoords = axis.getTicksCoords();
      var ticksEls = createTicks(ticksCoords, axisBuilder._transform, tickEndCoord, defaults$4(lineStyleModel.getLineStyle(), {
        stroke: axisModel.get('axisLine.lineStyle.color')
      }), 'ticks');

      for (var i = 0; i < ticksEls.length; i++) {
        axisBuilder.group.add(ticksEls[i]);
      }

      return ticksEls;
    }

    function buildAxisMinorTicks(axisBuilder, axisModel, opt) {
      var axis = axisModel.axis;
      var minorTickModel = axisModel.getModel('minorTick');

      if (!minorTickModel.get('show') || axis.scale.isBlank()) {
        return;
      }

      var minorTicksCoords = axis.getMinorTicksCoords();

      if (!minorTicksCoords.length) {
        return;
      }

      var lineStyleModel = minorTickModel.getModel('lineStyle');
      var tickEndCoord = opt.tickDirection * minorTickModel.get('length');
      var minorTickLineStyle = defaults$4(lineStyleModel.getLineStyle(), defaults$4(axisModel.getModel('axisTick').getLineStyle(), {
        stroke: axisModel.get('axisLine.lineStyle.color')
      }));

      for (var i = 0; i < minorTicksCoords.length; i++) {
        var minorTicksEls = createTicks(minorTicksCoords[i], axisBuilder._transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);

        for (var k = 0; k < minorTicksEls.length; k++) {
          axisBuilder.group.add(minorTicksEls[k]);
        }
      }
    }

    function buildAxisLabel(axisBuilder, axisModel, opt) {
      var axis = axisModel.axis;
      var show = retrieve$1(opt.axisLabelShow, axisModel.get('axisLabel.show'));

      if (!show || axis.scale.isBlank()) {
        return;
      }

      var labelModel = axisModel.getModel('axisLabel');
      var labelMargin = labelModel.get('margin');
      var labels = axis.getViewLabels(); // Special label rotate.

      var labelRotation = (retrieve$1(opt.labelRotate, labelModel.get('rotate')) || 0) * PI$2 / 180;
      var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
      var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
      var labelEls = [];
      var silent = isLabelSilent(axisModel);
      var triggerEvent = axisModel.get('triggerEvent');
      each$l(labels, function (labelItem, index) {
        var tickValue = labelItem.tickValue;
        var formattedLabel = labelItem.formattedLabel;
        var rawLabel = labelItem.rawLabel;
        var itemLabelModel = labelModel;

        if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
          itemLabelModel = new Model_1(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);
        }

        var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');
        var tickCoord = axis.dataToCoord(tickValue);
        var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
        var textEl = new graphic.Text({
          // Id for animation
          anid: 'label_' + tickValue,
          position: pos,
          rotation: labelLayout.rotation,
          silent: silent,
          z2: 10
        });
        graphic.setTextStyle(textEl.style, itemLabelModel, {
          text: formattedLabel,
          textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
          textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
          textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original
          // index of axis.data. So tick should not be exposed to user
          // in category axis.
          // (2) Compatible with previous version, which always use formatted label as
          // input. But in interval scale the formatted label is like '223,445', which
          // maked user repalce ','. So we modify it to return original val but remain
          // it as 'string' to avoid error in replacing.
          axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor
        }); // Pack data for mouse event

        if (triggerEvent) {
          textEl.eventData = makeAxisEventDataBase(axisModel);
          textEl.eventData.targetType = 'axisLabel';
          textEl.eventData.value = rawLabel;
        } // FIXME


        axisBuilder._dumbGroup.add(textEl);

        textEl.updateTransform();
        labelEls.push(textEl);
        axisBuilder.group.add(textEl);
        textEl.decomposeTransform();
      });
      return labelEls;
    }

    var _default$1H = AxisBuilder;
    var AxisBuilder_1 = _default$1H;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var each$m = util.each;
    var curry$1 = util.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
    // allAxesInfo should be updated when setOption performed.

    function collect(ecModel, api) {
      var result = {
        /**
         * key: makeKey(axis.model)
         * value: {
         *      axis,
         *      coordSys,
         *      axisPointerModel,
         *      triggerTooltip,
         *      involveSeries,
         *      snap,
         *      seriesModels,
         *      seriesDataCount
         * }
         */
        axesInfo: {},
        seriesInvolved: false,

        /**
         * key: makeKey(coordSys.model)
         * value: Object: key makeKey(axis.model), value: axisInfo
         */
        coordSysAxesInfo: {},
        coordSysMap: {}
      };
      collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.

      result.seriesInvolved && collectSeriesInfo(result, ecModel);
      return result;
    }

    function collectAxesInfo(result, ecModel, api) {
      var globalTooltipModel = ecModel.getComponent('tooltip');
      var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.

      var linksOption = globalAxisPointerModel.get('link', true) || [];
      var linkGroups = []; // Collect axes info.

      each$m(api.getCoordinateSystems(), function (coordSys) {
        // Some coordinate system do not support axes, like geo.
        if (!coordSys.axisPointerEnabled) {
          return;
        }

        var coordSysKey = makeKey(coordSys.model);
        var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
        result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer
        // for user. So we enable seting tooltip on coordSys model.

        var coordSysModel = coordSys.model;
        var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);
        each$m(coordSys.getAxes(), curry$1(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.
        // Notice this case: coordSys is `grid` but not `cartesian2D` here.

        if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not
        // show but axisPointer will show as normal.
        && baseTooltipModel.get('show')) {
          // Compatible with previous logic. But series.tooltip.trigger: 'axis'
          // or series.data[n].tooltip.trigger: 'axis' are not support any more.
          var triggerAxis = baseTooltipModel.get('trigger') === 'axis';
          var cross = baseTooltipModel.get('axisPointer.type') === 'cross';
          var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));

          if (triggerAxis || cross) {
            each$m(tooltipAxes.baseAxes, curry$1(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));
          }

          if (cross) {
            each$m(tooltipAxes.otherAxes, curry$1(saveTooltipAxisInfo, 'cross', false));
          }
        } // fromTooltip: true | false | 'cross'
        // triggerTooltip: true | false | null


        function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
          var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);
          var axisPointerShow = axisPointerModel.get('show');

          if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
            return;
          }

          if (triggerTooltip == null) {
            triggerTooltip = axisPointerModel.get('triggerTooltip');
          }

          axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
          var snap = axisPointerModel.get('snap');
          var key = makeKey(axis.model);
          var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).

          var axisInfo = result.axesInfo[key] = {
            key: key,
            axis: axis,
            coordSys: coordSys,
            axisPointerModel: axisPointerModel,
            triggerTooltip: triggerTooltip,
            involveSeries: involveSeries,
            snap: snap,
            useHandle: isHandleTrigger(axisPointerModel),
            seriesModels: []
          };
          axesInfoInCoordSys[key] = axisInfo;
          result.seriesInvolved |= involveSeries;
          var groupIndex = getLinkGroupIndex(linksOption, axis);

          if (groupIndex != null) {
            var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
              axesInfo: {}
            });
            linkGroup.axesInfo[key] = axisInfo;
            linkGroup.mapper = linksOption[groupIndex].mapper;
            axisInfo.linkGroup = linkGroup;
          }
        }
      });
    }

    function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
      var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');
      var volatileOption = {};
      each$m(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {
        volatileOption[field] = util.clone(tooltipAxisPointerModel.get(field));
      }); // category axis do not auto snap, otherwise some tick that do not
      // has value can not be hovered. value/time/log axis default snap if
      // triggered from tooltip and trigger tooltip.

      volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.
      // Only these properties can be overrided from tooltip to axisPointer.

      if (tooltipAxisPointerModel.get('type') === 'cross') {
        volatileOption.type = 'line';
      }

      var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.

      labelOption.show == null && (labelOption.show = false);

      if (fromTooltip === 'cross') {
        // When 'cross', both axes show labels.
        var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get('label.show');
        labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true; // If triggerTooltip, this is a base axis, which should better not use cross style
        // (cross style is dashed by default)

        if (!triggerTooltip) {
          var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');
          crossStyle && util.defaults(labelOption, crossStyle.textStyle);
        }
      }

      return axis.model.getModel('axisPointer', new Model_1(volatileOption, globalAxisPointerModel, ecModel));
    }

    function collectSeriesInfo(result, ecModel) {
      // Prepare data for axis trigger
      ecModel.eachSeries(function (seriesModel) {
        // Notice this case: this coordSys is `cartesian2D` but not `grid`.
        var coordSys = seriesModel.coordinateSystem;
        var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);
        var seriesTooltipShow = seriesModel.get('tooltip.show', true);

        if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {
          return;
        }

        each$m(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
          var axis = axisInfo.axis;

          if (coordSys.getAxis(axis.dim) === axis) {
            axisInfo.seriesModels.push(seriesModel);
            axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
            axisInfo.seriesDataCount += seriesModel.getData().count();
          }
        });
      }, this);
    }
    /**
     * For example:
     * {
     *     axisPointer: {
     *         links: [{
     *             xAxisIndex: [2, 4],
     *             yAxisIndex: 'all'
     *         }, {
     *             xAxisId: ['a5', 'a7'],
     *             xAxisName: 'xxx'
     *         }]
     *     }
     * }
     */


    function getLinkGroupIndex(linksOption, axis) {
      var axisModel = axis.model;
      var dim = axis.dim;

      for (var i = 0; i < linksOption.length; i++) {
        var linkOption = linksOption[i] || {};

        if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
          return i;
        }
      }
    }

    function checkPropInLink(linkPropValue, axisPropValue) {
      return linkPropValue === 'all' || util.isArray(linkPropValue) && util.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
    }

    function fixValue(axisModel) {
      var axisInfo = getAxisInfo(axisModel);

      if (!axisInfo) {
        return;
      }

      var axisPointerModel = axisInfo.axisPointerModel;
      var scale = axisInfo.axis.scale;
      var option = axisPointerModel.option;
      var status = axisPointerModel.get('status');
      var value = axisPointerModel.get('value'); // Parse init value for category and time axis.

      if (value != null) {
        value = scale.parse(value);
      }

      var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value
      // and status should be initialized.

      if (status == null) {
        option.status = useHandle ? 'show' : 'hide';
      }

      var extent = scale.getExtent().slice();
      extent[0] > extent[1] && extent.reverse();

      if ( // Pick a value on axis when initializing.
      value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,
      // where we should re-pick a value to keep `handle` displaying normally.
      || value > extent[1]) {
        // Make handle displayed on the end of the axis when init, which looks better.
        value = extent[1];
      }

      if (value < extent[0]) {
        value = extent[0];
      }

      option.value = value;

      if (useHandle) {
        option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';
      }
    }

    function getAxisInfo(axisModel) {
      var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;
      return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
    }

    function getAxisPointerModel(axisModel) {
      var axisInfo = getAxisInfo(axisModel);
      return axisInfo && axisInfo.axisPointerModel;
    }

    function isHandleTrigger(axisPointerModel) {
      return !!axisPointerModel.get('handle.show');
    }
    /**
     * @param {module:echarts/model/Model} model
     * @return {string} unique key
     */


    function makeKey(model) {
      return model.type + '||' + model.id;
    }

    var collect_1 = collect;
    var fixValue_1 = fixValue;
    var getAxisInfo_1 = getAxisInfo;
    var getAxisPointerModel_1 = getAxisPointerModel;
    var makeKey_1 = makeKey;

    var modelHelper = {
    	collect: collect_1,
    	fixValue: fixValue_1,
    	getAxisInfo: getAxisInfo_1,
    	getAxisPointerModel: getAxisPointerModel_1,
    	makeKey: makeKey_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Base class of AxisView.
     */
    var AxisView = echarts.extendComponentView({
      type: 'axis',

      /**
       * @private
       */
      _axisPointer: null,

      /**
       * @protected
       * @type {string}
       */
      axisPointerClass: null,

      /**
       * @override
       */
      render: function (axisModel, ecModel, api, payload) {
        // FIXME
        // This process should proformed after coordinate systems updated
        // (axis scale updated), and should be performed each time update.
        // So put it here temporarily, although it is not appropriate to
        // put a model-writing procedure in `view`.
        this.axisPointerClass && modelHelper.fixValue(axisModel);
        AxisView.superApply(this, 'render', arguments);
        updateAxisPointer(this, axisModel, ecModel, api, payload, true);
      },

      /**
       * Action handler.
       * @public
       * @param {module:echarts/coord/cartesian/AxisModel} axisModel
       * @param {module:echarts/model/Global} ecModel
       * @param {module:echarts/ExtensionAPI} api
       * @param {Object} payload
       */
      updateAxisPointer: function (axisModel, ecModel, api, payload, force) {
        updateAxisPointer(this, axisModel, ecModel, api, payload, false);
      },

      /**
       * @override
       */
      remove: function (ecModel, api) {
        var axisPointer = this._axisPointer;
        axisPointer && axisPointer.remove(api);
        AxisView.superApply(this, 'remove', arguments);
      },

      /**
       * @override
       */
      dispose: function (ecModel, api) {
        disposeAxisPointer(this, api);
        AxisView.superApply(this, 'dispose', arguments);
      }
    });

    function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
      var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);

      if (!Clazz) {
        return;
      }

      var axisPointerModel = modelHelper.getAxisPointerModel(axisModel);
      axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
    }

    function disposeAxisPointer(axisView, ecModel, api) {
      var axisPointer = axisView._axisPointer;
      axisPointer && axisPointer.dispose(ecModel, api);
      axisView._axisPointer = null;
    }

    var axisPointerClazz = [];

    AxisView.registerAxisPointerClass = function (type, clazz) {
      axisPointerClazz[type] = clazz;
    };

    AxisView.getAxisPointerClass = function (type) {
      return type && axisPointerClazz[type];
    };

    var _default$1I = AxisView;
    var AxisView_1 = _default$1I;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Can only be called after coordinate system creation stage.
     * (Can be called before coordinate system update stage).
     *
     * @param {Object} opt {labelInside}
     * @return {Object} {
     *  position, rotation, labelDirection, labelOffset,
     *  tickDirection, labelRotate, z2
     * }
     */
    function layout$2(gridModel, axisModel, opt) {
      opt = opt || {};
      var grid = gridModel.coordinateSystem;
      var axis = axisModel.axis;
      var layout = {};
      var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
      var rawAxisPosition = axis.position;
      var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;
      var axisDim = axis.dim;
      var rect = grid.getRect();
      var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
      var idx = {
        left: 0,
        right: 1,
        top: 0,
        bottom: 1,
        onZero: 2
      };
      var axisOffset = axisModel.get('offset') || 0;
      var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];

      if (otherAxisOnZeroOf) {
        var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
        posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
      } // Axis position


      layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation

      layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim

      var dirMap = {
        top: -1,
        bottom: 1,
        left: -1,
        right: 1
      };
      layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
      layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;

      if (axisModel.get('axisTick.inside')) {
        layout.tickDirection = -layout.tickDirection;
      }

      if (util.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {
        layout.labelDirection = -layout.labelDirection;
      } // Special label rotation


      var labelRotate = axisModel.get('axisLabel.rotate');
      layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // Over splitLine and splitArea

      layout.z2 = 1;
      return layout;
    }

    var layout_1$1 = layout$2;

    var cartesianAxisHelper = {
    	layout: layout_1$1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
      var axis = axisModel.axis;

      if (axis.scale.isBlank()) {
        return;
      }

      var splitAreaModel = axisModel.getModel('splitArea');
      var areaStyleModel = splitAreaModel.getModel('areaStyle');
      var areaColors = areaStyleModel.get('color');
      var gridRect = gridModel.coordinateSystem.getRect();
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitAreaModel,
        clamp: true
      });

      if (!ticksCoords.length) {
        return;
      } // For Making appropriate splitArea animation, the color and anid
      // should be corresponding to previous one if possible.


      var areaColorsLen = areaColors.length;
      var lastSplitAreaColors = axisView.__splitAreaColors;
      var newSplitAreaColors = util.createHashMap();
      var colorIndex = 0;

      if (lastSplitAreaColors) {
        for (var i = 0; i < ticksCoords.length; i++) {
          var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);

          if (cIndex != null) {
            colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
            break;
          }
        }
      }

      var prev = axis.toGlobalCoord(ticksCoords[0].coord);
      var areaStyle = areaStyleModel.getAreaStyle();
      areaColors = util.isArray(areaColors) ? areaColors : [areaColors];

      for (var i = 1; i < ticksCoords.length; i++) {
        var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
        var x;
        var y;
        var width;
        var height;

        if (axis.isHorizontal()) {
          x = prev;
          y = gridRect.y;
          width = tickCoord - x;
          height = gridRect.height;
          prev = x + width;
        } else {
          x = gridRect.x;
          y = prev;
          width = gridRect.width;
          height = tickCoord - y;
          prev = y + height;
        }

        var tickValue = ticksCoords[i - 1].tickValue;
        tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
        axisGroup.add(new graphic.Rect({
          anid: tickValue != null ? 'area_' + tickValue : null,
          shape: {
            x: x,
            y: y,
            width: width,
            height: height
          },
          style: util.defaults({
            fill: areaColors[colorIndex]
          }, areaStyle),
          silent: true
        }));
        colorIndex = (colorIndex + 1) % areaColorsLen;
      }

      axisView.__splitAreaColors = newSplitAreaColors;
    }

    function rectCoordAxisHandleRemove(axisView) {
      axisView.__splitAreaColors = null;
    }

    var rectCoordAxisBuildSplitArea_1 = rectCoordAxisBuildSplitArea;
    var rectCoordAxisHandleRemove_1 = rectCoordAxisHandleRemove;

    var axisSplitHelper = {
    	rectCoordAxisBuildSplitArea: rectCoordAxisBuildSplitArea_1,
    	rectCoordAxisHandleRemove: rectCoordAxisHandleRemove_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */













    var rectCoordAxisBuildSplitArea$1 = axisSplitHelper.rectCoordAxisBuildSplitArea;
    var rectCoordAxisHandleRemove$1 = axisSplitHelper.rectCoordAxisHandleRemove;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
    var selfBuilderAttrs = ['splitArea', 'splitLine', 'minorSplitLine'];
    var CartesianAxisView = AxisView_1.extend({
      type: 'cartesianAxis',
      axisPointerClass: 'CartesianAxisPointer',

      /**
       * @override
       */
      render: function (axisModel, ecModel, api, payload) {
        this.group.removeAll();
        var oldAxisGroup = this._axisGroup;
        this._axisGroup = new graphic.Group();
        this.group.add(this._axisGroup);

        if (!axisModel.get('show')) {
          return;
        }

        var gridModel = axisModel.getCoordSysModel();
        var layout = cartesianAxisHelper.layout(gridModel, axisModel);
        var axisBuilder = new AxisBuilder_1(axisModel, layout);
        util.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);

        this._axisGroup.add(axisBuilder.getGroup());

        util.each(selfBuilderAttrs, function (name) {
          if (axisModel.get(name + '.show')) {
            this['_' + name](axisModel, gridModel);
          }
        }, this);
        graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
        CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);
      },
      remove: function () {
        rectCoordAxisHandleRemove$1(this);
      },

      /**
       * @param {module:echarts/coord/cartesian/AxisModel} axisModel
       * @param {module:echarts/coord/cartesian/GridModel} gridModel
       * @private
       */
      _splitLine: function (axisModel, gridModel) {
        var axis = axisModel.axis;

        if (axis.scale.isBlank()) {
          return;
        }

        var splitLineModel = axisModel.getModel('splitLine');
        var lineStyleModel = splitLineModel.getModel('lineStyle');
        var lineColors = lineStyleModel.get('color');
        lineColors = util.isArray(lineColors) ? lineColors : [lineColors];
        var gridRect = gridModel.coordinateSystem.getRect();
        var isHorizontal = axis.isHorizontal();
        var lineCount = 0;
        var ticksCoords = axis.getTicksCoords({
          tickModel: splitLineModel
        });
        var p1 = [];
        var p2 = [];
        var lineStyle = lineStyleModel.getLineStyle();

        for (var i = 0; i < ticksCoords.length; i++) {
          var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);

          if (isHorizontal) {
            p1[0] = tickCoord;
            p1[1] = gridRect.y;
            p2[0] = tickCoord;
            p2[1] = gridRect.y + gridRect.height;
          } else {
            p1[0] = gridRect.x;
            p1[1] = tickCoord;
            p2[0] = gridRect.x + gridRect.width;
            p2[1] = tickCoord;
          }

          var colorIndex = lineCount++ % lineColors.length;
          var tickValue = ticksCoords[i].tickValue;

          this._axisGroup.add(new graphic.Line({
            anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,
            subPixelOptimize: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: util.defaults({
              stroke: lineColors[colorIndex]
            }, lineStyle),
            silent: true
          }));
        }
      },

      /**
       * @param {module:echarts/coord/cartesian/AxisModel} axisModel
       * @param {module:echarts/coord/cartesian/GridModel} gridModel
       * @private
       */
      _minorSplitLine: function (axisModel, gridModel) {
        var axis = axisModel.axis;
        var minorSplitLineModel = axisModel.getModel('minorSplitLine');
        var lineStyleModel = minorSplitLineModel.getModel('lineStyle');
        var gridRect = gridModel.coordinateSystem.getRect();
        var isHorizontal = axis.isHorizontal();
        var minorTicksCoords = axis.getMinorTicksCoords();

        if (!minorTicksCoords.length) {
          return;
        }

        var p1 = [];
        var p2 = [];
        var lineStyle = lineStyleModel.getLineStyle();

        for (var i = 0; i < minorTicksCoords.length; i++) {
          for (var k = 0; k < minorTicksCoords[i].length; k++) {
            var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);

            if (isHorizontal) {
              p1[0] = tickCoord;
              p1[1] = gridRect.y;
              p2[0] = tickCoord;
              p2[1] = gridRect.y + gridRect.height;
            } else {
              p1[0] = gridRect.x;
              p1[1] = tickCoord;
              p2[0] = gridRect.x + gridRect.width;
              p2[1] = tickCoord;
            }

            this._axisGroup.add(new graphic.Line({
              anid: 'minor_line_' + minorTicksCoords[i][k].tickValue,
              subPixelOptimize: true,
              shape: {
                x1: p1[0],
                y1: p1[1],
                x2: p2[0],
                y2: p2[1]
              },
              style: lineStyle,
              silent: true
            }));
          }
        }
      },

      /**
       * @param {module:echarts/coord/cartesian/AxisModel} axisModel
       * @param {module:echarts/coord/cartesian/GridModel} gridModel
       * @private
       */
      _splitArea: function (axisModel, gridModel) {
        rectCoordAxisBuildSplitArea$1(this, this._axisGroup, axisModel, gridModel);
      }
    });
    CartesianAxisView.extend({
      type: 'xAxis'
    });
    CartesianAxisView.extend({
      type: 'yAxis'
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */











    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // Grid view
    echarts.extendComponentView({
      type: 'grid',
      render: function (gridModel, ecModel) {
        this.group.removeAll();

        if (gridModel.get('show')) {
          this.group.add(new graphic.Rect({
            shape: gridModel.coordinateSystem.getRect(),
            style: util.defaults({
              fill: gridModel.get('backgroundColor')
            }, gridModel.getItemStyle()),
            silent: true,
            z2: -1
          }));
        }
      }
    });
    echarts.registerPreprocessor(function (option) {
      // Only create grid when need
      if (option.xAxis && option.yAxis && !option.grid) {
        option.grid = {};
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var layout$3 = barGrid.layout;
    var largeLayout$1 = barGrid.largeLayout;









    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // In case developer forget to include grid component
    echarts.registerLayout(echarts.PRIORITY.VISUAL.LAYOUT, util.curry(layout$3, 'bar')); // Use higher prority to avoid to be blocked by other overall layout, which do not
    // only exist in this module, but probably also exist in other modules, like `barPolar`.

    echarts.registerLayout(echarts.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, largeLayout$1);
    echarts.registerVisual({
      seriesType: 'bar',
      reset: function (seriesModel) {
        // Visual coding for legend
        seriesModel.getData().setVisual('legendSymbol', 'roundRect');
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var _default$1J = Series.extend({
      type: 'series.line',
      dependencies: ['grid', 'polar'],
      getInitialData: function (option, ecModel) {
        return createListFromArray_1(this.getSource(), this, {
          useEncodeDefaulter: true
        });
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: 'cartesian2d',
        legendHoverLink: true,
        hoverAnimation: true,
        // stack: null
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // polarIndex: 0,
        // If clip the overflow value
        clip: true,
        // cursor: null,
        label: {
          position: 'top'
        },
        // itemStyle: {
        // },
        lineStyle: {
          width: 2,
          type: 'solid'
        },
        // areaStyle: {
        // origin of areaStyle. Valid values:
        // `'auto'/null/undefined`: from axisLine to data
        // `'start'`: from min to data
        // `'end'`: from data to max
        // origin: 'auto'
        // },
        // false, 'start', 'end', 'middle'
        step: false,
        // Disabled if step is true
        smooth: false,
        smoothMonotone: null,
        symbol: 'emptyCircle',
        symbolSize: 4,
        symbolRotate: null,
        showSymbol: true,
        // `false`: follow the label interval strategy.
        // `true`: show all symbols.
        // `'auto'`: If possible, show all symbols, otherwise
        //           follow the label interval strategy.
        showAllSymbol: 'auto',
        // Whether to connect break point.
        connectNulls: false,
        // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.
        sampling: 'none',
        animationEasing: 'linear',
        // Disable progressive
        progressive: 0,
        hoverLayerThreshold: Infinity
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    var createSymbol$3 = symbol.createSymbol;





    var parsePercent$4 = number.parsePercent;



    var getDefaultLabel$2 = labelHelper.getDefaultLabel;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @module echarts/chart/helper/Symbol
     */

    /**
     * @constructor
     * @alias {module:echarts/chart/helper/Symbol}
     * @param {module:echarts/data/List} data
     * @param {number} idx
     * @extends {module:zrender/graphic/Group}
     */
    function SymbolClz$1(data, idx, seriesScope) {
      graphic.Group.call(this);
      this.updateData(data, idx, seriesScope);
    }

    var symbolProto = SymbolClz$1.prototype;
    /**
     * @public
     * @static
     * @param {module:echarts/data/List} data
     * @param {number} dataIndex
     * @return {Array.<number>} [width, height]
     */

    var getSymbolSize = SymbolClz$1.getSymbolSize = function (data, idx) {
      var symbolSize = data.getItemVisual(idx, 'symbolSize');
      return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
    };

    function getScale(symbolSize) {
      return [symbolSize[0] / 2, symbolSize[1] / 2];
    }

    function driftSymbol(dx, dy) {
      this.parent.drift(dx, dy);
    }

    symbolProto._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {
      // Remove paths created before
      this.removeAll();
      var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(
      //     symbolType, -0.5, -0.5, 1, 1, color
      // );
      // If width/height are set too small (e.g., set to 1) on ios10
      // and macOS Sierra, a circle stroke become a rect, no matter what
      // the scale is set. So we set width/height as 2. See #4150.

      var symbolPath = createSymbol$3(symbolType, -1, -1, 2, 2, color, keepAspect);
      symbolPath.attr({
        z2: 100,
        culling: true,
        scale: getScale(symbolSize)
      }); // Rewrite drift method

      symbolPath.drift = driftSymbol;
      this._symbolType = symbolType;
      this.add(symbolPath);
    };
    /**
     * Stop animation
     * @param {boolean} toLastFrame
     */


    symbolProto.stopSymbolAnimation = function (toLastFrame) {
      this.childAt(0).stopAnimation(toLastFrame);
    };
    /**
     * FIXME:
     * Caution: This method breaks the encapsulation of this module,
     * but it indeed brings convenience. So do not use the method
     * unless you detailedly know all the implements of `Symbol`,
     * especially animation.
     *
     * Get symbol path element.
     */


    symbolProto.getSymbolPath = function () {
      return this.childAt(0);
    };
    /**
     * Get scale(aka, current symbol size).
     * Including the change caused by animation
     */


    symbolProto.getScale = function () {
      return this.childAt(0).scale;
    };
    /**
     * Highlight symbol
     */


    symbolProto.highlight = function () {
      this.childAt(0).trigger('emphasis');
    };
    /**
     * Downplay symbol
     */


    symbolProto.downplay = function () {
      this.childAt(0).trigger('normal');
    };
    /**
     * @param {number} zlevel
     * @param {number} z
     */


    symbolProto.setZ = function (zlevel, z) {
      var symbolPath = this.childAt(0);
      symbolPath.zlevel = zlevel;
      symbolPath.z = z;
    };

    symbolProto.setDraggable = function (draggable) {
      var symbolPath = this.childAt(0);
      symbolPath.draggable = draggable;
      symbolPath.cursor = draggable ? 'move' : symbolPath.cursor;
    };
    /**
     * Update symbol properties
     * @param {module:echarts/data/List} data
     * @param {number} idx
     * @param {Object} [seriesScope]
     * @param {Object} [seriesScope.itemStyle]
     * @param {Object} [seriesScope.hoverItemStyle]
     * @param {Object} [seriesScope.symbolRotate]
     * @param {Object} [seriesScope.symbolOffset]
     * @param {module:echarts/model/Model} [seriesScope.labelModel]
     * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]
     * @param {boolean} [seriesScope.hoverAnimation]
     * @param {Object} [seriesScope.cursorStyle]
     * @param {module:echarts/model/Model} [seriesScope.itemModel]
     * @param {string} [seriesScope.symbolInnerColor]
     * @param {Object} [seriesScope.fadeIn=false]
     */


    symbolProto.updateData = function (data, idx, seriesScope) {
      this.silent = false;
      var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
      var seriesModel = data.hostModel;
      var symbolSize = getSymbolSize(data, idx);
      var isInit = symbolType !== this._symbolType;

      if (isInit) {
        var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');

        this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
      } else {
        var symbolPath = this.childAt(0);
        symbolPath.silent = false;
        graphic.updateProps(symbolPath, {
          scale: getScale(symbolSize)
        }, seriesModel, idx);
      }

      this._updateCommon(data, idx, symbolSize, seriesScope);

      if (isInit) {
        var symbolPath = this.childAt(0);
        var fadeIn = seriesScope && seriesScope.fadeIn;
        var target = {
          scale: symbolPath.scale.slice()
        };
        fadeIn && (target.style = {
          opacity: symbolPath.style.opacity
        });
        symbolPath.scale = [0, 0];
        fadeIn && (symbolPath.style.opacity = 0);
        graphic.initProps(symbolPath, target, seriesModel, idx);
      }

      this._seriesModel = seriesModel;
    }; // Update common properties


    var normalStyleAccessPath = ['itemStyle'];
    var emphasisStyleAccessPath = ['emphasis', 'itemStyle'];
    var normalLabelAccessPath = ['label'];
    var emphasisLabelAccessPath = ['emphasis', 'label'];
    /**
     * @param {module:echarts/data/List} data
     * @param {number} idx
     * @param {Array.<number>} symbolSize
     * @param {Object} [seriesScope]
     */

    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {
      var symbolPath = this.childAt(0);
      var seriesModel = data.hostModel;
      var color = data.getItemVisual(idx, 'color'); // Reset style

      if (symbolPath.type !== 'image') {
        symbolPath.useStyle({
          strokeNoScale: true
        });
      } else {
        symbolPath.setStyle({
          opacity: null,
          shadowBlur: null,
          shadowOffsetX: null,
          shadowOffsetY: null,
          shadowColor: null
        });
      }

      var itemStyle = seriesScope && seriesScope.itemStyle;
      var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
      var symbolOffset = seriesScope && seriesScope.symbolOffset;
      var labelModel = seriesScope && seriesScope.labelModel;
      var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
      var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
      var cursorStyle = seriesScope && seriesScope.cursorStyle;

      if (!seriesScope || data.hasItemOption) {
        var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.
        // Because symbol provide setColor individually to set fill and stroke

        itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);
        hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
        symbolOffset = itemModel.getShallow('symbolOffset');
        labelModel = itemModel.getModel(normalLabelAccessPath);
        hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
        hoverAnimation = itemModel.getShallow('hoverAnimation');
        cursorStyle = itemModel.getShallow('cursor');
      } else {
        hoverItemStyle = util.extend({}, hoverItemStyle);
      }

      var elStyle = symbolPath.style;
      var symbolRotate = data.getItemVisual(idx, 'symbolRotate');
      symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);

      if (symbolOffset) {
        symbolPath.attr('position', [parsePercent$4(symbolOffset[0], symbolSize[0]), parsePercent$4(symbolOffset[1], symbolSize[1])]);
      }

      cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!

      symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);
      symbolPath.setStyle(itemStyle);
      var opacity = data.getItemVisual(idx, 'opacity');

      if (opacity != null) {
        elStyle.opacity = opacity;
      }

      var liftZ = data.getItemVisual(idx, 'liftZ');
      var z2Origin = symbolPath.__z2Origin;

      if (liftZ != null) {
        if (z2Origin == null) {
          symbolPath.__z2Origin = symbolPath.z2;
          symbolPath.z2 += liftZ;
        }
      } else if (z2Origin != null) {
        symbolPath.z2 = z2Origin;
        symbolPath.__z2Origin = null;
      }

      var useNameLabel = seriesScope && seriesScope.useNameLabel;
      graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
        labelFetcher: seriesModel,
        labelDataIndex: idx,
        defaultText: getLabelDefaultText,
        isRectText: true,
        autoColor: color
      }); // Do not execute util needed.

      function getLabelDefaultText(idx, opt) {
        return useNameLabel ? data.getName(idx) : getDefaultLabel$2(data, idx);
      }

      symbolPath.__symbolOriginalScale = getScale(symbolSize);
      symbolPath.hoverStyle = hoverItemStyle;
      symbolPath.highDownOnUpdate = hoverAnimation && seriesModel.isAnimationEnabled() ? highDownOnUpdate : null;
      graphic.setHoverStyle(symbolPath);
    };

    function highDownOnUpdate(fromState, toState) {
      // Do not support this hover animation util some scenario required.
      // Animation can only be supported in hover layer when using `el.incremetal`.
      if (this.incremental || this.useHoverLayer) {
        return;
      }

      if (toState === 'emphasis') {
        var scale = this.__symbolOriginalScale;
        var ratio = scale[1] / scale[0];
        var emphasisOpt = {
          scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]
        }; // FIXME
        // modify it after support stop specified animation.
        // toState === fromState
        //     ? (this.stopAnimation(), this.attr(emphasisOpt))

        this.animateTo(emphasisOpt, 400, 'elasticOut');
      } else if (toState === 'normal') {
        this.animateTo({
          scale: this.__symbolOriginalScale
        }, 400, 'elasticOut');
      }
    }
    /**
     * @param {Function} cb
     * @param {Object} [opt]
     * @param {Object} [opt.keepLabel=true]
     */


    symbolProto.fadeOut = function (cb, opt) {
      var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out

      this.silent = symbolPath.silent = true; // Not show text when animating

      !(opt && opt.keepLabel) && (symbolPath.style.text = null);
      graphic.updateProps(symbolPath, {
        style: {
          opacity: 0
        },
        scale: [0, 0]
      }, this._seriesModel, this.dataIndex, cb);
    };

    util.inherits(SymbolClz$1, graphic.Group);
    var _default$1K = SymbolClz$1;
    var _Symbol = _default$1K;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var isObject$e = util.isObject;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @module echarts/chart/helper/SymbolDraw
     */

    /**
     * @constructor
     * @alias module:echarts/chart/helper/SymbolDraw
     * @param {module:zrender/graphic/Group} [symbolCtor]
     */
    function SymbolDraw(symbolCtor) {
      this.group = new graphic.Group();
      this._symbolCtor = symbolCtor || _Symbol;
    }

    var symbolDrawProto = SymbolDraw.prototype;

    function symbolNeedsDraw(data, point, idx, opt) {
      return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of
      // the symbol element shape. We use the same clip shape here as
      // the line clip.
      && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';
    }
    /**
     * Update symbols draw by new data
     * @param {module:echarts/data/List} data
     * @param {Object} [opt] Or isIgnore
     * @param {Function} [opt.isIgnore]
     * @param {Object} [opt.clipShape]
     */


    symbolDrawProto.updateData = function (data, opt) {
      opt = normalizeUpdateOpt(opt);
      var group = this.group;
      var seriesModel = data.hostModel;
      var oldData = this._data;
      var SymbolCtor = this._symbolCtor;
      var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from
      // stream mode to normal mode, where previous elements should be removed.

      if (!oldData) {
        group.removeAll();
      }

      data.diff(oldData).add(function (newIdx) {
        var point = data.getItemLayout(newIdx);

        if (symbolNeedsDraw(data, point, newIdx, opt)) {
          var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
          symbolEl.attr('position', point);
          data.setItemGraphicEl(newIdx, symbolEl);
          group.add(symbolEl);
        }
      }).update(function (newIdx, oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        var point = data.getItemLayout(newIdx);

        if (!symbolNeedsDraw(data, point, newIdx, opt)) {
          group.remove(symbolEl);
          return;
        }

        if (!symbolEl) {
          symbolEl = new SymbolCtor(data, newIdx);
          symbolEl.attr('position', point);
        } else {
          symbolEl.updateData(data, newIdx, seriesScope);
          graphic.updateProps(symbolEl, {
            position: point
          }, seriesModel);
        } // Add back


        group.add(symbolEl);
        data.setItemGraphicEl(newIdx, symbolEl);
      }).remove(function (oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        el && el.fadeOut(function () {
          group.remove(el);
        });
      }).execute();
      this._data = data;
    };

    symbolDrawProto.isPersistent = function () {
      return true;
    };

    symbolDrawProto.updateLayout = function () {
      var data = this._data;

      if (data) {
        // Not use animation
        data.eachItemGraphicEl(function (el, idx) {
          var point = data.getItemLayout(idx);
          el.attr('position', point);
        });
      }
    };

    symbolDrawProto.incrementalPrepareUpdate = function (data) {
      this._seriesScope = makeSeriesScope(data);
      this._data = null;
      this.group.removeAll();
    };
    /**
     * Update symbols draw by new data
     * @param {module:echarts/data/List} data
     * @param {Object} [opt] Or isIgnore
     * @param {Function} [opt.isIgnore]
     * @param {Object} [opt.clipShape]
     */


    symbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {
      opt = normalizeUpdateOpt(opt);

      function updateIncrementalAndHover(el) {
        if (!el.isGroup) {
          el.incremental = el.useHoverLayer = true;
        }
      }

      for (var idx = taskParams.start; idx < taskParams.end; idx++) {
        var point = data.getItemLayout(idx);

        if (symbolNeedsDraw(data, point, idx, opt)) {
          var el = new this._symbolCtor(data, idx, this._seriesScope);
          el.traverse(updateIncrementalAndHover);
          el.attr('position', point);
          this.group.add(el);
          data.setItemGraphicEl(idx, el);
        }
      }
    };

    function normalizeUpdateOpt(opt) {
      if (opt != null && !isObject$e(opt)) {
        opt = {
          isIgnore: opt
        };
      }

      return opt || {};
    }

    symbolDrawProto.remove = function (enableAnimation) {
      var group = this.group;
      var data = this._data; // Incremental model do not have this._data.

      if (data && enableAnimation) {
        data.eachItemGraphicEl(function (el) {
          el.fadeOut(function () {
            group.remove(el);
          });
        });
      } else {
        group.removeAll();
      }
    };

    function makeSeriesScope(data) {
      var seriesModel = data.hostModel;
      return {
        itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),
        hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),
        symbolRotate: seriesModel.get('symbolRotate'),
        symbolOffset: seriesModel.get('symbolOffset'),
        hoverAnimation: seriesModel.get('hoverAnimation'),
        labelModel: seriesModel.getModel('label'),
        hoverLabelModel: seriesModel.getModel('emphasis.label'),
        cursorStyle: seriesModel.get('cursor')
      };
    }

    var _default$1L = SymbolDraw;
    var SymbolDraw_1 = _default$1L;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var isDimensionStacked$3 = dataStackHelper.isDimensionStacked;



    var map$8 = util.map;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @param {Object} coordSys
     * @param {module:echarts/data/List} data
     * @param {string} valueOrigin lineSeries.option.areaStyle.origin
     */
    function prepareDataCoordInfo(coordSys, data, valueOrigin) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis = coordSys.getOtherAxis(baseAxis);
      var valueStart = getValueStart(valueAxis, valueOrigin);
      var baseAxisDim = baseAxis.dim;
      var valueAxisDim = valueAxis.dim;
      var valueDim = data.mapDimension(valueAxisDim);
      var baseDim = data.mapDimension(baseAxisDim);
      var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;
      var dims = map$8(coordSys.dimensions, function (coordDim) {
        return data.mapDimension(coordDim);
      });
      var stacked;
      var stackResultDim = data.getCalculationInfo('stackResultDimension');

      if (stacked |= isDimensionStacked$3(data, dims[0]
      /*, dims[1]*/
      )) {
        // jshint ignore:line
        dims[0] = stackResultDim;
      }

      if (stacked |= isDimensionStacked$3(data, dims[1]
      /*, dims[0]*/
      )) {
        // jshint ignore:line
        dims[1] = stackResultDim;
      }

      return {
        dataDimsForPoint: dims,
        valueStart: valueStart,
        valueAxisDim: valueAxisDim,
        baseAxisDim: baseAxisDim,
        stacked: !!stacked,
        valueDim: valueDim,
        baseDim: baseDim,
        baseDataOffset: baseDataOffset,
        stackedOverDimension: data.getCalculationInfo('stackedOverDimension')
      };
    }

    function getValueStart(valueAxis, valueOrigin) {
      var valueStart = 0;
      var extent = valueAxis.scale.getExtent();

      if (valueOrigin === 'start') {
        valueStart = extent[0];
      } else if (valueOrigin === 'end') {
        valueStart = extent[1];
      } // auto
      else {
          // Both positive
          if (extent[0] > 0) {
            valueStart = extent[0];
          } // Both negative
          else if (extent[1] < 0) {
              valueStart = extent[1];
            } // If is one positive, and one negative, onZero shall be true

        }

      return valueStart;
    }

    function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
      var value = NaN;

      if (dataCoordInfo.stacked) {
        value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);
      }

      if (isNaN(value)) {
        value = dataCoordInfo.valueStart;
      }

      var baseDataOffset = dataCoordInfo.baseDataOffset;
      var stackedData = [];
      stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
      stackedData[1 - baseDataOffset] = value;
      return coordSys.dataToPoint(stackedData);
    }

    var prepareDataCoordInfo_1 = prepareDataCoordInfo;
    var getStackedOnPoint_1 = getStackedOnPoint;

    var helper$4 = {
    	prepareDataCoordInfo: prepareDataCoordInfo_1,
    	getStackedOnPoint: getStackedOnPoint_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var prepareDataCoordInfo$1 = helper$4.prepareDataCoordInfo;
    var getStackedOnPoint$1 = helper$4.getStackedOnPoint;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // var arrayDiff = require('zrender/src/core/arrayDiff');
    // 'zrender/src/core/arrayDiff' has been used before, but it did
    // not do well in performance when roam with fixed dataZoom window.
    // function convertToIntId(newIdList, oldIdList) {
    //     // Generate int id instead of string id.
    //     // Compare string maybe slow in score function of arrDiff
    //     // Assume id in idList are all unique
    //     var idIndicesMap = {};
    //     var idx = 0;
    //     for (var i = 0; i < newIdList.length; i++) {
    //         idIndicesMap[newIdList[i]] = idx;
    //         newIdList[i] = idx++;
    //     }
    //     for (var i = 0; i < oldIdList.length; i++) {
    //         var oldId = oldIdList[i];
    //         // Same with newIdList
    //         if (idIndicesMap[oldId]) {
    //             oldIdList[i] = idIndicesMap[oldId];
    //         }
    //         else {
    //             oldIdList[i] = idx++;
    //         }
    //     }
    // }
    function diffData(oldData, newData) {
      var diffResult = [];
      newData.diff(oldData).add(function (idx) {
        diffResult.push({
          cmd: '+',
          idx: idx
        });
      }).update(function (newIdx, oldIdx) {
        diffResult.push({
          cmd: '=',
          idx: oldIdx,
          idx1: newIdx
        });
      }).remove(function (idx) {
        diffResult.push({
          cmd: '-',
          idx: idx
        });
      }).execute();
      return diffResult;
    }

    function _default$1M(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
      var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);
      // var oldIdList = oldData.mapArray(oldData.getId);
      // convertToIntId(newIdList, oldIdList);
      // // FIXME One data ?
      // diff = arrayDiff(oldIdList, newIdList);

      var currPoints = [];
      var nextPoints = []; // Points for stacking base line

      var currStackedPoints = [];
      var nextStackedPoints = [];
      var status = [];
      var sortedIndices = [];
      var rawIndices = [];
      var newDataOldCoordInfo = prepareDataCoordInfo$1(oldCoordSys, newData, oldValueOrigin);
      var oldDataNewCoordInfo = prepareDataCoordInfo$1(newCoordSys, oldData, newValueOrigin);

      for (var i = 0; i < diff.length; i++) {
        var diffItem = diff[i];
        var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast
        // Which is in case remvoing or add more than one data in the tail or head

        switch (diffItem.cmd) {
          case '=':
            var currentPt = oldData.getItemLayout(diffItem.idx);
            var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly

            if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
              currentPt = nextPt.slice();
            }

            currPoints.push(currentPt);
            nextPoints.push(nextPt);
            currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
            nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
            rawIndices.push(newData.getRawIndex(diffItem.idx1));
            break;

          case '+':
            var idx = diffItem.idx;
            currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));
            nextPoints.push(newData.getItemLayout(idx).slice());
            currStackedPoints.push(getStackedOnPoint$1(newDataOldCoordInfo, oldCoordSys, newData, idx));
            nextStackedPoints.push(newStackedOnPoints[idx]);
            rawIndices.push(newData.getRawIndex(idx));
            break;

          case '-':
            var idx = diffItem.idx;
            var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue
            // FIXME FIXME FIXME

            if (rawIndex !== idx) {
              currPoints.push(oldData.getItemLayout(idx));
              nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));
              currStackedPoints.push(oldStackedOnPoints[idx]);
              nextStackedPoints.push(getStackedOnPoint$1(oldDataNewCoordInfo, newCoordSys, oldData, idx));
              rawIndices.push(rawIndex);
            } else {
              pointAdded = false;
            }

        } // Original indices


        if (pointAdded) {
          status.push(diffItem);
          sortedIndices.push(sortedIndices.length);
        }
      } // Diff result may be crossed if all items are changed
      // Sort by data index


      sortedIndices.sort(function (a, b) {
        return rawIndices[a] - rawIndices[b];
      });
      var sortedCurrPoints = [];
      var sortedNextPoints = [];
      var sortedCurrStackedPoints = [];
      var sortedNextStackedPoints = [];
      var sortedStatus = [];

      for (var i = 0; i < sortedIndices.length; i++) {
        var idx = sortedIndices[i];
        sortedCurrPoints[i] = currPoints[idx];
        sortedNextPoints[i] = nextPoints[idx];
        sortedCurrStackedPoints[i] = currStackedPoints[idx];
        sortedNextStackedPoints[i] = nextStackedPoints[idx];
        sortedStatus[i] = status[idx];
      }

      return {
        current: sortedCurrPoints,
        next: sortedNextPoints,
        stackedOnCurrent: sortedCurrStackedPoints,
        stackedOnNext: sortedNextStackedPoints,
        status: sortedStatus
      };
    }

    var lineAnimationDiff = _default$1M;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // Poly path support NaN point
    var vec2Min = vector.min;
    var vec2Max = vector.max;
    var scaleAndAdd$1 = vector.scaleAndAdd;
    var v2Copy = vector.copy; // Temporary variable

    var v = [];
    var cp0 = [];
    var cp1 = [];

    function isPointNull(p) {
      return isNaN(p[0]) || isNaN(p[1]);
    }

    function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
      // if (smoothMonotone == null) {
      //     if (isMono(points, 'x')) {
      //         return drawMono(ctx, points, start, segLen, allLen,
      //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);
      //     }
      //     else if (isMono(points, 'y')) {
      //         return drawMono(ctx, points, start, segLen, allLen,
      //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);
      //     }
      //     else {
      //         return drawNonMono.apply(this, arguments);
      //     }
      // }
      // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {
      //     return drawMono.apply(this, arguments);
      // }
      // else {
      //     return drawNonMono.apply(this, arguments);
      // }
      if (smoothMonotone === 'none' || !smoothMonotone) {
        return drawNonMono.apply(this, arguments);
      } else {
        return drawMono.apply(this, arguments);
      }
    }
    /**
     * Check if points is in monotone.
     *
     * @param {number[][]} points         Array of points which is in [x, y] form
     * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which
     *                                    dimension that is checking.
     *                                    If is 'none', `drawNonMono` should be
     *                                    called.
     *                                    If is undefined, either being monotone
     *                                    in 'x' or 'y' will call `drawMono`.
     */
    // function isMono(points, smoothMonotone) {
    //     if (points.length <= 1) {
    //         return true;
    //     }
    //     var dim = smoothMonotone === 'x' ? 0 : 1;
    //     var last = points[0][dim];
    //     var lastDiff = 0;
    //     for (var i = 1; i < points.length; ++i) {
    //         var diff = points[i][dim] - last;
    //         if (!isNaN(diff) && !isNaN(lastDiff)
    //             && diff !== 0 && lastDiff !== 0
    //             && ((diff >= 0) !== (lastDiff >= 0))
    //         ) {
    //             return false;
    //         }
    //         if (!isNaN(diff) && diff !== 0) {
    //             lastDiff = diff;
    //             last = points[i][dim];
    //         }
    //     }
    //     return true;
    // }

    /**
     * Draw smoothed line in monotone, in which only vertical or horizontal bezier
     * control points will be used. This should be used when points are monotone
     * either in x or y dimension.
     */


    function drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
      var prevIdx = 0;
      var idx = start;

      for (var k = 0; k < segLen; k++) {
        var p = points[idx];

        if (idx >= allLen || idx < 0) {
          break;
        }

        if (isPointNull(p)) {
          if (connectNulls) {
            idx += dir;
            continue;
          }

          break;
        }

        if (idx === start) {
          ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
        } else {
          if (smooth > 0) {
            var prevP = points[prevIdx];
            var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both

            var ctrlLen = (p[dim] - prevP[dim]) * smooth;
            v2Copy(cp0, prevP);
            cp0[dim] = prevP[dim] + ctrlLen;
            v2Copy(cp1, p);
            cp1[dim] = p[dim] - ctrlLen;
            ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
          } else {
            ctx.lineTo(p[0], p[1]);
          }
        }

        prevIdx = idx;
        idx += dir;
      }

      return k;
    }
    /**
     * Draw smoothed line in non-monotone, in may cause undesired curve in extreme
     * situations. This should be used when points are non-monotone neither in x or
     * y dimension.
     */


    function drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
      var prevIdx = 0;
      var idx = start;

      for (var k = 0; k < segLen; k++) {
        var p = points[idx];

        if (idx >= allLen || idx < 0) {
          break;
        }

        if (isPointNull(p)) {
          if (connectNulls) {
            idx += dir;
            continue;
          }

          break;
        }

        if (idx === start) {
          ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
          v2Copy(cp0, p);
        } else {
          if (smooth > 0) {
            var nextIdx = idx + dir;
            var nextP = points[nextIdx];

            if (connectNulls) {
              // Find next point not null
              while (nextP && isPointNull(points[nextIdx])) {
                nextIdx += dir;
                nextP = points[nextIdx];
              }
            }

            var ratioNextSeg = 0.5;
            var prevP = points[prevIdx];
            var nextP = points[nextIdx]; // Last point

            if (!nextP || isPointNull(nextP)) {
              v2Copy(cp1, p);
            } else {
              // If next data is null in not connect case
              if (isPointNull(nextP) && !connectNulls) {
                nextP = p;
              }

              vector.sub(v, nextP, prevP);
              var lenPrevSeg;
              var lenNextSeg;

              if (smoothMonotone === 'x' || smoothMonotone === 'y') {
                var dim = smoothMonotone === 'x' ? 0 : 1;
                lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
                lenNextSeg = Math.abs(p[dim] - nextP[dim]);
              } else {
                lenPrevSeg = vector.dist(p, prevP);
                lenNextSeg = vector.dist(p, nextP);
              } // Use ratio of seg length


              ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
              scaleAndAdd$1(cp1, p, v, -smooth * (1 - ratioNextSeg));
            } // Smooth constraint


            vec2Min(cp0, cp0, smoothMax);
            vec2Max(cp0, cp0, smoothMin);
            vec2Min(cp1, cp1, smoothMax);
            vec2Max(cp1, cp1, smoothMin);
            ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment

            scaleAndAdd$1(cp0, p, v, smooth * ratioNextSeg);
          } else {
            ctx.lineTo(p[0], p[1]);
          }
        }

        prevIdx = idx;
        idx += dir;
      }

      return k;
    }

    function getBoundingBox(points, smoothConstraint) {
      var ptMin = [Infinity, Infinity];
      var ptMax = [-Infinity, -Infinity];

      if (smoothConstraint) {
        for (var i = 0; i < points.length; i++) {
          var pt = points[i];

          if (pt[0] < ptMin[0]) {
            ptMin[0] = pt[0];
          }

          if (pt[1] < ptMin[1]) {
            ptMin[1] = pt[1];
          }

          if (pt[0] > ptMax[0]) {
            ptMax[0] = pt[0];
          }

          if (pt[1] > ptMax[1]) {
            ptMax[1] = pt[1];
          }
        }
      }

      return {
        min: smoothConstraint ? ptMin : ptMax,
        max: smoothConstraint ? ptMax : ptMin
      };
    }

    var Polyline$1 = Path_1.extend({
      type: 'ec-polyline',
      shape: {
        points: [],
        smooth: 0,
        smoothConstraint: true,
        smoothMonotone: null,
        connectNulls: false
      },
      style: {
        fill: null,
        stroke: '#000'
      },
      brush: fixClipWithShadow(Path_1.prototype.brush),
      buildPath: function (ctx, shape) {
        var points = shape.points;
        var i = 0;
        var len = points.length;
        var result = getBoundingBox(points, shape.smoothConstraint);

        if (shape.connectNulls) {
          // Must remove first and last null values avoid draw error in polygon
          for (; len > 0; len--) {
            if (!isPointNull(points[len - 1])) {
              break;
            }
          }

          for (; i < len; i++) {
            if (!isPointNull(points[i])) {
              break;
            }
          }
        }

        while (i < len) {
          i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
        }
      }
    });
    var Polygon$1 = Path_1.extend({
      type: 'ec-polygon',
      shape: {
        points: [],
        // Offset between stacked base points and points
        stackedOnPoints: [],
        smooth: 0,
        stackedOnSmooth: 0,
        smoothConstraint: true,
        smoothMonotone: null,
        connectNulls: false
      },
      brush: fixClipWithShadow(Path_1.prototype.brush),
      buildPath: function (ctx, shape) {
        var points = shape.points;
        var stackedOnPoints = shape.stackedOnPoints;
        var i = 0;
        var len = points.length;
        var smoothMonotone = shape.smoothMonotone;
        var bbox = getBoundingBox(points, shape.smoothConstraint);
        var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);

        if (shape.connectNulls) {
          // Must remove first and last null values avoid draw error in polygon
          for (; len > 0; len--) {
            if (!isPointNull(points[len - 1])) {
              break;
            }
          }

          for (; i < len; i++) {
            if (!isPointNull(points[i])) {
              break;
            }
          }
        }

        while (i < len) {
          var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
          drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
          i += k + 1;
          ctx.closePath();
        }
      }
    });
    var Polyline_1$1 = Polyline$1;
    var Polygon_1$1 = Polygon$1;

    var poly$1 = {
    	Polyline: Polyline_1$1,
    	Polygon: Polygon_1$1
    };

    var fromPoints$1 = bbox.fromPoints;













    var Polyline$2 = poly$1.Polyline;
    var Polygon$2 = poly$1.Polygon;





    var prepareDataCoordInfo$2 = helper$4.prepareDataCoordInfo;
    var getStackedOnPoint$2 = helper$4.getStackedOnPoint;



    var createGridClipPath$1 = createClipPathFromCoordSys.createGridClipPath;
    var createPolarClipPath$1 = createClipPathFromCoordSys.createPolarClipPath;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // FIXME step not support polar
    function isPointsSame(points1, points2) {
      if (points1.length !== points2.length) {
        return;
      }

      for (var i = 0; i < points1.length; i++) {
        var p1 = points1[i];
        var p2 = points2[i];

        if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
          return;
        }
      }

      return true;
    }

    function getBoundingDiff(points1, points2) {
      var min1 = [];
      var max1 = [];
      var min2 = [];
      var max2 = [];
      fromPoints$1(points1, min1, max1);
      fromPoints$1(points2, min2, max2); // Get a max value from each corner of two boundings.

      return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));
    }

    function getSmooth(smooth) {
      return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;
    }
    /**
     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys
     * @param {module:echarts/data/List} data
     * @param {Object} dataCoordInfo
     * @param {Array.<Array.<number>>} points
     */


    function getStackedOnPoints(coordSys, data, dataCoordInfo) {
      if (!dataCoordInfo.valueDim) {
        return [];
      }

      var points = [];

      for (var idx = 0, len = data.count(); idx < len; idx++) {
        points.push(getStackedOnPoint$2(dataCoordInfo, coordSys, data, idx));
      }

      return points;
    }

    function turnPointsIntoStep(points, coordSys, stepTurnAt) {
      var baseAxis = coordSys.getBaseAxis();
      var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
      var stepPoints = [];

      for (var i = 0; i < points.length - 1; i++) {
        var nextPt = points[i + 1];
        var pt = points[i];
        stepPoints.push(pt);
        var stepPt = [];

        switch (stepTurnAt) {
          case 'end':
            stepPt[baseIndex] = nextPt[baseIndex];
            stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start

            stepPoints.push(stepPt);
            break;

          case 'middle':
            // default is start
            var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
            var stepPt2 = [];
            stepPt[baseIndex] = stepPt2[baseIndex] = middle;
            stepPt[1 - baseIndex] = pt[1 - baseIndex];
            stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
            stepPoints.push(stepPt);
            stepPoints.push(stepPt2);
            break;

          default:
            stepPt[baseIndex] = pt[baseIndex];
            stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start

            stepPoints.push(stepPt);
        }
      } // Last points


      points[i] && stepPoints.push(points[i]);
      return stepPoints;
    }

    function getVisualGradient(data, coordSys) {
      var visualMetaList = data.getVisual('visualMeta');

      if (!visualMetaList || !visualMetaList.length || !data.count()) {
        // When data.count() is 0, gradient range can not be calculated.
        return;
      }

      if (coordSys.type !== 'cartesian2d') {
        return;
      }

      var coordDim;
      var visualMeta;

      for (var i = visualMetaList.length - 1; i >= 0; i--) {
        var dimIndex = visualMetaList[i].dimension;
        var dimName = data.dimensions[dimIndex];
        var dimInfo = data.getDimensionInfo(dimName);
        coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y

        if (coordDim === 'x' || coordDim === 'y') {
          visualMeta = visualMetaList[i];
          break;
        }
      }

      if (!visualMeta) {
        return;
      } // If the area to be rendered is bigger than area defined by LinearGradient,
      // the canvas spec prescribes that the color of the first stop and the last
      // stop should be used. But if two stops are added at offset 0, in effect
      // browsers use the color of the second stop to render area outside
      // LinearGradient. So we can only infinitesimally extend area defined in
      // LinearGradient to render `outerColors`.


      var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.

      var colorStops = util.map(visualMeta.stops, function (stop) {
        return {
          coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
          color: stop.color
        };
      });
      var stopLen = colorStops.length;
      var outerColors = visualMeta.outerColors.slice();

      if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
        colorStops.reverse();
        outerColors.reverse();
      }

      var tinyExtent = 10; // Arbitrary value: 10px

      var minCoord = colorStops[0].coord - tinyExtent;
      var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
      var coordSpan = maxCoord - minCoord;

      if (coordSpan < 1e-3) {
        return 'transparent';
      }

      util.each(colorStops, function (stop) {
        stop.offset = (stop.coord - minCoord) / coordSpan;
      });
      colorStops.push({
        offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
        color: outerColors[1] || 'transparent'
      });
      colorStops.unshift({
        // notice colorStops.length have been changed.
        offset: stopLen ? colorStops[0].offset : 0.5,
        color: outerColors[0] || 'transparent'
      }); // zrUtil.each(colorStops, function (colorStop) {
      //     // Make sure each offset has rounded px to avoid not sharp edge
      //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);
      // });

      var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
      gradient[coordDim] = minCoord;
      gradient[coordDim + '2'] = maxCoord;
      return gradient;
    }

    function getIsIgnoreFunc(seriesModel, data, coordSys) {
      var showAllSymbol = seriesModel.get('showAllSymbol');
      var isAuto = showAllSymbol === 'auto';

      if (showAllSymbol && !isAuto) {
        return;
      }

      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

      if (!categoryAxis) {
        return;
      } // Note that category label interval strategy might bring some weird effect
      // in some scenario: users may wonder why some of the symbols are not
      // displayed. So we show all symbols as possible as we can.


      if (isAuto // Simplify the logic, do not determine label overlap here.
      && canShowAllSymbolForCategory(categoryAxis, data)) {
        return;
      } // Otherwise follow the label interval strategy on category axis.


      var categoryDataDim = data.mapDimension(categoryAxis.dim);
      var labelMap = {};
      util.each(categoryAxis.getViewLabels(), function (labelItem) {
        labelMap[labelItem.tickValue] = 1;
      });
      return function (dataIndex) {
        return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
      };
    }

    function canShowAllSymbolForCategory(categoryAxis, data) {
      // In mose cases, line is monotonous on category axis, and the label size
      // is close with each other. So we check the symbol size and some of the
      // label size alone with the category axis to estimate whether all symbol
      // can be shown without overlap.
      var axisExtent = categoryAxis.getExtent();
      var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
      isNaN(availSize) && (availSize = 0); // 0/0 is NaN.
      // Sampling some points, max 5.

      var dataLen = data.count();
      var step = Math.max(1, Math.round(dataLen / 5));

      for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
        if (_Symbol.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.
        )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number
        * 1.5 > availSize) {
          return false;
        }
      }

      return true;
    }

    function createLineClipPath(coordSys, hasAnimation, seriesModel) {
      if (coordSys.type === 'cartesian2d') {
        var isHorizontal = coordSys.getBaseAxis().isHorizontal();
        var clipPath = createGridClipPath$1(coordSys, hasAnimation, seriesModel); // Expand clip shape to avoid clipping when line value exceeds axis

        if (!seriesModel.get('clip', true)) {
          var rectShape = clipPath.shape;
          var expandSize = Math.max(rectShape.width, rectShape.height);

          if (isHorizontal) {
            rectShape.y -= expandSize;
            rectShape.height += expandSize * 2;
          } else {
            rectShape.x -= expandSize;
            rectShape.width += expandSize * 2;
          }
        }

        return clipPath;
      } else {
        return createPolarClipPath$1(coordSys, hasAnimation, seriesModel);
      }
    }

    var _default$1N = Chart_1.extend({
      type: 'line',
      init: function () {
        var lineGroup = new graphic.Group();
        var symbolDraw = new SymbolDraw_1();
        this.group.add(symbolDraw.group);
        this._symbolDraw = symbolDraw;
        this._lineGroup = lineGroup;
      },
      render: function (seriesModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var group = this.group;
        var data = seriesModel.getData();
        var lineStyleModel = seriesModel.getModel('lineStyle');
        var areaStyleModel = seriesModel.getModel('areaStyle');
        var points = data.mapArray(data.getItemLayout);
        var isCoordSysPolar = coordSys.type === 'polar';
        var prevCoordSys = this._coordSys;
        var symbolDraw = this._symbolDraw;
        var polyline = this._polyline;
        var polygon = this._polygon;
        var lineGroup = this._lineGroup;
        var hasAnimation = seriesModel.get('animation');
        var isAreaChart = !areaStyleModel.isEmpty();
        var valueOrigin = areaStyleModel.get('origin');
        var dataCoordInfo = prepareDataCoordInfo$2(coordSys, data, valueOrigin);
        var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);
        var showSymbol = seriesModel.get('showSymbol');
        var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols

        var oldData = this._data;
        oldData && oldData.eachItemGraphicEl(function (el, idx) {
          if (el.__temp) {
            group.remove(el);
            oldData.setItemGraphicEl(idx, null);
          }
        }); // Remove previous created symbols if showSymbol changed to false

        if (!showSymbol) {
          symbolDraw.remove();
        }

        group.add(lineGroup); // FIXME step not support polar

        var step = !isCoordSysPolar && seriesModel.get('step');
        var clipShapeForSymbol;

        if (coordSys && coordSys.getArea && seriesModel.get('clip', true)) {
          clipShapeForSymbol = coordSys.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.
          // See #7913 and `test/dataZoom-clip.html`.

          if (clipShapeForSymbol.width != null) {
            clipShapeForSymbol.x -= 0.1;
            clipShapeForSymbol.y -= 0.1;
            clipShapeForSymbol.width += 0.2;
            clipShapeForSymbol.height += 0.2;
          } else if (clipShapeForSymbol.r0) {
            clipShapeForSymbol.r0 -= 0.5;
            clipShapeForSymbol.r1 += 0.5;
          }
        }

        this._clipShapeForSymbol = clipShapeForSymbol; // Initialization animation or coordinate system changed

        if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol
          });

          if (step) {
            // TODO If stacked series is not step
            points = turnPointsIntoStep(points, coordSys, step);
            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
          }

          polyline = this._newPolyline(points, coordSys, hasAnimation);

          if (isAreaChart) {
            polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
          }

          lineGroup.setClipPath(createLineClipPath(coordSys, true, seriesModel));
        } else {
          if (isAreaChart && !polygon) {
            // If areaStyle is added
            polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
          } else if (polygon && !isAreaChart) {
            // If areaStyle is removed
            lineGroup.remove(polygon);
            polygon = this._polygon = null;
          } // Update clipPath


          lineGroup.setClipPath(createLineClipPath(coordSys, false, seriesModel)); // Always update, or it is wrong in the case turning on legend
          // because points are not changed

          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol
          }); // Stop symbol animation and sync with line points
          // FIXME performance?

          data.eachItemGraphicEl(function (el) {
            el.stopAnimation(true);
          }); // In the case data zoom triggerred refreshing frequently
          // Data may not change if line has a category axis. So it should animate nothing

          if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
            if (hasAnimation) {
              this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);
            } else {
              // Not do it in update with animation
              if (step) {
                // TODO If stacked series is not step
                points = turnPointsIntoStep(points, coordSys, step);
                stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
              }

              polyline.setShape({
                points: points
              });
              polygon && polygon.setShape({
                points: points,
                stackedOnPoints: stackedOnPoints
              });
            }
          }
        }

        var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');
        polyline.useStyle(util.defaults( // Use color in lineStyle first
        lineStyleModel.getLineStyle(), {
          fill: 'none',
          stroke: visualColor,
          lineJoin: 'bevel'
        }));
        var smooth = seriesModel.get('smooth');
        smooth = getSmooth(seriesModel.get('smooth'));
        polyline.setShape({
          smooth: smooth,
          smoothMonotone: seriesModel.get('smoothMonotone'),
          connectNulls: seriesModel.get('connectNulls')
        });

        if (polygon) {
          var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
          var stackedOnSmooth = 0;
          polygon.useStyle(util.defaults(areaStyleModel.getAreaStyle(), {
            fill: visualColor,
            opacity: 0.7,
            lineJoin: 'bevel'
          }));

          if (stackedOnSeries) {
            stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
          }

          polygon.setShape({
            smooth: smooth,
            stackedOnSmooth: stackedOnSmooth,
            smoothMonotone: seriesModel.get('smoothMonotone'),
            connectNulls: seriesModel.get('connectNulls')
          });
        }

        this._data = data; // Save the coordinate system for transition animation when data changed

        this._coordSys = coordSys;
        this._stackedOnPoints = stackedOnPoints;
        this._points = points;
        this._step = step;
        this._valueOrigin = valueOrigin;
      },
      dispose: function () {},
      highlight: function (seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = model.queryDataIndex(data, payload);

        if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
          var symbol = data.getItemGraphicEl(dataIndex);

          if (!symbol) {
            // Create a temporary symbol if it is not exists
            var pt = data.getItemLayout(dataIndex);

            if (!pt) {
              // Null data
              return;
            } // fix #11360: should't draw symbol outside clipShapeForSymbol


            if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(pt[0], pt[1])) {
              return;
            }

            symbol = new _Symbol(data, dataIndex);
            symbol.position = pt;
            symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
            symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
            symbol.__temp = true;
            data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation

            symbol.stopSymbolAnimation(true);
            this.group.add(symbol);
          }

          symbol.highlight();
        } else {
          // Highlight whole series
          Chart_1.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
        }
      },
      downplay: function (seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = model.queryDataIndex(data, payload);

        if (dataIndex != null && dataIndex >= 0) {
          var symbol = data.getItemGraphicEl(dataIndex);

          if (symbol) {
            if (symbol.__temp) {
              data.setItemGraphicEl(dataIndex, null);
              this.group.remove(symbol);
            } else {
              symbol.downplay();
            }
          }
        } else {
          // FIXME
          // can not downplay completely.
          // Downplay whole series
          Chart_1.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
        }
      },

      /**
       * @param {module:zrender/container/Group} group
       * @param {Array.<Array.<number>>} points
       * @private
       */
      _newPolyline: function (points) {
        var polyline = this._polyline; // Remove previous created polyline

        if (polyline) {
          this._lineGroup.remove(polyline);
        }

        polyline = new Polyline$2({
          shape: {
            points: points
          },
          silent: true,
          z2: 10
        });

        this._lineGroup.add(polyline);

        this._polyline = polyline;
        return polyline;
      },

      /**
       * @param {module:zrender/container/Group} group
       * @param {Array.<Array.<number>>} stackedOnPoints
       * @param {Array.<Array.<number>>} points
       * @private
       */
      _newPolygon: function (points, stackedOnPoints) {
        var polygon = this._polygon; // Remove previous created polygon

        if (polygon) {
          this._lineGroup.remove(polygon);
        }

        polygon = new Polygon$2({
          shape: {
            points: points,
            stackedOnPoints: stackedOnPoints
          },
          silent: true
        });

        this._lineGroup.add(polygon);

        this._polygon = polygon;
        return polygon;
      },

      /**
       * @private
       */
      // FIXME Two value axis
      _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {
        var polyline = this._polyline;
        var polygon = this._polygon;
        var seriesModel = data.hostModel;
        var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
        var current = diff.current;
        var stackedOnCurrent = diff.stackedOnCurrent;
        var next = diff.next;
        var stackedOnNext = diff.stackedOnNext;

        if (step) {
          // TODO If stacked series is not step
          current = turnPointsIntoStep(diff.current, coordSys, step);
          stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
          next = turnPointsIntoStep(diff.next, coordSys, step);
          stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
        } // Don't apply animation if diff is large.
        // For better result and avoid memory explosion problems like
        // https://github.com/apache/incubator-echarts/issues/12229


        if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {
          polyline.setShape({
            points: next
          });

          if (polygon) {
            polygon.setShape({
              points: next,
              stackedOnPoints: stackedOnNext
            });
          }

          return;
        } // `diff.current` is subset of `current` (which should be ensured by
        // turnPointsIntoStep), so points in `__points` can be updated when
        // points in `current` are update during animation.


        polyline.shape.__points = diff.current;
        polyline.shape.points = current;
        graphic.updateProps(polyline, {
          shape: {
            points: next
          }
        }, seriesModel);

        if (polygon) {
          polygon.setShape({
            points: current,
            stackedOnPoints: stackedOnCurrent
          });
          graphic.updateProps(polygon, {
            shape: {
              points: next,
              stackedOnPoints: stackedOnNext
            }
          }, seriesModel);
        }

        var updatedDataInfo = [];
        var diffStatus = diff.status;

        for (var i = 0; i < diffStatus.length; i++) {
          var cmd = diffStatus[i].cmd;

          if (cmd === '=') {
            var el = data.getItemGraphicEl(diffStatus[i].idx1);

            if (el) {
              updatedDataInfo.push({
                el: el,
                ptIdx: i // Index of points

              });
            }
          }
        }

        if (polyline.animators && polyline.animators.length) {
          polyline.animators[0].during(function () {
            for (var i = 0; i < updatedDataInfo.length; i++) {
              var el = updatedDataInfo[i].el;
              el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);
            }
          });
        }
      },
      remove: function (ecModel) {
        var group = this.group;
        var oldData = this._data;

        this._lineGroup.removeAll();

        this._symbolDraw.remove(true); // Remove temporary created elements when highlighting


        oldData && oldData.eachItemGraphicEl(function (el, idx) {
          if (el.__temp) {
            group.remove(el);
            oldData.setItemGraphicEl(idx, null);
          }
        });
        this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var isFunction$5 = util.isFunction;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function _default$1O(seriesType, defaultSymbolType, legendSymbol) {
      // Encoding visual for all series include which is filtered for legend drawing
      return {
        seriesType: seriesType,
        // For legend.
        performRawSeries: true,
        reset: function (seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var symbolType = seriesModel.get('symbol');
          var symbolSize = seriesModel.get('symbolSize');
          var keepAspect = seriesModel.get('symbolKeepAspect');
          var symbolRotate = seriesModel.get('symbolRotate');
          var hasSymbolTypeCallback = isFunction$5(symbolType);
          var hasSymbolSizeCallback = isFunction$5(symbolSize);
          var hasSymbolRotateCallback = isFunction$5(symbolRotate);
          var hasCallback = hasSymbolTypeCallback || hasSymbolSizeCallback || hasSymbolRotateCallback;
          var seriesSymbol = !hasSymbolTypeCallback && symbolType ? symbolType : defaultSymbolType;
          var seriesSymbolSize = !hasSymbolSizeCallback ? symbolSize : null;
          data.setVisual({
            legendSymbol: legendSymbol || seriesSymbol,
            // If seting callback functions on `symbol` or `symbolSize`, for simplicity and avoiding
            // to bring trouble, we do not pick a reuslt from one of its calling on data item here,
            // but just use the default value. Callback on `symbol` or `symbolSize` is convenient in
            // some cases but generally it is not recommanded.
            symbol: seriesSymbol,
            symbolSize: seriesSymbolSize,
            symbolKeepAspect: keepAspect,
            symbolRotate: symbolRotate
          }); // Only visible series has each data be visual encoded

          if (ecModel.isSeriesFiltered(seriesModel)) {
            return;
          }

          function dataEach(data, idx) {
            if (hasCallback) {
              var rawValue = seriesModel.getRawValue(idx);
              var params = seriesModel.getDataParams(idx);
              hasSymbolTypeCallback && data.setItemVisual(idx, 'symbol', symbolType(rawValue, params));
              hasSymbolSizeCallback && data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
              hasSymbolRotateCallback && data.setItemVisual(idx, 'symbolRotate', symbolRotate(rawValue, params));
            }

            if (data.hasItemOption) {
              var itemModel = data.getItemModel(idx);
              var itemSymbolType = itemModel.getShallow('symbol', true);
              var itemSymbolSize = itemModel.getShallow('symbolSize', true);
              var itemSymbolRotate = itemModel.getShallow('symbolRotate', true);
              var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol

              if (itemSymbolType != null) {
                data.setItemVisual(idx, 'symbol', itemSymbolType);
              }

              if (itemSymbolSize != null) {
                // PENDING Transform symbolSize ?
                data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
              }

              if (itemSymbolRotate != null) {
                data.setItemVisual(idx, 'symbolRotate', itemSymbolRotate);
              }

              if (itemSymbolKeepAspect != null) {
                data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);
              }
            }
          }

          return {
            dataEach: data.hasItemOption || hasCallback ? dataEach : null
          };
        }
      };
    }

    var symbol$1 = _default$1O;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var map$9 = util.map;





    var isDimensionStacked$4 = dataStackHelper.isDimensionStacked;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /* global Float32Array */
    function _default$1P(seriesType) {
      return {
        seriesType: seriesType,
        plan: createRenderPlanner(),
        reset: function (seriesModel) {
          var data = seriesModel.getData();
          var coordSys = seriesModel.coordinateSystem;
          var pipelineContext = seriesModel.pipelineContext;
          var isLargeRender = pipelineContext.large;

          if (!coordSys) {
            return;
          }

          var dims = map$9(coordSys.dimensions, function (dim) {
            return data.mapDimension(dim);
          }).slice(0, 2);
          var dimLen = dims.length;
          var stackResultDim = data.getCalculationInfo('stackResultDimension');

          if (isDimensionStacked$4(data, dims[0]
          /*, dims[1]*/
          )) {
            dims[0] = stackResultDim;
          }

          if (isDimensionStacked$4(data, dims[1]
          /*, dims[0]*/
          )) {
            dims[1] = stackResultDim;
          }

          function progress(params, data) {
            var segCount = params.end - params.start;
            var points = isLargeRender && new Float32Array(segCount * dimLen);

            for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {
              var point;

              if (dimLen === 1) {
                var x = data.get(dims[0], i);
                point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);
              } else {
                var x = tmpIn[0] = data.get(dims[0], i);
                var y = tmpIn[1] = data.get(dims[1], i); // Also {Array.<number>}, not undefined to avoid if...else... statement

                point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);
              }

              if (isLargeRender) {
                points[offset++] = point ? point[0] : NaN;
                points[offset++] = point ? point[1] : NaN;
              } else {
                data.setItemLayout(i, point && point.slice() || [NaN, NaN]);
              }
            }

            isLargeRender && data.setLayout('symbolPoints', points);
          }

          return dimLen && {
            progress: progress
          };
        }
      };
    }

    var points$1 = _default$1P;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var samplers = {
      average: function (frame) {
        var sum = 0;
        var count = 0;

        for (var i = 0; i < frame.length; i++) {
          if (!isNaN(frame[i])) {
            sum += frame[i];
            count++;
          }
        } // Return NaN if count is 0


        return count === 0 ? NaN : sum / count;
      },
      sum: function (frame) {
        var sum = 0;

        for (var i = 0; i < frame.length; i++) {
          // Ignore NaN
          sum += frame[i] || 0;
        }

        return sum;
      },
      max: function (frame) {
        var max = -Infinity;

        for (var i = 0; i < frame.length; i++) {
          frame[i] > max && (max = frame[i]);
        } // NaN will cause illegal axis extent.


        return isFinite(max) ? max : NaN;
      },
      min: function (frame) {
        var min = Infinity;

        for (var i = 0; i < frame.length; i++) {
          frame[i] < min && (min = frame[i]);
        } // NaN will cause illegal axis extent.


        return isFinite(min) ? min : NaN;
      },
      // TODO
      // Median
      nearest: function (frame) {
        return frame[0];
      }
    };

    var indexSampler = function (frame, value) {
      return Math.round(frame.length / 2);
    };

    function _default$1Q(seriesType) {
      return {
        seriesType: seriesType,
        modifyOutputEnd: true,
        reset: function (seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var sampling = seriesModel.get('sampling');
          var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling

          if (coordSys.type === 'cartesian2d' && sampling) {
            var baseAxis = coordSys.getBaseAxis();
            var valueAxis = coordSys.getOtherAxis(baseAxis);
            var extent = baseAxis.getExtent(); // Coordinste system has been resized

            var size = extent[1] - extent[0];
            var rate = Math.round(data.count() / size);

            if (rate > 1) {
              var sampler;

              if (typeof sampling === 'string') {
                sampler = samplers[sampling];
              } else if (typeof sampling === 'function') {
                sampler = sampling;
              }

              if (sampler) {
                // Only support sample the first dim mapped from value axis.
                seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
              }
            }
          }
        }
      };
    }

    var dataSample = _default$1Q;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */















    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // In case developer forget to include grid component
    echarts.registerVisual(symbol$1('line', 'circle', 'line'));
    echarts.registerLayout(points$1('line')); // Down sample after filter

    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    var isNameSpecified$1 = model.isNameSpecified;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var langSelector = lang.legend.selector;
    var defaultSelectorOption = {
      all: {
        type: 'all',
        title: util.clone(langSelector.all)
      },
      inverse: {
        type: 'inverse',
        title: util.clone(langSelector.inverse)
      }
    };
    var LegendModel = echarts.extendComponentModel({
      type: 'legend.plain',
      dependencies: ['series'],
      layoutMode: {
        type: 'box',
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas realy width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: true
      },
      init: function (option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel);
        option.selected = option.selected || {};

        this._updateSelector(option);
      },
      mergeOption: function (option) {
        LegendModel.superCall(this, 'mergeOption', option);

        this._updateSelector(option);
      },
      _updateSelector: function (option) {
        var selector = option.selector;

        if (selector === true) {
          selector = option.selector = ['all', 'inverse'];
        }

        if (util.isArray(selector)) {
          util.each(selector, function (item, index) {
            util.isString(item) && (item = {
              type: item
            });
            selector[index] = util.merge(item, defaultSelectorOption[item.type]);
          });
        }
      },
      optionUpdated: function () {
        this._updateData(this.ecModel);

        var legendData = this._data; // If selectedMode is single, try to select one

        if (legendData[0] && this.get('selectedMode') === 'single') {
          var hasSelected = false; // If has any selected in option.selected

          for (var i = 0; i < legendData.length; i++) {
            var name = legendData[i].get('name');

            if (this.isSelected(name)) {
              // Force to unselect others
              this.select(name);
              hasSelected = true;
              break;
            }
          } // Try select the first if selectedMode is single


          !hasSelected && this.select(legendData[0].get('name'));
        }
      },
      _updateData: function (ecModel) {
        var potentialData = [];
        var availableNames = [];
        ecModel.eachRawSeries(function (seriesModel) {
          var seriesName = seriesModel.name;
          availableNames.push(seriesName);
          var isPotential;

          if (seriesModel.legendVisualProvider) {
            var provider = seriesModel.legendVisualProvider;
            var names = provider.getAllNames();

            if (!ecModel.isSeriesFiltered(seriesModel)) {
              availableNames = availableNames.concat(names);
            }

            if (names.length) {
              potentialData = potentialData.concat(names);
            } else {
              isPotential = true;
            }
          } else {
            isPotential = true;
          }

          if (isPotential && isNameSpecified$1(seriesModel)) {
            potentialData.push(seriesModel.name);
          }
        });
        /**
         * @type {Array.<string>}
         * @private
         */

        this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,
        // which is convinient for user preparing option.

        var rawData = this.get('data') || potentialData;
        var legendData = util.map(rawData, function (dataItem) {
          // Can be string or number
          if (typeof dataItem === 'string' || typeof dataItem === 'number') {
            dataItem = {
              name: dataItem
            };
          }

          return new Model_1(dataItem, this, this.ecModel);
        }, this);
        /**
         * @type {Array.<module:echarts/model/Model>}
         * @private
         */

        this._data = legendData;
      },

      /**
       * @return {Array.<module:echarts/model/Model>}
       */
      getData: function () {
        return this._data;
      },

      /**
       * @param {string} name
       */
      select: function (name) {
        var selected = this.option.selected;
        var selectedMode = this.get('selectedMode');

        if (selectedMode === 'single') {
          var data = this._data;
          util.each(data, function (dataItem) {
            selected[dataItem.get('name')] = false;
          });
        }

        selected[name] = true;
      },

      /**
       * @param {string} name
       */
      unSelect: function (name) {
        if (this.get('selectedMode') !== 'single') {
          this.option.selected[name] = false;
        }
      },

      /**
       * @param {string} name
       */
      toggleSelected: function (name) {
        var selected = this.option.selected; // Default is true

        if (!selected.hasOwnProperty(name)) {
          selected[name] = true;
        }

        this[selected[name] ? 'unSelect' : 'select'](name);
      },
      allSelect: function () {
        var data = this._data;
        var selected = this.option.selected;
        util.each(data, function (dataItem) {
          selected[dataItem.get('name', true)] = true;
        });
      },
      inverseSelect: function () {
        var data = this._data;
        var selected = this.option.selected;
        util.each(data, function (dataItem) {
          var name = dataItem.get('name', true); // Initially, default value is true

          if (!selected.hasOwnProperty(name)) {
            selected[name] = true;
          }

          selected[name] = !selected[name];
        });
      },

      /**
       * @param {string} name
       */
      isSelected: function (name) {
        var selected = this.option.selected;
        return !(selected.hasOwnProperty(name) && !selected[name]) && util.indexOf(this._availableNames, name) >= 0;
      },
      getOrient: function () {
        return this.get('orient') === 'vertical' ? {
          index: 1,
          name: 'vertical'
        } : {
          index: 0,
          name: 'horizontal'
        };
      },
      defaultOption: {
        // 一级层叠
        zlevel: 0,
        // 二级层叠
        z: 4,
        show: true,
        // 布局方式，默认为水平布局，可选为：
        // 'horizontal' | 'vertical'
        orient: 'horizontal',
        left: 'center',
        // right: 'center',
        top: 0,
        // bottom: null,
        // 水平对齐
        // 'auto' | 'left' | 'right'
        // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐
        align: 'auto',
        backgroundColor: 'rgba(0,0,0,0)',
        // 图例边框颜色
        borderColor: '#ccc',
        borderRadius: 0,
        // 图例边框线宽，单位px，默认为0（无边框）
        borderWidth: 0,
        // 图例内边距，单位px，默认各方向内边距为5，
        // 接受数组分别设定上右下左边距，同css
        padding: 5,
        // 各个item之间的间隔，单位px，默认为10，
        // 横向布局时为水平间隔，纵向布局时为纵向间隔
        itemGap: 10,
        // the width of legend symbol
        itemWidth: 25,
        // the height of legend symbol
        itemHeight: 14,
        // the color of unselected legend symbol
        inactiveColor: '#ccc',
        // the borderColor of unselected legend symbol
        inactiveBorderColor: '#ccc',
        itemStyle: {
          // the default borderWidth of legend symbol
          borderWidth: 0
        },
        textStyle: {
          // 图例文字颜色
          color: '#333'
        },
        // formatter: '',
        // 选择模式，默认开启图例开关
        selectedMode: true,
        // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入
        // selected: null,
        // 图例内容（详见legend.data，数组中每一项代表一个item
        // data: [],
        // Usage:
        // selector: [{type: 'all or inverse', title: xxx}]
        // or
        // selector: true
        // or
        // selector: ['all', 'inverse']
        selector: false,
        selectorLabel: {
          show: true,
          borderRadius: 10,
          padding: [3, 5, 3, 5],
          fontSize: 12,
          fontFamily: ' sans-serif',
          color: '#666',
          borderWidth: 1,
          borderColor: '#666'
        },
        emphasis: {
          selectorLabel: {
            show: true,
            color: '#eee',
            backgroundColor: '#666'
          }
        },
        // Value can be 'start' or 'end'
        selectorPosition: 'auto',
        selectorItemGap: 7,
        selectorButtonGap: 10,
        // Tooltip 相关配置
        tooltip: {
          show: false
        }
      }
    });
    var _default$1R = LegendModel;
    var LegendModel_1 = _default$1R;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function legendSelectActionHandler(methodName, payload, ecModel) {
      var selectedMap = {};
      var isToggleSelect = methodName === 'toggleSelected';
      var isSelected; // Update all legend components

      ecModel.eachComponent('legend', function (legendModel) {
        if (isToggleSelect && isSelected != null) {
          // Force other legend has same selected status
          // Or the first is toggled to true and other are toggled to false
          // In the case one legend has some item unSelected in option. And if other legend
          // doesn't has the item, they will assume it is selected.
          legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
        } else if (methodName === 'allSelect' || methodName === 'inverseSelect') {
          legendModel[methodName]();
        } else {
          legendModel[methodName](payload.name);
          isSelected = legendModel.isSelected(payload.name);
        }

        var legendData = legendModel.getData();
        util.each(legendData, function (model) {
          var name = model.get('name'); // Wrap element

          if (name === '\n' || name === '') {
            return;
          }

          var isItemSelected = legendModel.isSelected(name);

          if (selectedMap.hasOwnProperty(name)) {
            // Unselected if any legend is unselected
            selectedMap[name] = selectedMap[name] && isItemSelected;
          } else {
            selectedMap[name] = isItemSelected;
          }
        });
      }); // Return the event explicitly

      return methodName === 'allSelect' || methodName === 'inverseSelect' ? {
        selected: selectedMap
      } : {
        name: payload.name,
        selected: selectedMap
      };
    }
    /**
     * @event legendToggleSelect
     * @type {Object}
     * @property {string} type 'legendToggleSelect'
     * @property {string} [from]
     * @property {string} name Series name or data item name
     */


    echarts.registerAction('legendToggleSelect', 'legendselectchanged', util.curry(legendSelectActionHandler, 'toggleSelected'));
    echarts.registerAction('legendAllSelect', 'legendselectall', util.curry(legendSelectActionHandler, 'allSelect'));
    echarts.registerAction('legendInverseSelect', 'legendinverseselect', util.curry(legendSelectActionHandler, 'inverseSelect'));
    /**
     * @event legendSelect
     * @type {Object}
     * @property {string} type 'legendSelect'
     * @property {string} name Series name or data item name
     */

    echarts.registerAction('legendSelect', 'legendselected', util.curry(legendSelectActionHandler, 'select'));
    /**
     * @event legendUnSelect
     * @type {Object}
     * @property {string} type 'legendUnSelect'
     * @property {string} name Series name or data item name
     */

    echarts.registerAction('legendUnSelect', 'legendunselected', util.curry(legendSelectActionHandler, 'unSelect'));

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var getLayoutRect$2 = layout.getLayoutRect;
    var layoutBox = layout.box;
    var positionElement$1 = layout.positionElement;





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Layout list like component.
     * It will box layout each items in group of component and then position the whole group in the viewport
     * @param {module:zrender/group/Group} group
     * @param {module:echarts/model/Component} componentModel
     * @param {module:echarts/ExtensionAPI}
     */
    function layout$4(group, componentModel, api) {
      var boxLayoutParams = componentModel.getBoxLayoutParams();
      var padding = componentModel.get('padding');
      var viewportSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var rect = getLayoutRect$2(boxLayoutParams, viewportSize, padding);
      layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);
      positionElement$1(group, boxLayoutParams, viewportSize, padding);
    }

    function makeBackground(rect, componentModel) {
      var padding = format$1.normalizeCssArray(componentModel.get('padding'));
      var style = componentModel.getItemStyle(['color', 'opacity']);
      style.fill = componentModel.get('backgroundColor');
      var rect = new graphic.Rect({
        shape: {
          x: rect.x - padding[3],
          y: rect.y - padding[0],
          width: rect.width + padding[1] + padding[3],
          height: rect.height + padding[0] + padding[2],
          r: componentModel.get('borderRadius')
        },
        style: style,
        silent: true,
        z2: -1
      }); // FIXME
      // `subPixelOptimizeRect` may bring some gap between edge of viewpart
      // and background rect when setting like `left: 0`, `top: 0`.
      // graphic.subPixelOptimizeRect(rect);

      return rect;
    }

    var layout_1$2 = layout$4;
    var makeBackground_1 = makeBackground;

    var listComponent = {
    	layout: layout_1$2,
    	makeBackground: makeBackground_1
    };

    var createSymbol$4 = symbol.createSymbol;





    var makeBackground$1 = listComponent.makeBackground;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var curry$2 = util.curry;
    var each$n = util.each;
    var Group$1 = graphic.Group;

    var _default$1S = echarts.extendComponentView({
      type: 'legend.plain',
      newlineDisabled: false,

      /**
       * @override
       */
      init: function () {
        /**
         * @private
         * @type {module:zrender/container/Group}
         */
        this.group.add(this._contentGroup = new Group$1());
        /**
         * @private
         * @type {module:zrender/Element}
         */

        this._backgroundEl;
        /**
         * @private
         * @type {module:zrender/container/Group}
         */

        this.group.add(this._selectorGroup = new Group$1());
        /**
         * If first rendering, `contentGroup.position` is [0, 0], which
         * does not make sense and may cause unexepcted animation if adopted.
         * @private
         * @type {boolean}
         */

        this._isFirstRender = true;
      },

      /**
       * @protected
       */
      getContentGroup: function () {
        return this._contentGroup;
      },

      /**
       * @protected
       */
      getSelectorGroup: function () {
        return this._selectorGroup;
      },

      /**
       * @override
       */
      render: function (legendModel, ecModel, api) {
        var isFirstRender = this._isFirstRender;
        this._isFirstRender = false;
        this.resetInner();

        if (!legendModel.get('show', true)) {
          return;
        }

        var itemAlign = legendModel.get('align');
        var orient = legendModel.get('orient');

        if (!itemAlign || itemAlign === 'auto') {
          itemAlign = legendModel.get('left') === 'right' && orient === 'vertical' ? 'right' : 'left';
        }

        var selector = legendModel.get('selector', true);
        var selectorPosition = legendModel.get('selectorPosition', true);

        if (selector && (!selectorPosition || selectorPosition === 'auto')) {
          selectorPosition = orient === 'horizontal' ? 'end' : 'start';
        }

        this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition); // Perform layout.

        var positionInfo = legendModel.getBoxLayoutParams();
        var viewportSize = {
          width: api.getWidth(),
          height: api.getHeight()
        };
        var padding = legendModel.get('padding');
        var maxSize = layout.getLayoutRect(positionInfo, viewportSize, padding);
        var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition); // Place mainGroup, based on the calculated `mainRect`.

        var layoutRect = layout.getLayoutRect(util.defaults({
          width: mainRect.width,
          height: mainRect.height
        }, positionInfo), viewportSize, padding);
        this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.

        this.group.add(this._backgroundEl = makeBackground$1(mainRect, legendModel));
      },

      /**
       * @protected
       */
      resetInner: function () {
        this.getContentGroup().removeAll();
        this._backgroundEl && this.group.remove(this._backgroundEl);
        this.getSelectorGroup().removeAll();
      },

      /**
       * @protected
       */
      renderInner: function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
        var contentGroup = this.getContentGroup();
        var legendDrawnMap = util.createHashMap();
        var selectMode = legendModel.get('selectedMode');
        var excludeSeriesId = [];
        ecModel.eachRawSeries(function (seriesModel) {
          !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);
        });
        each$n(legendModel.getData(), function (itemModel, dataIndex) {
          var name = itemModel.get('name'); // Use empty string or \n as a newline string

          if (!this.newlineDisabled && (name === '' || name === '\n')) {
            contentGroup.add(new Group$1({
              newline: true
            }));
            return;
          } // Representitive series.


          var seriesModel = ecModel.getSeriesByName(name)[0];

          if (legendDrawnMap.get(name)) {
            // Have been drawed
            return;
          } // Legend to control series.


          if (seriesModel) {
            var data = seriesModel.getData();
            var color = data.getVisual('color');
            var borderColor = data.getVisual('borderColor'); // If color is a callback function

            if (typeof color === 'function') {
              // Use the first data
              color = color(seriesModel.getDataParams(0));
            } // If borderColor is a callback function


            if (typeof borderColor === 'function') {
              // Use the first data
              borderColor = borderColor(seriesModel.getDataParams(0));
            } // Using rect symbol defaultly


            var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';
            var symbolType = data.getVisual('symbol');

            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, selectMode);

            itemGroup.on('click', curry$2(dispatchSelectAction, name, null, api, excludeSeriesId)).on('mouseover', curry$2(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on('mouseout', curry$2(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
            legendDrawnMap.set(name, true);
          } else {
            // Legend to control data. In pie and funnel.
            ecModel.eachRawSeries(function (seriesModel) {
              // In case multiple series has same data name
              if (legendDrawnMap.get(name)) {
                return;
              }

              if (seriesModel.legendVisualProvider) {
                var provider = seriesModel.legendVisualProvider;

                if (!provider.containName(name)) {
                  return;
                }

                var idx = provider.indexOfName(name);
                var color = provider.getItemVisual(idx, 'color');
                var borderColor = provider.getItemVisual(idx, 'borderColor');
                var legendSymbolType = 'roundRect';

                var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, borderColor, selectMode); // FIXME: consider different series has items with the same name.


                itemGroup.on('click', curry$2(dispatchSelectAction, null, name, api, excludeSeriesId)) // Should not specify the series name, consider legend controls
                // more than one pie series.
                .on('mouseover', curry$2(dispatchHighlightAction, null, name, api, excludeSeriesId)).on('mouseout', curry$2(dispatchDownplayAction, null, name, api, excludeSeriesId));
                legendDrawnMap.set(name, true);
              }
            }, this);
          }
        }, this);

        if (selector) {
          this._createSelector(selector, legendModel, api, orient, selectorPosition);
        }
      },
      _createSelector: function (selector, legendModel, api, orient, selectorPosition) {
        var selectorGroup = this.getSelectorGroup();
        each$n(selector, function (selectorItem) {
          createSelectorButton(selectorItem);
        });

        function createSelectorButton(selectorItem) {
          var type = selectorItem.type;
          var labelText = new graphic.Text({
            style: {
              x: 0,
              y: 0,
              align: 'center',
              verticalAlign: 'middle'
            },
            onclick: function () {
              api.dispatchAction({
                type: type === 'all' ? 'legendAllSelect' : 'legendInverseSelect'
              });
            }
          });
          selectorGroup.add(labelText);
          var labelModel = legendModel.getModel('selectorLabel');
          var emphasisLabelModel = legendModel.getModel('emphasis.selectorLabel');
          graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, emphasisLabelModel, {
            defaultText: selectorItem.title,
            isRectText: false
          });
          graphic.setHoverStyle(labelText);
        }
      },
      _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, selectMode) {
        var itemWidth = legendModel.get('itemWidth');
        var itemHeight = legendModel.get('itemHeight');
        var inactiveColor = legendModel.get('inactiveColor');
        var inactiveBorderColor = legendModel.get('inactiveBorderColor');
        var symbolKeepAspect = legendModel.get('symbolKeepAspect');
        var legendModelItemStyle = legendModel.getModel('itemStyle');
        var isSelected = legendModel.isSelected(name);
        var itemGroup = new Group$1();
        var textStyleModel = itemModel.getModel('textStyle');
        var itemIcon = itemModel.get('icon');
        var tooltipModel = itemModel.getModel('tooltip');
        var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first

        legendSymbolType = itemIcon || legendSymbolType;
        var legendSymbol = createSymbol$4(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend
        symbolKeepAspect == null ? true : symbolKeepAspect);
        itemGroup.add(setSymbolStyle(legendSymbol, legendSymbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected)); // Compose symbols
        // PENDING

        if (!itemIcon && symbolType // At least show one symbol, can't be all none
        && (symbolType !== legendSymbolType || symbolType === 'none')) {
          var size = itemHeight * 0.8;

          if (symbolType === 'none') {
            symbolType = 'circle';
          }

          var legendSymbolCenter = createSymbol$4(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend
          symbolKeepAspect == null ? true : symbolKeepAspect); // Put symbol in the center

          itemGroup.add(setSymbolStyle(legendSymbolCenter, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected));
        }

        var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
        var textAlign = itemAlign;
        var formatter = legendModel.get('formatter');
        var content = name;

        if (typeof formatter === 'string' && formatter) {
          content = formatter.replace('{name}', name != null ? name : '');
        } else if (typeof formatter === 'function') {
          content = formatter(name);
        }

        itemGroup.add(new graphic.Text({
          style: graphic.setTextStyle({}, textStyleModel, {
            text: content,
            x: textX,
            y: itemHeight / 2,
            textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
            textAlign: textAlign,
            textVerticalAlign: 'middle'
          })
        })); // Add a invisible rect to increase the area of mouse hover

        var hitRect = new graphic.Rect({
          shape: itemGroup.getBoundingRect(),
          invisible: true,
          tooltip: tooltipModel.get('show') ? util.extend({
            content: name,
            // Defaul formatter
            formatter: legendGlobalTooltipModel.get('formatter', true) || function () {
              return name;
            },
            formatterParams: {
              componentType: 'legend',
              legendIndex: legendModel.componentIndex,
              name: name,
              $vars: ['name']
            }
          }, tooltipModel.option) : null
        });
        itemGroup.add(hitRect);
        itemGroup.eachChild(function (child) {
          child.silent = true;
        });
        hitRect.silent = !selectMode;
        this.getContentGroup().add(itemGroup);
        graphic.setHoverStyle(itemGroup);
        itemGroup.__legendDataIndex = dataIndex;
        return itemGroup;
      },

      /**
       * @protected
       */
      layoutInner: function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        var contentGroup = this.getContentGroup();
        var selectorGroup = this.getSelectorGroup(); // Place items in contentGroup.

        layout.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);
        var contentRect = contentGroup.getBoundingRect();
        var contentPos = [-contentRect.x, -contentRect.y];

        if (selector) {
          // Place buttons in selectorGroup
          layout.box( // Buttons in selectorGroup always layout horizontally
          'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));
          var selectorRect = selectorGroup.getBoundingRect();
          var selectorPos = [-selectorRect.x, -selectorRect.y];
          var selectorButtonGap = legendModel.get('selectorButtonGap', true);
          var orientIdx = legendModel.getOrient().index;
          var wh = orientIdx === 0 ? 'width' : 'height';
          var hw = orientIdx === 0 ? 'height' : 'width';
          var yx = orientIdx === 0 ? 'y' : 'x';

          if (selectorPosition === 'end') {
            selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
          } else {
            contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
          } //Always align selector to content as 'middle'


          selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
          selectorGroup.attr('position', selectorPos);
          contentGroup.attr('position', contentPos);
          var mainRect = {
            x: 0,
            y: 0
          };
          mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
          mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
          mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
          return mainRect;
        } else {
          contentGroup.attr('position', contentPos);
          return this.group.getBoundingRect();
        }
      },

      /**
       * @protected
       */
      remove: function () {
        this.getContentGroup().removeAll();
        this._isFirstRender = true;
      }
    });

    function setSymbolStyle(symbol, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected) {
      var itemStyle;

      if (symbolType !== 'line' && symbolType.indexOf('empty') < 0) {
        itemStyle = legendModelItemStyle.getItemStyle();
        symbol.style.stroke = borderColor;

        if (!isSelected) {
          itemStyle.stroke = inactiveBorderColor;
        }
      } else {
        itemStyle = legendModelItemStyle.getItemStyle(['borderWidth', 'borderColor']);
      }

      return symbol.setStyle(itemStyle);
    }

    function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
      // downplay before unselect
      dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
      api.dispatchAction({
        type: 'legendToggleSelect',
        name: seriesName != null ? seriesName : dataName
      }); // highlight after select

      dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
    }

    function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
      // If element hover will move to a hoverLayer.
      var el = api.getZr().storage.getDisplayList()[0];

      if (!(el && el.useHoverLayer)) {
        api.dispatchAction({
          type: 'highlight',
          seriesName: seriesName,
          name: dataName,
          excludeSeriesId: excludeSeriesId
        });
      }
    }

    function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
      // If element hover will move to a hoverLayer.
      var el = api.getZr().storage.getDisplayList()[0];

      if (!(el && el.useHoverLayer)) {
        api.dispatchAction({
          type: 'downplay',
          seriesName: seriesName,
          name: dataName,
          excludeSeriesId: excludeSeriesId
        });
      }
    }

    var LegendView = _default$1S;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function _default$1T(ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: 'legend'
      });

      if (legendModels && legendModels.length) {
        ecModel.filterSeries(function (series) {
          // If in any legend component the status is not selected.
          // Because in legend series is assumed selected when it is not in the legend data.
          for (var i = 0; i < legendModels.length; i++) {
            if (!legendModels[i].isSelected(series.name)) {
              return false;
            }
          }

          return true;
        });
      }
    }

    var legendFilter = _default$1T;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */













    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // Do not contain scrollable legend, for sake of file size.
    // Series Filter
    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
    Component.registerSubTypeDefaulter('legend', function () {
      // Default 'plain' when no type specified.
      return 'plain';
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}
     * @param {module:echarts/model/Global} ecModel
     * @return {Object} {point: [x, y], el: ...} point Will not be null.
     */
    function _default$1U(finder, ecModel) {
      var point = [];
      var seriesIndex = finder.seriesIndex;
      var seriesModel;

      if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
        return {
          point: []
        };
      }

      var data = seriesModel.getData();
      var dataIndex = model.queryDataIndex(data, finder);

      if (dataIndex == null || dataIndex < 0 || util.isArray(dataIndex)) {
        return {
          point: []
        };
      }

      var el = data.getItemGraphicEl(dataIndex);
      var coordSys = seriesModel.coordinateSystem;

      if (seriesModel.getTooltipPosition) {
        point = seriesModel.getTooltipPosition(dataIndex) || [];
      } else if (coordSys && coordSys.dataToPoint) {
        point = coordSys.dataToPoint(data.getValues(util.map(coordSys.dimensions, function (dim) {
          return data.mapDimension(dim);
        }), dataIndex, true)) || [];
      } else if (el) {
        // Use graphic bounding rect
        var rect = el.getBoundingRect().clone();
        rect.applyTransform(el.transform);
        point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      }

      return {
        point: point,
        el: el
      };
    }

    var findPointFromSeries = _default$1U;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    var makeInner$7 = model.makeInner;





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var each$o = util.each;
    var curry$3 = util.curry;
    var inner$7 = makeInner$7();
    /**
     * Basic logic: check all axis, if they do not demand show/highlight,
     * then hide/downplay them.
     *
     * @param {Object} coordSysAxesInfo
     * @param {Object} payload
     * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'
     * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to
     *              trigger axisPointer and tooltip.
     * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to
     *              trigger axisPointer and tooltip.
     * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.
     * @param {Object} [payload.dataIndex] finder, restrict target axes.
     * @param {Object} [payload.axesInfo] finder, restrict target axes.
     *        [{
     *          axisDim: 'x'|'y'|'angle'|...,
     *          axisIndex: ...,
     *          value: ...
     *        }, ...]
     * @param {Function} [payload.dispatchAction]
     * @param {Object} [payload.tooltipOption]
     * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,
     *        which can be specified in dispatchAction
     * @param {module:echarts/model/Global} ecModel
     * @param {module:echarts/ExtensionAPI} api
     * @return {Object} content of event obj for echarts.connect.
     */

    function _default$1V(payload, ecModel, api) {
      var currTrigger = payload.currTrigger;
      var point = [payload.x, payload.y];
      var finder = payload;
      var dispatchAction = payload.dispatchAction || util.bind(api.dispatchAction, api);
      var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending
      // See #6121. But we are not able to reproduce it yet.

      if (!coordSysAxesInfo) {
        return;
      }

      if (illegalPoint(point)) {
        // Used in the default behavior of `connection`: use the sample seriesIndex
        // and dataIndex. And also used in the tooltipView trigger.
        point = findPointFromSeries({
          seriesIndex: finder.seriesIndex,
          // Do not use dataIndexInside from other ec instance.
          // FIXME: auto detect it?
          dataIndex: finder.dataIndex
        }, ecModel).point;
      }

      var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
      // Notice: In this case, it is difficult to get the `point` (which is necessary to show
      // tooltip, so if point is not given, we just use the point found by sample seriesIndex
      // and dataIndex.

      var inputAxesInfo = finder.axesInfo;
      var axesInfo = coordSysAxesInfo.axesInfo;
      var shouldHide = currTrigger === 'leave' || illegalPoint(point);
      var outputFinder = {};
      var showValueMap = {};
      var dataByCoordSys = {
        list: [],
        map: {}
      };
      var updaters = {
        showPointer: curry$3(showPointer, showValueMap),
        showTooltip: curry$3(showTooltip, dataByCoordSys)
      }; // Process for triggered axes.

      each$o(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
        // If a point given, it must be contained by the coordinate system.
        var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
        each$o(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
          var axis = axisInfo.axis;
          var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.

          if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
            var val = inputAxisInfo && inputAxisInfo.value;

            if (val == null && !isIllegalPoint) {
              val = axis.pointToData(point);
            }

            val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);
          }
        });
      }); // Process for linked axes.

      var linkTriggers = {};
      each$o(axesInfo, function (tarAxisInfo, tarKey) {
        var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.

        if (linkGroup && !showValueMap[tarKey]) {
          each$o(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
            var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.

            if (srcAxisInfo !== tarAxisInfo && srcValItem) {
              var val = srcValItem.value;
              linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
              linkTriggers[tarAxisInfo.key] = val;
            }
          });
        }
      });
      each$o(linkTriggers, function (val, tarKey) {
        processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);
      });
      updateModelActually(showValueMap, axesInfo, outputFinder);
      dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
      dispatchHighDownActually(axesInfo, dispatchAction, api);
      return outputFinder;
    }

    function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
      var axis = axisInfo.axis;

      if (axis.scale.isBlank() || !axis.containData(newValue)) {
        return;
      }

      if (!axisInfo.involveSeries) {
        updaters.showPointer(axisInfo, newValue);
        return;
      } // Heavy calculation. So put it after axis.containData checking.


      var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
      var payloadBatch = payloadInfo.payloadBatch;
      var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.
      // By defualt use the first involved series data as a sample to connect.

      if (payloadBatch[0] && outputFinder.seriesIndex == null) {
        util.extend(outputFinder, payloadBatch[0]);
      } // If no linkSource input, this process is for collecting link
      // target, where snap should not be accepted.


      if (!dontSnap && axisInfo.snap) {
        if (axis.containData(snapToValue) && snapToValue != null) {
          newValue = snapToValue;
        }
      }

      updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be
      // incorrect "axis value ~ series value" mapping displayed in tooltip.

      updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
    }

    function buildPayloadsBySeries(value, axisInfo) {
      var axis = axisInfo.axis;
      var dim = axis.dim;
      var snapToValue = value;
      var payloadBatch = [];
      var minDist = Number.MAX_VALUE;
      var minDiff = -1;
      each$o(axisInfo.seriesModels, function (series, idx) {
        var dataDim = series.getData().mapDimension(dim, true);
        var seriesNestestValue;
        var dataIndices;

        if (series.getAxisTooltipData) {
          var result = series.getAxisTooltipData(dataDim, value, axis);
          dataIndices = result.dataIndices;
          seriesNestestValue = result.nestestValue;
        } else {
          dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex
          // when data length is not same.
          // false,
          axis.type === 'category' ? 0.5 : null);

          if (!dataIndices.length) {
            return;
          }

          seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
        }

        if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
          return;
        }

        var diff = value - seriesNestestValue;
        var dist = Math.abs(diff); // Consider category case

        if (dist <= minDist) {
          if (dist < minDist || diff >= 0 && minDiff < 0) {
            minDist = dist;
            minDiff = diff;
            snapToValue = seriesNestestValue;
            payloadBatch.length = 0;
          }

          each$o(dataIndices, function (dataIndex) {
            payloadBatch.push({
              seriesIndex: series.seriesIndex,
              dataIndexInside: dataIndex,
              dataIndex: series.getData().getRawIndex(dataIndex)
            });
          });
        }
      });
      return {
        payloadBatch: payloadBatch,
        snapToValue: snapToValue
      };
    }

    function showPointer(showValueMap, axisInfo, value, payloadBatch) {
      showValueMap[axisInfo.key] = {
        value: value,
        payloadBatch: payloadBatch
      };
    }

    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
      var payloadBatch = payloadInfo.payloadBatch;
      var axis = axisInfo.axis;
      var axisModel = axis.model;
      var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,
      // whose length will be used to judge whether dispatch action.

      if (!axisInfo.triggerTooltip || !payloadBatch.length) {
        return;
      }

      var coordSysModel = axisInfo.coordSys.model;
      var coordSysKey = modelHelper.makeKey(coordSysModel);
      var coordSysItem = dataByCoordSys.map[coordSysKey];

      if (!coordSysItem) {
        coordSysItem = dataByCoordSys.map[coordSysKey] = {
          coordSysId: coordSysModel.id,
          coordSysIndex: coordSysModel.componentIndex,
          coordSysType: coordSysModel.type,
          coordSysMainType: coordSysModel.mainType,
          dataByAxis: []
        };
        dataByCoordSys.list.push(coordSysItem);
      }

      coordSysItem.dataByAxis.push({
        axisDim: axis.dim,
        axisIndex: axisModel.componentIndex,
        axisType: axisModel.type,
        axisId: axisModel.id,
        value: value,
        // Caustion: viewHelper.getValueLabel is actually on "view stage", which
        // depends that all models have been updated. So it should not be performed
        // here. Considering axisPointerModel used here is volatile, which is hard
        // to be retrieve in TooltipView, we prepare parameters here.
        valueLabelOpt: {
          precision: axisPointerModel.get('label.precision'),
          formatter: axisPointerModel.get('label.formatter')
        },
        seriesDataIndices: payloadBatch.slice()
      });
    }

    function updateModelActually(showValueMap, axesInfo, outputFinder) {
      var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.

      each$o(axesInfo, function (axisInfo, key) {
        var option = axisInfo.axisPointerModel.option;
        var valItem = showValueMap[key];

        if (valItem) {
          !axisInfo.useHandle && (option.status = 'show');
          option.value = valItem.value; // For label formatter param and highlight.

          option.seriesDataIndices = (valItem.payloadBatch || []).slice();
        } // When always show (e.g., handle used), remain
        // original value and status.
        else {
            // If hide, value still need to be set, consider
            // click legend to toggle axis blank.
            !axisInfo.useHandle && (option.status = 'hide');
          } // If status is 'hide', should be no info in payload.


        option.status === 'show' && outputAxesInfo.push({
          axisDim: axisInfo.axis.dim,
          axisIndex: axisInfo.axis.model.componentIndex,
          value: option.value
        });
      });
    }

    function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
      // Basic logic: If no showTip required, hideTip will be dispatched.
      if (illegalPoint(point) || !dataByCoordSys.list.length) {
        dispatchAction({
          type: 'hideTip'
        });
        return;
      } // In most case only one axis (or event one series is used). It is
      // convinient to fetch payload.seriesIndex and payload.dataIndex
      // dirtectly. So put the first seriesIndex and dataIndex of the first
      // axis on the payload.


      var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
      dispatchAction({
        type: 'showTip',
        escapeConnect: true,
        x: point[0],
        y: point[1],
        tooltipOption: payload.tooltipOption,
        position: payload.position,
        dataIndexInside: sampleItem.dataIndexInside,
        dataIndex: sampleItem.dataIndex,
        seriesIndex: sampleItem.seriesIndex,
        dataByCoordSys: dataByCoordSys.list
      });
    }

    function dispatchHighDownActually(axesInfo, dispatchAction, api) {
      // FIXME
      // highlight status modification shoule be a stage of main process?
      // (Consider confilct (e.g., legend and axisPointer) and setOption)
      var zr = api.getZr();
      var highDownKey = 'axisPointerLastHighlights';
      var lastHighlights = inner$7(zr)[highDownKey] || {};
      var newHighlights = inner$7(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.
      // Build hash map and remove duplicate incidentally.

      each$o(axesInfo, function (axisInfo, key) {
        var option = axisInfo.axisPointerModel.option;
        option.status === 'show' && each$o(option.seriesDataIndices, function (batchItem) {
          var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;
          newHighlights[key] = batchItem;
        });
      }); // Diff.

      var toHighlight = [];
      var toDownplay = [];
      util.each(lastHighlights, function (batchItem, key) {
        !newHighlights[key] && toDownplay.push(batchItem);
      });
      util.each(newHighlights, function (batchItem, key) {
        !lastHighlights[key] && toHighlight.push(batchItem);
      });
      toDownplay.length && api.dispatchAction({
        type: 'downplay',
        escapeConnect: true,
        batch: toDownplay
      });
      toHighlight.length && api.dispatchAction({
        type: 'highlight',
        escapeConnect: true,
        batch: toHighlight
      });
    }

    function findInputAxisInfo(inputAxesInfo, axisInfo) {
      for (var i = 0; i < (inputAxesInfo || []).length; i++) {
        var inputAxisInfo = inputAxesInfo[i];

        if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
          return inputAxisInfo;
        }
      }
    }

    function makeMapperParam(axisInfo) {
      var axisModel = axisInfo.axis.model;
      var item = {};
      var dim = item.axisDim = axisInfo.axis.dim;
      item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;
      item.axisName = item[dim + 'AxisName'] = axisModel.name;
      item.axisId = item[dim + 'AxisId'] = axisModel.id;
      return item;
    }

    function illegalPoint(point) {
      return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
    }

    var axisTrigger = _default$1V;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var AxisPointerModel = echarts.extendComponentModel({
      type: 'axisPointer',
      coordSysAxesInfo: null,
      defaultOption: {
        // 'auto' means that show when triggered by tooltip or handle.
        show: 'auto',
        // 'click' | 'mousemove' | 'none'
        triggerOn: null,
        // set default in AxisPonterView.js
        zlevel: 0,
        z: 50,
        type: 'line',
        // 'line' 'shadow' 'cross' 'none'.
        // axispointer triggered by tootip determine snap automatically,
        // see `modelHelper`.
        snap: false,
        triggerTooltip: true,
        value: null,
        status: null,
        // Init value depends on whether handle is used.
        // [group0, group1, ...]
        // Each group can be: {
        //      mapper: function () {},
        //      singleTooltip: 'multiple',  // 'multiple' or 'single'
        //      xAxisId: ...,
        //      yAxisName: ...,
        //      angleAxisIndex: ...
        // }
        // mapper: can be ignored.
        //      input: {axisInfo, value}
        //      output: {axisInfo, value}
        link: [],
        // Do not set 'auto' here, otherwise global animation: false
        // will not effect at this axispointer.
        animation: null,
        animationDurationUpdate: 200,
        lineStyle: {
          color: '#aaa',
          width: 1,
          type: 'solid'
        },
        shadowStyle: {
          color: 'rgba(150,150,150,0.3)'
        },
        label: {
          show: true,
          formatter: null,
          // string | Function
          precision: 'auto',
          // Or a number like 0, 1, 2 ...
          margin: 3,
          color: '#fff',
          padding: [5, 7, 5, 7],
          backgroundColor: 'auto',
          // default: axis line color
          borderColor: null,
          borderWidth: 0,
          shadowBlur: 3,
          shadowColor: '#aaa' // Considering applicability, common style should
          // better not have shadowOffset.
          // shadowOffsetX: 0,
          // shadowOffsetY: 2

        },
        handle: {
          show: false,

          /* eslint-disable */
          icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
          // jshint ignore:line

          /* eslint-enable */
          size: 45,
          // handle margin is from symbol center to axis, which is stable when circular move.
          margin: 50,
          // color: '#1b8bbd'
          // color: '#2f4554'
          color: '#333',
          shadowBlur: 3,
          shadowColor: '#aaa',
          shadowOffsetX: 0,
          shadowOffsetY: 2,
          // For mobile performance
          throttle: 40
        }
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var makeInner$8 = model.makeInner;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var inner$8 = makeInner$8();
    var each$p = util.each;
    /**
     * @param {string} key
     * @param {module:echarts/ExtensionAPI} api
     * @param {Function} handler
     *      param: {string} currTrigger
     *      param: {Array.<number>} point
     */

    function register(key, api, handler) {
      if (env_1.node) {
        return;
      }

      var zr = api.getZr();
      inner$8(zr).records || (inner$8(zr).records = {});
      initGlobalListeners(zr, api);
      var record = inner$8(zr).records[key] || (inner$8(zr).records[key] = {});
      record.handler = handler;
    }

    function initGlobalListeners(zr, api) {
      if (inner$8(zr).initialized) {
        return;
      }

      inner$8(zr).initialized = true;
      useHandler('click', util.curry(doEnter, 'click'));
      useHandler('mousemove', util.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);

      useHandler('globalout', onLeave);

      function useHandler(eventType, cb) {
        zr.on(eventType, function (e) {
          var dis = makeDispatchAction(api);
          each$p(inner$8(zr).records, function (record) {
            record && cb(record, e, dis.dispatchAction);
          });
          dispatchTooltipFinally(dis.pendings, api);
        });
      }
    }

    function dispatchTooltipFinally(pendings, api) {
      var showLen = pendings.showTip.length;
      var hideLen = pendings.hideTip.length;
      var actuallyPayload;

      if (showLen) {
        actuallyPayload = pendings.showTip[showLen - 1];
      } else if (hideLen) {
        actuallyPayload = pendings.hideTip[hideLen - 1];
      }

      if (actuallyPayload) {
        actuallyPayload.dispatchAction = null;
        api.dispatchAction(actuallyPayload);
      }
    }

    function onLeave(record, e, dispatchAction) {
      record.handler('leave', null, dispatchAction);
    }

    function doEnter(currTrigger, record, e, dispatchAction) {
      record.handler(currTrigger, e, dispatchAction);
    }

    function makeDispatchAction(api) {
      var pendings = {
        showTip: [],
        hideTip: []
      }; // FIXME
      // better approach?
      // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
      // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
      // So we have to add "final stage" to merge those dispatched actions.

      var dispatchAction = function (payload) {
        var pendingList = pendings[payload.type];

        if (pendingList) {
          pendingList.push(payload);
        } else {
          payload.dispatchAction = dispatchAction;
          api.dispatchAction(payload);
        }
      };

      return {
        dispatchAction: dispatchAction,
        pendings: pendings
      };
    }
    /**
     * @param {string} key
     * @param {module:echarts/ExtensionAPI} api
     */


    function unregister(key, api) {
      if (env_1.node) {
        return;
      }

      var zr = api.getZr();
      var record = (inner$8(zr).records || {})[key];

      if (record) {
        inner$8(zr).records[key] = null;
      }
    }

    var register_1 = register;
    var unregister_1 = unregister;

    var globalListener = {
    	register: register_1,
    	unregister: unregister_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var AxisPointerView = echarts.extendComponentView({
      type: 'axisPointer',
      render: function (globalAxisPointerModel, ecModel, api) {
        var globalTooltipModel = ecModel.getComponent('tooltip');
        var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable
        // AxisPointerView to be independent to Tooltip.

        globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {
          // If 'none', it is not controlled by mouse totally.
          if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
            dispatchAction({
              type: 'updateAxisPointer',
              currTrigger: currTrigger,
              x: e && e.offsetX,
              y: e && e.offsetY
            });
          }
        });
      },

      /**
       * @override
       */
      remove: function (ecModel, api) {
        globalListener.unregister(api.getZr(), 'axisPointer');
        AxisPointerView.superApply(this._model, 'remove', arguments);
      },

      /**
       * @override
       */
      dispose: function (ecModel, api) {
        globalListener.unregister('axisPointer', api);
        AxisPointerView.superApply(this._model, 'dispose', arguments);
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */















    var makeInner$9 = model.makeInner;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var inner$9 = makeInner$9();
    var clone$7 = util.clone;
    var bind$2 = util.bind;
    /**
     * Base axis pointer class in 2D.
     * Implemenents {module:echarts/component/axis/IAxisPointer}.
     */

    function BaseAxisPointer() {}

    BaseAxisPointer.prototype = {
      /**
       * @private
       */
      _group: null,

      /**
       * @private
       */
      _lastGraphicKey: null,

      /**
       * @private
       */
      _handle: null,

      /**
       * @private
       */
      _dragging: false,

      /**
       * @private
       */
      _lastValue: null,

      /**
       * @private
       */
      _lastStatus: null,

      /**
       * @private
       */
      _payloadInfo: null,

      /**
       * In px, arbitrary value. Do not set too small,
       * no animation is ok for most cases.
       * @protected
       */
      animationThreshold: 15,

      /**
       * @implement
       */
      render: function (axisModel, axisPointerModel, api, forceRender) {
        var value = axisPointerModel.get('value');
        var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not
        // be replaced when user calling setOption in not merge mode.

        this._axisModel = axisModel;
        this._axisPointerModel = axisPointerModel;
        this._api = api; // Optimize: `render` will be called repeatly during mouse move.
        // So it is power consuming if performing `render` each time,
        // especially on mobile device.

        if (!forceRender && this._lastValue === value && this._lastStatus === status) {
          return;
        }

        this._lastValue = value;
        this._lastStatus = status;
        var group = this._group;
        var handle = this._handle;

        if (!status || status === 'hide') {
          // Do not clear here, for animation better.
          group && group.hide();
          handle && handle.hide();
          return;
        }

        group && group.show();
        handle && handle.show(); // Otherwise status is 'show'

        var elOption = {};
        this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.

        var graphicKey = elOption.graphicKey;

        if (graphicKey !== this._lastGraphicKey) {
          this.clear(api);
        }

        this._lastGraphicKey = graphicKey;
        var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);

        if (!group) {
          group = this._group = new graphic.Group();
          this.createPointerEl(group, elOption, axisModel, axisPointerModel);
          this.createLabelEl(group, elOption, axisModel, axisPointerModel);
          api.getZr().add(group);
        } else {
          var doUpdateProps = util.curry(updateProps$1, axisPointerModel, moveAnimation);
          this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);
          this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
        }

        updateMandatoryProps(group, axisPointerModel, true);

        this._renderHandle(value);
      },

      /**
       * @implement
       */
      remove: function (api) {
        this.clear(api);
      },

      /**
       * @implement
       */
      dispose: function (api) {
        this.clear(api);
      },

      /**
       * @protected
       */
      determineAnimation: function (axisModel, axisPointerModel) {
        var animation = axisPointerModel.get('animation');
        var axis = axisModel.axis;
        var isCategoryAxis = axis.type === 'category';
        var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.

        if (!useSnap && !isCategoryAxis) {
          return false;
        }

        if (animation === 'auto' || animation == null) {
          var animationThreshold = this.animationThreshold;

          if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
            return true;
          } // It is important to auto animation when snap used. Consider if there is
          // a dataZoom, animation will be disabled when too many points exist, while
          // it will be enabled for better visual effect when little points exist.


          if (useSnap) {
            var seriesDataCount = modelHelper.getAxisInfo(axisModel).seriesDataCount;
            var axisExtent = axis.getExtent(); // Approximate band width

            return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
          }

          return false;
        }

        return animation === true;
      },

      /**
       * add {pointer, label, graphicKey} to elOption
       * @protected
       */
      makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.
      },

      /**
       * @protected
       */
      createPointerEl: function (group, elOption, axisModel, axisPointerModel) {
        var pointerOption = elOption.pointer;

        if (pointerOption) {
          var pointerEl = inner$9(group).pointerEl = new graphic[pointerOption.type](clone$7(elOption.pointer));
          group.add(pointerEl);
        }
      },

      /**
       * @protected
       */
      createLabelEl: function (group, elOption, axisModel, axisPointerModel) {
        if (elOption.label) {
          var labelEl = inner$9(group).labelEl = new graphic.Rect(clone$7(elOption.label));
          group.add(labelEl);
          updateLabelShowHide(labelEl, axisPointerModel);
        }
      },

      /**
       * @protected
       */
      updatePointerEl: function (group, elOption, updateProps) {
        var pointerEl = inner$9(group).pointerEl;

        if (pointerEl && elOption.pointer) {
          pointerEl.setStyle(elOption.pointer.style);
          updateProps(pointerEl, {
            shape: elOption.pointer.shape
          });
        }
      },

      /**
       * @protected
       */
      updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {
        var labelEl = inner$9(group).labelEl;

        if (labelEl) {
          labelEl.setStyle(elOption.label.style);
          updateProps(labelEl, {
            // Consider text length change in vertical axis, animation should
            // be used on shape, otherwise the effect will be weird.
            shape: elOption.label.shape,
            position: elOption.label.position
          });
          updateLabelShowHide(labelEl, axisPointerModel);
        }
      },

      /**
       * @private
       */
      _renderHandle: function (value) {
        if (this._dragging || !this.updateHandleTransform) {
          return;
        }

        var axisPointerModel = this._axisPointerModel;

        var zr = this._api.getZr();

        var handle = this._handle;
        var handleModel = axisPointerModel.getModel('handle');
        var status = axisPointerModel.get('status');

        if (!handleModel.get('show') || !status || status === 'hide') {
          handle && zr.remove(handle);
          this._handle = null;
          return;
        }

        var isInit;

        if (!this._handle) {
          isInit = true;
          handle = this._handle = graphic.createIcon(handleModel.get('icon'), {
            cursor: 'move',
            draggable: true,
            onmousemove: function (e) {
              // Fot mobile devicem, prevent screen slider on the button.
              event.stop(e.event);
            },
            onmousedown: bind$2(this._onHandleDragMove, this, 0, 0),
            drift: bind$2(this._onHandleDragMove, this),
            ondragend: bind$2(this._onHandleDragEnd, this)
          });
          zr.add(handle);
        }

        updateMandatoryProps(handle, axisPointerModel, false); // update style

        var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];
        handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position

        var handleSize = handleModel.get('size');

        if (!util.isArray(handleSize)) {
          handleSize = [handleSize, handleSize];
        }

        handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);
        throttle_1.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');

        this._moveHandleToValue(value, isInit);
      },

      /**
       * @private
       */
      _moveHandleToValue: function (value, isInit) {
        updateProps$1(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
      },

      /**
       * @private
       */
      _onHandleDragMove: function (dx, dy) {
        var handle = this._handle;

        if (!handle) {
          return;
        }

        this._dragging = true; // Persistent for throttle.

        var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
        this._payloadInfo = trans;
        handle.stopAnimation();
        handle.attr(getHandleTransProps(trans));
        inner$9(handle).lastProp = null;

        this._doDispatchAxisPointer();
      },

      /**
       * Throttled method.
       * @private
       */
      _doDispatchAxisPointer: function () {
        var handle = this._handle;

        if (!handle) {
          return;
        }

        var payloadInfo = this._payloadInfo;
        var axisModel = this._axisModel;

        this._api.dispatchAction({
          type: 'updateAxisPointer',
          x: payloadInfo.cursorPoint[0],
          y: payloadInfo.cursorPoint[1],
          tooltipOption: payloadInfo.tooltipOption,
          axesInfo: [{
            axisDim: axisModel.axis.dim,
            axisIndex: axisModel.componentIndex
          }]
        });
      },

      /**
       * @private
       */
      _onHandleDragEnd: function (moveAnimation) {
        this._dragging = false;
        var handle = this._handle;

        if (!handle) {
          return;
        }

        var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with
        // axisPointer. So move handle to align the exact value position when
        // drag ended.


        this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle
        // button, and will be hidden after finger left handle button.


        this._api.dispatchAction({
          type: 'hideTip'
        });
      },

      /**
       * Should be implemenented by sub-class if support `handle`.
       * @protected
       * @param {number} value
       * @param {module:echarts/model/Model} axisModel
       * @param {module:echarts/model/Model} axisPointerModel
       * @return {Object} {position: [x, y], rotation: 0}
       */
      getHandleTransform: null,

      /**
       * * Should be implemenented by sub-class if support `handle`.
       * @protected
       * @param {Object} transform {position, rotation}
       * @param {Array.<number>} delta [dx, dy]
       * @param {module:echarts/model/Model} axisModel
       * @param {module:echarts/model/Model} axisPointerModel
       * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}
       */
      updateHandleTransform: null,

      /**
       * @private
       */
      clear: function (api) {
        this._lastValue = null;
        this._lastStatus = null;
        var zr = api.getZr();
        var group = this._group;
        var handle = this._handle;

        if (zr && group) {
          this._lastGraphicKey = null;
          group && zr.remove(group);
          handle && zr.remove(handle);
          this._group = null;
          this._handle = null;
          this._payloadInfo = null;
        }
      },

      /**
       * @protected
       */
      doClear: function () {// Implemented by sub-class if necessary.
      },

      /**
       * @protected
       * @param {Array.<number>} xy
       * @param {Array.<number>} wh
       * @param {number} [xDimIndex=0] or 1
       */
      buildLabel: function (xy, wh, xDimIndex) {
        xDimIndex = xDimIndex || 0;
        return {
          x: xy[xDimIndex],
          y: xy[1 - xDimIndex],
          width: wh[xDimIndex],
          height: wh[1 - xDimIndex]
        };
      }
    };
    BaseAxisPointer.prototype.constructor = BaseAxisPointer;

    function updateProps$1(animationModel, moveAnimation, el, props) {
      // Animation optimize.
      if (!propsEqual(inner$9(el).lastProp, props)) {
        inner$9(el).lastProp = props;
        moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
      }
    }

    function propsEqual(lastProps, newProps) {
      if (util.isObject(lastProps) && util.isObject(newProps)) {
        var equals = true;
        util.each(newProps, function (item, key) {
          equals = equals && propsEqual(lastProps[key], item);
        });
        return !!equals;
      } else {
        return lastProps === newProps;
      }
    }

    function updateLabelShowHide(labelEl, axisPointerModel) {
      labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();
    }

    function getHandleTransProps(trans) {
      return {
        position: trans.position.slice(),
        rotation: trans.rotation || 0
      };
    }

    function updateMandatoryProps(group, axisPointerModel, silent) {
      var z = axisPointerModel.get('z');
      var zlevel = axisPointerModel.get('zlevel');
      group && group.traverse(function (el) {
        if (el.type !== 'group') {
          z != null && (el.z = z);
          zlevel != null && (el.zlevel = zlevel);
          el.silent = silent;
        }
      });
    }

    clazz.enableClassExtend(BaseAxisPointer);
    var _default$1W = BaseAxisPointer;
    var BaseAxisPointer_1 = _default$1W;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */















    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @param {module:echarts/model/Model} axisPointerModel
     */
    function buildElStyle(axisPointerModel) {
      var axisPointerType = axisPointerModel.get('type');
      var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');
      var style;

      if (axisPointerType === 'line') {
        style = styleModel.getLineStyle();
        style.fill = null;
      } else if (axisPointerType === 'shadow') {
        style = styleModel.getAreaStyle();
        style.stroke = null;
      }

      return style;
    }
    /**
     * @param {Function} labelPos {align, verticalAlign, position}
     */


    function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
      var value = axisPointerModel.get('value');
      var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
        precision: axisPointerModel.get('label.precision'),
        formatter: axisPointerModel.get('label.formatter')
      });
      var labelModel = axisPointerModel.getModel('label');
      var paddings = format$1.normalizeCssArray(labelModel.get('padding') || 0);
      var font = labelModel.getFont();
      var textRect = text$1.getBoundingRect(text, font);
      var position = labelPos.position;
      var width = textRect.width + paddings[1] + paddings[3];
      var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.

      var align = labelPos.align;
      align === 'right' && (position[0] -= width);
      align === 'center' && (position[0] -= width / 2);
      var verticalAlign = labelPos.verticalAlign;
      verticalAlign === 'bottom' && (position[1] -= height);
      verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container

      confineInContainer(position, width, height, api);
      var bgColor = labelModel.get('backgroundColor');

      if (!bgColor || bgColor === 'auto') {
        bgColor = axisModel.get('axisLine.lineStyle.color');
      }

      elOption.label = {
        shape: {
          x: 0,
          y: 0,
          width: width,
          height: height,
          r: labelModel.get('borderRadius')
        },
        position: position.slice(),
        // TODO: rich
        style: {
          text: text,
          textFont: font,
          textFill: labelModel.getTextColor(),
          textPosition: 'inside',
          textPadding: paddings,
          fill: bgColor,
          stroke: labelModel.get('borderColor') || 'transparent',
          lineWidth: labelModel.get('borderWidth') || 0,
          shadowBlur: labelModel.get('shadowBlur'),
          shadowColor: labelModel.get('shadowColor'),
          shadowOffsetX: labelModel.get('shadowOffsetX'),
          shadowOffsetY: labelModel.get('shadowOffsetY')
        },
        // Lable should be over axisPointer.
        z2: 10
      };
    } // Do not overflow ec container


    function confineInContainer(position, width, height, api) {
      var viewWidth = api.getWidth();
      var viewHeight = api.getHeight();
      position[0] = Math.min(position[0] + width, viewWidth) - width;
      position[1] = Math.min(position[1] + height, viewHeight) - height;
      position[0] = Math.max(position[0], 0);
      position[1] = Math.max(position[1], 0);
    }
    /**
     * @param {number} value
     * @param {module:echarts/coord/Axis} axis
     * @param {module:echarts/model/Global} ecModel
     * @param {Object} opt
     * @param {Array.<Object>} seriesDataIndices
     * @param {number|string} opt.precision 'auto' or a number
     * @param {string|Function} opt.formatter label formatter
     */


    function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
      value = axis.scale.parse(value);
      var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which
      // helps to debounce when when moving label.
      value, {
        precision: opt.precision
      });
      var formatter = opt.formatter;

      if (formatter) {
        var params = {
          value: axisHelper.getAxisRawValue(axis, value),
          axisDimension: axis.dim,
          axisIndex: axis.index,
          seriesData: []
        };
        util.each(seriesDataIndices, function (idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var dataParams = series && series.getDataParams(dataIndex);
          dataParams && params.seriesData.push(dataParams);
        });

        if (util.isString(formatter)) {
          text = formatter.replace('{value}', text);
        } else if (util.isFunction(formatter)) {
          text = formatter(params);
        }
      }

      return text;
    }
    /**
     * @param {module:echarts/coord/Axis} axis
     * @param {number} value
     * @param {Object} layoutInfo {
     *  rotation, position, labelOffset, labelDirection, labelMargin
     * }
     */


    function getTransformedPosition(axis, value, layoutInfo) {
      var transform = matrix.create();
      matrix.rotate(transform, transform, layoutInfo.rotation);
      matrix.translate(transform, transform, layoutInfo.position);
      return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
    }

    function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
      var textLayout = AxisBuilder_1.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
      layoutInfo.labelMargin = axisPointerModel.get('label.margin');
      buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
        position: getTransformedPosition(axisModel.axis, value, layoutInfo),
        align: textLayout.textAlign,
        verticalAlign: textLayout.textVerticalAlign
      });
    }
    /**
     * @param {Array.<number>} p1
     * @param {Array.<number>} p2
     * @param {number} [xDimIndex=0] or 1
     */


    function makeLineShape(p1, p2, xDimIndex) {
      xDimIndex = xDimIndex || 0;
      return {
        x1: p1[xDimIndex],
        y1: p1[1 - xDimIndex],
        x2: p2[xDimIndex],
        y2: p2[1 - xDimIndex]
      };
    }
    /**
     * @param {Array.<number>} xy
     * @param {Array.<number>} wh
     * @param {number} [xDimIndex=0] or 1
     */


    function makeRectShape(xy, wh, xDimIndex) {
      xDimIndex = xDimIndex || 0;
      return {
        x: xy[xDimIndex],
        y: xy[1 - xDimIndex],
        width: wh[xDimIndex],
        height: wh[1 - xDimIndex]
      };
    }

    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
      return {
        cx: cx,
        cy: cy,
        r0: r0,
        r: r,
        startAngle: startAngle,
        endAngle: endAngle,
        clockwise: true
      };
    }

    var buildElStyle_1 = buildElStyle;
    var buildLabelElOption_1 = buildLabelElOption;
    var getValueLabel_1 = getValueLabel;
    var getTransformedPosition_1 = getTransformedPosition;
    var buildCartesianSingleLabelElOption_1 = buildCartesianSingleLabelElOption;
    var makeLineShape_1 = makeLineShape;
    var makeRectShape_1 = makeRectShape;
    var makeSectorShape_1 = makeSectorShape;

    var viewHelper = {
    	buildElStyle: buildElStyle_1,
    	buildLabelElOption: buildLabelElOption_1,
    	getValueLabel: getValueLabel_1,
    	getTransformedPosition: getTransformedPosition_1,
    	buildCartesianSingleLabelElOption: buildCartesianSingleLabelElOption_1,
    	makeLineShape: makeLineShape_1,
    	makeRectShape: makeRectShape_1,
    	makeSectorShape: makeSectorShape_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var CartesianAxisPointer = BaseAxisPointer_1.extend({
      /**
       * @override
       */
      makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisPointerType = axisPointerModel.get('type');
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));

        if (axisPointerType && axisPointerType !== 'none') {
          var elStyle = viewHelper.buildElStyle(axisPointerModel);
          var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
          pointerOption.style = elStyle;
          elOption.graphicKey = pointerOption.type;
          elOption.pointer = pointerOption;
        }

        var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);
        viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
      },

      /**
       * @override
       */
      getHandleTransform: function (value, axisModel, axisPointerModel) {
        var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {
          labelInside: false
        });
        layoutInfo.labelMargin = axisPointerModel.get('handle.margin');
        return {
          position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
        };
      },

      /**
       * @override
       */
      updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisExtent = axis.getGlobalExtent(true);
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var dimIndex = axis.dim === 'x' ? 0 : 1;
        var currPosition = transform.position;
        currPosition[dimIndex] += delta[dimIndex];
        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
        var cursorPoint = [cursorOtherValue, cursorOtherValue];
        cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.

        var tooltipOptions = [{
          verticalAlign: 'middle'
        }, {
          align: 'center'
        }];
        return {
          position: currPosition,
          rotation: transform.rotation,
          cursorPoint: cursorPoint,
          tooltipOption: tooltipOptions[dimIndex]
        };
      }
    });

    function getCartesian(grid, axis) {
      var opt = {};
      opt[axis.dim + 'AxisIndex'] = axis.index;
      return grid.getCartesian(opt);
    }

    var pointerShapeBuilder = {
      line: function (axis, pixelValue, otherExtent) {
        var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
        return {
          type: 'Line',
          subPixelOptimize: true,
          shape: targetShape
        };
      },
      shadow: function (axis, pixelValue, otherExtent) {
        var bandWidth = Math.max(1, axis.getBandWidth());
        var span = otherExtent[1] - otherExtent[0];
        return {
          type: 'Rect',
          shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
        };
      }
    };

    function getAxisDimIndex(axis) {
      return axis.dim === 'x' ? 0 : 1;
    }

    AxisView_1.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */















    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // CartesianAxisPointer is not supposed to be required here. But consider
    // echarts.simple.js and online build tooltip, which only require gridSimple,
    // CartesianAxisPointer should be able to required somewhere.
    echarts.registerPreprocessor(function (option) {
      // Always has a global axisPointerModel for default setting.
      if (option) {
        (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
        var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link
        // is not set, remain null/undefined, otherwise it will
        // override existent link setting.

        if (link && !util.isArray(link)) {
          option.axisPointer.link = [link];
        }
      }
    }); // This process should proformed after coordinate systems created
    // and series data processed. So put it on statistic processing stage.

    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
      // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
      // allAxesInfo should be updated when setOption performed.
      ecModel.getComponent('axisPointer').coordSysAxesInfo = modelHelper.collect(ecModel, api);
    }); // Broadcast to all views.

    echarts.registerAction({
      type: 'updateAxisPointer',
      event: 'updateAxisPointer',
      update: ':updateAxisPointer'
    }, axisTrigger);

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var _default$1X = echarts.extendComponentModel({
      type: 'tooltip',
      dependencies: ['axisPointer'],
      defaultOption: {
        zlevel: 0,
        z: 60,
        show: true,
        // tooltip主体内容
        showContent: true,
        // 'trigger' only works on coordinate system.
        // 'item' | 'axis' | 'none'
        trigger: 'item',
        // 'click' | 'mousemove' | 'none'
        triggerOn: 'mousemove|click',
        alwaysShowContent: false,
        displayMode: 'single',
        // 'single' | 'multipleByCoordSys'
        renderMode: 'auto',
        // 'auto' | 'html' | 'richText'
        // 'auto': use html by default, and use non-html if `document` is not defined
        // 'html': use html for tooltip
        // 'richText': use canvas, svg, and etc. for tooltip
        // 位置 {Array} | {Function}
        // position: null
        // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
        // align: null,
        // verticalAlign: null,
        // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。
        confine: false,
        // 内容格式器：{string}（Template） ¦ {Function}
        // formatter: null
        showDelay: 0,
        // 隐藏延迟，单位ms
        hideDelay: 100,
        // 动画变换时间，单位s
        transitionDuration: 0.4,
        enterable: false,
        // 提示背景颜色，默认为透明度为0.7的黑色
        backgroundColor: 'rgba(50,50,50,0.7)',
        // 提示边框颜色
        borderColor: '#333',
        // 提示边框圆角，单位px，默认为4
        borderRadius: 4,
        // 提示边框线宽，单位px，默认为0（无边框）
        borderWidth: 0,
        // 提示内边距，单位px，默认各方向内边距为5，
        // 接受数组分别设定上右下左边距，同css
        padding: 5,
        // Extra css text
        extraCssText: '',
        // 坐标轴指示器，坐标轴触发有效
        axisPointer: {
          // 默认为直线
          // 可选为：'line' | 'shadow' | 'cross'
          type: 'line',
          // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选
          // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'
          // 默认 'auto'，会选择类型为 category 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴
          // 极坐标系会默认选择 angle 轴
          axis: 'auto',
          animation: 'auto',
          animationDurationUpdate: 200,
          animationEasingUpdate: 'exponentialOut',
          crossStyle: {
            color: '#999',
            width: 1,
            type: 'dashed',
            // TODO formatter
            textStyle: {} // lineStyle and shadowStyle should not be specified here,
            // otherwise it will always override those styles on option.axisPointer.

          }
        },
        textStyle: {
          color: '#fff',
          fontSize: 14
        }
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */













    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var each$q = util.each;
    var toCamelCase$1 = format$1.toCamelCase;
    var vendors = ['', '-webkit-', '-moz-', '-o-'];
    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';
    /**
     * @param {number} duration
     * @return {string}
     * @inner
     */

    function assembleTransition(duration) {
      var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
      var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;
      return util.map(vendors, function (vendorPrefix) {
        return vendorPrefix + 'transition:' + transitionText;
      }).join(';');
    }
    /**
     * @param {Object} textStyle
     * @return {string}
     * @inner
     */


    function assembleFont(textStyleModel) {
      var cssText = [];
      var fontSize = textStyleModel.get('fontSize');
      var color = textStyleModel.getTextColor();
      color && cssText.push('color:' + color);
      cssText.push('font:' + textStyleModel.getFont());
      fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
      each$q(['decoration', 'align'], function (name) {
        var val = textStyleModel.get(name);
        val && cssText.push('text-' + name + ':' + val);
      });
      return cssText.join(';');
    }
    /**
     * @param {Object} tooltipModel
     * @return {string}
     * @inner
     */


    function assembleCssText(tooltipModel) {
      var cssText = [];
      var transitionDuration = tooltipModel.get('transitionDuration');
      var backgroundColor = tooltipModel.get('backgroundColor');
      var textStyleModel = tooltipModel.getModel('textStyle');
      var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.

      transitionDuration && cssText.push(assembleTransition(transitionDuration));

      if (backgroundColor) {
        if (env_1.canvasSupported) {
          cssText.push('background-Color:' + backgroundColor);
        } else {
          // for ie
          cssText.push('background-Color:#' + color.toHex(backgroundColor));
          cssText.push('filter:alpha(opacity=70)');
        }
      } // Border style


      each$q(['width', 'color', 'radius'], function (name) {
        var borderName = 'border-' + name;
        var camelCase = toCamelCase$1(borderName);
        var val = tooltipModel.get(camelCase);
        val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
      }); // Text style

      cssText.push(assembleFont(textStyleModel)); // Padding

      if (padding != null) {
        cssText.push('padding:' + format$1.normalizeCssArray(padding).join('px ') + 'px');
      }

      return cssText.join(';') + ';';
    } // If not able to make, do not modify the input `out`.


    function makeStyleCoord(out, zr, appendToBody, zrX, zrY) {
      var zrPainter = zr && zr.painter;

      if (appendToBody) {
        var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();

        if (zrViewportRoot) {
          // Some APPs might use scale on body, so we support CSS transform here.
          dom.transformLocalCoord(out, zrViewportRoot, document.body, zrX, zrY);
        }
      } else {
        out[0] = zrX;
        out[1] = zrY; // xy should be based on canvas root. But tooltipContent is
        // the sibling of canvas root. So padding of ec container
        // should be considered here.

        var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();

        if (viewportRootOffset) {
          out[0] += viewportRootOffset.offsetLeft;
          out[1] += viewportRootOffset.offsetTop;
        }
      }
    }
    /**
     * @alias module:echarts/component/tooltip/TooltipContent
     * @param {HTMLElement} container
     * @param {ExtensionAPI} api
     * @param {Object} [opt]
     * @param {boolean} [opt.appendToBody]
     *        `false`: the DOM element will be inside the container. Default value.
     *        `true`: the DOM element will be appended to HTML body, which avoid
     *                some overflow clip but intrude outside of the container.
     * @constructor
     */


    function TooltipContent(container, api, opt) {
      if (env_1.wxa) {
        return null;
      }

      var el = document.createElement('div');
      el.domBelongToZr = true;
      this.el = el;
      var zr = this._zr = api.getZr();
      var appendToBody = this._appendToBody = opt && opt.appendToBody;
      this._styleCoord = [0, 0];
      makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);

      if (appendToBody) {
        document.body.appendChild(el);
      } else {
        container.appendChild(el);
      }

      this._container = container;
      this._show = false;
      /**
       * @private
       */

      this._hideTimeout; // FIXME
      // Is it needed to trigger zr event manually if
      // the browser do not support `pointer-events: none`.

      var self = this;

      el.onmouseenter = function () {
        // clear the timeout in hideLater and keep showing tooltip
        if (self._enterable) {
          clearTimeout(self._hideTimeout);
          self._show = true;
        }

        self._inContent = true;
      };

      el.onmousemove = function (e) {
        e = e || window.event;

        if (!self._enterable) {
          // `pointer-events: none` is set to tooltip content div
          // if `enterable` is set as `false`, and `el.onmousemove`
          // can not be triggered. But in browser that do not
          // support `pointer-events`, we need to do this:
          // Try trigger zrender event to avoid mouse
          // in and out shape too frequently
          var handler = zr.handler;
          var zrViewportRoot = zr.painter.getViewportRoot();
          event.normalizeEvent(zrViewportRoot, e, true);
          handler.dispatch('mousemove', e);
        }
      };

      el.onmouseleave = function () {
        if (self._enterable) {
          if (self._show) {
            self.hideLater(self._hideDelay);
          }
        }

        self._inContent = false;
      };
    }

    TooltipContent.prototype = {
      constructor: TooltipContent,

      /**
       * @private
       * @type {boolean}
       */
      _enterable: true,

      /**
       * Update when tooltip is rendered
       */
      update: function () {
        // FIXME
        // Move this logic to ec main?
        var container = this._container;
        var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
        var domStyle = container.style;

        if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
          domStyle.position = 'relative';
        } // Hide the tooltip
        // PENDING
        // this.hide();

      },
      show: function (tooltipModel) {
        clearTimeout(this._hideTimeout);
        var el = this.el;
        var styleCoord = this._styleCoord;
        el.style.cssText = gCssText + assembleCssText(tooltipModel) // Because of the reason described in:
        // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
        // we should set initial value to `left` and `top`.
        + ';left:' + styleCoord[0] + 'px;top:' + styleCoord[1] + 'px;' + (tooltipModel.get('extraCssText') || '');
        el.style.display = el.innerHTML ? 'block' : 'none'; // If mouse occsionally move over the tooltip, a mouseout event will be
        // triggered by canvas, and cuase some unexpectable result like dragging
        // stop, "unfocusAdjacency". Here `pointer-events: none` is used to solve
        // it. Although it is not suppored by IE8~IE10, fortunately it is a rare
        // scenario.

        el.style.pointerEvents = this._enterable ? 'auto' : 'none';
        this._show = true;
      },
      setContent: function (content) {
        this.el.innerHTML = content == null ? '' : content;
      },
      setEnterable: function (enterable) {
        this._enterable = enterable;
      },
      getSize: function () {
        var el = this.el;
        return [el.clientWidth, el.clientHeight];
      },
      moveTo: function (zrX, zrY) {
        var styleCoord = this._styleCoord;
        makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY);
        var style = this.el.style;
        style.left = styleCoord[0] + 'px';
        style.top = styleCoord[1] + 'px';
      },
      hide: function () {
        this.el.style.display = 'none';
        this._show = false;
      },
      hideLater: function (time) {
        if (this._show && !(this._inContent && this._enterable)) {
          if (time) {
            this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times

            this._show = false;
            this._hideTimeout = setTimeout(util.bind(this.hide, this), time);
          } else {
            this.hide();
          }
        }
      },
      isShow: function () {
        return this._show;
      },
      dispose: function () {
        this.el.parentNode.removeChild(this.el);
      },
      getOuterSize: function () {
        var width = this.el.clientWidth;
        var height = this.el.clientHeight; // Consider browser compatibility.
        // IE8 does not support getComputedStyle.

        if (document.defaultView && document.defaultView.getComputedStyle) {
          var stl = document.defaultView.getComputedStyle(this.el);

          if (stl) {
            width += parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
            height += parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
          }
        }

        return {
          width: width,
          height: height
        };
      }
    };
    var _default$1Y = TooltipContent;
    var TooltipContent_1 = _default$1Y;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // import Group from 'zrender/src/container/Group';

    /**
     * @alias module:echarts/component/tooltip/TooltipRichContent
     * @constructor
     */
    function TooltipRichContent(api) {
      this._zr = api.getZr();
      this._show = false;
      /**
       * @private
       */

      this._hideTimeout;
    }

    TooltipRichContent.prototype = {
      constructor: TooltipRichContent,

      /**
       * @private
       * @type {boolean}
       */
      _enterable: true,

      /**
       * Update when tooltip is rendered
       */
      update: function () {// noop
      },
      show: function (tooltipModel) {
        if (this._hideTimeout) {
          clearTimeout(this._hideTimeout);
        }

        this.el.attr('show', true);
        this._show = true;
      },

      /**
       * Set tooltip content
       *
       * @param {string} content rich text string of content
       * @param {Object} markerRich rich text style
       * @param {Object} tooltipModel tooltip model
       */
      setContent: function (content, markerRich, tooltipModel) {
        if (this.el) {
          this._zr.remove(this.el);
        }

        var markers = {};
        var text = content;
        var prefix = '{marker';
        var suffix = '|}';
        var startId = text.indexOf(prefix);

        while (startId >= 0) {
          var endId = text.indexOf(suffix);
          var name = text.substr(startId + prefix.length, endId - startId - prefix.length);

          if (name.indexOf('sub') > -1) {
            markers['marker' + name] = {
              textWidth: 4,
              textHeight: 4,
              textBorderRadius: 2,
              textBackgroundColor: markerRich[name],
              // TODO: textOffset is not implemented for rich text
              textOffset: [3, 0]
            };
          } else {
            markers['marker' + name] = {
              textWidth: 10,
              textHeight: 10,
              textBorderRadius: 5,
              textBackgroundColor: markerRich[name]
            };
          }

          text = text.substr(endId + 1);
          startId = text.indexOf('{marker');
        }

        this.el = new Text_1({
          style: {
            rich: markers,
            text: content,
            textLineHeight: 20,
            textBackgroundColor: tooltipModel.get('backgroundColor'),
            textBorderRadius: tooltipModel.get('borderRadius'),
            textFill: tooltipModel.get('textStyle.color'),
            textPadding: tooltipModel.get('padding')
          },
          z: tooltipModel.get('z')
        });

        this._zr.add(this.el);

        var self = this;
        this.el.on('mouseover', function () {
          // clear the timeout in hideLater and keep showing tooltip
          if (self._enterable) {
            clearTimeout(self._hideTimeout);
            self._show = true;
          }

          self._inContent = true;
        });
        this.el.on('mouseout', function () {
          if (self._enterable) {
            if (self._show) {
              self.hideLater(self._hideDelay);
            }
          }

          self._inContent = false;
        });
      },
      setEnterable: function (enterable) {
        this._enterable = enterable;
      },
      getSize: function () {
        var bounding = this.el.getBoundingRect();
        return [bounding.width, bounding.height];
      },
      moveTo: function (x, y) {
        if (this.el) {
          this.el.attr('position', [x, y]);
        }
      },
      hide: function () {
        if (this.el) {
          this.el.hide();
        }

        this._show = false;
      },
      hideLater: function (time) {
        if (this._show && !(this._inContent && this._enterable)) {
          if (time) {
            this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times

            this._show = false;
            this._hideTimeout = setTimeout(util.bind(this.hide, this), time);
          } else {
            this.hide();
          }
        }
      },
      isShow: function () {
        return this._show;
      },
      getOuterSize: function () {
        var size = this.getSize();
        return {
          width: size[0],
          height: size[1]
        };
      }
    };
    var _default$1Z = TooltipRichContent;
    var TooltipRichContent_1 = _default$1Z;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */































    var getTooltipRenderMode$2 = model.getTooltipRenderMode;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var bind$3 = util.bind;
    var each$r = util.each;
    var parsePercent$5 = number.parsePercent;
    var proxyRect = new graphic.Rect({
      shape: {
        x: -1,
        y: -1,
        width: 2,
        height: 2
      }
    });

    var _default$1_ = echarts.extendComponentView({
      type: 'tooltip',
      init: function (ecModel, api) {
        if (env_1.node) {
          return;
        }

        var tooltipModel = ecModel.getComponent('tooltip');
        var renderMode = tooltipModel.get('renderMode');
        this._renderMode = getTooltipRenderMode$2(renderMode);
        var tooltipContent;

        if (this._renderMode === 'html') {
          tooltipContent = new TooltipContent_1(api.getDom(), api, {
            appendToBody: tooltipModel.get('appendToBody', true)
          });
          this._newLine = '<br/>';
        } else {
          tooltipContent = new TooltipRichContent_1(api);
          this._newLine = '\n';
        }

        this._tooltipContent = tooltipContent;
      },
      render: function (tooltipModel, ecModel, api) {
        if (env_1.node) {
          return;
        } // Reset


        this.group.removeAll();
        /**
         * @private
         * @type {module:echarts/component/tooltip/TooltipModel}
         */

        this._tooltipModel = tooltipModel;
        /**
         * @private
         * @type {module:echarts/model/Global}
         */

        this._ecModel = ecModel;
        /**
         * @private
         * @type {module:echarts/ExtensionAPI}
         */

        this._api = api;
        /**
         * Should be cleaned when render.
         * @private
         * @type {Array.<Array.<Object>>}
         */

        this._lastDataByCoordSys = null;
        /**
         * @private
         * @type {boolean}
         */

        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
        var tooltipContent = this._tooltipContent;
        tooltipContent.update();
        tooltipContent.setEnterable(tooltipModel.get('enterable'));

        this._initGlobalListener();

        this._keepShow();
      },
      _initGlobalListener: function () {
        var tooltipModel = this._tooltipModel;
        var triggerOn = tooltipModel.get('triggerOn');
        globalListener.register('itemTooltip', this._api, bind$3(function (currTrigger, e, dispatchAction) {
          // If 'none', it is not controlled by mouse totally.
          if (triggerOn !== 'none') {
            if (triggerOn.indexOf(currTrigger) >= 0) {
              this._tryShow(e, dispatchAction);
            } else if (currTrigger === 'leave') {
              this._hide(dispatchAction);
            }
          }
        }, this));
      },
      _keepShow: function () {
        var tooltipModel = this._tooltipModel;
        var ecModel = this._ecModel;
        var api = this._api; // Try to keep the tooltip show when refreshing

        if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,
        // self.manuallyShowTip({x, y}) might cause tooltip hide,
        // which is not expected.
        && tooltipModel.get('triggerOn') !== 'none') {
          var self = this;
          clearTimeout(this._refreshUpdateTimeout);
          this._refreshUpdateTimeout = setTimeout(function () {
            // Show tip next tick after other charts are rendered
            // In case highlight action has wrong result
            // FIXME
            !api.isDisposed() && self.manuallyShowTip(tooltipModel, ecModel, api, {
              x: self._lastX,
              y: self._lastY
            });
          });
        }
      },

      /**
       * Show tip manually by
       * dispatchAction({
       *     type: 'showTip',
       *     x: 10,
       *     y: 10
       * });
       * Or
       * dispatchAction({
       *      type: 'showTip',
       *      seriesIndex: 0,
       *      dataIndex or dataIndexInside or name
       * });
       *
       *  TODO Batch
       */
      manuallyShowTip: function (tooltipModel, ecModel, api, payload) {
        if (payload.from === this.uid || env_1.node) {
          return;
        }

        var dispatchAction = makeDispatchAction$1(payload, api); // Reset ticket

        this._ticket = ''; // When triggered from axisPointer.

        var dataByCoordSys = payload.dataByCoordSys;

        if (payload.tooltip && payload.x != null && payload.y != null) {
          var el = proxyRect;
          el.position = [payload.x, payload.y];
          el.update();
          el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.

          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            target: el
          }, dispatchAction);
        } else if (dataByCoordSys) {
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            dataByCoordSys: payload.dataByCoordSys,
            tooltipOption: payload.tooltipOption
          }, dispatchAction);
        } else if (payload.seriesIndex != null) {
          if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
            return;
          }

          var pointInfo = findPointFromSeries(payload, ecModel);
          var cx = pointInfo.point[0];
          var cy = pointInfo.point[1];

          if (cx != null && cy != null) {
            this._tryShow({
              offsetX: cx,
              offsetY: cy,
              position: payload.position,
              target: pointInfo.el
            }, dispatchAction);
          }
        } else if (payload.x != null && payload.y != null) {
          // FIXME
          // should wrap dispatchAction like `axisPointer/globalListener` ?
          api.dispatchAction({
            type: 'updateAxisPointer',
            x: payload.x,
            y: payload.y
          });

          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            target: api.getZr().findHover(payload.x, payload.y).target
          }, dispatchAction);
        }
      },
      manuallyHideTip: function (tooltipModel, ecModel, api, payload) {
        var tooltipContent = this._tooltipContent;

        if (!this._alwaysShowContent && this._tooltipModel) {
          tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
        }

        this._lastX = this._lastY = null;

        if (payload.from !== this.uid) {
          this._hide(makeDispatchAction$1(payload, api));
        }
      },
      // Be compatible with previous design, that is, when tooltip.type is 'axis' and
      // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
      // and tooltip.
      _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {
        var seriesIndex = payload.seriesIndex;
        var dataIndex = payload.dataIndex;
        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;

        if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
          return;
        }

        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);

        if (!seriesModel) {
          return;
        }

        var data = seriesModel.getData();
        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);

        if (tooltipModel.get('trigger') !== 'axis') {
          return;
        }

        api.dispatchAction({
          type: 'updateAxisPointer',
          seriesIndex: seriesIndex,
          dataIndex: dataIndex,
          position: payload.position
        });
        return true;
      },
      _tryShow: function (e, dispatchAction) {
        var el = e.target;
        var tooltipModel = this._tooltipModel;

        if (!tooltipModel) {
          return;
        } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed


        this._lastX = e.offsetX;
        this._lastY = e.offsetY;
        var dataByCoordSys = e.dataByCoordSys;

        if (dataByCoordSys && dataByCoordSys.length) {
          this._showAxisTooltip(dataByCoordSys, e);
        } // Always show item tooltip if mouse is on the element with dataIndex
        else if (el && el.dataIndex != null) {
            this._lastDataByCoordSys = null;

            this._showSeriesItemTooltip(e, el, dispatchAction);
          } // Tooltip provided directly. Like legend.
          else if (el && el.tooltip) {
              this._lastDataByCoordSys = null;

              this._showComponentItemTooltip(e, el, dispatchAction);
            } else {
              this._lastDataByCoordSys = null;

              this._hide(dispatchAction);
            }
      },
      _showOrMove: function (tooltipModel, cb) {
        // showDelay is used in this case: tooltip.enterable is set
        // as true. User intent to move mouse into tooltip and click
        // something. `showDelay` makes it easyer to enter the content
        // but tooltip do not move immediately.
        var delay = tooltipModel.get('showDelay');
        cb = util.bind(cb, this);
        clearTimeout(this._showTimout);
        delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
      },
      _showAxisTooltip: function (dataByCoordSys, e) {
        var ecModel = this._ecModel;
        var globalTooltipModel = this._tooltipModel;
        var point = [e.offsetX, e.offsetY];
        var singleDefaultHTML = [];
        var singleParamsList = [];
        var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);
        var renderMode = this._renderMode;
        var newLine = this._newLine;
        var markers = {};
        each$r(dataByCoordSys, function (itemCoordSys) {
          // var coordParamList = [];
          // var coordDefaultHTML = [];
          // var coordTooltipModel = buildTooltipModel([
          //     e.tooltipOption,
          //     itemCoordSys.tooltipOption,
          //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),
          //     globalTooltipModel
          // ]);
          // var displayMode = coordTooltipModel.get('displayMode');
          // var paramsList = displayMode === 'single' ? singleParamsList : [];
          each$r(itemCoordSys.dataByAxis, function (item) {
            var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);
            var axisValue = item.value;
            var seriesDefaultHTML = [];

            if (!axisModel || axisValue == null) {
              return;
            }

            var valueLabel = viewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);
            util.each(item.seriesDataIndices, function (idxItem) {
              var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
              var dataIndex = idxItem.dataIndexInside;
              var dataParams = series && series.getDataParams(dataIndex);
              dataParams.axisDim = item.axisDim;
              dataParams.axisIndex = item.axisIndex;
              dataParams.axisType = item.axisType;
              dataParams.axisId = item.axisId;
              dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);
              dataParams.axisValueLabel = valueLabel;

              if (dataParams) {
                singleParamsList.push(dataParams);
                var seriesTooltip = series.formatTooltip(dataIndex, true, null, renderMode);
                var html;

                if (util.isObject(seriesTooltip)) {
                  html = seriesTooltip.html;
                  var newMarkers = seriesTooltip.markers;
                  util.merge(markers, newMarkers);
                } else {
                  html = seriesTooltip;
                }

                seriesDefaultHTML.push(html);
              }
            }); // Default tooltip content
            // FIXME
            // (1) shold be the first data which has name?
            // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.

            var firstLine = valueLabel;

            if (renderMode !== 'html') {
              singleDefaultHTML.push(seriesDefaultHTML.join(newLine));
            } else {
              singleDefaultHTML.push((firstLine ? format$1.encodeHTML(firstLine) + newLine : '') + seriesDefaultHTML.join(newLine));
            }
          });
        }, this); // In most case, the second axis is shown upper than the first one.

        singleDefaultHTML.reverse();
        singleDefaultHTML = singleDefaultHTML.join(this._newLine + this._newLine);
        var positionExpr = e.position;

        this._showOrMove(singleTooltipModel, function () {
          if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
            this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);
          } else {
            this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr, undefined, markers);
          }
        }); // Do not trigger events here, because this branch only be entered
        // from dispatchAction.

      },
      _showSeriesItemTooltip: function (e, el, dispatchAction) {
        var ecModel = this._ecModel; // Use dataModel in element if possible
        // Used when mouseover on a element like markPoint or edge
        // In which case, the data is not main data in series.

        var seriesIndex = el.seriesIndex;
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.

        var dataModel = el.dataModel || seriesModel;
        var dataIndex = el.dataIndex;
        var dataType = el.dataType;
        var data = dataModel.getData(dataType);
        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
        var tooltipTrigger = tooltipModel.get('trigger');

        if (tooltipTrigger != null && tooltipTrigger !== 'item') {
          return;
        }

        var params = dataModel.getDataParams(dataIndex, dataType);
        var seriesTooltip = dataModel.formatTooltip(dataIndex, false, dataType, this._renderMode);
        var defaultHtml;
        var markers;

        if (util.isObject(seriesTooltip)) {
          defaultHtml = seriesTooltip.html;
          markers = seriesTooltip.markers;
        } else {
          defaultHtml = seriesTooltip;
          markers = null;
        }

        var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;

        this._showOrMove(tooltipModel, function () {
          this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markers);
        }); // FIXME
        // duplicated showtip if manuallyShowTip is called from dispatchAction.


        dispatchAction({
          type: 'showTip',
          dataIndexInside: dataIndex,
          dataIndex: data.getRawIndex(dataIndex),
          seriesIndex: seriesIndex,
          from: this.uid
        });
      },
      _showComponentItemTooltip: function (e, el, dispatchAction) {
        var tooltipOpt = el.tooltip;

        if (typeof tooltipOpt === 'string') {
          var content = tooltipOpt;
          tooltipOpt = {
            content: content,
            // Fixed formatter
            formatter: content
          };
        }

        var subTooltipModel = new Model_1(tooltipOpt, this._tooltipModel, this._ecModel);
        var defaultHtml = subTooltipModel.get('content');
        var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`
        // only works on cooridinate system. In fact, we have not found case
        // that requires setting `trigger` nothing on component yet.

        this._showOrMove(subTooltipModel, function () {
          this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);
        }); // If not dispatch showTip, tip may be hide triggered by axis.


        dispatchAction({
          type: 'showTip',
          from: this.uid
        });
      },
      _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markers) {
        // Reset ticket
        this._ticket = '';

        if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
          return;
        }

        var tooltipContent = this._tooltipContent;
        var formatter = tooltipModel.get('formatter');
        positionExpr = positionExpr || tooltipModel.get('position');
        var html = defaultHtml;

        if (formatter && typeof formatter === 'string') {
          html = format$1.formatTpl(formatter, params, true);
        } else if (typeof formatter === 'function') {
          var callback = bind$3(function (cbTicket, html) {
            if (cbTicket === this._ticket) {
              tooltipContent.setContent(html, markers, tooltipModel);

              this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
            }
          }, this);
          this._ticket = asyncTicket;
          html = formatter(params, asyncTicket, callback);
        }

        tooltipContent.setContent(html, markers, tooltipModel);
        tooltipContent.show(tooltipModel);

        this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
      },

      /**
       * @param  {string|Function|Array.<number>|Object} positionExpr
       * @param  {number} x Mouse x
       * @param  {number} y Mouse y
       * @param  {boolean} confine Whether confine tooltip content in view rect.
       * @param  {Object|<Array.<Object>} params
       * @param  {module:zrender/Element} el target element
       * @param  {module:echarts/ExtensionAPI} api
       * @return {Array.<number>}
       */
      _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {
        var viewWidth = this._api.getWidth();

        var viewHeight = this._api.getHeight();

        positionExpr = positionExpr || tooltipModel.get('position');
        var contentSize = content.getSize();
        var align = tooltipModel.get('align');
        var vAlign = tooltipModel.get('verticalAlign');
        var rect = el && el.getBoundingRect().clone();
        el && rect.applyTransform(el.transform);

        if (typeof positionExpr === 'function') {
          // Callback of position can be an array or a string specify the position
          positionExpr = positionExpr([x, y], params, content.el, rect, {
            viewSize: [viewWidth, viewHeight],
            contentSize: contentSize.slice()
          });
        }

        if (util.isArray(positionExpr)) {
          x = parsePercent$5(positionExpr[0], viewWidth);
          y = parsePercent$5(positionExpr[1], viewHeight);
        } else if (util.isObject(positionExpr)) {
          positionExpr.width = contentSize[0];
          positionExpr.height = contentSize[1];
          var layoutRect = layout.getLayoutRect(positionExpr, {
            width: viewWidth,
            height: viewHeight
          });
          x = layoutRect.x;
          y = layoutRect.y;
          align = null; // When positionExpr is left/top/right/bottom,
          // align and verticalAlign will not work.

          vAlign = null;
        } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
        else if (typeof positionExpr === 'string' && el) {
            var pos = calcTooltipPosition(positionExpr, rect, contentSize);
            x = pos[0];
            y = pos[1];
          } else {
            var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
            x = pos[0];
            y = pos[1];
          }

        align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
        vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);

        if (tooltipModel.get('confine')) {
          var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
          x = pos[0];
          y = pos[1];
        }

        content.moveTo(x, y);
      },
      // FIXME
      // Should we remove this but leave this to user?
      _updateContentNotChangedOnAxis: function (dataByCoordSys) {
        var lastCoordSys = this._lastDataByCoordSys;
        var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
        contentNotChanged && each$r(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
          var lastDataByAxis = lastItemCoordSys.dataByAxis || {};
          var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
          var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
          contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;
          contentNotChanged && each$r(lastDataByAxis, function (lastItem, indexAxis) {
            var thisItem = thisDataByAxis[indexAxis] || {};
            var lastIndices = lastItem.seriesDataIndices || [];
            var newIndices = thisItem.seriesDataIndices || [];
            contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
            contentNotChanged && each$r(lastIndices, function (lastIdxItem, j) {
              var newIdxItem = newIndices[j];
              contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
            });
          });
        });
        this._lastDataByCoordSys = dataByCoordSys;
        return !!contentNotChanged;
      },
      _hide: function (dispatchAction) {
        // Do not directly hideLater here, because this behavior may be prevented
        // in dispatchAction when showTip is dispatched.
        // FIXME
        // duplicated hideTip if manuallyHideTip is called from dispatchAction.
        this._lastDataByCoordSys = null;
        dispatchAction({
          type: 'hideTip',
          from: this.uid
        });
      },
      dispose: function (ecModel, api) {
        if (env_1.node) {
          return;
        }

        this._tooltipContent.dispose();

        globalListener.unregister('itemTooltip', api);
      }
    });
    /**
     * @param {Array.<Object|module:echarts/model/Model>} modelCascade
     * From top to bottom. (the last one should be globalTooltipModel);
     */


    function buildTooltipModel(modelCascade) {
      var resultModel = modelCascade.pop();

      while (modelCascade.length) {
        var tooltipOpt = modelCascade.pop();

        if (tooltipOpt) {
          if (Model_1.isInstance(tooltipOpt)) {
            tooltipOpt = tooltipOpt.get('tooltip', true);
          } // In each data item tooltip can be simply write:
          // {
          //  value: 10,
          //  tooltip: 'Something you need to know'
          // }


          if (typeof tooltipOpt === 'string') {
            tooltipOpt = {
              formatter: tooltipOpt
            };
          }

          resultModel = new Model_1(tooltipOpt, resultModel, resultModel.ecModel);
        }
      }

      return resultModel;
    }

    function makeDispatchAction$1(payload, api) {
      return payload.dispatchAction || util.bind(api.dispatchAction, api);
    }

    function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
      var size = content.getOuterSize();
      var width = size.width;
      var height = size.height;

      if (gapH != null) {
        if (x + width + gapH > viewWidth) {
          x -= width + gapH;
        } else {
          x += gapH;
        }
      }

      if (gapV != null) {
        if (y + height + gapV > viewHeight) {
          y -= height + gapV;
        } else {
          y += gapV;
        }
      }

      return [x, y];
    }

    function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
      var size = content.getOuterSize();
      var width = size.width;
      var height = size.height;
      x = Math.min(x + width, viewWidth) - width;
      y = Math.min(y + height, viewHeight) - height;
      x = Math.max(x, 0);
      y = Math.max(y, 0);
      return [x, y];
    }

    function calcTooltipPosition(position, rect, contentSize) {
      var domWidth = contentSize[0];
      var domHeight = contentSize[1];
      var gap = 5;
      var x = 0;
      var y = 0;
      var rectWidth = rect.width;
      var rectHeight = rect.height;

      switch (position) {
        case 'inside':
          x = rect.x + rectWidth / 2 - domWidth / 2;
          y = rect.y + rectHeight / 2 - domHeight / 2;
          break;

        case 'top':
          x = rect.x + rectWidth / 2 - domWidth / 2;
          y = rect.y - domHeight - gap;
          break;

        case 'bottom':
          x = rect.x + rectWidth / 2 - domWidth / 2;
          y = rect.y + rectHeight + gap;
          break;

        case 'left':
          x = rect.x - domWidth - gap;
          y = rect.y + rectHeight / 2 - domHeight / 2;
          break;

        case 'right':
          x = rect.x + rectWidth + gap;
          y = rect.y + rectHeight / 2 - domHeight / 2;
      }

      return [x, y];
    }

    function isCenterAlign(align) {
      return align === 'center' || align === 'middle';
    }

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // FIXME Better way to pack data in graphic element

    /**
     * @action
     * @property {string} type
     * @property {number} seriesIndex
     * @property {number} dataIndex
     * @property {number} [x]
     * @property {number} [y]
     */
    echarts.registerAction({
      type: 'showTip',
      event: 'showTip',
      update: 'tooltip:manuallyShowTip'
    }, // noop
    function () {});
    echarts.registerAction({
      type: 'hideTip',
      event: 'hideTip',
      update: 'tooltip:manuallyHideTip'
    }, // noop
    function () {});

    /* src\components\Chart\Series.svelte generated by Svelte v3.22.3 */
    const file$D = "src\\components\\Chart\\Series.svelte";

    // (63:0) {:else}
    function create_else_block$6(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(63:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (56:0) {#if series}
    function create_if_block$d(ctx) {
    	let div1;
    	let t;
    	let div0;
    	let current;
    	let chart_1_props = {};
    	const chart_1 = new Chart$1({ props: chart_1_props, $$inline: true });
    	/*chart_1_binding*/ ctx[9](chart_1);
    	chart_1.$on("render", /*onRender*/ ctx[2]);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			t = text(" \r\n    ");
    			div0 = element("div");
    			create_component(chart_1.$$.fragment);
    			set_style(div0, "margin-top", "-40px");
    			set_style(div0, "height", "calc(100% + 20px)");
    			add_location(div0, file$D, 58, 4, 1148);
    			attr_dev(div1, "class", "h-full");
    			add_location(div1, file$D, 56, 2, 1110);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			mount_component(chart_1, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const chart_1_changes = {};
    			chart_1.$set(chart_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chart_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chart_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*chart_1_binding*/ ctx[9](null);
    			destroy_component(chart_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(56:0) {#if series}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$d, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*series*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { xAxis = {} } = $$props;
    	let { yAxis } = $$props;
    	let { series } = $$props;
    	let { grid = undefined } = $$props;
    	let { legends = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { options = undefined } = $$props;
    	let chart;

    	function onRender({ detail: chart }) {
    		chart.showLoading();

    		chart.setOption({
    			grid,
    			tooltip: {
    				trigger: "axis",
    				axisPointer: {
    					type: "cross",
    					crossStyle: { color: "#999" }
    				},
    				...tooltip
    			},
    			legend: {
    				bottom: -5,
    				textStyle: { fontSize: 10 },
    				...legends
    			},
    			xAxis,
    			yAxis,
    			series,
    			...options
    		});

    		chart.hideLoading();
    	}

    	const writable_props = ["xAxis", "yAxis", "series", "grid", "legends", "tooltip", "options"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Series> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Series", $$slots, []);

    	function chart_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(1, chart = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("xAxis" in $$props) $$invalidate(3, xAxis = $$props.xAxis);
    		if ("yAxis" in $$props) $$invalidate(4, yAxis = $$props.yAxis);
    		if ("series" in $$props) $$invalidate(0, series = $$props.series);
    		if ("grid" in $$props) $$invalidate(5, grid = $$props.grid);
    		if ("legends" in $$props) $$invalidate(6, legends = $$props.legends);
    		if ("tooltip" in $$props) $$invalidate(7, tooltip = $$props.tooltip);
    		if ("options" in $$props) $$invalidate(8, options = $$props.options);
    	};

    	$$self.$capture_state = () => ({
    		Loading,
    		Chart: Chart$1,
    		xAxis,
    		yAxis,
    		series,
    		grid,
    		legends,
    		tooltip,
    		options,
    		chart,
    		onRender
    	});

    	$$self.$inject_state = $$props => {
    		if ("xAxis" in $$props) $$invalidate(3, xAxis = $$props.xAxis);
    		if ("yAxis" in $$props) $$invalidate(4, yAxis = $$props.yAxis);
    		if ("series" in $$props) $$invalidate(0, series = $$props.series);
    		if ("grid" in $$props) $$invalidate(5, grid = $$props.grid);
    		if ("legends" in $$props) $$invalidate(6, legends = $$props.legends);
    		if ("tooltip" in $$props) $$invalidate(7, tooltip = $$props.tooltip);
    		if ("options" in $$props) $$invalidate(8, options = $$props.options);
    		if ("chart" in $$props) $$invalidate(1, chart = $$props.chart);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*series, chart*/ 3) {
    			 if (series && chart) {
    				chart.update();
    			}
    		}
    	};

    	return [
    		series,
    		chart,
    		onRender,
    		xAxis,
    		yAxis,
    		grid,
    		legends,
    		tooltip,
    		options,
    		chart_1_binding
    	];
    }

    class Series$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$F, create_fragment$G, safe_not_equal, {
    			xAxis: 3,
    			yAxis: 4,
    			series: 0,
    			grid: 5,
    			legends: 6,
    			tooltip: 7,
    			options: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Series",
    			options,
    			id: create_fragment$G.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*yAxis*/ ctx[4] === undefined && !("yAxis" in props)) {
    			console.warn("<Series> was created without expected prop 'yAxis'");
    		}

    		if (/*series*/ ctx[0] === undefined && !("series" in props)) {
    			console.warn("<Series> was created without expected prop 'series'");
    		}
    	}

    	get xAxis() {
    		throw new Error("<Series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xAxis(value) {
    		throw new Error("<Series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yAxis() {
    		throw new Error("<Series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yAxis(value) {
    		throw new Error("<Series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get series() {
    		throw new Error("<Series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set series(value) {
    		throw new Error("<Series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grid() {
    		throw new Error("<Series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grid(value) {
    		throw new Error("<Series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get legends() {
    		throw new Error("<Series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set legends(value) {
    		throw new Error("<Series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<Series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\_components\ReceitaXDespesaEvolucaoAnual.svelte generated by Svelte v3.22.3 */
    const file$E = "src\\pages\\_components\\ReceitaXDespesaEvolucaoAnual.svelte";
    const get_tooltip_slot_changes$1 = dirty => ({});
    const get_tooltip_slot_context$1 = ctx => ({});
    const get_title_slot_changes$1 = dirty => ({});
    const get_title_slot_context$1 = ctx => ({});

    // (113:2) <span slot="title">
    function create_title_slot(ctx) {
    	let span;
    	let current;
    	const title_slot_template = /*$$slots*/ ctx[9].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[10], get_title_slot_context$1);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (title_slot) title_slot.c();
    			attr_dev(span, "slot", "title");
    			add_location(span, file$E, 112, 2, 2030);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (title_slot) {
    				title_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && dirty & /*$$scope*/ 1024) {
    					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[10], get_title_slot_context$1), get_slot_changes(title_slot_template, /*$$scope*/ ctx[10], dirty, get_title_slot_changes$1));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot.name,
    		type: "slot",
    		source: "(113:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:2) <span slot="tooltip">
    function create_tooltip_slot(ctx) {
    	let span;
    	let current;
    	const tooltip_slot_template = /*$$slots*/ ctx[9].tooltip;
    	const tooltip_slot = create_slot(tooltip_slot_template, ctx, /*$$scope*/ ctx[10], get_tooltip_slot_context$1);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (tooltip_slot) tooltip_slot.c();
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$E, 115, 2, 2091);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (tooltip_slot) {
    				tooltip_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (tooltip_slot) {
    				if (tooltip_slot.p && dirty & /*$$scope*/ 1024) {
    					tooltip_slot.p(get_slot_context(tooltip_slot_template, ctx, /*$$scope*/ ctx[10], get_tooltip_slot_context$1), get_slot_changes(tooltip_slot_template, /*$$scope*/ ctx[10], dirty, get_tooltip_slot_changes$1));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (tooltip_slot) tooltip_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot.name,
    		type: "slot",
    		source: "(116:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (112:0) <Widget>
    function create_default_slot$g(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				grid: /*grid*/ ctx[3],
    				xAxis: /*xAxis*/ ctx[2],
    				yAxis: /*yAxis*/ ctx[4],
    				series: /*series*/ ctx[1],
    				legends: /*legends*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(series_1.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$E, 118, 2, 2156);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(series_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 4) series_1_changes.xAxis = /*xAxis*/ ctx[2];
    			if (dirty & /*series*/ 2) series_1_changes.series = /*series*/ ctx[1];
    			if (dirty & /*legends*/ 1) series_1_changes.legends = /*legends*/ ctx[0];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(series_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(112:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$g],
    					tooltip: [create_tooltip_slot],
    					title: [create_title_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, xAxis, series, legends*/ 1031) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { receita } = $$props;
    	let { despesa } = $$props;
    	let { view = "receita" } = $$props;
    	const grid = { left: 90 };
    	let legends;
    	let series;
    	let xAxis;

    	const yAxis = [
    		{
    			type: "value",
    			name: "Receita",
    			axisLabel: { formatter: "R$ {value}" }
    		},
    		{
    			type: "value",
    			name: "Despesa",
    			axisLabel: { formatter: "R$ {value}" }
    		}
    	];

    	function render(receita, despesa) {
    		if (!receita || !despesa) {
    			$$invalidate(1, series = null);
    			return;
    		}

    		const anos = [];
    		const arrecadadas = [];
    		const empenhadas = [];
    		const liquidadas = [];
    		const pagas = [];

    		receita.value.forEach(r => {
    			anos.push(r.ano);
    			arrecadadas.push(r.arrecadada);
    		});

    		despesa.value.forEach(d => {
    			empenhadas.push(d.empenhada);
    			liquidadas.push(d.liquidada);
    			pagas.push(d.paga);
    		});

    		$$invalidate(2, xAxis = [
    			{
    				type: "category",
    				data: anos,
    				axisPointer: { type: "shadow" }
    			}
    		]);

    		$$invalidate(1, series = [
    			{
    				type: "line",
    				name: "Rec. arrecadada",
    				data: arrecadadas
    			},
    			{
    				type: "bar",
    				name: "Desp. empenhada",
    				data: empenhadas
    			},
    			{
    				type: "bar",
    				name: "Desp. liquidada",
    				data: liquidadas
    			},
    			{
    				type: "bar",
    				name: "Desp. paga",
    				data: pagas
    			}
    		]);

    		let selected;

    		if (view === "receita") {
    			selected = {
    				"Desp. empenhada": false,
    				"Desp. paga": false
    			};
    		} else {
    			selected = { "Rec. arrecadada": false };
    		}

    		$$invalidate(0, legends = { data: series.map(s => s.name), selected });
    	}

    	const writable_props = ["receita", "despesa", "view"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ReceitaXDespesaEvolucaoAnual> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ReceitaXDespesaEvolucaoAnual", $$slots, ['title','tooltip']);

    	$$self.$set = $$props => {
    		if ("receita" in $$props) $$invalidate(5, receita = $$props.receita);
    		if ("despesa" in $$props) $$invalidate(6, despesa = $$props.despesa);
    		if ("view" in $$props) $$invalidate(7, view = $$props.view);
    		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Series: Series$1,
    		receita,
    		despesa,
    		view,
    		grid,
    		legends,
    		series,
    		xAxis,
    		yAxis,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("receita" in $$props) $$invalidate(5, receita = $$props.receita);
    		if ("despesa" in $$props) $$invalidate(6, despesa = $$props.despesa);
    		if ("view" in $$props) $$invalidate(7, view = $$props.view);
    		if ("legends" in $$props) $$invalidate(0, legends = $$props.legends);
    		if ("series" in $$props) $$invalidate(1, series = $$props.series);
    		if ("xAxis" in $$props) $$invalidate(2, xAxis = $$props.xAxis);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*receita, despesa*/ 96) {
    			 render(receita, despesa);
    		}
    	};

    	return [
    		legends,
    		series,
    		xAxis,
    		grid,
    		yAxis,
    		receita,
    		despesa,
    		view,
    		render,
    		$$slots,
    		$$scope
    	];
    }

    class ReceitaXDespesaEvolucaoAnual extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$H, safe_not_equal, { receita: 5, despesa: 6, view: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ReceitaXDespesaEvolucaoAnual",
    			options,
    			id: create_fragment$H.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*receita*/ ctx[5] === undefined && !("receita" in props)) {
    			console.warn("<ReceitaXDespesaEvolucaoAnual> was created without expected prop 'receita'");
    		}

    		if (/*despesa*/ ctx[6] === undefined && !("despesa" in props)) {
    			console.warn("<ReceitaXDespesaEvolucaoAnual> was created without expected prop 'despesa'");
    		}
    	}

    	get receita() {
    		throw new Error("<ReceitaXDespesaEvolucaoAnual>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set receita(value) {
    		throw new Error("<ReceitaXDespesaEvolucaoAnual>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get despesa() {
    		throw new Error("<ReceitaXDespesaEvolucaoAnual>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set despesa(value) {
    		throw new Error("<ReceitaXDespesaEvolucaoAnual>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get view() {
    		throw new Error("<ReceitaXDespesaEvolucaoAnual>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set view(value) {
    		throw new Error("<ReceitaXDespesaEvolucaoAnual>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\_components\ReceitaXDespesaEvolucaoMensal.svelte generated by Svelte v3.22.3 */
    const file$F = "src\\pages\\_components\\ReceitaXDespesaEvolucaoMensal.svelte";
    const get_tooltip_slot_changes$2 = dirty => ({});
    const get_tooltip_slot_context$2 = ctx => ({});
    const get_title_slot_changes$2 = dirty => ({});
    const get_title_slot_context$2 = ctx => ({});

    // (126:2) <span slot="title">
    function create_title_slot$1(ctx) {
    	let span;
    	let current;
    	const title_slot_template = /*$$slots*/ ctx[10].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[11], get_title_slot_context$2);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (title_slot) title_slot.c();
    			attr_dev(span, "slot", "title");
    			add_location(span, file$F, 125, 2, 2154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (title_slot) {
    				title_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && dirty & /*$$scope*/ 2048) {
    					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[11], get_title_slot_context$2), get_slot_changes(title_slot_template, /*$$scope*/ ctx[11], dirty, get_title_slot_changes$2));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$1.name,
    		type: "slot",
    		source: "(126:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:2) <span slot="tooltip">
    function create_tooltip_slot$1(ctx) {
    	let span;
    	let current;
    	const tooltip_slot_template = /*$$slots*/ ctx[10].tooltip;
    	const tooltip_slot = create_slot(tooltip_slot_template, ctx, /*$$scope*/ ctx[11], get_tooltip_slot_context$2);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (tooltip_slot) tooltip_slot.c();
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$F, 128, 2, 2215);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (tooltip_slot) {
    				tooltip_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (tooltip_slot) {
    				if (tooltip_slot.p && dirty & /*$$scope*/ 2048) {
    					tooltip_slot.p(get_slot_context(tooltip_slot_template, ctx, /*$$scope*/ ctx[11], get_tooltip_slot_context$2), get_slot_changes(tooltip_slot_template, /*$$scope*/ ctx[11], dirty, get_tooltip_slot_changes$2));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (tooltip_slot) tooltip_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$1.name,
    		type: "slot",
    		source: "(129:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:0) <Widget>
    function create_default_slot$h(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				grid: /*grid*/ ctx[3],
    				xAxis: /*xAxis*/ ctx[2],
    				yAxis: /*yAxis*/ ctx[4],
    				series: /*series*/ ctx[1],
    				legends: /*legends*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(series_1.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$F, 131, 2, 2280);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(series_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 4) series_1_changes.xAxis = /*xAxis*/ ctx[2];
    			if (dirty & /*series*/ 2) series_1_changes.series = /*series*/ ctx[1];
    			if (dirty & /*legends*/ 1) series_1_changes.legends = /*legends*/ ctx[0];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(series_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(125:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$h],
    					tooltip: [create_tooltip_slot$1],
    					title: [create_title_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, xAxis, series, legends*/ 2055) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { receita } = $$props;
    	let { despesa } = $$props;
    	let { view = "receita" } = $$props;

    	const meses = [
    		"Jan",
    		"Fev",
    		"Mar",
    		"Abr",
    		"Mai",
    		"Jun",
    		"Jul",
    		"Ago",
    		"Set",
    		"Out",
    		"Nov",
    		"Dez"
    	];

    	const grid = { left: 90 };
    	let legends;
    	let series;
    	let xAxis;

    	const yAxis = [
    		{
    			type: "value",
    			name: "Receita",
    			axisLabel: { formatter: "R$ {value}" }
    		},
    		{
    			type: "value",
    			name: "Despesa",
    			axisLabel: { formatter: "R$ {value}" }
    		}
    	];

    	function render(receita, despesa) {
    		if (!receita || !despesa) {
    			$$invalidate(1, series = null);
    			return;
    		}

    		const arrecadadas = [];
    		const empenhadas = [];
    		const liquidadas = [];
    		const pagas = [];

    		receita.value.forEach(r => {
    			arrecadadas.push(r.arrecadada);
    		});

    		despesa.value.forEach(d => {
    			empenhadas.push(d.empenhada);
    			liquidadas.push(d.liquidada);
    			pagas.push(d.paga);
    		});

    		$$invalidate(2, xAxis = [
    			{
    				type: "category",
    				data: meses,
    				axisPointer: { type: "shadow" }
    			}
    		]);

    		$$invalidate(1, series = [
    			{
    				type: "line",
    				name: "Rec. arrecadada",
    				data: arrecadadas
    			},
    			{
    				type: "bar",
    				name: "Desp. empenhada",
    				data: empenhadas
    			},
    			{
    				type: "bar",
    				name: "Desp. liquidada",
    				data: liquidadas
    			},
    			{
    				type: "bar",
    				name: "Desp. paga",
    				data: pagas
    			}
    		]);

    		let selected;

    		if (view === "receita") {
    			selected = {
    				"Desp. empenhada": false,
    				"Desp. paga": false
    			};
    		} else {
    			selected = { "Rec. arrecadada": false };
    		}

    		$$invalidate(0, legends = { data: series.map(s => s.name), selected });
    	}

    	const writable_props = ["receita", "despesa", "view"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ReceitaXDespesaEvolucaoMensal> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ReceitaXDespesaEvolucaoMensal", $$slots, ['title','tooltip']);

    	$$self.$set = $$props => {
    		if ("receita" in $$props) $$invalidate(5, receita = $$props.receita);
    		if ("despesa" in $$props) $$invalidate(6, despesa = $$props.despesa);
    		if ("view" in $$props) $$invalidate(7, view = $$props.view);
    		if ("$$scope" in $$props) $$invalidate(11, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Series: Series$1,
    		receita,
    		despesa,
    		view,
    		meses,
    		grid,
    		legends,
    		series,
    		xAxis,
    		yAxis,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("receita" in $$props) $$invalidate(5, receita = $$props.receita);
    		if ("despesa" in $$props) $$invalidate(6, despesa = $$props.despesa);
    		if ("view" in $$props) $$invalidate(7, view = $$props.view);
    		if ("legends" in $$props) $$invalidate(0, legends = $$props.legends);
    		if ("series" in $$props) $$invalidate(1, series = $$props.series);
    		if ("xAxis" in $$props) $$invalidate(2, xAxis = $$props.xAxis);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*receita, despesa*/ 96) {
    			 render(receita, despesa);
    		}
    	};

    	return [
    		legends,
    		series,
    		xAxis,
    		grid,
    		yAxis,
    		receita,
    		despesa,
    		view,
    		meses,
    		render,
    		$$slots,
    		$$scope
    	];
    }

    class ReceitaXDespesaEvolucaoMensal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$I, safe_not_equal, { receita: 5, despesa: 6, view: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ReceitaXDespesaEvolucaoMensal",
    			options,
    			id: create_fragment$I.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*receita*/ ctx[5] === undefined && !("receita" in props)) {
    			console.warn("<ReceitaXDespesaEvolucaoMensal> was created without expected prop 'receita'");
    		}

    		if (/*despesa*/ ctx[6] === undefined && !("despesa" in props)) {
    			console.warn("<ReceitaXDespesaEvolucaoMensal> was created without expected prop 'despesa'");
    		}
    	}

    	get receita() {
    		throw new Error("<ReceitaXDespesaEvolucaoMensal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set receita(value) {
    		throw new Error("<ReceitaXDespesaEvolucaoMensal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get despesa() {
    		throw new Error("<ReceitaXDespesaEvolucaoMensal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set despesa(value) {
    		throw new Error("<ReceitaXDespesaEvolucaoMensal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get view() {
    		throw new Error("<ReceitaXDespesaEvolucaoMensal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set view(value) {
    		throw new Error("<ReceitaXDespesaEvolucaoMensal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\_components\ReceitaXDespesa.svelte generated by Svelte v3.22.3 */
    const file$G = "src\\pages\\_components\\ReceitaXDespesa.svelte";

    // (66:2) <span slot="title">
    function create_title_slot$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Receitas X Despesas";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$G, 65, 2, 1336);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$2.name,
    		type: "slot",
    		source: "(66:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (67:2) <span slot="tooltip">
    function create_tooltip_slot$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Possibilita comparar os gastos realizados com o montante arrecadado no\r\n    exercício e identificar a ocorrência de déficit (despesa maior que receita)\r\n    ou superávit (receita maior que despesa).";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$G, 66, 2, 1385);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$2.name,
    		type: "slot",
    		source: "(67:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (65:0) <Widget>
    function create_default_slot$i(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				grid: /*grid*/ ctx[3],
    				xAxis: /*xAxis*/ ctx[1],
    				yAxis: /*yAxis*/ ctx[2],
    				series: /*series*/ ctx[0],
    				tooltip: /*tooltip*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(series_1.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$G, 71, 2, 1625);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(series_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 2) series_1_changes.xAxis = /*xAxis*/ ctx[1];
    			if (dirty & /*yAxis*/ 4) series_1_changes.yAxis = /*yAxis*/ ctx[2];
    			if (dirty & /*series*/ 1) series_1_changes.series = /*series*/ ctx[0];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(series_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(65:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$i],
    					tooltip: [create_tooltip_slot$2],
    					title: [create_title_slot$2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, xAxis, yAxis, series*/ 263) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { remessaReceita } = $$props;
    	let { remessaDespesa } = $$props;
    	const grid = { left: 130, top: 30, height: "80%" };

    	const tooltip = {
    		trigger: "axis",
    		axisPointer: { type: "shadow" }
    	};

    	let series;
    	let xAxis;
    	let yAxis;

    	function render(remessaReceita, remessaDespesa) {
    		if (!remessaReceita || !remessaDespesa) {
    			$$invalidate(0, series = null);
    			return;
    		}

    		$$invalidate(2, yAxis = {
    			type: "category",
    			data: [
    				"Receita prevista",
    				"Receita arrecadada",
    				"Despesa prevista",
    				"Despesa empenhada",
    				"Despesa liquidada",
    				"Despesa paga"
    			]
    		});

    		$$invalidate(1, xAxis = { type: "value", show: false });

    		$$invalidate(0, series = [
    			{
    				type: "bar",
    				position: "left",
    				data: [
    					remessaReceita.value.previsaoInicial,
    					remessaReceita.value.arrecadada,
    					remessaDespesa.value.previsaoInicial,
    					remessaDespesa.value.empenhada,
    					remessaDespesa.value.liquidada,
    					remessaDespesa.value.paga
    				]
    			}
    		]);
    	}

    	const writable_props = ["remessaReceita", "remessaDespesa"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ReceitaXDespesa> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ReceitaXDespesa", $$slots, []);

    	$$self.$set = $$props => {
    		if ("remessaReceita" in $$props) $$invalidate(5, remessaReceita = $$props.remessaReceita);
    		if ("remessaDespesa" in $$props) $$invalidate(6, remessaDespesa = $$props.remessaDespesa);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Series: Series$1,
    		remessaReceita,
    		remessaDespesa,
    		grid,
    		tooltip,
    		series,
    		xAxis,
    		yAxis,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("remessaReceita" in $$props) $$invalidate(5, remessaReceita = $$props.remessaReceita);
    		if ("remessaDespesa" in $$props) $$invalidate(6, remessaDespesa = $$props.remessaDespesa);
    		if ("series" in $$props) $$invalidate(0, series = $$props.series);
    		if ("xAxis" in $$props) $$invalidate(1, xAxis = $$props.xAxis);
    		if ("yAxis" in $$props) $$invalidate(2, yAxis = $$props.yAxis);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*remessaReceita, remessaDespesa*/ 96) {
    			 render(remessaReceita, remessaDespesa);
    		}
    	};

    	return [series, xAxis, yAxis, grid, tooltip, remessaReceita, remessaDespesa];
    }

    class ReceitaXDespesa extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$J, safe_not_equal, { remessaReceita: 5, remessaDespesa: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ReceitaXDespesa",
    			options,
    			id: create_fragment$J.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*remessaReceita*/ ctx[5] === undefined && !("remessaReceita" in props)) {
    			console.warn("<ReceitaXDespesa> was created without expected prop 'remessaReceita'");
    		}

    		if (/*remessaDespesa*/ ctx[6] === undefined && !("remessaDespesa" in props)) {
    			console.warn("<ReceitaXDespesa> was created without expected prop 'remessaDespesa'");
    		}
    	}

    	get remessaReceita() {
    		throw new Error("<ReceitaXDespesa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set remessaReceita(value) {
    		throw new Error("<ReceitaXDespesa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get remessaDespesa() {
    		throw new Error("<ReceitaXDespesa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set remessaDespesa(value) {
    		throw new Error("<ReceitaXDespesa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\despesas\_components\CardLiquidada.svelte generated by Svelte v3.22.3 */
    const file$H = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\despesas\\_components\\CardLiquidada.svelte";

    // (11:2) <span slot="title">
    function create_title_slot$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Despesa liquidada";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$H, 10, 2, 323);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$3.name,
    		type: "slot",
    		source: "(11:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:2) <span slot="tooltip">
    function create_tooltip_slot$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Informações diversas sobre a despesa liquidada no ano.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$H, 11, 2, 370);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$3.name,
    		type: "slot",
    		source: "(12:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (29:4) {:else}
    function create_else_block$7(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(29:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#if remessa}
    function create_if_block$e(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = format(/*remessa*/ ctx[0].value.liquidada) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "R$";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			attr_dev(span0, "class", "text-sm");
    			add_location(span0, file$H, 17, 8, 546);
    			attr_dev(span1, "class", "text-4xl font-bold");
    			add_location(span1, file$H, 18, 8, 587);
    			attr_dev(div, "class", "text-center");
    			add_location(div, file$H, 16, 6, 511);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*remessa*/ 1 && t2_value !== (t2_value = format(/*remessa*/ ctx[0].value.liquidada) + "")) set_data_dev(t2, t2_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(16:4) {#if remessa}",
    		ctx
    	});

    	return block;
    }

    // (10:0) <Widget>
    function create_default_slot$j(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$e, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*remessa*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$H, 14, 2, 466);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(10:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$j],
    					tooltip: [create_tooltip_slot$3],
    					title: [create_title_slot$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, remessa*/ 3) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let { remessa } = $$props;
    	const writable_props = ["remessa"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardLiquidada> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("CardLiquidada", $$slots, []);

    	$$self.$set = $$props => {
    		if ("remessa" in $$props) $$invalidate(0, remessa = $$props.remessa);
    	};

    	$$self.$capture_state = () => ({ Loading, Widget, format, remessa });

    	$$self.$inject_state = $$props => {
    		if ("remessa" in $$props) $$invalidate(0, remessa = $$props.remessa);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [remessa];
    }

    class CardLiquidada extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$K, safe_not_equal, { remessa: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardLiquidada",
    			options,
    			id: create_fragment$K.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*remessa*/ ctx[0] === undefined && !("remessa" in props)) {
    			console.warn("<CardLiquidada> was created without expected prop 'remessa'");
    		}
    	}

    	get remessa() {
    		throw new Error("<CardLiquidada>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set remessa(value) {
    		throw new Error("<CardLiquidada>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\_components\ComparacaoAnoAnterior.svelte generated by Svelte v3.22.3 */
    const file$I = "src\\pages\\_components\\ComparacaoAnoAnterior.svelte";
    const get_title_slot_changes$3 = dirty => ({});
    const get_title_slot_context$3 = ctx => ({});

    // (63:2) <span slot="title">
    function create_title_slot$4(ctx) {
    	let span;
    	let current;
    	const title_slot_template = /*$$slots*/ ctx[7].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[8], get_title_slot_context$3);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (title_slot) title_slot.c();
    			attr_dev(span, "slot", "title");
    			add_location(span, file$I, 62, 2, 1257);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (title_slot) {
    				title_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && dirty & /*$$scope*/ 256) {
    					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[8], get_title_slot_context$3), get_slot_changes(title_slot_template, /*$$scope*/ ctx[8], dirty, get_title_slot_changes$3));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$4.name,
    		type: "slot",
    		source: "(63:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (66:2) <span slot="tooltip">
    function create_tooltip_slot$4(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Possibilita comparar o montante arrecadado no exercício (ano) em relação à\r\n    arrecadação ocorrida no exercício anterior.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$I, 65, 2, 1318);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$4.name,
    		type: "slot",
    		source: "(66:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (73:4) {:else}
    function create_else_block$8(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(73:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (71:4) {#if model}
    function create_if_block$f(ctx) {
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				xAxis: /*xAxis*/ ctx[2],
    				yAxis: /*yAxis*/ ctx[4],
    				series: /*series*/ ctx[1],
    				tooltip: /*tooltip*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(series_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(series_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 4) series_1_changes.xAxis = /*xAxis*/ ctx[2];
    			if (dirty & /*series*/ 2) series_1_changes.series = /*series*/ ctx[1];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(series_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(71:4) {#if model}",
    		ctx
    	});

    	return block;
    }

    // (62:0) <Widget>
    function create_default_slot$k(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$f, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*model*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$I, 69, 2, 1483);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(62:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$k],
    					tooltip: [create_tooltip_slot$4],
    					title: [create_title_slot$4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, xAxis, series, model*/ 263) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { seriesProperty } = $$props;
    	const tooltip = { axisPointer: { type: "shadow" } };
    	let series;
    	let xAxis;

    	const yAxis = {
    		type: "value",
    		position: "top",
    		splitLine: {
    			lineStyle: false, /*{ type: "dashed" }*/
    			
    		}
    	};

    	function render(model) {
    		if (!model || !model.value) {
    			return;
    		}

    		const anos = [];
    		const data = [];

    		for (let i = 1; i < model.value.length; i++) {
    			const anterior = model.value[i - 1][seriesProperty];
    			const atual = model.value[i][seriesProperty];
    			data.push(Math.round(100 - anterior * 100 / atual));
    			anos.push(model.value[i].ano);
    		}

    		$$invalidate(2, xAxis = {
    			type: "category",
    			axisTick: { show: false },
    			data: anos
    		});

    		$$invalidate(1, series = [
    			{
    				type: "bar",
    				label: {
    					normal: { show: true, formatter: "{c}%" }
    				},
    				data
    			}
    		]);
    	}

    	const writable_props = ["model", "seriesProperty"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparacaoAnoAnterior> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparacaoAnoAnterior", $$slots, ['title']);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("seriesProperty" in $$props) $$invalidate(5, seriesProperty = $$props.seriesProperty);
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Series: Series$1,
    		Loading,
    		model,
    		seriesProperty,
    		tooltip,
    		series,
    		xAxis,
    		yAxis,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("seriesProperty" in $$props) $$invalidate(5, seriesProperty = $$props.seriesProperty);
    		if ("series" in $$props) $$invalidate(1, series = $$props.series);
    		if ("xAxis" in $$props) $$invalidate(2, xAxis = $$props.xAxis);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*model*/ 1) {
    			 render(model);
    		}
    	};

    	return [model, series, xAxis, tooltip, yAxis, seriesProperty, render, $$slots, $$scope];
    }

    class ComparacaoAnoAnterior extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$L, safe_not_equal, { model: 0, seriesProperty: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparacaoAnoAnterior",
    			options,
    			id: create_fragment$L.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<ComparacaoAnoAnterior> was created without expected prop 'model'");
    		}

    		if (/*seriesProperty*/ ctx[5] === undefined && !("seriesProperty" in props)) {
    			console.warn("<ComparacaoAnoAnterior> was created without expected prop 'seriesProperty'");
    		}
    	}

    	get model() {
    		throw new Error("<ComparacaoAnoAnterior>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<ComparacaoAnoAnterior>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seriesProperty() {
    		throw new Error("<ComparacaoAnoAnterior>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set seriesProperty(value) {
    		throw new Error("<ComparacaoAnoAnterior>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var faBed = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'bed';
    var width = 640;
    var height = 512;
    var ligatures = [];
    var unicode = 'f236';
    var svgPathData = 'M176 256c44.11 0 80-35.89 80-80s-35.89-80-80-80-80 35.89-80 80 35.89 80 80 80zm352-128H304c-8.84 0-16 7.16-16 16v144H64V80c0-8.84-7.16-16-16-16H16C7.16 64 0 71.16 0 80v352c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16v-48h512v48c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V240c0-61.86-50.14-112-112-112z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faBed = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faBed);
    var faBed_1 = faBed.definition;
    var faBed_2 = faBed.faBed;
    var faBed_3 = faBed.prefix;
    var faBed_4 = faBed.iconName;
    var faBed_5 = faBed.width;
    var faBed_6 = faBed.height;
    var faBed_7 = faBed.ligatures;
    var faBed_8 = faBed.unicode;
    var faBed_9 = faBed.svgPathData;

    var faCubes = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'cubes';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f1b3';
    var svgPathData = 'M488.6 250.2L392 214V105.5c0-15-9.3-28.4-23.4-33.7l-100-37.5c-8.1-3.1-17.1-3.1-25.3 0l-100 37.5c-14.1 5.3-23.4 18.7-23.4 33.7V214l-96.6 36.2C9.3 255.5 0 268.9 0 283.9V394c0 13.6 7.7 26.1 19.9 32.2l100 50c10.1 5.1 22.1 5.1 32.2 0l103.9-52 103.9 52c10.1 5.1 22.1 5.1 32.2 0l100-50c12.2-6.1 19.9-18.6 19.9-32.2V283.9c0-15-9.3-28.4-23.4-33.7zM358 214.8l-85 31.9v-68.2l85-37v73.3zM154 104.1l102-38.2 102 38.2v.6l-102 41.4-102-41.4v-.6zm84 291.1l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6zm240 112l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faCubes = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faCubes);
    var faCubes_1 = faCubes.definition;
    var faCubes_2 = faCubes.faCubes;
    var faCubes_3 = faCubes.prefix;
    var faCubes_4 = faCubes.iconName;
    var faCubes_5 = faCubes.width;
    var faCubes_6 = faCubes.height;
    var faCubes_7 = faCubes.ligatures;
    var faCubes_8 = faCubes.unicode;
    var faCubes_9 = faCubes.svgPathData;

    var faHammer = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'hammer';
    var width = 576;
    var height = 512;
    var ligatures = [];
    var unicode = 'f6e3';
    var svgPathData = 'M571.31 193.94l-22.63-22.63c-6.25-6.25-16.38-6.25-22.63 0l-11.31 11.31-28.9-28.9c5.63-21.31.36-44.9-16.35-61.61l-45.25-45.25c-62.48-62.48-163.79-62.48-226.28 0l90.51 45.25v18.75c0 16.97 6.74 33.25 18.75 45.25l49.14 49.14c16.71 16.71 40.3 21.98 61.61 16.35l28.9 28.9-11.31 11.31c-6.25 6.25-6.25 16.38 0 22.63l22.63 22.63c6.25 6.25 16.38 6.25 22.63 0l90.51-90.51c6.23-6.24 6.23-16.37-.02-22.62zm-286.72-15.2c-3.7-3.7-6.84-7.79-9.85-11.95L19.64 404.96c-25.57 23.88-26.26 64.19-1.53 88.93s65.05 24.05 88.93-1.53l238.13-255.07c-3.96-2.91-7.9-5.87-11.44-9.41l-49.14-49.14z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faHammer = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faHammer);
    var faHammer_1 = faHammer.definition;
    var faHammer_2 = faHammer.faHammer;
    var faHammer_3 = faHammer.prefix;
    var faHammer_4 = faHammer.iconName;
    var faHammer_5 = faHammer.width;
    var faHammer_6 = faHammer.height;
    var faHammer_7 = faHammer.ligatures;
    var faHammer_8 = faHammer.unicode;
    var faHammer_9 = faHammer.svgPathData;

    var faBarcode = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'barcode';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f02a';
    var svgPathData = 'M0 448V64h18v384H0zm26.857-.273V64H36v383.727h-9.143zm27.143 0V64h8.857v383.727H54zm44.857 0V64h8.857v383.727h-8.857zm36 0V64h17.714v383.727h-17.714zm44.857 0V64h8.857v383.727h-8.857zm18 0V64h8.857v383.727h-8.857zm18 0V64h8.857v383.727h-8.857zm35.715 0V64h18v383.727h-18zm44.857 0V64h18v383.727h-18zm35.999 0V64h18.001v383.727h-18.001zm36.001 0V64h18.001v383.727h-18.001zm26.857 0V64h18v383.727h-18zm45.143 0V64h26.857v383.727h-26.857zm35.714 0V64h9.143v383.727H476zm18 .273V64h18v384h-18z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faBarcode = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faBarcode);
    var faBarcode_1 = faBarcode.definition;
    var faBarcode_2 = faBarcode.faBarcode;
    var faBarcode_3 = faBarcode.prefix;
    var faBarcode_4 = faBarcode.iconName;
    var faBarcode_5 = faBarcode.width;
    var faBarcode_6 = faBarcode.height;
    var faBarcode_7 = faBarcode.ligatures;
    var faBarcode_8 = faBarcode.unicode;
    var faBarcode_9 = faBarcode.svgPathData;

    /* src\pages\_components\EvolucaoAnual.svelte generated by Svelte v3.22.3 */
    const file$J = "src\\pages\\_components\\EvolucaoAnual.svelte";
    const get_tooltip_slot_changes$3 = dirty => ({});
    const get_tooltip_slot_context$3 = ctx => ({});

    // (56:2) <span slot="title">
    function create_title_slot$5(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução anual";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$J, 55, 2, 1056);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$5.name,
    		type: "slot",
    		source: "(56:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (57:2) <span slot="tooltip" bind:this={tooltipRef}>
    function create_tooltip_slot$5(ctx) {
    	let span;
    	let current;
    	const tooltip_slot_template = /*$$slots*/ ctx[9].tooltip;
    	const tooltip_slot = create_slot(tooltip_slot_template, ctx, /*$$scope*/ ctx[11], get_tooltip_slot_context$3);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (tooltip_slot) tooltip_slot.c();
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$J, 56, 2, 1100);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (tooltip_slot) {
    				tooltip_slot.m(span, null);
    			}

    			/*span_binding*/ ctx[10](span);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (tooltip_slot) {
    				if (tooltip_slot.p && dirty & /*$$scope*/ 2048) {
    					tooltip_slot.p(get_slot_context(tooltip_slot_template, ctx, /*$$scope*/ ctx[11], get_tooltip_slot_context$3), get_slot_changes(tooltip_slot_template, /*$$scope*/ ctx[11], dirty, get_tooltip_slot_changes$3));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (tooltip_slot) tooltip_slot.d(detaching);
    			/*span_binding*/ ctx[10](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$5.name,
    		type: "slot",
    		source: "(57:2) <span slot=\\\"tooltip\\\" bind:this={tooltipRef}>",
    		ctx
    	});

    	return block;
    }

    // (63:4) {:else}
    function create_else_block$9(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(63:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (61:4) {#if model}
    function create_if_block$g(ctx) {
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				xAxis: /*xAxis*/ ctx[2],
    				yAxis: /*yAxis*/ ctx[5],
    				series: /*series*/ ctx[3],
    				options: /*options*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(series_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(series_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 4) series_1_changes.xAxis = /*xAxis*/ ctx[2];
    			if (dirty & /*series*/ 8) series_1_changes.series = /*series*/ ctx[3];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(series_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(61:4) {#if model}",
    		ctx
    	});

    	return block;
    }

    // (55:0) <Widget noTooltip={tooltipRef.innerHTML.trim().length === 0}>
    function create_default_slot$l(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$g, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*model*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$J, 59, 2, 1188);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(55:0) <Widget noTooltip={tooltipRef.innerHTML.trim().length === 0}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				noTooltip: /*tooltipRef*/ ctx[1].innerHTML.trim().length === 0,
    				$$slots: {
    					default: [create_default_slot$l],
    					tooltip: [create_tooltip_slot$5],
    					title: [create_title_slot$5]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};
    			if (dirty & /*tooltipRef*/ 2) widget_changes.noTooltip = /*tooltipRef*/ ctx[1].innerHTML.trim().length === 0;

    			if (dirty & /*$$scope, xAxis, series, model, tooltipRef*/ 2063) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { seriesName } = $$props;
    	let { seriesProperty } = $$props;
    	let tooltipRef = { innerHTML: "" };
    	const options = { legend: { show: false } };
    	const yAxis = { show: false };
    	let xAxis;
    	let series;

    	function refresh(model) {
    		if (!model) {
    			return;
    		}

    		const anos = [];
    		const values = [];

    		model.value.forEach(o => {
    			anos.push(o.ano);
    			values.push(o[seriesProperty]);
    		});

    		$$invalidate(2, xAxis = [
    			{
    				type: "category",
    				data: anos,
    				axisPointer: { type: "shadow" }
    			}
    		]);

    		$$invalidate(3, series = [
    			{
    				type: "bar",
    				name: seriesName,
    				data: values
    			}
    		]);
    	}

    	const writable_props = ["model", "seriesName", "seriesProperty"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoAnual> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoAnual", $$slots, ['tooltip']);

    	function span_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(1, tooltipRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("seriesName" in $$props) $$invalidate(6, seriesName = $$props.seriesName);
    		if ("seriesProperty" in $$props) $$invalidate(7, seriesProperty = $$props.seriesProperty);
    		if ("$$scope" in $$props) $$invalidate(11, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Series: Series$1,
    		Loading,
    		model,
    		seriesName,
    		seriesProperty,
    		tooltipRef,
    		options,
    		yAxis,
    		xAxis,
    		series,
    		refresh
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("seriesName" in $$props) $$invalidate(6, seriesName = $$props.seriesName);
    		if ("seriesProperty" in $$props) $$invalidate(7, seriesProperty = $$props.seriesProperty);
    		if ("tooltipRef" in $$props) $$invalidate(1, tooltipRef = $$props.tooltipRef);
    		if ("xAxis" in $$props) $$invalidate(2, xAxis = $$props.xAxis);
    		if ("series" in $$props) $$invalidate(3, series = $$props.series);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*model*/ 1) {
    			 refresh(model);
    		}
    	};

    	return [
    		model,
    		tooltipRef,
    		xAxis,
    		series,
    		options,
    		yAxis,
    		seriesName,
    		seriesProperty,
    		refresh,
    		$$slots,
    		span_binding,
    		$$scope
    	];
    }

    class EvolucaoAnual extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$L, create_fragment$M, safe_not_equal, {
    			model: 0,
    			seriesName: 6,
    			seriesProperty: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoAnual",
    			options,
    			id: create_fragment$M.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoAnual> was created without expected prop 'model'");
    		}

    		if (/*seriesName*/ ctx[6] === undefined && !("seriesName" in props)) {
    			console.warn("<EvolucaoAnual> was created without expected prop 'seriesName'");
    		}

    		if (/*seriesProperty*/ ctx[7] === undefined && !("seriesProperty" in props)) {
    			console.warn("<EvolucaoAnual> was created without expected prop 'seriesProperty'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoAnual>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoAnual>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seriesName() {
    		throw new Error("<EvolucaoAnual>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set seriesName(value) {
    		throw new Error("<EvolucaoAnual>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seriesProperty() {
    		throw new Error("<EvolucaoAnual>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set seriesProperty(value) {
    		throw new Error("<EvolucaoAnual>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\_components\EvolucaoMensal.svelte generated by Svelte v3.22.3 */
    const file$K = "src\\pages\\_components\\EvolucaoMensal.svelte";
    const get_tooltip_slot_changes$4 = dirty => ({});
    const get_tooltip_slot_context$4 = ctx => ({});

    // (66:2) <span slot="title">
    function create_title_slot$6(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução mensal";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$K, 65, 2, 1150);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$6.name,
    		type: "slot",
    		source: "(66:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (67:2) <span slot="tooltip" bind:this={tooltipRef}>
    function create_tooltip_slot$6(ctx) {
    	let span;
    	let current;
    	const tooltip_slot_template = /*$$slots*/ ctx[10].tooltip;
    	const tooltip_slot = create_slot(tooltip_slot_template, ctx, /*$$scope*/ ctx[12], get_tooltip_slot_context$4);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (tooltip_slot) tooltip_slot.c();
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$K, 66, 2, 1195);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (tooltip_slot) {
    				tooltip_slot.m(span, null);
    			}

    			/*span_binding*/ ctx[11](span);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (tooltip_slot) {
    				if (tooltip_slot.p && dirty & /*$$scope*/ 4096) {
    					tooltip_slot.p(get_slot_context(tooltip_slot_template, ctx, /*$$scope*/ ctx[12], get_tooltip_slot_context$4), get_slot_changes(tooltip_slot_template, /*$$scope*/ ctx[12], dirty, get_tooltip_slot_changes$4));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (tooltip_slot) tooltip_slot.d(detaching);
    			/*span_binding*/ ctx[11](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$6.name,
    		type: "slot",
    		source: "(67:2) <span slot=\\\"tooltip\\\" bind:this={tooltipRef}>",
    		ctx
    	});

    	return block;
    }

    // (73:4) {:else}
    function create_else_block$a(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(73:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (71:4) {#if model}
    function create_if_block$h(ctx) {
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				xAxis: /*xAxis*/ ctx[5],
    				yAxis: /*yAxis*/ ctx[4],
    				series: /*series*/ ctx[1],
    				options: /*options*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(series_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(series_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*series*/ 2) series_1_changes.series = /*series*/ ctx[1];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(series_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(71:4) {#if model}",
    		ctx
    	});

    	return block;
    }

    // (65:0) <Widget noTooltip={tooltipRef.innerHTML.trim().length === 0}>
    function create_default_slot$m(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$h, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*model*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$K, 69, 2, 1283);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(65:0) <Widget noTooltip={tooltipRef.innerHTML.trim().length === 0}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				noTooltip: /*tooltipRef*/ ctx[2].innerHTML.trim().length === 0,
    				$$slots: {
    					default: [create_default_slot$m],
    					tooltip: [create_tooltip_slot$6],
    					title: [create_title_slot$6]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};
    			if (dirty & /*tooltipRef*/ 4) widget_changes.noTooltip = /*tooltipRef*/ ctx[2].innerHTML.trim().length === 0;

    			if (dirty & /*$$scope, series, model, tooltipRef*/ 4103) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { seriesName } = $$props;
    	let { seriesProperty } = $$props;

    	const meses = [
    		"Jan",
    		"Fev",
    		"Mar",
    		"Abr",
    		"Mai",
    		"Jun",
    		"Jul",
    		"Ago",
    		"Set",
    		"Out",
    		"Nov",
    		"Dez"
    	];

    	const options = { legend: { show: false } };
    	const yAxis = { show: false };

    	const xAxis = [
    		{
    			type: "category",
    			data: meses,
    			axisPointer: { type: "shadow" }
    		}
    	];

    	let series;
    	let tooltipRef = { innerHTML: "" };

    	function refresh(model) {
    		if (!model) {
    			return;
    		}

    		const values = [];

    		model.value.forEach(o => {
    			values.push(o[seriesProperty]);
    		});

    		$$invalidate(1, series = [
    			{
    				type: "bar",
    				name: seriesName,
    				data: values
    			}
    		]);
    	}

    	const writable_props = ["model", "seriesName", "seriesProperty"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoMensal> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoMensal", $$slots, ['tooltip']);

    	function span_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(2, tooltipRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("seriesName" in $$props) $$invalidate(6, seriesName = $$props.seriesName);
    		if ("seriesProperty" in $$props) $$invalidate(7, seriesProperty = $$props.seriesProperty);
    		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Series: Series$1,
    		Loading,
    		model,
    		seriesName,
    		seriesProperty,
    		meses,
    		options,
    		yAxis,
    		xAxis,
    		series,
    		tooltipRef,
    		refresh
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("seriesName" in $$props) $$invalidate(6, seriesName = $$props.seriesName);
    		if ("seriesProperty" in $$props) $$invalidate(7, seriesProperty = $$props.seriesProperty);
    		if ("series" in $$props) $$invalidate(1, series = $$props.series);
    		if ("tooltipRef" in $$props) $$invalidate(2, tooltipRef = $$props.tooltipRef);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*model*/ 1) {
    			 refresh(model);
    		}
    	};

    	return [
    		model,
    		series,
    		tooltipRef,
    		options,
    		yAxis,
    		xAxis,
    		seriesName,
    		seriesProperty,
    		meses,
    		refresh,
    		$$slots,
    		span_binding,
    		$$scope
    	];
    }

    class EvolucaoMensal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$M, create_fragment$N, safe_not_equal, {
    			model: 0,
    			seriesName: 6,
    			seriesProperty: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoMensal",
    			options,
    			id: create_fragment$N.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoMensal> was created without expected prop 'model'");
    		}

    		if (/*seriesName*/ ctx[6] === undefined && !("seriesName" in props)) {
    			console.warn("<EvolucaoMensal> was created without expected prop 'seriesName'");
    		}

    		if (/*seriesProperty*/ ctx[7] === undefined && !("seriesProperty" in props)) {
    			console.warn("<EvolucaoMensal> was created without expected prop 'seriesProperty'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoMensal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoMensal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seriesName() {
    		throw new Error("<EvolucaoMensal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set seriesName(value) {
    		throw new Error("<EvolucaoMensal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seriesProperty() {
    		throw new Error("<EvolucaoMensal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set seriesProperty(value) {
    		throw new Error("<EvolucaoMensal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\_components\Destaque.svelte generated by Svelte v3.22.3 */
    const file$L = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\_components\\Destaque.svelte";
    const get_title_slot_changes$4 = dirty => ({});
    const get_title_slot_context$4 = ctx => ({});
    const get_icon_slot_changes$1 = dirty => ({});
    const get_icon_slot_context$1 = ctx => ({});

    // (81:4) {:else}
    function create_else_block_1$2(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(81:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (79:4) {#if model}
    function create_if_block_1$8(ctx) {
    	let div;
    	let t_value = format(/*model*/ ctx[0].value) + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "text-lg w-full font-bold");
    			add_location(div, file$L, 79, 6, 2351);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*model*/ 1 && t_value !== (t_value = format(/*model*/ ctx[0].value) + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(79:4) {#if model}",
    		ctx
    	});

    	return block;
    }

    // (87:4) <span slot="header">
    function create_header_slot$1(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*title*/ ctx[1]);
    			attr_dev(span, "slot", "header");
    			add_location(span, file$L, 86, 4, 2525);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 2) set_data_dev(t, /*title*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot$1.name,
    		type: "slot",
    		source: "(87:4) <span slot=\\\"header\\\">",
    		ctx
    	});

    	return block;
    }

    // (103:4) {:else}
    function create_else_block$b(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(103:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (90:4) {#if seriesEvolucaoAnual && seriesEvolucaoMensal}
    function create_if_block$i(ctx) {
    	let div0;
    	let t;
    	let div1;
    	let current;

    	const evolucaoanual = new EvolucaoAnual({
    			props: {
    				model: /*seriesEvolucaoAnual*/ ctx[5],
    				seriesName: /*seriesName*/ ctx[2],
    				seriesProperty: /*seriesProperty*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const evolucaomensal = new EvolucaoMensal({
    			props: {
    				model: /*seriesEvolucaoMensal*/ ctx[6],
    				seriesName: /*seriesName*/ ctx[2],
    				seriesProperty: /*seriesProperty*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(evolucaoanual.$$.fragment);
    			t = space();
    			div1 = element("div");
    			create_component(evolucaomensal.$$.fragment);
    			attr_dev(div0, "class", "mb-3");
    			add_location(div0, file$L, 90, 6, 2649);
    			add_location(div1, file$L, 96, 6, 2807);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(evolucaoanual, div0, null);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(evolucaomensal, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const evolucaoanual_changes = {};
    			if (dirty & /*seriesEvolucaoAnual*/ 32) evolucaoanual_changes.model = /*seriesEvolucaoAnual*/ ctx[5];
    			if (dirty & /*seriesName*/ 4) evolucaoanual_changes.seriesName = /*seriesName*/ ctx[2];
    			if (dirty & /*seriesProperty*/ 8) evolucaoanual_changes.seriesProperty = /*seriesProperty*/ ctx[3];
    			evolucaoanual.$set(evolucaoanual_changes);
    			const evolucaomensal_changes = {};
    			if (dirty & /*seriesEvolucaoMensal*/ 64) evolucaomensal_changes.model = /*seriesEvolucaoMensal*/ ctx[6];
    			if (dirty & /*seriesName*/ 4) evolucaomensal_changes.seriesName = /*seriesName*/ ctx[2];
    			if (dirty & /*seriesProperty*/ 8) evolucaomensal_changes.seriesProperty = /*seriesProperty*/ ctx[3];
    			evolucaomensal.$set(evolucaomensal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(evolucaoanual.$$.fragment, local);
    			transition_in(evolucaomensal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(evolucaoanual.$$.fragment, local);
    			transition_out(evolucaomensal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(evolucaoanual);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    			destroy_component(evolucaomensal);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(90:4) {#if seriesEvolucaoAnual && seriesEvolucaoMensal}",
    		ctx
    	});

    	return block;
    }

    // (86:2) <Modal bind:this={modalRef} class="w-full">
    function create_default_slot$n(ctx) {
    	let t0;
    	let hr;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$i, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*seriesEvolucaoAnual*/ ctx[5] && /*seriesEvolucaoMensal*/ ctx[6]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			hr = element("hr");
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(hr, "class", "mb-3");
    			add_location(hr, file$L, 87, 4, 2565);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(86:2) <Modal bind:this={modalRef} class=\\\"w-full\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let span1;
    	let span0;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let t2;
    	let current;
    	let dispose;
    	const icon_slot_template = /*$$slots*/ ctx[17].icon;
    	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[19], get_icon_slot_context$1);
    	const title_slot_template = /*$$slots*/ ctx[17].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[19], get_title_slot_context$4);
    	const if_block_creators = [create_if_block_1$8, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*model*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let modal_props = {
    		class: "w-full",
    		$$slots: {
    			default: [create_default_slot$n],
    			header: [create_header_slot$1]
    		},
    		$$scope: { ctx }
    	};

    	const modal = new Modal({ props: modal_props, $$inline: true });
    	/*modal_binding*/ ctx[18](modal);

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			span0 = element("span");
    			div0 = element("div");
    			if (icon_slot) icon_slot.c();
    			t0 = space();
    			div1 = element("div");
    			if (title_slot) title_slot.c();
    			t1 = space();
    			if_block.c();
    			t2 = space();
    			create_component(modal.$$.fragment);
    			attr_dev(div0, "class", "text-3xl h-full float-left px-2");
    			add_location(div0, file$L, 72, 4, 2166);
    			attr_dev(div1, "class", "text-lg w-full");
    			add_location(div1, file$L, 75, 4, 2257);
    			attr_dev(span0, "class", "destaque svelte-1kmd3gs");
    			add_location(span0, file$L, 71, 2, 2118);
    			set_style(span1, "position", "relative");
    			add_location(span1, file$L, 70, 0, 2081);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, span0);
    			append_dev(span0, div0);

    			if (icon_slot) {
    				icon_slot.m(div0, null);
    			}

    			append_dev(span0, t0);
    			append_dev(span0, div1);

    			if (title_slot) {
    				title_slot.m(div1, null);
    			}

    			append_dev(span0, t1);
    			if_blocks[current_block_type_index].m(span0, null);
    			append_dev(span1, t2);
    			mount_component(modal, span1, null);
    			current = true;
    			if (remount) dispose();
    			dispose = listen_dev(span0, "click", /*onClick*/ ctx[7], false, false, false);
    		},
    		p: function update(ctx, [dirty]) {
    			if (icon_slot) {
    				if (icon_slot.p && dirty & /*$$scope*/ 524288) {
    					icon_slot.p(get_slot_context(icon_slot_template, ctx, /*$$scope*/ ctx[19], get_icon_slot_context$1), get_slot_changes(icon_slot_template, /*$$scope*/ ctx[19], dirty, get_icon_slot_changes$1));
    				}
    			}

    			if (title_slot) {
    				if (title_slot.p && dirty & /*$$scope*/ 524288) {
    					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[19], get_title_slot_context$4), get_slot_changes(title_slot_template, /*$$scope*/ ctx[19], dirty, get_title_slot_changes$4));
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(span0, null);
    			}

    			const modal_changes = {};

    			if (dirty & /*$$scope, seriesEvolucaoMensal, seriesName, seriesProperty, seriesEvolucaoAnual, title*/ 524398) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_slot, local);
    			transition_in(title_slot, local);
    			transition_in(if_block);
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_slot, local);
    			transition_out(title_slot, local);
    			transition_out(if_block);
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    			if (icon_slot) icon_slot.d(detaching);
    			if (title_slot) title_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			/*modal_binding*/ ctx[18](null);
    			destroy_component(modal);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(11, $params = $$value));
    	const ano = parseInt($params.ano);
    	const ug = $params.ug;
    	const municipio = ug === "consolidado" ? $params.municipio : ug;
    	let { model } = $$props;
    	let { workflow } = $$props;
    	let { workflowAnual } = $$props;
    	let { workflowMensal } = $$props;
    	let { title } = $$props;
    	let { seriesName } = $$props;
    	let { seriesProperty } = $$props;
    	let modalRef;
    	let seriesEvolucaoAnual;
    	let seriesEvolucaoMensal;

    	function getDestaqueEvolucaoAnual(ano, municipio) {
    		const workflows = workflow(ano, municipio, workflowAnual);
    		workflows[0].id = "destaqueEvolucaoAnual";
    		return workflows;
    	}

    	function getDestaqueEvolucaoMensal(ano, municipio) {
    		const workflows = workflow(ano, municipio, workflowMensal);
    		workflows[0].id = "destaqueEvolucaoMensal";
    		return workflows;
    	}

    	async function onClick() {
    		modalRef.show();

    		if (!seriesEvolucaoAnual || !seriesEvolucaoMensal) {
    			const res = await axios$1.post(api.getApiUrl("DWControleSocial"), getDestaqueEvolucaoAnual(ano, municipio).concat(getDestaqueEvolucaoMensal(ano, municipio)));

    			if (res.data[0].id === "destaqueEvolucaoAnual") {
    				$$invalidate(5, seriesEvolucaoAnual = res.data[0]);
    				$$invalidate(6, seriesEvolucaoMensal = res.data[1]);
    			} else {
    				$$invalidate(5, seriesEvolucaoAnual = res.data[1]);
    				$$invalidate(6, seriesEvolucaoMensal = res.data[0]);
    			}
    		}
    	}

    	const writable_props = [
    		"model",
    		"workflow",
    		"workflowAnual",
    		"workflowMensal",
    		"title",
    		"seriesName",
    		"seriesProperty"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Destaque> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Destaque", $$slots, ['icon','title']);

    	function modal_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(4, modalRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("workflow" in $$props) $$invalidate(8, workflow = $$props.workflow);
    		if ("workflowAnual" in $$props) $$invalidate(9, workflowAnual = $$props.workflowAnual);
    		if ("workflowMensal" in $$props) $$invalidate(10, workflowMensal = $$props.workflowMensal);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    		if ("seriesName" in $$props) $$invalidate(2, seriesName = $$props.seriesName);
    		if ("seriesProperty" in $$props) $$invalidate(3, seriesProperty = $$props.seriesProperty);
    		if ("$$scope" in $$props) $$invalidate(19, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		api,
    		format,
    		Loading,
    		Modal,
    		EvolucaoAnual,
    		EvolucaoMensal,
    		ano,
    		ug,
    		municipio,
    		model,
    		workflow,
    		workflowAnual,
    		workflowMensal,
    		title,
    		seriesName,
    		seriesProperty,
    		modalRef,
    		seriesEvolucaoAnual,
    		seriesEvolucaoMensal,
    		getDestaqueEvolucaoAnual,
    		getDestaqueEvolucaoMensal,
    		onClick,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("workflow" in $$props) $$invalidate(8, workflow = $$props.workflow);
    		if ("workflowAnual" in $$props) $$invalidate(9, workflowAnual = $$props.workflowAnual);
    		if ("workflowMensal" in $$props) $$invalidate(10, workflowMensal = $$props.workflowMensal);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    		if ("seriesName" in $$props) $$invalidate(2, seriesName = $$props.seriesName);
    		if ("seriesProperty" in $$props) $$invalidate(3, seriesProperty = $$props.seriesProperty);
    		if ("modalRef" in $$props) $$invalidate(4, modalRef = $$props.modalRef);
    		if ("seriesEvolucaoAnual" in $$props) $$invalidate(5, seriesEvolucaoAnual = $$props.seriesEvolucaoAnual);
    		if ("seriesEvolucaoMensal" in $$props) $$invalidate(6, seriesEvolucaoMensal = $$props.seriesEvolucaoMensal);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		model,
    		title,
    		seriesName,
    		seriesProperty,
    		modalRef,
    		seriesEvolucaoAnual,
    		seriesEvolucaoMensal,
    		onClick,
    		workflow,
    		workflowAnual,
    		workflowMensal,
    		$params,
    		ano,
    		ug,
    		municipio,
    		getDestaqueEvolucaoAnual,
    		getDestaqueEvolucaoMensal,
    		$$slots,
    		modal_binding,
    		$$scope
    	];
    }

    class Destaque extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$N, create_fragment$O, safe_not_equal, {
    			model: 0,
    			workflow: 8,
    			workflowAnual: 9,
    			workflowMensal: 10,
    			title: 1,
    			seriesName: 2,
    			seriesProperty: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Destaque",
    			options,
    			id: create_fragment$O.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<Destaque> was created without expected prop 'model'");
    		}

    		if (/*workflow*/ ctx[8] === undefined && !("workflow" in props)) {
    			console.warn("<Destaque> was created without expected prop 'workflow'");
    		}

    		if (/*workflowAnual*/ ctx[9] === undefined && !("workflowAnual" in props)) {
    			console.warn("<Destaque> was created without expected prop 'workflowAnual'");
    		}

    		if (/*workflowMensal*/ ctx[10] === undefined && !("workflowMensal" in props)) {
    			console.warn("<Destaque> was created without expected prop 'workflowMensal'");
    		}

    		if (/*title*/ ctx[1] === undefined && !("title" in props)) {
    			console.warn("<Destaque> was created without expected prop 'title'");
    		}

    		if (/*seriesName*/ ctx[2] === undefined && !("seriesName" in props)) {
    			console.warn("<Destaque> was created without expected prop 'seriesName'");
    		}

    		if (/*seriesProperty*/ ctx[3] === undefined && !("seriesProperty" in props)) {
    			console.warn("<Destaque> was created without expected prop 'seriesProperty'");
    		}
    	}

    	get model() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get workflow() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set workflow(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get workflowAnual() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set workflowAnual(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get workflowMensal() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set workflowMensal(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seriesName() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set seriesName(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seriesProperty() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set seriesProperty(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function despesaDestaqueDiarias(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "despesaDestaqueDiarias",
    			run: "Municipio.Despesa.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.Like",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ["3___14%", "4___14%"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function despesaDestaqueMaterialDeConsumo(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "despesaDestaqueMaterialDeConsumo",
    			run: "Municipio.Despesa.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.Like",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ["3___30%", "4___30%"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function despesaDestaqueMaterialPermanente(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "despesaDestaqueMaterialPermanente",
    			run: "Municipio.Despesa.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.Like",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ["3___52%", "4___52%"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function despesaDestaqueObras(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "despesaDestaqueObras",
    			run: "Municipio.Despesa.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.Like",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ["3___51%", "4___51%"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function despesaEmpenhada(ano, ug) {
    	return [
    		{
    			id: "despesaEmpenhada",
    			run: "Municipio.Despesa.FiltrarPorAnoECodigo",
    			args: [ano, ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Despesa.Empenhada",
    			args: []
    		}
    	];
    }

    function despesaEvolucaoAnual(ano, ug, quantidade = 5) {
    	return [
    		{
    			id: "despesaEvolucaoAnual",
    			run: "Municipio.Despesa.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Despesa.EvolucaoAnual",
    			args: [ano, quantidade]
    		}
    	];
    }

    function despesaEvolucaoMensal(ano, ug) {
    	return [
    		{
    			id: "despesaEvolucaoMensal",
    			run: "Municipio.Despesa.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Despesa.EvolucaoMensal",
    			args: [ano]
    		}
    	];
    }

    function despesaLiquidada(ano, ug) {
    	return [
    		{
    			id: "despesaLiquidada",
    			run: "Municipio.Despesa.FiltrarPorAnoECodigo",
    			args: [ano, ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Despesa.Liquidada",
    			args: []
    		}
    	];
    }

    function despesaMaioresLiquidadaPorFuncao(ano, ug, quantidade = 5) {
    	return [
    		{
    			id: "despesaMaioresLiquidadaPorFuncao",
    			run: "Municipio.Despesa.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Despesa.MaioresLiquidadaPorFuncao",
    			args: [ano, quantidade]
    		}
    	];
    }

    function despesaPaga(ano, ug) {
    	return [
    		{
    			id: "despesaPaga",
    			run: "Municipio.Despesa.FiltrarPorAnoECodigo",
    			args: [ano, ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Despesa.Paga",
    			args: []
    		}
    	];
    }

    function despesaPrevisaoInicial(ano, ug) {
    	return [
    		{
    			id: "despesaPrevisaoInicial",
    			run: "Municipio.Despesa.FiltrarPorAnoECodigo",
    			args: [ano, ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Despesa.PrevisaoInicial",
    			args: []
    		}
    	];
    }

    function despesaRemessaAtual(ano, ug) {
    	return [
    		{
    			id: "despesaRemessaAtual",
    			run: "Municipio.Despesa.FiltrarPorAnoECodigo1",
    			args: [ano, ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Despesa.RemessaAtual",
    			args: []
    		}
    	];
    }

    function despesaSumLiquidada() {
    	return [
    		{
    			id: "despesaSumLiquidada",
    			run: "Municipio.Despesa.Liquidada"
    		}
    	];
    }

    var despesaApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        despesaDestaqueDiarias: despesaDestaqueDiarias,
        despesaDestaqueMaterialDeConsumo: despesaDestaqueMaterialDeConsumo,
        despesaDestaqueMaterialPermanente: despesaDestaqueMaterialPermanente,
        despesaDestaqueObras: despesaDestaqueObras,
        despesaEmpenhada: despesaEmpenhada,
        despesaEvolucaoAnual: despesaEvolucaoAnual,
        despesaEvolucaoMensal: despesaEvolucaoMensal,
        despesaLiquidada: despesaLiquidada,
        despesaMaioresLiquidadaPorFuncao: despesaMaioresLiquidadaPorFuncao,
        despesaPaga: despesaPaga,
        despesaPrevisaoInicial: despesaPrevisaoInicial,
        despesaRemessaAtual: despesaRemessaAtual,
        despesaSumLiquidada: despesaSumLiquidada
    });

    /* src\pages\municipio\[ano]\[municipio]\[ug]\despesas\_components\Destaque.svelte generated by Svelte v3.22.3 */

    const file$M = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\despesas\\_components\\Destaque.svelte";
    const get_title_slot_changes$5 = dirty => ({});
    const get_title_slot_context$5 = ctx => ({});
    const get_icon_slot_changes$2 = dirty => ({});
    const get_icon_slot_context$2 = ctx => ({});

    // (22:2) <span slot="icon">
    function create_icon_slot$1(ctx) {
    	let span;
    	let current;
    	const icon_slot_template = /*$$slots*/ ctx[3].icon;
    	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[4], get_icon_slot_context$2);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (icon_slot) icon_slot.c();
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$M, 21, 2, 478);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (icon_slot) {
    				icon_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (icon_slot) {
    				if (icon_slot.p && dirty & /*$$scope*/ 16) {
    					icon_slot.p(get_slot_context(icon_slot_template, ctx, /*$$scope*/ ctx[4], get_icon_slot_context$2), get_slot_changes(icon_slot_template, /*$$scope*/ ctx[4], dirty, get_icon_slot_changes$2));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (icon_slot) icon_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot$1.name,
    		type: "slot",
    		source: "(22:2) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (25:2) <span slot="title">
    function create_title_slot$7(ctx) {
    	let span;
    	let current;
    	const title_slot_template = /*$$slots*/ ctx[3].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[4], get_title_slot_context$5);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (title_slot) title_slot.c();
    			attr_dev(span, "slot", "title");
    			add_location(span, file$M, 24, 2, 537);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (title_slot) {
    				title_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && dirty & /*$$scope*/ 16) {
    					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[4], get_title_slot_context$5), get_slot_changes(title_slot_template, /*$$scope*/ ctx[4], dirty, get_title_slot_changes$5));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$7.name,
    		type: "slot",
    		source: "(25:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (14:0) <Destaque    {model}    {workflow}    workflowAnual={despesaEvolucaoAnual}    workflowMensal={despesaEvolucaoMensal}    {title}    seriesName="Despesa liquidada"    seriesProperty="liquidada">
    function create_default_slot$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(14:0) <Destaque    {model}    {workflow}    workflowAnual={despesaEvolucaoAnual}    workflowMensal={despesaEvolucaoMensal}    {title}    seriesName=\\\"Despesa liquidada\\\"    seriesProperty=\\\"liquidada\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let current;

    	const destaque = new Destaque({
    			props: {
    				model: /*model*/ ctx[0],
    				workflow: /*workflow*/ ctx[1],
    				workflowAnual: despesaEvolucaoAnual,
    				workflowMensal: despesaEvolucaoMensal,
    				title: /*title*/ ctx[2],
    				seriesName: "Despesa liquidada",
    				seriesProperty: "liquidada",
    				$$slots: {
    					default: [create_default_slot$o],
    					title: [create_title_slot$7],
    					icon: [create_icon_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(destaque.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(destaque, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const destaque_changes = {};
    			if (dirty & /*model*/ 1) destaque_changes.model = /*model*/ ctx[0];
    			if (dirty & /*workflow*/ 2) destaque_changes.workflow = /*workflow*/ ctx[1];
    			if (dirty & /*title*/ 4) destaque_changes.title = /*title*/ ctx[2];

    			if (dirty & /*$$scope*/ 16) {
    				destaque_changes.$$scope = { dirty, ctx };
    			}

    			destaque.$set(destaque_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(destaque.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(destaque.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(destaque, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { workflow } = $$props;
    	let { title } = $$props;
    	const writable_props = ["model", "workflow", "title"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Destaque> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Destaque", $$slots, ['icon','title']);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("workflow" in $$props) $$invalidate(1, workflow = $$props.workflow);
    		if ("title" in $$props) $$invalidate(2, title = $$props.title);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Destaque,
    		despesaEvolucaoAnual,
    		despesaEvolucaoMensal,
    		model,
    		workflow,
    		title
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("workflow" in $$props) $$invalidate(1, workflow = $$props.workflow);
    		if ("title" in $$props) $$invalidate(2, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model, workflow, title, $$slots, $$scope];
    }

    class Destaque_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$P, safe_not_equal, { model: 0, workflow: 1, title: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Destaque_1",
    			options,
    			id: create_fragment$P.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<Destaque> was created without expected prop 'model'");
    		}

    		if (/*workflow*/ ctx[1] === undefined && !("workflow" in props)) {
    			console.warn("<Destaque> was created without expected prop 'workflow'");
    		}

    		if (/*title*/ ctx[2] === undefined && !("title" in props)) {
    			console.warn("<Destaque> was created without expected prop 'title'");
    		}
    	}

    	get model() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get workflow() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set workflow(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\despesas\_components\Destaques.svelte generated by Svelte v3.22.3 */
    const file$N = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\despesas\\_components\\Destaques.svelte";

    // (84:4) <span slot="title">
    function create_title_slot_4(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Transferências do Estado em destaque";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$N, 83, 4, 2399);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_4.name,
    		type: "slot",
    		source: "(84:4) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (85:4) <span slot="tooltip">
    function create_tooltip_slot$7(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Destaque das mais relevantes transferências realizadas pelo Estado para o\r\n      Município para amenizar as desigualdades regionais e promover o equilíbrio\r\n      sócio-econômico entre os municípios.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$N, 84, 4, 2467);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$7.name,
    		type: "slot",
    		source: "(85:4) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (96:10) <span slot="icon">
    function create_icon_slot_3(ctx) {
    	let span;
    	let current;
    	const icon = new Icon({ props: { icon: faBed_2 }, $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$N, 95, 10, 2959);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_3.name,
    		type: "slot",
    		source: "(96:10) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (99:10) <span slot="title">
    function create_title_slot_3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Diárias";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$N, 98, 10, 3043);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_3.name,
    		type: "slot",
    		source: "(99:10) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (92:8) <Destaque            model={$store.despesaDestaqueDiarias}            workflow={despesaApi.despesaDestaqueDiarias}            title={titles.diarias}>
    function create_default_slot_4$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(92:8) <Destaque            model={$store.despesaDestaqueDiarias}            workflow={despesaApi.despesaDestaqueDiarias}            title={titles.diarias}>",
    		ctx
    	});

    	return block;
    }

    // (108:10) <span slot="icon">
    function create_icon_slot_2(ctx) {
    	let span;
    	let current;
    	const icon = new Icon({ props: { icon: faCubes_2 }, $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$N, 107, 10, 3397);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_2.name,
    		type: "slot",
    		source: "(108:10) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (111:10) <span slot="title">
    function create_title_slot_2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Material permanente";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$N, 110, 10, 3483);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_2.name,
    		type: "slot",
    		source: "(111:10) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:8) <Destaque            model={$store.despesaDestaqueMaterialPermanente}            workflow={despesaApi.despesaDestaqueMaterialPermanente}            title={titles.materialPermanente}>
    function create_default_slot_3$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(104:8) <Destaque            model={$store.despesaDestaqueMaterialPermanente}            workflow={despesaApi.despesaDestaqueMaterialPermanente}            title={titles.materialPermanente}>",
    		ctx
    	});

    	return block;
    }

    // (120:10) <span slot="icon">
    function create_icon_slot_1(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faHammer_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$N, 119, 10, 3797);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_1.name,
    		type: "slot",
    		source: "(120:10) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (123:10) <span slot="title">
    function create_title_slot_1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Obras";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$N, 122, 10, 3884);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_1.name,
    		type: "slot",
    		source: "(123:10) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:8) <Destaque            model={$store.despesaDestaqueObras}            workflow={despesaApi.despesaDestaqueObras}            title={titles.obras}>
    function create_default_slot_2$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(116:8) <Destaque            model={$store.despesaDestaqueObras}            workflow={despesaApi.despesaDestaqueObras}            title={titles.obras}>",
    		ctx
    	});

    	return block;
    }

    // (132:10) <span slot="icon">
    function create_icon_slot$2(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faBarcode_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$N, 131, 10, 4232);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot$2.name,
    		type: "slot",
    		source: "(132:10) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (135:10) <span slot="title">
    function create_title_slot$8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Material de consumo";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$N, 134, 10, 4320);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$8.name,
    		type: "slot",
    		source: "(135:10) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (128:8) <Destaque            model={$store.despesaDestaqueMaterialDeConsumo}            workflow={despesaApi.despesaDestaqueMaterialDeConsumo}            title={titles.materialDeConsumo}>
    function create_default_slot_1$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(128:8) <Destaque            model={$store.despesaDestaqueMaterialDeConsumo}            workflow={despesaApi.despesaDestaqueMaterialDeConsumo}            title={titles.materialDeConsumo}>",
    		ctx
    	});

    	return block;
    }

    // (83:2) <Widget>
    function create_default_slot$p(ctx) {
    	let t0;
    	let t1;
    	let div4;
    	let div0;
    	let div0_title_value;
    	let t2;
    	let div1;
    	let div1_title_value;
    	let t3;
    	let div2;
    	let div2_title_value;
    	let t4;
    	let div3;
    	let div3_title_value;
    	let current;

    	const destaque0 = new Destaque_1({
    			props: {
    				model: /*$store*/ ctx[0].despesaDestaqueDiarias,
    				workflow: despesaDestaqueDiarias,
    				title: /*titles*/ ctx[1].diarias,
    				$$slots: {
    					default: [create_default_slot_4$2],
    					title: [create_title_slot_3],
    					icon: [create_icon_slot_3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaque1 = new Destaque_1({
    			props: {
    				model: /*$store*/ ctx[0].despesaDestaqueMaterialPermanente,
    				workflow: despesaDestaqueMaterialPermanente,
    				title: /*titles*/ ctx[1].materialPermanente,
    				$$slots: {
    					default: [create_default_slot_3$4],
    					title: [create_title_slot_2],
    					icon: [create_icon_slot_2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaque2 = new Destaque_1({
    			props: {
    				model: /*$store*/ ctx[0].despesaDestaqueObras,
    				workflow: despesaDestaqueObras,
    				title: /*titles*/ ctx[1].obras,
    				$$slots: {
    					default: [create_default_slot_2$a],
    					title: [create_title_slot_1],
    					icon: [create_icon_slot_1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaque3 = new Destaque_1({
    			props: {
    				model: /*$store*/ ctx[0].despesaDestaqueMaterialDeConsumo,
    				workflow: despesaDestaqueMaterialDeConsumo,
    				title: /*titles*/ ctx[1].materialDeConsumo,
    				$$slots: {
    					default: [create_default_slot_1$d],
    					title: [create_title_slot$8],
    					icon: [create_icon_slot$2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div4 = element("div");
    			div0 = element("div");
    			create_component(destaque0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(destaque1.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			create_component(destaque2.$$.fragment);
    			t4 = space();
    			div3 = element("div");
    			create_component(destaque3.$$.fragment);
    			attr_dev(div0, "class", "destaque w-full md:w-1/4 svelte-198uu9h");
    			attr_dev(div0, "title", div0_title_value = /*titles*/ ctx[1].diarias);
    			add_location(div0, file$N, 90, 6, 2727);
    			attr_dev(div1, "class", "destaque w-full md:w-1/4 svelte-198uu9h");
    			attr_dev(div1, "title", div1_title_value = /*titles*/ ctx[1].materialPermanente);
    			add_location(div1, file$N, 102, 6, 3121);
    			attr_dev(div2, "class", "destaque w-full md:w-1/4 svelte-198uu9h");
    			attr_dev(div2, "title", div2_title_value = /*titles*/ ctx[1].obras);
    			add_location(div2, file$N, 114, 6, 3573);
    			attr_dev(div3, "class", "destaque w-full md:w-1/4 svelte-198uu9h");
    			attr_dev(div3, "title", div3_title_value = /*titles*/ ctx[1].materialDeConsumo);
    			add_location(div3, file$N, 126, 6, 3960);
    			add_location(div4, file$N, 89, 4, 2714);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			mount_component(destaque0, div0, null);
    			append_dev(div4, t2);
    			append_dev(div4, div1);
    			mount_component(destaque1, div1, null);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			mount_component(destaque2, div2, null);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			mount_component(destaque3, div3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const destaque0_changes = {};
    			if (dirty & /*$store*/ 1) destaque0_changes.model = /*$store*/ ctx[0].despesaDestaqueDiarias;

    			if (dirty & /*$$scope*/ 64) {
    				destaque0_changes.$$scope = { dirty, ctx };
    			}

    			destaque0.$set(destaque0_changes);
    			const destaque1_changes = {};
    			if (dirty & /*$store*/ 1) destaque1_changes.model = /*$store*/ ctx[0].despesaDestaqueMaterialPermanente;

    			if (dirty & /*$$scope*/ 64) {
    				destaque1_changes.$$scope = { dirty, ctx };
    			}

    			destaque1.$set(destaque1_changes);
    			const destaque2_changes = {};
    			if (dirty & /*$store*/ 1) destaque2_changes.model = /*$store*/ ctx[0].despesaDestaqueObras;

    			if (dirty & /*$$scope*/ 64) {
    				destaque2_changes.$$scope = { dirty, ctx };
    			}

    			destaque2.$set(destaque2_changes);
    			const destaque3_changes = {};
    			if (dirty & /*$store*/ 1) destaque3_changes.model = /*$store*/ ctx[0].despesaDestaqueMaterialDeConsumo;

    			if (dirty & /*$$scope*/ 64) {
    				destaque3_changes.$$scope = { dirty, ctx };
    			}

    			destaque3.$set(destaque3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(destaque0.$$.fragment, local);
    			transition_in(destaque1.$$.fragment, local);
    			transition_in(destaque2.$$.fragment, local);
    			transition_in(destaque3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(destaque0.$$.fragment, local);
    			transition_out(destaque1.$$.fragment, local);
    			transition_out(destaque2.$$.fragment, local);
    			transition_out(destaque3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div4);
    			destroy_component(destaque0);
    			destroy_component(destaque1);
    			destroy_component(destaque2);
    			destroy_component(destaque3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(83:2) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let div;
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$p],
    					tooltip: [create_tooltip_slot$7],
    					title: [create_title_slot_4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(widget.$$.fragment);
    			attr_dev(div, "class", "w-full float-left");
    			add_location(div, file$N, 81, 0, 2350);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(widget, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, $store*/ 65) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(widget);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let $params;
    	let $store;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(3, $params = $$value));

    	const titles = {
    		diarias: "Despesas com diárias",
    		materialPermanente: "Despesas com equipamentos e material permanente",
    		obras: "Despesas com obras e instalações",
    		materialDeConsumo: "Despesas com material de consumo"
    	};

    	const store = api.createStore();
    	validate_store(store, "store");
    	component_subscribe($$self, store, value => $$invalidate(0, $store = value));

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		const ug = params.ug;
    		const municipio = ug === "consolidado" ? params.municipio : ug;
    		await api.post(api.getApiUrl("DWControleSocial"), getDestaqueSumLiquidada(despesaDestaqueDiarias, ano, municipio).concat(getDestaqueSumLiquidada(despesaDestaqueMaterialDeConsumo, ano, municipio)).concat(getDestaqueSumLiquidada(despesaDestaqueMaterialPermanente, ano, municipio)).concat(getDestaqueSumLiquidada(despesaDestaqueObras, ano, municipio)), { store });
    	}

    	function getDestaqueSumLiquidada(destaque, ano, municipio) {
    		const workflow = destaque(ano, municipio, despesaSumLiquidada);

    		return [
    			{
    				id: workflow[0].id,
    				run: "Municipio.Despesa.FiltrarPorAno",
    				args: [ano],
    				continue: true,
    				evaluate: false
    			}
    		].concat(workflow);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Destaques> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Destaques", $$slots, []);

    	$$self.$capture_state = () => ({
    		params,
    		api,
    		Icon,
    		faBed: faBed_2,
    		faCubes: faCubes_2,
    		faHammer: faHammer_2,
    		faBarcode: faBarcode_2,
    		Widget,
    		Destaque: Destaque_1,
    		despesaApi,
    		titles,
    		store,
    		refresh,
    		getDestaqueSumLiquidada,
    		$params,
    		$store
    	});

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 8) {
    			 refresh($params);
    		}
    	};

    	return [$store, titles, store];
    }

    class Destaques extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Destaques",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var extend$9 = util.extend;
    var isArray$8 = util.isArray;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * [Usage]:
     * (1)
     * createListSimply(seriesModel, ['value']);
     * (2)
     * createListSimply(seriesModel, {
     *     coordDimensions: ['value'],
     *     dimensionsCount: 5
     * });
     *
     * @param {module:echarts/model/Series} seriesModel
     * @param {Object|Array.<string|Object>} opt opt or coordDimensions
     *        The options in opt, see `echarts/data/helper/createDimensions`
     * @param {Array.<string>} [nameList]
     * @return {module:echarts/data/List}
     */
    function _default$1$(seriesModel, opt, nameList) {
      opt = isArray$8(opt) && {
        coordDimensions: opt
      } || extend$9({}, opt);
      var source = seriesModel.getSource();
      var dimensionsInfo = createDimensions(source, opt);
      var list = new List_1(dimensionsInfo, seriesModel);
      list.initData(source, nameList);
      return list;
    }

    var createListSimply = _default$1$;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Data selectable mixin for chart series.
     * To eanble data select, option of series must have `selectedMode`.
     * And each data item will use `selected` to toggle itself selected status
     */
    var _default$20 = {
      /**
       * @param {Array.<Object>} targetList [{name, value, selected}, ...]
       *        If targetList is an array, it should like [{name: ..., value: ...}, ...].
       *        If targetList is a "List", it must have coordDim: 'value' dimension and name.
       */
      updateSelectedMap: function (targetList) {
        this._targetList = util.isArray(targetList) ? targetList.slice() : [];
        this._selectTargetMap = util.reduce(targetList || [], function (targetMap, target) {
          targetMap.set(target.name, target);
          return targetMap;
        }, util.createHashMap());
      },

      /**
       * Either name or id should be passed as input here.
       * If both of them are defined, id is used.
       *
       * @param {string|undefined} name name of data
       * @param {number|undefined} id dataIndex of data
       */
      // PENGING If selectedMode is null ?
      select: function (name, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);
        var selectedMode = this.get('selectedMode');

        if (selectedMode === 'single') {
          this._selectTargetMap.each(function (target) {
            target.selected = false;
          });
        }

        target && (target.selected = true);
      },

      /**
       * Either name or id should be passed as input here.
       * If both of them are defined, id is used.
       *
       * @param {string|undefined} name name of data
       * @param {number|undefined} id dataIndex of data
       */
      unSelect: function (name, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');
        // selectedMode !== 'single' && target && (target.selected = false);

        target && (target.selected = false);
      },

      /**
       * Either name or id should be passed as input here.
       * If both of them are defined, id is used.
       *
       * @param {string|undefined} name name of data
       * @param {number|undefined} id dataIndex of data
       */
      toggleSelected: function (name, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);

        if (target != null) {
          this[target.selected ? 'unSelect' : 'select'](name, id);
          return target.selected;
        }
      },

      /**
       * Either name or id should be passed as input here.
       * If both of them are defined, id is used.
       *
       * @param {string|undefined} name name of data
       * @param {number|undefined} id dataIndex of data
       */
      isSelected: function (name, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);
        return target && target.selected;
      }
    };
    var selectableMixin = _default$20;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * LegendVisualProvider is an bridge that pick encoded color from data and
     * provide to the legend component.
     * @param {Function} getDataWithEncodedVisual Function to get data after filtered. It stores all the encoding info
     * @param {Function} getRawData Function to get raw data before filtered.
     */
    function LegendVisualProvider(getDataWithEncodedVisual, getRawData) {
      this.getAllNames = function () {
        var rawData = getRawData(); // We find the name from the raw data. In case it's filtered by the legend component.
        // Normally, the name can be found in rawData, but can't be found in filtered data will display as gray.

        return rawData.mapArray(rawData.getName);
      };

      this.containName = function (name) {
        var rawData = getRawData();
        return rawData.indexOfName(name) >= 0;
      };

      this.indexOfName = function (name) {
        // Only get data when necessary.
        // Because LegendVisualProvider constructor may be new in the stage that data is not prepared yet.
        // Invoking Series#getData immediately will throw an error.
        var dataWithEncodedVisual = getDataWithEncodedVisual();
        return dataWithEncodedVisual.indexOfName(name);
      };

      this.getItemVisual = function (dataIndex, key) {
        // Get encoded visual properties from final filtered data.
        var dataWithEncodedVisual = getDataWithEncodedVisual();
        return dataWithEncodedVisual.getItemVisual(dataIndex, key);
      };
    }

    var _default$21 = LegendVisualProvider;
    var LegendVisualProvider_1 = _default$21;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */











    var getPercentWithPrecision$1 = number.getPercentWithPrecision;





    var retrieveRawAttr$1 = dataProvider.retrieveRawAttr;



    var makeSeriesEncodeForNameBased$1 = sourceHelper.makeSeriesEncodeForNameBased;



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var PieSeries = echarts.extendSeriesModel({
      type: 'series.pie',
      // Overwrite
      init: function (option) {
        PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item
        // Use a function instead of direct access because data reference may changed

        this.legendVisualProvider = new LegendVisualProvider_1(util.bind(this.getData, this), util.bind(this.getRawData, this));
        this.updateSelectedMap(this._createSelectableList());

        this._defaultLabelLine(option);
      },
      // Overwrite
      mergeOption: function (newOption) {
        PieSeries.superCall(this, 'mergeOption', newOption);
        this.updateSelectedMap(this._createSelectableList());
      },
      getInitialData: function (option, ecModel) {
        return createListSimply(this, {
          coordDimensions: ['value'],
          encodeDefaulter: util.curry(makeSeriesEncodeForNameBased$1, this)
        });
      },
      _createSelectableList: function () {
        var data = this.getRawData();
        var valueDim = data.mapDimension('value');
        var targetList = [];

        for (var i = 0, len = data.count(); i < len; i++) {
          targetList.push({
            name: data.getName(i),
            value: data.get(valueDim, i),
            selected: retrieveRawAttr$1(data, i, 'selected')
          });
        }

        return targetList;
      },
      // Overwrite
      getDataParams: function (dataIndex) {
        var data = this.getData();
        var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?

        var valueList = [];
        data.each(data.mapDimension('value'), function (value) {
          valueList.push(value);
        });
        params.percent = getPercentWithPrecision$1(valueList, dataIndex, data.hostModel.get('percentPrecision'));
        params.$vars.push('percent');
        return params;
      },
      _defaultLabelLine: function (option) {
        // Extend labelLine emphasis
        model.defaultEmphasis(option, 'labelLine', ['show']);
        var labelLineNormalOpt = option.labelLine;
        var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`

        labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        hoverAnimation: true,
        // 默认全局居中
        center: ['50%', '50%'],
        radius: [0, '75%'],
        // 默认顺时针
        clockwise: true,
        startAngle: 90,
        // 最小角度改为0
        minAngle: 0,
        // If the angle of a sector less than `minShowLabelAngle`,
        // the label will not be displayed.
        minShowLabelAngle: 0,
        // 选中时扇区偏移量
        selectedOffset: 10,
        // 高亮扇区偏移量
        hoverOffset: 10,
        // If use strategy to avoid label overlapping
        avoidLabelOverlap: true,
        // 选择模式，默认关闭，可选single，multiple
        // selectedMode: false,
        // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
        // roseType: null,
        percentPrecision: 2,
        // If still show when all data zero.
        stillShowZeroSum: true,
        // cursor: null,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        width: null,
        height: null,
        label: {
          // If rotate around circle
          rotate: false,
          show: true,
          // 'outer', 'inside', 'center'
          position: 'outer',
          // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
          alignTo: 'none',
          // Closest distance between label and chart edge.
          // Works only position is 'outer' and alignTo is 'edge'.
          margin: '25%',
          // Works only position is 'outer' and alignTo is not 'edge'.
          bleedMargin: 10,
          // Distance between text and label line.
          distanceToLabelLine: 5 // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
          // 默认使用全局文本样式，详见TEXTSTYLE
          // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数

        },
        // Enabled when label.normal.position is 'outer'
        labelLine: {
          show: true,
          // 引导线两段中的第一段长度
          length: 15,
          // 引导线两段中的第二段长度
          length2: 15,
          smooth: false,
          lineStyle: {
            // color: 各异,
            width: 1,
            type: 'solid'
          }
        },
        itemStyle: {
          borderWidth: 1
        },
        // Animation type. Valid values: expansion, scale
        animationType: 'expansion',
        // Animation type when update. Valid values: transition, expansion
        animationTypeUpdate: 'transition',
        animationEasing: 'cubicOut'
      }
    });
    util.mixin(PieSeries, selectableMixin);

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @param {module:echarts/model/Series} seriesModel
     * @param {boolean} hasAnimation
     * @inner
     */
    function updateDataSelected(uid, seriesModel, hasAnimation, api) {
      var data = seriesModel.getData();
      var dataIndex = this.dataIndex;
      var name = data.getName(dataIndex);
      var selectedOffset = seriesModel.get('selectedOffset');
      api.dispatchAction({
        type: 'pieToggleSelect',
        from: uid,
        name: name,
        seriesId: seriesModel.id
      });
      data.each(function (idx) {
        toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);
      });
    }
    /**
     * @param {module:zrender/graphic/Sector} el
     * @param {Object} layout
     * @param {boolean} isSelected
     * @param {number} selectedOffset
     * @param {boolean} hasAnimation
     * @inner
     */


    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {
      var midAngle = (layout.startAngle + layout.endAngle) / 2;
      var dx = Math.cos(midAngle);
      var dy = Math.sin(midAngle);
      var offset = isSelected ? selectedOffset : 0;
      var position = [dx * offset, dy * offset];
      hasAnimation // animateTo will stop revious animation like update transition
      ? el.animate().when(200, {
        position: position
      }).start('bounceOut') : el.attr('position', position);
    }
    /**
     * Piece of pie including Sector, Label, LabelLine
     * @constructor
     * @extends {module:zrender/graphic/Group}
     */


    function PiePiece(data, idx) {
      graphic.Group.call(this);
      var sector = new graphic.Sector({
        z2: 2
      });
      var polyline = new graphic.Polyline();
      var text = new graphic.Text();
      this.add(sector);
      this.add(polyline);
      this.add(text);
      this.updateData(data, idx, true);
    }

    var piePieceProto = PiePiece.prototype;

    piePieceProto.updateData = function (data, idx, firstCreate) {
      var sector = this.childAt(0);
      var labelLine = this.childAt(1);
      var labelText = this.childAt(2);
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout = data.getItemLayout(idx);
      var sectorShape = util.extend({}, layout);
      sectorShape.label = null;
      var animationTypeUpdate = seriesModel.getShallow('animationTypeUpdate');

      if (firstCreate) {
        sector.setShape(sectorShape);
        var animationType = seriesModel.getShallow('animationType');

        if (animationType === 'scale') {
          sector.shape.r = layout.r0;
          graphic.initProps(sector, {
            shape: {
              r: layout.r
            }
          }, seriesModel, idx);
        } // Expansion
        else {
            sector.shape.endAngle = layout.startAngle;
            graphic.updateProps(sector, {
              shape: {
                endAngle: layout.endAngle
              }
            }, seriesModel, idx);
          }
      } else {
        if (animationTypeUpdate === 'expansion') {
          // Sectors are set to be target shape and an overlaying clipPath is used for animation
          sector.setShape(sectorShape);
        } else {
          // Transition animation from the old shape
          graphic.updateProps(sector, {
            shape: sectorShape
          }, seriesModel, idx);
        }
      } // Update common style


      var visualColor = data.getItemVisual(idx, 'color');
      sector.useStyle(util.defaults({
        lineJoin: 'bevel',
        fill: visualColor
      }, itemModel.getModel('itemStyle').getItemStyle()));
      sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();
      var cursorStyle = itemModel.getShallow('cursor');
      cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected

      toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), seriesModel.get('selectedOffset'), seriesModel.get('animation')); // Label and text animation should be applied only for transition type animation when update

      var withAnimation = !firstCreate && animationTypeUpdate === 'transition';

      this._updateLabel(data, idx, withAnimation);

      this.highDownOnUpdate = !seriesModel.get('silent') ? function (fromState, toState) {
        var hasAnimation = seriesModel.isAnimationEnabled() && itemModel.get('hoverAnimation');

        if (toState === 'emphasis') {
          labelLine.ignore = labelLine.hoverIgnore;
          labelText.ignore = labelText.hoverIgnore; // Sector may has animation of updating data. Force to move to the last frame
          // Or it may stopped on the wrong shape

          if (hasAnimation) {
            sector.stopAnimation(true);
            sector.animateTo({
              shape: {
                r: layout.r + seriesModel.get('hoverOffset')
              }
            }, 300, 'elasticOut');
          }
        } else {
          labelLine.ignore = labelLine.normalIgnore;
          labelText.ignore = labelText.normalIgnore;

          if (hasAnimation) {
            sector.stopAnimation(true);
            sector.animateTo({
              shape: {
                r: layout.r
              }
            }, 300, 'elasticOut');
          }
        }
      } : null;
      graphic.setHoverStyle(this);
    };

    piePieceProto._updateLabel = function (data, idx, withAnimation) {
      var labelLine = this.childAt(1);
      var labelText = this.childAt(2);
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout = data.getItemLayout(idx);
      var labelLayout = layout.label;
      var visualColor = data.getItemVisual(idx, 'color');

      if (!labelLayout || isNaN(labelLayout.x) || isNaN(labelLayout.y)) {
        labelText.ignore = labelText.normalIgnore = labelText.hoverIgnore = labelLine.ignore = labelLine.normalIgnore = labelLine.hoverIgnore = true;
        return;
      }

      var targetLineShape = {
        points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]
      };
      var targetTextStyle = {
        x: labelLayout.x,
        y: labelLayout.y
      };

      if (withAnimation) {
        graphic.updateProps(labelLine, {
          shape: targetLineShape
        }, seriesModel, idx);
        graphic.updateProps(labelText, {
          style: targetTextStyle
        }, seriesModel, idx);
      } else {
        labelLine.attr({
          shape: targetLineShape
        });
        labelText.attr({
          style: targetTextStyle
        });
      }

      labelText.attr({
        rotation: labelLayout.rotation,
        origin: [labelLayout.x, labelLayout.y],
        z2: 10
      });
      var labelModel = itemModel.getModel('label');
      var labelHoverModel = itemModel.getModel('emphasis.label');
      var labelLineModel = itemModel.getModel('labelLine');
      var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');
      var visualColor = data.getItemVisual(idx, 'color');
      graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
        labelFetcher: data.hostModel,
        labelDataIndex: idx,
        defaultText: labelLayout.text,
        autoColor: visualColor,
        useInsideStyle: !!labelLayout.inside
      }, {
        textAlign: labelLayout.textAlign,
        textVerticalAlign: labelLayout.verticalAlign,
        opacity: data.getItemVisual(idx, 'opacity')
      });
      labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
      labelText.hoverIgnore = !labelHoverModel.get('show');
      labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
      labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color

      labelLine.setStyle({
        stroke: visualColor,
        opacity: data.getItemVisual(idx, 'opacity')
      });
      labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());
      labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();
      var smooth = labelLineModel.get('smooth');

      if (smooth && smooth === true) {
        smooth = 0.4;
      }

      labelLine.setShape({
        smooth: smooth
      });
    };

    util.inherits(PiePiece, graphic.Group); // Pie view

    var PieView = Chart_1.extend({
      type: 'pie',
      init: function () {
        var sectorGroup = new graphic.Group();
        this._sectorGroup = sectorGroup;
      },
      render: function (seriesModel, ecModel, api, payload) {
        if (payload && payload.from === this.uid) {
          return;
        }

        var data = seriesModel.getData();
        var oldData = this._data;
        var group = this.group;
        var hasAnimation = ecModel.get('animation');
        var isFirstRender = !oldData;
        var animationType = seriesModel.get('animationType');
        var animationTypeUpdate = seriesModel.get('animationTypeUpdate');
        var onSectorClick = util.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);
        var selectedMode = seriesModel.get('selectedMode');
        data.diff(oldData).add(function (idx) {
          var piePiece = new PiePiece(data, idx); // Default expansion animation

          if (isFirstRender && animationType !== 'scale') {
            piePiece.eachChild(function (child) {
              child.stopAnimation(true);
            });
          }

          selectedMode && piePiece.on('click', onSectorClick);
          data.setItemGraphicEl(idx, piePiece);
          group.add(piePiece);
        }).update(function (newIdx, oldIdx) {
          var piePiece = oldData.getItemGraphicEl(oldIdx);

          if (!isFirstRender && animationTypeUpdate !== 'transition') {
            piePiece.eachChild(function (child) {
              child.stopAnimation(true);
            });
          }

          piePiece.updateData(data, newIdx);
          piePiece.off('click');
          selectedMode && piePiece.on('click', onSectorClick);
          group.add(piePiece);
          data.setItemGraphicEl(newIdx, piePiece);
        }).remove(function (idx) {
          var piePiece = oldData.getItemGraphicEl(idx);
          group.remove(piePiece);
        }).execute();

        if (hasAnimation && data.count() > 0 && (isFirstRender ? animationType !== 'scale' : animationTypeUpdate !== 'transition')) {
          var shape = data.getItemLayout(0);

          for (var s = 1; isNaN(shape.startAngle) && s < data.count(); ++s) {
            shape = data.getItemLayout(s);
          }

          var r = Math.max(api.getWidth(), api.getHeight()) / 2;
          var removeClipPath = util.bind(group.removeClipPath, group);
          group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel, isFirstRender));
        } else {
          // clipPath is used in first-time animation, so remove it when otherwise. See: #8994
          group.removeClipPath();
        }

        this._data = data;
      },
      dispose: function () {},
      _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel, isFirstRender) {
        var clipPath = new graphic.Sector({
          shape: {
            cx: cx,
            cy: cy,
            r0: 0,
            r: r,
            startAngle: startAngle,
            endAngle: startAngle,
            clockwise: clockwise
          }
        });
        var initOrUpdate = isFirstRender ? graphic.initProps : graphic.updateProps;
        initOrUpdate(clipPath, {
          shape: {
            endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2
          }
        }, seriesModel, cb);
        return clipPath;
      },

      /**
       * @implement
       */
      containPoint: function (point, seriesModel) {
        var data = seriesModel.getData();
        var itemLayout = data.getItemLayout(0);

        if (itemLayout) {
          var dx = point[0] - itemLayout.cx;
          var dy = point[1] - itemLayout.cy;
          var radius = Math.sqrt(dx * dx + dy * dy);
          return radius <= itemLayout.r && radius >= itemLayout.r0;
        }
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function _default$22(seriesType, actionInfos) {
      util.each(actionInfos, function (actionInfo) {
        actionInfo.update = 'updateView';
        /**
         * @payload
         * @property {string} seriesName
         * @property {string} name
         */

        echarts.registerAction(actionInfo, function (payload, ecModel) {
          var selected = {};
          ecModel.eachComponent({
            mainType: 'series',
            subType: seriesType,
            query: payload
          }, function (seriesModel) {
            if (seriesModel[actionInfo.method]) {
              seriesModel[actionInfo.method](payload.name, payload.dataIndex);
            }

            var data = seriesModel.getData(); // Create selected map

            data.each(function (idx) {
              var name = data.getName(idx);
              selected[name] = seriesModel.isSelected(name) || false;
            });
          });
          return {
            name: payload.name,
            selected: selected,
            seriesId: payload.seriesId
          };
        });
      });
    }

    var createDataSelectAction = _default$22;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var createHashMap$b = util.createHashMap;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // Pick color from palette for each data item.
    // Applicable for charts that require applying color palette
    // in data level (like pie, funnel, chord).
    function _default$23(seriesType) {
      return {
        getTargetSeries: function (ecModel) {
          // Pie and funnel may use diferrent scope
          var paletteScope = {};
          var seiresModelMap = createHashMap$b();
          ecModel.eachSeriesByType(seriesType, function (seriesModel) {
            seriesModel.__paletteScope = paletteScope;
            seiresModelMap.set(seriesModel.uid, seriesModel);
          });
          return seiresModelMap;
        },
        reset: function (seriesModel, ecModel) {
          var dataAll = seriesModel.getRawData();
          var idxMap = {};
          var data = seriesModel.getData();
          data.each(function (idx) {
            var rawIdx = data.getRawIndex(idx);
            idxMap[rawIdx] = idx;
          });
          dataAll.each(function (rawIdx) {
            var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded

            var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);
            var singleDataBorderColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'borderColor', true);
            var itemModel;

            if (!singleDataColor || !singleDataBorderColor) {
              // FIXME Performance
              itemModel = dataAll.getItemModel(rawIdx);
            }

            if (!singleDataColor) {
              var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Data is not filtered

              if (filteredIdx != null) {
                data.setItemVisual(filteredIdx, 'color', color);
              }
            }

            if (!singleDataBorderColor) {
              var borderColor = itemModel.get('itemStyle.borderColor'); // Data is not filtered

              if (filteredIdx != null) {
                data.setItemVisual(filteredIdx, 'borderColor', borderColor);
              }
            }
          });
        }
      };
    }

    var dataColor = _default$23;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    var parsePercent$6 = number.parsePercent;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    // FIXME emphasis label position is not same with normal label position
    var RADIAN = Math.PI / 180;

    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
      list.sort(function (a, b) {
        return a.y - b.y;
      });

      function shiftDown(start, end, delta, dir) {
        for (var j = start; j < end; j++) {
          if (list[j].y + delta > viewTop + viewHeight) {
            break;
          }

          list[j].y += delta;

          if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {
            shiftUp(j, delta / 2);
            return;
          }
        }

        shiftUp(end - 1, delta / 2);
      }

      function shiftUp(end, delta) {
        for (var j = end; j >= 0; j--) {
          if (list[j].y - delta < viewTop) {
            break;
          }

          list[j].y -= delta;

          if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {
            break;
          }
        }
      }

      function changeX(list, isDownList, cx, cy, r, dir) {
        var lastDeltaX = dir > 0 ? isDownList // right-side
        ? Number.MAX_VALUE // down
        : 0 // up
        : isDownList // left-side
        ? Number.MAX_VALUE // down
        : 0; // up

        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i].labelAlignTo !== 'none') {
            continue;
          }

          var deltaY = Math.abs(list[i].y - cy);
          var length = list[i].len;
          var length2 = list[i].len2;
          var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);

          if (isDownList && deltaX >= lastDeltaX) {
            // right-down, left-down
            deltaX = lastDeltaX - 10;
          }

          if (!isDownList && deltaX <= lastDeltaX) {
            // right-up, left-up
            deltaX = lastDeltaX + 10;
          }

          list[i].x = cx + deltaX * dir;
          lastDeltaX = deltaX;
        }
      }

      var lastY = 0;
      var delta;
      var len = list.length;
      var upList = [];
      var downList = [];

      for (var i = 0; i < len; i++) {
        if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {
          var dx = list[i].x - farthestX;
          list[i].linePoints[1][0] += dx;
          list[i].x = farthestX;
        }

        delta = list[i].y - lastY;

        if (delta < 0) {
          shiftDown(i, len, -delta);
        }

        lastY = list[i].y + list[i].height;
      }

      if (viewHeight - lastY < 0) {
        shiftUp(len - 1, lastY - viewHeight);
      }

      for (var i = 0; i < len; i++) {
        if (list[i].y >= cy) {
          downList.push(list[i]);
        } else {
          upList.push(list[i]);
        }
      }

      changeX(upList, false, cx, cy, r, dir);
      changeX(downList, true, cx, cy, r, dir);
    }

    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
      var leftList = [];
      var rightList = [];
      var leftmostX = Number.MAX_VALUE;
      var rightmostX = -Number.MAX_VALUE;

      for (var i = 0; i < labelLayoutList.length; i++) {
        if (isPositionCenter(labelLayoutList[i])) {
          continue;
        }

        if (labelLayoutList[i].x < cx) {
          leftmostX = Math.min(leftmostX, labelLayoutList[i].x);
          leftList.push(labelLayoutList[i]);
        } else {
          rightmostX = Math.max(rightmostX, labelLayoutList[i].x);
          rightList.push(labelLayoutList[i]);
        }
      }

      adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
      adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);

      for (var i = 0; i < labelLayoutList.length; i++) {
        var layout = labelLayoutList[i];

        if (isPositionCenter(layout)) {
          continue;
        }

        var linePoints = layout.linePoints;

        if (linePoints) {
          var isAlignToEdge = layout.labelAlignTo === 'edge';
          var realTextWidth = layout.textRect.width;
          var targetTextWidth;

          if (isAlignToEdge) {
            if (layout.x < cx) {
              targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.labelMargin;
            } else {
              targetTextWidth = viewLeft + viewWidth - layout.labelMargin - linePoints[2][0] - layout.labelDistance;
            }
          } else {
            if (layout.x < cx) {
              targetTextWidth = layout.x - viewLeft - layout.bleedMargin;
            } else {
              targetTextWidth = viewLeft + viewWidth - layout.x - layout.bleedMargin;
            }
          }

          if (targetTextWidth < layout.textRect.width) {
            layout.text = text$1.truncateText(layout.text, targetTextWidth, layout.font);

            if (layout.labelAlignTo === 'edge') {
              realTextWidth = text$1.getWidth(layout.text, layout.font);
            }
          }

          var dist = linePoints[1][0] - linePoints[2][0];

          if (isAlignToEdge) {
            if (layout.x < cx) {
              linePoints[2][0] = viewLeft + layout.labelMargin + realTextWidth + layout.labelDistance;
            } else {
              linePoints[2][0] = viewLeft + viewWidth - layout.labelMargin - realTextWidth - layout.labelDistance;
            }
          } else {
            if (layout.x < cx) {
              linePoints[2][0] = layout.x + layout.labelDistance;
            } else {
              linePoints[2][0] = layout.x - layout.labelDistance;
            }

            linePoints[1][0] = linePoints[2][0] + dist;
          }

          linePoints[1][1] = linePoints[2][1] = layout.y;
        }
      }
    }

    function isPositionCenter(layout) {
      // Not change x for center label
      return layout.position === 'center';
    }

    function _default$24(seriesModel, r, viewWidth, viewHeight, viewLeft, viewTop) {
      var data = seriesModel.getData();
      var labelLayoutList = [];
      var cx;
      var cy;
      var hasLabelRotate = false;
      var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN;
      data.each(function (idx) {
        var layout = data.getItemLayout(idx);
        var itemModel = data.getItemModel(idx);
        var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis

        var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');
        var labelDistance = labelModel.get('distanceToLabelLine');
        var labelAlignTo = labelModel.get('alignTo');
        var labelMargin = parsePercent$6(labelModel.get('margin'), viewWidth);
        var bleedMargin = labelModel.get('bleedMargin');
        var font = labelModel.getFont();
        var labelLineModel = itemModel.getModel('labelLine');
        var labelLineLen = labelLineModel.get('length');
        labelLineLen = parsePercent$6(labelLineLen, viewWidth);
        var labelLineLen2 = labelLineModel.get('length2');
        labelLineLen2 = parsePercent$6(labelLineLen2, viewWidth);

        if (layout.angle < minShowLabelRadian) {
          return;
        }

        var midAngle = (layout.startAngle + layout.endAngle) / 2;
        var dx = Math.cos(midAngle);
        var dy = Math.sin(midAngle);
        var textX;
        var textY;
        var linePoints;
        var textAlign;
        cx = layout.cx;
        cy = layout.cy;
        var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);
        var textRect = text$1.getBoundingRect(text, font, textAlign, 'top');
        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';

        if (labelPosition === 'center') {
          textX = layout.cx;
          textY = layout.cy;
          textAlign = 'center';
        } else {
          var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;
          var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;
          textX = x1 + dx * 3;
          textY = y1 + dy * 3;

          if (!isLabelInside) {
            // For roseType
            var x2 = x1 + dx * (labelLineLen + r - layout.r);
            var y2 = y1 + dy * (labelLineLen + r - layout.r);
            var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;
            var y3 = y2;

            if (labelAlignTo === 'edge') {
              // Adjust textX because text align of edge is opposite
              textX = dx < 0 ? viewLeft + labelMargin : viewLeft + viewWidth - labelMargin;
            } else {
              textX = x3 + (dx < 0 ? -labelDistance : labelDistance);
            }

            textY = y3;
            linePoints = [[x1, y1], [x2, y2], [x3, y3]];
          }

          textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? dx > 0 ? 'right' : 'left' : dx > 0 ? 'left' : 'right';
        }

        var labelRotate;
        var rotate = labelModel.get('rotate');

        if (typeof rotate === 'number') {
          labelRotate = rotate * (Math.PI / 180);
        } else {
          labelRotate = rotate ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;
        }

        hasLabelRotate = !!labelRotate;
        layout.label = {
          x: textX,
          y: textY,
          position: labelPosition,
          height: textRect.height,
          len: labelLineLen,
          len2: labelLineLen2,
          linePoints: linePoints,
          textAlign: textAlign,
          verticalAlign: 'middle',
          rotation: labelRotate,
          inside: isLabelInside,
          labelDistance: labelDistance,
          labelAlignTo: labelAlignTo,
          labelMargin: labelMargin,
          bleedMargin: bleedMargin,
          textRect: textRect,
          text: text,
          font: font
        }; // Not layout the inside label

        if (!isLabelInside) {
          labelLayoutList.push(layout.label);
        }
      });

      if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {
        avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
      }
    }

    var labelLayout = _default$24;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    var parsePercent$7 = number.parsePercent;
    var linearMap$2 = number.linearMap;







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var PI2$4 = Math.PI * 2;
    var RADIAN$1 = Math.PI / 180;

    function getViewRect(seriesModel, api) {
      return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }

    function _default$25(seriesType, ecModel, api, payload) {
      ecModel.eachSeriesByType(seriesType, function (seriesModel) {
        var data = seriesModel.getData();
        var valueDim = data.mapDimension('value');
        var viewRect = getViewRect(seriesModel, api);
        var center = seriesModel.get('center');
        var radius = seriesModel.get('radius');

        if (!util.isArray(radius)) {
          radius = [0, radius];
        }

        if (!util.isArray(center)) {
          center = [center, center];
        }

        var width = parsePercent$7(viewRect.width, api.getWidth());
        var height = parsePercent$7(viewRect.height, api.getHeight());
        var size = Math.min(width, height);
        var cx = parsePercent$7(center[0], width) + viewRect.x;
        var cy = parsePercent$7(center[1], height) + viewRect.y;
        var r0 = parsePercent$7(radius[0], size / 2);
        var r = parsePercent$7(radius[1], size / 2);
        var startAngle = -seriesModel.get('startAngle') * RADIAN$1;
        var minAngle = seriesModel.get('minAngle') * RADIAN$1;
        var validDataCount = 0;
        data.each(valueDim, function (value) {
          !isNaN(value) && validDataCount++;
        });
        var sum = data.getSum(valueDim); // Sum may be 0

        var unitRadian = Math.PI / (sum || validDataCount) * 2;
        var clockwise = seriesModel.get('clockwise');
        var roseType = seriesModel.get('roseType');
        var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]

        var extent = data.getDataExtent(valueDim);
        extent[0] = 0; // In the case some sector angle is smaller than minAngle

        var restAngle = PI2$4;
        var valueSumLargerThanMinAngle = 0;
        var currentAngle = startAngle;
        var dir = clockwise ? 1 : -1;
        data.each(valueDim, function (value, idx) {
          var angle;

          if (isNaN(value)) {
            data.setItemLayout(idx, {
              angle: NaN,
              startAngle: NaN,
              endAngle: NaN,
              clockwise: clockwise,
              cx: cx,
              cy: cy,
              r0: r0,
              r: roseType ? NaN : r,
              viewRect: viewRect
            });
            return;
          } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？


          if (roseType !== 'area') {
            angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
          } else {
            angle = PI2$4 / validDataCount;
          }

          if (angle < minAngle) {
            angle = minAngle;
            restAngle -= minAngle;
          } else {
            valueSumLargerThanMinAngle += value;
          }

          var endAngle = currentAngle + dir * angle;
          data.setItemLayout(idx, {
            angle: angle,
            startAngle: currentAngle,
            endAngle: endAngle,
            clockwise: clockwise,
            cx: cx,
            cy: cy,
            r0: r0,
            r: roseType ? linearMap$2(value, extent, [r0, r]) : r,
            viewRect: viewRect
          });
          currentAngle = endAngle;
        }); // Some sector is constrained by minAngle
        // Rest sectors needs recalculate angle

        if (restAngle < PI2$4 && validDataCount) {
          // Average the angle if rest angle is not enough after all angles is
          // Constrained by minAngle
          if (restAngle <= 1e-3) {
            var angle = PI2$4 / validDataCount;
            data.each(valueDim, function (value, idx) {
              if (!isNaN(value)) {
                var layout = data.getItemLayout(idx);
                layout.angle = angle;
                layout.startAngle = startAngle + dir * idx * angle;
                layout.endAngle = startAngle + dir * (idx + 1) * angle;
              }
            });
          } else {
            unitRadian = restAngle / valueSumLargerThanMinAngle;
            currentAngle = startAngle;
            data.each(valueDim, function (value, idx) {
              if (!isNaN(value)) {
                var layout = data.getItemLayout(idx);
                var angle = layout.angle === minAngle ? minAngle : value * unitRadian;
                layout.startAngle = currentAngle;
                layout.endAngle = currentAngle + dir * angle;
                currentAngle += dir * angle;
              }
            });
          }
        }

        labelLayout(seriesModel, r, viewRect.width, viewRect.height, viewRect.x, viewRect.y);
      });
    }

    var pieLayout = _default$25;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function _default$26(seriesType) {
      return {
        seriesType: seriesType,
        reset: function (seriesModel, ecModel) {
          var legendModels = ecModel.findComponents({
            mainType: 'legend'
          });

          if (!legendModels || !legendModels.length) {
            return;
          }

          var data = seriesModel.getData();
          data.filterSelf(function (idx) {
            var name = data.getName(idx); // If in any legend component the status is not selected.

            for (var i = 0; i < legendModels.length; i++) {
              if (!legendModels[i].isSelected(name)) {
                return false;
              }
            }

            return true;
          });
        }
      };
    }

    var dataFilter = _default$26;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

















    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    createDataSelectAction('pie', [{
      type: 'pieToggleSelect',
      event: 'pieselectchanged',
      method: 'toggleSelected'
    }, {
      type: 'pieSelect',
      event: 'pieselected',
      method: 'select'
    }, {
      type: 'pieUnSelect',
      event: 'pieunselected',
      method: 'unSelect'
    }]);
    echarts.registerVisual(dataColor('pie'));
    echarts.registerLayout(util.curry(pieLayout, 'pie'));
    echarts.registerProcessor(dataFilter('pie'));

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    var mergeLayoutParam$3 = layout.mergeLayoutParam;
    var getLayoutParams$3 = layout.getLayoutParams;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var ScrollableLegendModel = LegendModel_1.extend({
      type: 'legend.scroll',

      /**
       * @param {number} scrollDataIndex
       */
      setScrollDataIndex: function (scrollDataIndex) {
        this.option.scrollDataIndex = scrollDataIndex;
      },
      defaultOption: {
        scrollDataIndex: 0,
        pageButtonItemGap: 5,
        pageButtonGap: null,
        pageButtonPosition: 'end',
        // 'start' or 'end'
        pageFormatter: '{current}/{total}',
        // If null/undefined, do not show page.
        pageIcons: {
          horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
          vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']
        },
        pageIconColor: '#2f4554',
        pageIconInactiveColor: '#aaa',
        pageIconSize: 15,
        // Can be [10, 3], which represents [width, height]
        pageTextStyle: {
          color: '#333'
        },
        animationDurationUpdate: 800
      },

      /**
       * @override
       */
      init: function (option, parentModel, ecModel, extraOpt) {
        var inputPositionParams = getLayoutParams$3(option);
        ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);
        mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
      },

      /**
       * @override
       */
      mergeOption: function (option, extraOpt) {
        ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);
        mergeAndNormalizeLayoutParams(this, this.option, option);
      }
    }); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.

    function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
      var orient = legendModel.getOrient();
      var ignoreSize = [1, 1];
      ignoreSize[orient.index] = 0;
      mergeLayoutParam$3(target, raw, {
        type: 'box',
        ignoreSize: ignoreSize
      });
    }

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Separate legend and scrollable legend to reduce package size.
     */
    var Group$2 = graphic.Group;
    var WH = ['width', 'height'];
    var XY = ['x', 'y'];
    var ScrollableLegendView = LegendView.extend({
      type: 'legend.scroll',
      newlineDisabled: true,
      init: function () {
        ScrollableLegendView.superCall(this, 'init');
        /**
         * @private
         * @type {number} For `scroll`.
         */

        this._currentIndex = 0;
        /**
         * @private
         * @type {module:zrender/container/Group}
         */

        this.group.add(this._containerGroup = new Group$2());

        this._containerGroup.add(this.getContentGroup());
        /**
         * @private
         * @type {module:zrender/container/Group}
         */


        this.group.add(this._controllerGroup = new Group$2());
        /**
         *
         * @private
         */

        this._showController;
      },

      /**
       * @override
       */
      resetInner: function () {
        ScrollableLegendView.superCall(this, 'resetInner');

        this._controllerGroup.removeAll();

        this._containerGroup.removeClipPath();

        this._containerGroup.__rectSize = null;
      },

      /**
       * @override
       */
      renderInner: function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
        var me = this; // Render content items.

        ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
        var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,
        // e.g., '3/12345' should not overlap with the control arrow button.

        var pageIconSize = legendModel.get('pageIconSize', true);

        if (!util.isArray(pageIconSize)) {
          pageIconSize = [pageIconSize, pageIconSize];
        }

        createPageButton('pagePrev', 0);
        var pageTextStyleModel = legendModel.getModel('pageTextStyle');
        controllerGroup.add(new graphic.Text({
          name: 'pageText',
          style: {
            textFill: pageTextStyleModel.getTextColor(),
            font: pageTextStyleModel.getFont(),
            textVerticalAlign: 'middle',
            textAlign: 'center'
          },
          silent: true
        }));
        createPageButton('pageNext', 1);

        function createPageButton(name, iconIdx) {
          var pageDataIndexName = name + 'DataIndex';
          var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {
            // Buttons will be created in each render, so we do not need
            // to worry about avoiding using legendModel kept in scope.
            onclick: util.bind(me._pageGo, me, pageDataIndexName, legendModel, api)
          }, {
            x: -pageIconSize[0] / 2,
            y: -pageIconSize[1] / 2,
            width: pageIconSize[0],
            height: pageIconSize[1]
          });
          icon.name = name;
          controllerGroup.add(icon);
        }
      },

      /**
       * @override
       */
      layoutInner: function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        var selectorGroup = this.getSelectorGroup();
        var orientIdx = legendModel.getOrient().index;
        var wh = WH[orientIdx];
        var xy = XY[orientIdx];
        var hw = WH[1 - orientIdx];
        var yx = XY[1 - orientIdx];
        selector && layout.box( // Buttons in selectorGroup always layout horizontally
        'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));
        var selectorButtonGap = legendModel.get('selectorButtonGap', true);
        var selectorRect = selectorGroup.getBoundingRect();
        var selectorPos = [-selectorRect.x, -selectorRect.y];
        var processMaxSize = util.clone(maxSize);
        selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);

        var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);

        if (selector) {
          if (selectorPosition === 'end') {
            selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
          } else {
            var offset = selectorRect[wh] + selectorButtonGap;
            selectorPos[orientIdx] -= offset;
            mainRect[xy] -= offset;
          }

          mainRect[wh] += selectorRect[wh] + selectorButtonGap;
          selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
          mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
          mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
          selectorGroup.attr('position', selectorPos);
        }

        return mainRect;
      },
      _layoutContentAndController: function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {
        var contentGroup = this.getContentGroup();
        var containerGroup = this._containerGroup;
        var controllerGroup = this._controllerGroup; // Place items in contentGroup.

        layout.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
        layout.box( // Buttons in controller are layout always horizontally.
        'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));
        var contentRect = contentGroup.getBoundingRect();
        var controllerRect = controllerGroup.getBoundingRect();
        var showController = this._showController = contentRect[wh] > maxSize[wh];
        var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.
        // If first rendering, `contentGroup.position` is [0, 0], which
        // does not make sense and may cause unexepcted animation if adopted.

        if (!isFirstRender) {
          contentPos[orientIdx] = contentGroup.position[orientIdx];
        } // Layout container group based on 0.


        var containerPos = [0, 0];
        var controllerPos = [-controllerRect.x, -controllerRect.y];
        var pageButtonGap = util.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.

        if (showController) {
          var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.

          if (pageButtonPosition === 'end') {
            controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
          } // controller is on the left / top.
          else {
              containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
            }
        } // Always align controller to content as 'middle'.


        controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
        contentGroup.attr('position', contentPos);
        containerGroup.attr('position', containerPos);
        controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.
        // mainRect should not be calculated by `this.group.getBoundingRect()`
        // for sake of the overflow.

        var mainRect = {
          x: 0,
          y: 0
        }; // Consider content may be overflow (should be clipped).

        mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
        mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.

        mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
        containerGroup.__rectSize = maxSize[wh];

        if (showController) {
          var clipShape = {
            x: 0,
            y: 0
          };
          clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
          clipShape[hw] = mainRect[hw];
          containerGroup.setClipPath(new graphic.Rect({
            shape: clipShape
          })); // Consider content may be larger than container, container rect
          // can not be obtained from `containerGroup.getBoundingRect()`.

          containerGroup.__rectSize = clipShape[wh];
        } else {
          // Do not remove or ignore controller. Keep them set as placeholders.
          controllerGroup.eachChild(function (child) {
            child.attr({
              invisible: true,
              silent: true
            });
          });
        } // Content translate animation.


        var pageInfo = this._getPageInfo(legendModel);

        pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {
          position: pageInfo.contentPosition
        }, // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        showController ? legendModel : false);

        this._updatePageInfoView(legendModel, pageInfo);

        return mainRect;
      },
      _pageGo: function (to, legendModel, api) {
        var scrollDataIndex = this._getPageInfo(legendModel)[to];

        scrollDataIndex != null && api.dispatchAction({
          type: 'legendScroll',
          scrollDataIndex: scrollDataIndex,
          legendId: legendModel.id
        });
      },
      _updatePageInfoView: function (legendModel, pageInfo) {
        var controllerGroup = this._controllerGroup;
        util.each(['pagePrev', 'pageNext'], function (name) {
          var canJump = pageInfo[name + 'DataIndex'] != null;
          var icon = controllerGroup.childOfName(name);

          if (icon) {
            icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));
            icon.cursor = canJump ? 'pointer' : 'default';
          }
        });
        var pageText = controllerGroup.childOfName('pageText');
        var pageFormatter = legendModel.get('pageFormatter');
        var pageIndex = pageInfo.pageIndex;
        var current = pageIndex != null ? pageIndex + 1 : 0;
        var total = pageInfo.pageCount;
        pageText && pageFormatter && pageText.setStyle('text', util.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({
          current: current,
          total: total
        }));
      },

      /**
       * @param {module:echarts/model/Model} legendModel
       * @return {Object} {
       *  contentPosition: Array.<number>, null when data item not found.
       *  pageIndex: number, null when data item not found.
       *  pageCount: number, always be a number, can be 0.
       *  pagePrevDataIndex: number, null when no previous page.
       *  pageNextDataIndex: number, null when no next page.
       * }
       */
      _getPageInfo: function (legendModel) {
        var scrollDataIndex = legendModel.get('scrollDataIndex', true);
        var contentGroup = this.getContentGroup();
        var containerRectSize = this._containerGroup.__rectSize;
        var orientIdx = legendModel.getOrient().index;
        var wh = WH[orientIdx];
        var xy = XY[orientIdx];

        var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);

        var children = contentGroup.children();
        var targetItem = children[targetItemIndex];
        var itemCount = children.length;
        var pCount = !itemCount ? 0 : 1;
        var result = {
          contentPosition: contentGroup.position.slice(),
          pageCount: pCount,
          pageIndex: pCount - 1,
          pagePrevDataIndex: null,
          pageNextDataIndex: null
        };

        if (!targetItem) {
          return result;
        }

        var targetItemInfo = getItemInfo(targetItem);
        result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:
        // (1) Always align based on the left/top most item.
        // (2) It is user-friendly that the last item shown in the
        // current window is shown at the begining of next window.
        // Otherwise if half of the last item is cut by the window,
        // it will have no chance to display entirely.
        // (3) Consider that item size probably be different, we
        // have calculate pageIndex by size rather than item index,
        // and we can not get page index directly by division.
        // (4) The window is to narrow to contain more than
        // one item, we should make sure that the page can be fliped.

        for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
          currItemInfo = getItemInfo(children[i]);

          if ( // Half of the last item is out of the window.
          !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page
          // can be started at the current item or the last item.
          currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {
            if (winEndItemInfo.i > winStartItemInfo.i) {
              winStartItemInfo = winEndItemInfo;
            } else {
              // e.g., when page size is smaller than item size.
              winStartItemInfo = currItemInfo;
            }

            if (winStartItemInfo) {
              if (result.pageNextDataIndex == null) {
                result.pageNextDataIndex = winStartItemInfo.i;
              }

              ++result.pageCount;
            }
          }

          winEndItemInfo = currItemInfo;
        }

        for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
          currItemInfo = getItemInfo(children[i]);

          if ( // If the the end item does not intersect with the window started
          // from the current item, a page can be settled.
          (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.
          winStartItemInfo.i < winEndItemInfo.i) {
            winEndItemInfo = winStartItemInfo;

            if (result.pagePrevDataIndex == null) {
              result.pagePrevDataIndex = winStartItemInfo.i;
            }

            ++result.pageCount;
            ++result.pageIndex;
          }

          winStartItemInfo = currItemInfo;
        }

        return result;

        function getItemInfo(el) {
          if (el) {
            var itemRect = el.getBoundingRect();
            var start = itemRect[xy] + el.position[orientIdx];
            return {
              s: start,
              e: start + itemRect[wh],
              i: el.__legendDataIndex
            };
          }
        }

        function intersect(itemInfo, winStart) {
          return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
        }
      },
      _findTargetItemIndex: function (targetDataIndex) {
        if (!this._showController) {
          return 0;
        }

        var index;
        var contentGroup = this.getContentGroup();
        var defaultIndex;
        contentGroup.eachChild(function (child, idx) {
          var legendDataIdx = child.__legendDataIndex; // FIXME
          // If the given targetDataIndex (from model) is illegal,
          // we use defualtIndex. But the index on the legend model and
          // action payload is still illegal. That case will not be
          // changed until some scenario requires.

          if (defaultIndex == null && legendDataIdx != null) {
            defaultIndex = idx;
          }

          if (legendDataIdx === targetDataIndex) {
            index = idx;
          }
        });
        return index != null ? index : defaultIndex;
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @event legendScroll
     * @type {Object}
     * @property {string} type 'legendScroll'
     * @property {string} scrollDataIndex
     */
    echarts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {
      var scrollDataIndex = payload.scrollDataIndex;
      scrollDataIndex != null && ecModel.eachComponent({
        mainType: 'legend',
        subType: 'scroll',
        query: payload
      }, function (legendModel) {
        legendModel.setScrollDataIndex(scrollDataIndex);
      });
    });

    /* src\components\Chart\Doughnut.svelte generated by Svelte v3.22.3 */

    // (58:0) {:else}
    function create_else_block$c(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(58:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (56:0) {#if data}
    function create_if_block$j(ctx) {
    	let current;
    	let chart_1_props = {};
    	const chart_1 = new Chart$1({ props: chart_1_props, $$inline: true });
    	/*chart_1_binding*/ ctx[6](chart_1);
    	chart_1.$on("render", /*onRender*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(chart_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chart_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const chart_1_changes = {};
    			chart_1.$set(chart_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chart_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chart_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*chart_1_binding*/ ctx[6](null);
    			destroy_component(chart_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(56:0) {#if data}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$j, create_else_block$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { legends = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { options = undefined } = $$props;

    	let chart = {
    		update: () => {
    			
    		}
    	};

    	function onRender({ detail: chart }) {
    		chart.showLoading();

    		chart.setOption({
    			tooltip: {
    				trigger: "item",
    				formatter: "{b}<br>{c} ({d}%)",
    				...tooltip
    			},
    			legend: {
    				type: "plain",
    				orient: "vertical",
    				left: "52%",
    				top: 10,
    				icon: "circle",
    				...legends
    			},
    			series: [
    				{
    					type: "pie",
    					radius: ["50%", "80%"],
    					center: ["20%", "50%"],
    					label: { normal: { show: false } },
    					data
    				}
    			],
    			...options
    		});

    		chart.hideLoading();
    	}

    	const writable_props = ["data", "legends", "tooltip", "options"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Doughnut> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Doughnut", $$slots, []);

    	function chart_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(1, chart = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("legends" in $$props) $$invalidate(3, legends = $$props.legends);
    		if ("tooltip" in $$props) $$invalidate(4, tooltip = $$props.tooltip);
    		if ("options" in $$props) $$invalidate(5, options = $$props.options);
    	};

    	$$self.$capture_state = () => ({
    		Loading,
    		Chart: Chart$1,
    		data,
    		legends,
    		tooltip,
    		options,
    		chart,
    		onRender
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("legends" in $$props) $$invalidate(3, legends = $$props.legends);
    		if ("tooltip" in $$props) $$invalidate(4, tooltip = $$props.tooltip);
    		if ("options" in $$props) $$invalidate(5, options = $$props.options);
    		if ("chart" in $$props) $$invalidate(1, chart = $$props.chart);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, chart*/ 3) {
    			 if (data) {
    				chart.update();
    			}
    		}
    	};

    	return [data, chart, onRender, legends, tooltip, options, chart_1_binding];
    }

    class Doughnut extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$Q, create_fragment$R, safe_not_equal, {
    			data: 0,
    			legends: 3,
    			tooltip: 4,
    			options: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Doughnut",
    			options,
    			id: create_fragment$R.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<Doughnut> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<Doughnut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Doughnut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get legends() {
    		throw new Error("<Doughnut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set legends(value) {
    		throw new Error("<Doughnut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Doughnut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Doughnut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<Doughnut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Doughnut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\despesas\_components\MaioresDespesasPorFuncao.svelte generated by Svelte v3.22.3 */
    const file$O = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\despesas\\_components\\MaioresDespesasPorFuncao.svelte";

    // (26:2) <span slot="title">
    function create_title_slot$9(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Maiores despesas por função";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$O, 25, 2, 510);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$9.name,
    		type: "slot",
    		source: "(26:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (27:2) <span slot="tooltip">
    function create_tooltip_slot$8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Cinco maiores despesas liquidadas, classificadas por função.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$O, 26, 2, 567);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$8.name,
    		type: "slot",
    		source: "(27:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (25:0) <Widget>
    function create_default_slot$q(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const doughnut = new Doughnut({
    			props: { data: /*data*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(doughnut.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$O, 29, 2, 669);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(doughnut, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const doughnut_changes = {};
    			if (dirty & /*data*/ 1) doughnut_changes.data = /*data*/ ctx[0];
    			doughnut.$set(doughnut_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(doughnut.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(doughnut.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(doughnut);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(25:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$q],
    					tooltip: [create_tooltip_slot$8],
    					title: [create_title_slot$9]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, data*/ 9) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { despesasPorFuncao } = $$props;
    	let data;

    	function render(despesasPorFuncao) {
    		if (!despesasPorFuncao) {
    			return;
    		}

    		$$invalidate(0, data = despesasPorFuncao.value.map(d => {
    			return { name: d.nome, value: d.valor };
    		}));
    	}

    	const writable_props = ["despesasPorFuncao"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MaioresDespesasPorFuncao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("MaioresDespesasPorFuncao", $$slots, []);

    	$$self.$set = $$props => {
    		if ("despesasPorFuncao" in $$props) $$invalidate(1, despesasPorFuncao = $$props.despesasPorFuncao);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Doughnut,
    		despesasPorFuncao,
    		data,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("despesasPorFuncao" in $$props) $$invalidate(1, despesasPorFuncao = $$props.despesasPorFuncao);
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*despesasPorFuncao*/ 2) {
    			 render(despesasPorFuncao);
    		}
    	};

    	return [data, despesasPorFuncao];
    }

    class MaioresDespesasPorFuncao extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$S, safe_not_equal, { despesasPorFuncao: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MaioresDespesasPorFuncao",
    			options,
    			id: create_fragment$S.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*despesasPorFuncao*/ ctx[1] === undefined && !("despesasPorFuncao" in props)) {
    			console.warn("<MaioresDespesasPorFuncao> was created without expected prop 'despesasPorFuncao'");
    		}
    	}

    	get despesasPorFuncao() {
    		throw new Error("<MaioresDespesasPorFuncao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set despesasPorFuncao(value) {
    		throw new Error("<MaioresDespesasPorFuncao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Link lists and struct (graph or tree)
     */
    var each$s = util.each;
    var DATAS = '\0__link_datas';
    var MAIN_DATA = '\0__link_mainData'; // Caution:
    // In most case, either list or its shallow clones (see list.cloneShallow)
    // is active in echarts process. So considering heap memory consumption,
    // we do not clone tree or graph, but share them among list and its shallow clones.
    // But in some rare case, we have to keep old list (like do animation in chart). So
    // please take care that both the old list and the new list share the same tree/graph.

    /**
     * @param {Object} opt
     * @param {module:echarts/data/List} opt.mainData
     * @param {Object} [opt.struct] For example, instance of Graph or Tree.
     * @param {string} [opt.structAttr] designation: list[structAttr] = struct;
     * @param {Object} [opt.datas] {dataType: data},
     *                 like: {node: nodeList, edge: edgeList}.
     *                 Should contain mainData.
     * @param {Object} [opt.datasAttr] {dataType: attr},
     *                 designation: struct[datasAttr[dataType]] = list;
     */

    function linkList(opt) {
      var mainData = opt.mainData;
      var datas = opt.datas;

      if (!datas) {
        datas = {
          main: mainData
        };
        opt.datasAttr = {
          main: 'data'
        };
      }

      opt.datas = opt.mainData = null;
      linkAll(mainData, datas, opt); // Porxy data original methods.

      each$s(datas, function (data) {
        each$s(mainData.TRANSFERABLE_METHODS, function (methodName) {
          data.wrapMethod(methodName, util.curry(transferInjection, opt));
        });
      }); // Beyond transfer, additional features should be added to `cloneShallow`.

      mainData.wrapMethod('cloneShallow', util.curry(cloneShallowInjection, opt)); // Only mainData trigger change, because struct.update may trigger
      // another changable methods, which may bring about dead lock.

      each$s(mainData.CHANGABLE_METHODS, function (methodName) {
        mainData.wrapMethod(methodName, util.curry(changeInjection, opt));
      }); // Make sure datas contains mainData.

      util.assert(datas[mainData.dataType] === mainData);
    }

    function transferInjection(opt, res) {
      if (isMainData(this)) {
        // Transfer datas to new main data.
        var datas = util.extend({}, this[DATAS]);
        datas[this.dataType] = res;
        linkAll(res, datas, opt);
      } else {
        // Modify the reference in main data to point newData.
        linkSingle(res, this.dataType, this[MAIN_DATA], opt);
      }

      return res;
    }

    function changeInjection(opt, res) {
      opt.struct && opt.struct.update(this);
      return res;
    }

    function cloneShallowInjection(opt, res) {
      // cloneShallow, which brings about some fragilities, may be inappropriate
      // to be exposed as an API. So for implementation simplicity we can make
      // the restriction that cloneShallow of not-mainData should not be invoked
      // outside, but only be invoked here.
      each$s(res[DATAS], function (data, dataType) {
        data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
      });
      return res;
    }
    /**
     * Supplement method to List.
     *
     * @public
     * @param {string} [dataType] If not specified, return mainData.
     * @return {module:echarts/data/List}
     */


    function getLinkedData(dataType) {
      var mainData = this[MAIN_DATA];
      return dataType == null || mainData == null ? mainData : mainData[DATAS][dataType];
    }

    function isMainData(data) {
      return data[MAIN_DATA] === data;
    }

    function linkAll(mainData, datas, opt) {
      mainData[DATAS] = {};
      each$s(datas, function (data, dataType) {
        linkSingle(data, dataType, mainData, opt);
      });
    }

    function linkSingle(data, dataType, mainData, opt) {
      mainData[DATAS][dataType] = data;
      data[MAIN_DATA] = mainData;
      data.dataType = dataType;

      if (opt.struct) {
        data[opt.structAttr] = opt.struct;
        opt.struct[opt.datasAttr[dataType]] = data;
      } // Supplement method.


      data.getLinkedData = getLinkedData;
    }

    var _default$27 = linkList;
    var linkList_1 = _default$27;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */











    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Tree data structure
     *
     * @module echarts/data/Tree
     */

    /**
     * @constructor module:echarts/data/Tree~TreeNode
     * @param {string} name
     * @param {module:echarts/data/Tree} hostTree
     */
    var TreeNode = function (name, hostTree) {
      /**
       * @type {string}
       */
      this.name = name || '';
      /**
       * Depth of node
       *
       * @type {number}
       * @readOnly
       */

      this.depth = 0;
      /**
       * Height of the subtree rooted at this node.
       * @type {number}
       * @readOnly
       */

      this.height = 0;
      /**
       * @type {module:echarts/data/Tree~TreeNode}
       * @readOnly
       */

      this.parentNode = null;
      /**
       * Reference to list item.
       * Do not persistent dataIndex outside,
       * besause it may be changed by list.
       * If dataIndex -1,
       * this node is logical deleted (filtered) in list.
       *
       * @type {Object}
       * @readOnly
       */

      this.dataIndex = -1;
      /**
       * @type {Array.<module:echarts/data/Tree~TreeNode>}
       * @readOnly
       */

      this.children = [];
      /**
       * @type {Array.<module:echarts/data/Tree~TreeNode>}
       * @pubilc
       */

      this.viewChildren = [];
      /**
       * @type {moduel:echarts/data/Tree}
       * @readOnly
       */

      this.hostTree = hostTree;
    };

    TreeNode.prototype = {
      constructor: TreeNode,

      /**
       * The node is removed.
       * @return {boolean} is removed.
       */
      isRemoved: function () {
        return this.dataIndex < 0;
      },

      /**
       * Travel this subtree (include this node).
       * Usage:
       *    node.eachNode(function () { ... }); // preorder
       *    node.eachNode('preorder', function () { ... }); // preorder
       *    node.eachNode('postorder', function () { ... }); // postorder
       *    node.eachNode(
       *        {order: 'postorder', attr: 'viewChildren'},
       *        function () { ... }
       *    ); // postorder
       *
       * @param {(Object|string)} options If string, means order.
       * @param {string=} options.order 'preorder' or 'postorder'
       * @param {string=} options.attr 'children' or 'viewChildren'
       * @param {Function} cb If in preorder and return false,
       *                      its subtree will not be visited.
       * @param {Object} [context]
       */
      eachNode: function (options, cb, context) {
        if (typeof options === 'function') {
          context = cb;
          cb = options;
          options = null;
        }

        options = options || {};

        if (util.isString(options)) {
          options = {
            order: options
          };
        }

        var order = options.order || 'preorder';
        var children = this[options.attr || 'children'];
        var suppressVisitSub;
        order === 'preorder' && (suppressVisitSub = cb.call(context, this));

        for (var i = 0; !suppressVisitSub && i < children.length; i++) {
          children[i].eachNode(options, cb, context);
        }

        order === 'postorder' && cb.call(context, this);
      },

      /**
       * Update depth and height of this subtree.
       *
       * @param  {number} depth
       */
      updateDepthAndHeight: function (depth) {
        var height = 0;
        this.depth = depth;

        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          child.updateDepthAndHeight(depth + 1);

          if (child.height > height) {
            height = child.height;
          }
        }

        this.height = height + 1;
      },

      /**
       * @param  {string} id
       * @return {module:echarts/data/Tree~TreeNode}
       */
      getNodeById: function (id) {
        if (this.getId() === id) {
          return this;
        }

        for (var i = 0, children = this.children, len = children.length; i < len; i++) {
          var res = children[i].getNodeById(id);

          if (res) {
            return res;
          }
        }
      },

      /**
       * @param {module:echarts/data/Tree~TreeNode} node
       * @return {boolean}
       */
      contains: function (node) {
        if (node === this) {
          return true;
        }

        for (var i = 0, children = this.children, len = children.length; i < len; i++) {
          var res = children[i].contains(node);

          if (res) {
            return res;
          }
        }
      },

      /**
       * @param {boolean} includeSelf Default false.
       * @return {Array.<module:echarts/data/Tree~TreeNode>} order: [root, child, grandchild, ...]
       */
      getAncestors: function (includeSelf) {
        var ancestors = [];
        var node = includeSelf ? this : this.parentNode;

        while (node) {
          ancestors.push(node);
          node = node.parentNode;
        }

        ancestors.reverse();
        return ancestors;
      },

      /**
       * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3
       * @return {number} Value.
       */
      getValue: function (dimension) {
        var data = this.hostTree.data;
        return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
      },

      /**
       * @param {Object} layout
       * @param {boolean=} [merge=false]
       */
      setLayout: function (layout, merge) {
        this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);
      },

      /**
       * @return {Object} layout
       */
      getLayout: function () {
        return this.hostTree.data.getItemLayout(this.dataIndex);
      },

      /**
       * @param {string} [path]
       * @return {module:echarts/model/Model}
       */
      getModel: function (path) {
        if (this.dataIndex < 0) {
          return;
        }

        var hostTree = this.hostTree;
        var itemModel = hostTree.data.getItemModel(this.dataIndex);
        var levelModel = this.getLevelModel(); // FIXME: refactor levelModel to "beforeLink", and remove levelModel here.

        if (levelModel) {
          return itemModel.getModel(path, levelModel.getModel(path));
        } else {
          return itemModel.getModel(path);
        }
      },

      /**
       * @return {module:echarts/model/Model}
       */
      getLevelModel: function () {
        return (this.hostTree.levelModels || [])[this.depth];
      },

      /**
       * @example
       *  setItemVisual('color', color);
       *  setItemVisual({
       *      'color': color
       *  });
       */
      setVisual: function (key, value) {
        this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
      },

      /**
       * Get item visual
       */
      getVisual: function (key, ignoreParent) {
        return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);
      },

      /**
       * @public
       * @return {number}
       */
      getRawIndex: function () {
        return this.hostTree.data.getRawIndex(this.dataIndex);
      },

      /**
       * @public
       * @return {string}
       */
      getId: function () {
        return this.hostTree.data.getId(this.dataIndex);
      },

      /**
       * if this is an ancestor of another node
       *
       * @public
       * @param {TreeNode} node another node
       * @return {boolean} if is ancestor
       */
      isAncestorOf: function (node) {
        var parent = node.parentNode;

        while (parent) {
          if (parent === this) {
            return true;
          }

          parent = parent.parentNode;
        }

        return false;
      },

      /**
       * if this is an descendant of another node
       *
       * @public
       * @param {TreeNode} node another node
       * @return {boolean} if is descendant
       */
      isDescendantOf: function (node) {
        return node !== this && node.isAncestorOf(this);
      }
    };
    /**
     * @constructor
     * @alias module:echarts/data/Tree
     * @param {module:echarts/model/Model} hostModel
     * @param {Array.<Object>} levelOptions
     */

    function Tree(hostModel, levelOptions) {
      /**
       * @type {module:echarts/data/Tree~TreeNode}
       * @readOnly
       */
      this.root;
      /**
       * @type {module:echarts/data/List}
       * @readOnly
       */

      this.data;
      /**
       * Index of each item is the same as the raw index of coresponding list item.
       * @private
       * @type {Array.<module:echarts/data/Tree~TreeNode}
       */

      this._nodes = [];
      /**
       * @private
       * @readOnly
       * @type {module:echarts/model/Model}
       */

      this.hostModel = hostModel;
      /**
       * @private
       * @readOnly
       * @type {Array.<module:echarts/model/Model}
       */

      this.levelModels = util.map(levelOptions || [], function (levelDefine) {
        return new Model_1(levelDefine, hostModel, hostModel.ecModel);
      });
    }

    Tree.prototype = {
      constructor: Tree,
      type: 'tree',

      /**
       * Travel this subtree (include this node).
       * Usage:
       *    node.eachNode(function () { ... }); // preorder
       *    node.eachNode('preorder', function () { ... }); // preorder
       *    node.eachNode('postorder', function () { ... }); // postorder
       *    node.eachNode(
       *        {order: 'postorder', attr: 'viewChildren'},
       *        function () { ... }
       *    ); // postorder
       *
       * @param {(Object|string)} options If string, means order.
       * @param {string=} options.order 'preorder' or 'postorder'
       * @param {string=} options.attr 'children' or 'viewChildren'
       * @param {Function} cb
       * @param {Object}   [context]
       */
      eachNode: function (options, cb, context) {
        this.root.eachNode(options, cb, context);
      },

      /**
       * @param {number} dataIndex
       * @return {module:echarts/data/Tree~TreeNode}
       */
      getNodeByDataIndex: function (dataIndex) {
        var rawIndex = this.data.getRawIndex(dataIndex);
        return this._nodes[rawIndex];
      },

      /**
       * @param {string} name
       * @return {module:echarts/data/Tree~TreeNode}
       */
      getNodeByName: function (name) {
        return this.root.getNodeByName(name);
      },

      /**
       * Update item available by list,
       * when list has been performed options like 'filterSelf' or 'map'.
       */
      update: function () {
        var data = this.data;
        var nodes = this._nodes;

        for (var i = 0, len = nodes.length; i < len; i++) {
          nodes[i].dataIndex = -1;
        }

        for (var i = 0, len = data.count(); i < len; i++) {
          nodes[data.getRawIndex(i)].dataIndex = i;
        }
      },

      /**
       * Clear all layouts
       */
      clearLayouts: function () {
        this.data.clearItemLayouts();
      }
    };
    /**
     * data node format:
     * {
     *     name: ...
     *     value: ...
     *     children: [
     *         {
     *             name: ...
     *             value: ...
     *             children: ...
     *         },
     *         ...
     *     ]
     * }
     *
     * @static
     * @param {Object} dataRoot Root node.
     * @param {module:echarts/model/Model} hostModel
     * @param {Object} treeOptions
     * @param {Array.<Object>} treeOptions.levels
     * @return module:echarts/data/Tree
     */

    Tree.createTree = function (dataRoot, hostModel, treeOptions, beforeLink) {
      var tree = new Tree(hostModel, treeOptions && treeOptions.levels);
      var listData = [];
      var dimMax = 1;
      buildHierarchy(dataRoot);

      function buildHierarchy(dataNode, parentNode) {
        var value = dataNode.value;
        dimMax = Math.max(dimMax, util.isArray(value) ? value.length : 1);
        listData.push(dataNode);
        var node = new TreeNode(dataNode.name, tree);
        parentNode ? addChild(node, parentNode) : tree.root = node;

        tree._nodes.push(node);

        var children = dataNode.children;

        if (children) {
          for (var i = 0; i < children.length; i++) {
            buildHierarchy(children[i], node);
          }
        }
      }

      tree.root.updateDepthAndHeight(0);
      var dimensionsInfo = createDimensions(listData, {
        coordDimensions: ['value'],
        dimensionsCount: dimMax
      });
      var list = new List_1(dimensionsInfo, hostModel);
      list.initData(listData);
      beforeLink && beforeLink(list);
      linkList_1({
        mainData: list,
        struct: tree,
        structAttr: 'tree'
      });
      tree.update();
      return tree;
    };
    /**
     * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,
     * so this function is not ready and not necessary to be public.
     *
     * @param {(module:echarts/data/Tree~TreeNode|Object)} child
     */


    function addChild(child, node) {
      var children = node.children;

      if (child.parentNode === node) {
        return;
      }

      children.push(child);
      child.parentNode = node;
    }

    var _default$28 = Tree;
    var Tree_1 = _default$28;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
      if (payload && util.indexOf(validPayloadTypes, payload.type) >= 0) {
        var root = seriesModel.getData().tree.root;
        var targetNode = payload.targetNode;

        if (typeof targetNode === 'string') {
          targetNode = root.getNodeById(targetNode);
        }

        if (targetNode && root.contains(targetNode)) {
          return {
            node: targetNode
          };
        }

        var targetNodeId = payload.targetNodeId;

        if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
          return {
            node: targetNode
          };
        }
      }
    } // Not includes the given node at the last item.


    function getPathToRoot(node) {
      var path = [];

      while (node) {
        node = node.parentNode;
        node && path.push(node);
      }

      return path.reverse();
    }

    function aboveViewRoot(viewRoot, node) {
      var viewPath = getPathToRoot(viewRoot);
      return util.indexOf(viewPath, node) >= 0;
    } // From root to the input node (the input node will be included).


    function wrapTreePathInfo(node, seriesModel) {
      var treePathInfo = [];

      while (node) {
        var nodeDataIndex = node.dataIndex;
        treePathInfo.push({
          name: node.name,
          dataIndex: nodeDataIndex,
          value: seriesModel.getRawValue(nodeDataIndex)
        });
        node = node.parentNode;
      }

      treePathInfo.reverse();
      return treePathInfo;
    }

    var retrieveTargetInfo_1 = retrieveTargetInfo;
    var getPathToRoot_1 = getPathToRoot;
    var aboveViewRoot_1 = aboveViewRoot;
    var wrapTreePathInfo_1 = wrapTreePathInfo;

    var treeHelper = {
    	retrieveTargetInfo: retrieveTargetInfo_1,
    	getPathToRoot: getPathToRoot_1,
    	aboveViewRoot: aboveViewRoot_1,
    	wrapTreePathInfo: wrapTreePathInfo_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */











    var encodeHTML$2 = format$1.encodeHTML;
    var addCommas$2 = format$1.addCommas;



    var wrapTreePathInfo$1 = treeHelper.wrapTreePathInfo;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var _default$29 = Series.extend({
      type: 'series.treemap',
      layoutMode: 'box',
      dependencies: ['grid', 'polar'],
      preventUsingHoverLayer: true,

      /**
       * @type {module:echarts/data/Tree~Node}
       */
      _viewRoot: null,
      defaultOption: {
        // Disable progressive rendering
        progressive: 0,
        // center: ['50%', '50%'],          // not supported in ec3.
        // size: ['80%', '80%'],            // deprecated, compatible with ec2.
        left: 'center',
        top: 'middle',
        right: null,
        bottom: null,
        width: '80%',
        height: '80%',
        sort: true,
        // Can be null or false or true
        // (order by desc default, asc not supported yet (strange effect))
        clipWindow: 'origin',
        // Size of clipped window when zooming. 'origin' or 'fullscreen'
        squareRatio: 0.5 * (1 + Math.sqrt(5)),
        // golden ratio
        leafDepth: null,
        // Nodes on depth from root are regarded as leaves.
        // Count from zero (zero represents only view root).
        drillDownIcon: '▶',
        // Use html character temporarily because it is complicated
        // to align specialized icon. ▷▶❒❐▼✚
        zoomToNodeRatio: 0.32 * 0.32,
        // Be effective when using zoomToNode. Specify the proportion of the
        // target node area in the view area.
        roam: true,
        // true, false, 'scale' or 'zoom', 'move'.
        nodeClick: 'zoomToNode',
        // Leaf node click behaviour: 'zoomToNode', 'link', false.
        // If leafDepth is set and clicking a node which has children but
        // be on left depth, the behaviour would be changing root. Otherwise
        // use behavious defined above.
        animation: true,
        animationDurationUpdate: 900,
        animationEasing: 'quinticInOut',
        breadcrumb: {
          show: true,
          height: 22,
          left: 'center',
          top: 'bottom',
          // right
          // bottom
          emptyItemWidth: 25,
          // Width of empty node.
          itemStyle: {
            color: 'rgba(0,0,0,0.7)',
            //'#5793f3',
            borderColor: 'rgba(255,255,255,0.7)',
            borderWidth: 1,
            shadowColor: 'rgba(150,150,150,1)',
            shadowBlur: 3,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            textStyle: {
              color: '#fff'
            }
          },
          emphasis: {
            textStyle: {}
          }
        },
        label: {
          show: true,
          // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
          distance: 0,
          padding: 5,
          position: 'inside',
          // Can be [5, '5%'] or position stirng like 'insideTopLeft', ...
          // formatter: null,
          color: '#fff',
          ellipsis: true // align
          // verticalAlign

        },
        upperLabel: {
          // Label when node is parent.
          show: false,
          position: [0, '50%'],
          height: 20,
          // formatter: null,
          color: '#fff',
          ellipsis: true,
          // align: null,
          verticalAlign: 'middle'
        },
        itemStyle: {
          color: null,
          // Can be 'none' if not necessary.
          colorAlpha: null,
          // Can be 'none' if not necessary.
          colorSaturation: null,
          // Can be 'none' if not necessary.
          borderWidth: 0,
          gapWidth: 0,
          borderColor: '#fff',
          borderColorSaturation: null // If specified, borderColor will be ineffective, and the
          // border color is evaluated by color of current node and
          // borderColorSaturation.

        },
        emphasis: {
          upperLabel: {
            show: true,
            position: [0, '50%'],
            color: '#fff',
            ellipsis: true,
            verticalAlign: 'middle'
          }
        },
        visualDimension: 0,
        // Can be 0, 1, 2, 3.
        visualMin: null,
        visualMax: null,
        color: [],
        // + treemapSeries.color should not be modified. Please only modified
        // level[n].color (if necessary).
        // + Specify color list of each level. level[0].color would be global
        // color list if not specified. (see method `setDefault`).
        // + But set as a empty array to forbid fetch color from global palette
        // when using nodeModel.get('color'), otherwise nodes on deep level
        // will always has color palette set and are not able to inherit color
        // from parent node.
        // + TreemapSeries.color can not be set as 'none', otherwise effect
        // legend color fetching (see seriesColor.js).
        colorAlpha: null,
        // Array. Specify color alpha range of each level, like [0.2, 0.8]
        colorSaturation: null,
        // Array. Specify color saturation of each level, like [0.2, 0.5]
        colorMappingBy: 'index',
        // 'value' or 'index' or 'id'.
        visibleMin: 10,
        // If area less than this threshold (unit: pixel^2), node will not
        // be rendered. Only works when sort is 'asc' or 'desc'.
        childrenVisibleMin: null,
        // If area of a node less than this threshold (unit: pixel^2),
        // grandchildren will not show.
        // Why grandchildren? If not grandchildren but children,
        // some siblings show children and some not,
        // the appearance may be mess and not consistent,
        levels: [] // Each item: {
        //     visibleMin, itemStyle, visualDimension, label
        // }
        // data: {
        //      value: [],
        //      children: [],
        //      link: 'http://xxx.xxx.xxx',
        //      target: 'blank' or 'self'
        // }

      },

      /**
       * @override
       */
      getInitialData: function (option, ecModel) {
        // Create a virtual root.
        var root = {
          name: option.name,
          children: option.data
        };
        completeTreeValue(root);
        var levels = option.levels || [];
        levels = option.levels = setDefault(levels, ecModel);
        var levelModels = util.map(levels || [], function (levelDefine) {
          return new Model_1(levelDefine, this, ecModel);
        }, this); // Make sure always a new tree is created when setOption,
        // in TreemapView, we check whether oldTree === newTree
        // to choose mappings approach among old shapes and new shapes.

        var tree = Tree_1.createTree(root, this, null, beforeLink);

        function beforeLink(nodeData) {
          nodeData.wrapMethod('getItemModel', function (model, idx) {
            var node = tree.getNodeByDataIndex(idx);
            var levelModel = levelModels[node.depth];
            levelModel && (model.parentModel = levelModel);
            return model;
          });
        }

        return tree.data;
      },
      optionUpdated: function () {
        this.resetViewRoot();
      },

      /**
       * @override
       * @param {number} dataIndex
       * @param {boolean} [mutipleSeries=false]
       */
      formatTooltip: function (dataIndex) {
        var data = this.getData();
        var value = this.getRawValue(dataIndex);
        var formattedValue = util.isArray(value) ? addCommas$2(value[0]) : addCommas$2(value);
        var name = data.getName(dataIndex);
        return encodeHTML$2(name + ': ' + formattedValue);
      },

      /**
       * Add tree path to tooltip param
       *
       * @override
       * @param {number} dataIndex
       * @return {Object}
       */
      getDataParams: function (dataIndex) {
        var params = Series.prototype.getDataParams.apply(this, arguments);
        var node = this.getData().tree.getNodeByDataIndex(dataIndex);
        params.treePathInfo = wrapTreePathInfo$1(node, this);
        return params;
      },

      /**
       * @public
       * @param {Object} layoutInfo {
       *                                x: containerGroup x
       *                                y: containerGroup y
       *                                width: containerGroup width
       *                                height: containerGroup height
       *                            }
       */
      setLayoutInfo: function (layoutInfo) {
        /**
         * @readOnly
         * @type {Object}
         */
        this.layoutInfo = this.layoutInfo || {};
        util.extend(this.layoutInfo, layoutInfo);
      },

      /**
       * @param  {string} id
       * @return {number} index
       */
      mapIdToIndex: function (id) {
        // A feature is implemented:
        // index is monotone increasing with the sequence of
        // input id at the first time.
        // This feature can make sure that each data item and its
        // mapped color have the same index between data list and
        // color list at the beginning, which is useful for user
        // to adjust data-color mapping.

        /**
         * @private
         * @type {Object}
         */
        var idIndexMap = this._idIndexMap;

        if (!idIndexMap) {
          idIndexMap = this._idIndexMap = util.createHashMap();
          /**
           * @private
           * @type {number}
           */

          this._idIndexMapCount = 0;
        }

        var index = idIndexMap.get(id);

        if (index == null) {
          idIndexMap.set(id, index = this._idIndexMapCount++);
        }

        return index;
      },
      getViewRoot: function () {
        return this._viewRoot;
      },

      /**
       * @param {module:echarts/data/Tree~Node} [viewRoot]
       */
      resetViewRoot: function (viewRoot) {
        viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
        var root = this.getRawData().tree.root;

        if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
          this._viewRoot = root;
        }
      }
    });
    /**
     * @param {Object} dataNode
     */


    function completeTreeValue(dataNode) {
      // Postorder travel tree.
      // If value of none-leaf node is not set,
      // calculate it by suming up the value of all children.
      var sum = 0;
      util.each(dataNode.children, function (child) {
        completeTreeValue(child);
        var childValue = child.value;
        util.isArray(childValue) && (childValue = childValue[0]);
        sum += childValue;
      });
      var thisValue = dataNode.value;

      if (util.isArray(thisValue)) {
        thisValue = thisValue[0];
      }

      if (thisValue == null || isNaN(thisValue)) {
        thisValue = sum;
      } // Value should not less than 0.


      if (thisValue < 0) {
        thisValue = 0;
      }

      util.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
    }
    /**
     * set default to level configuration
     */


    function setDefault(levels, ecModel) {
      var globalColorList = ecModel.get('color');

      if (!globalColorList) {
        return;
      }

      levels = levels || [];
      var hasColorDefine;
      util.each(levels, function (levelDefine) {
        var model = new Model_1(levelDefine);
        var modelColor = model.get('color');

        if (model.get('itemStyle.color') || modelColor && modelColor !== 'none') {
          hasColorDefine = true;
        }
      });

      if (!hasColorDefine) {
        var level0 = levels[0] || (levels[0] = {});
        level0.color = globalColorList.slice();
      }

      return levels;
    }

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    var wrapTreePathInfo$2 = treeHelper.wrapTreePathInfo;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var TEXT_PADDING = 8;
    var ITEM_GAP = 8;
    var ARRAY_LENGTH = 5;

    function Breadcrumb$1(containerGroup) {
      /**
       * @private
       * @type {module:zrender/container/Group}
       */
      this.group = new graphic.Group();
      containerGroup.add(this.group);
    }

    Breadcrumb$1.prototype = {
      constructor: Breadcrumb$1,
      render: function (seriesModel, api, targetNode, onSelect) {
        var model = seriesModel.getModel('breadcrumb');
        var thisGroup = this.group;
        thisGroup.removeAll();

        if (!model.get('show') || !targetNode) {
          return;
        }

        var normalStyleModel = model.getModel('itemStyle'); // var emphasisStyleModel = model.getModel('emphasis.itemStyle');

        var textStyleModel = normalStyleModel.getModel('textStyle');
        var layoutParam = {
          pos: {
            left: model.get('left'),
            right: model.get('right'),
            top: model.get('top'),
            bottom: model.get('bottom')
          },
          box: {
            width: api.getWidth(),
            height: api.getHeight()
          },
          emptyItemWidth: model.get('emptyItemWidth'),
          totalWidth: 0,
          renderList: []
        };

        this._prepare(targetNode, layoutParam, textStyleModel);

        this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);

        layout.positionElement(thisGroup, layoutParam.pos, layoutParam.box);
      },

      /**
       * Prepare render list and total width
       * @private
       */
      _prepare: function (targetNode, layoutParam, textStyleModel) {
        for (var node = targetNode; node; node = node.parentNode) {
          var text = node.getModel().get('name');
          var textRect = textStyleModel.getTextRect(text);
          var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
          layoutParam.totalWidth += itemWidth + ITEM_GAP;
          layoutParam.renderList.push({
            node: node,
            text: text,
            width: itemWidth
          });
        }
      },

      /**
       * @private
       */
      _renderContent: function (seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {
        // Start rendering.
        var lastX = 0;
        var emptyItemWidth = layoutParam.emptyItemWidth;
        var height = seriesModel.get('breadcrumb.height');
        var availableSize = layout.getAvailableSize(layoutParam.pos, layoutParam.box);
        var totalWidth = layoutParam.totalWidth;
        var renderList = layoutParam.renderList;

        for (var i = renderList.length - 1; i >= 0; i--) {
          var item = renderList[i];
          var itemNode = item.node;
          var itemWidth = item.width;
          var text = item.text; // Hdie text and shorten width if necessary.

          if (totalWidth > availableSize.width) {
            totalWidth -= itemWidth - emptyItemWidth;
            itemWidth = emptyItemWidth;
            text = null;
          }

          var el = new graphic.Polygon({
            shape: {
              points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
            },
            style: util.defaults(normalStyleModel.getItemStyle(), {
              lineJoin: 'bevel',
              text: text,
              textFill: textStyleModel.getTextColor(),
              textFont: textStyleModel.getFont()
            }),
            z: 10,
            onclick: util.curry(onSelect, itemNode)
          });
          this.group.add(el);
          packEventData(el, seriesModel, itemNode);
          lastX += itemWidth + ITEM_GAP;
        }
      },

      /**
       * @override
       */
      remove: function () {
        this.group.removeAll();
      }
    };

    function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
      var points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];
      !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
      !head && points.push([x, y + itemHeight / 2]);
      return points;
    } // Package custom mouse event.


    function packEventData(el, seriesModel, itemNode) {
      el.eventData = {
        componentType: 'series',
        componentSubType: 'treemap',
        componentIndex: seriesModel.componentIndex,
        seriesIndex: seriesModel.componentIndex,
        seriesName: seriesModel.name,
        seriesType: 'treemap',
        selfType: 'breadcrumb',
        // Distinguish with click event on treemap node.
        nodeData: {
          dataIndex: itemNode && itemNode.dataIndex,
          name: itemNode && itemNode.name
        },
        treePathInfo: itemNode && wrapTreePathInfo$2(itemNode, seriesModel)
      };
    }

    var _default$2a = Breadcrumb$1;
    var Breadcrumb_1 = _default$2a;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var ATTR = '\0_ec_interaction_mutex';

    function take(zr, resourceKey, userKey) {
      var store = getStore(zr);
      store[resourceKey] = userKey;
    }

    function release(zr, resourceKey, userKey) {
      var store = getStore(zr);
      var uKey = store[resourceKey];

      if (uKey === userKey) {
        store[resourceKey] = null;
      }
    }

    function isTaken(zr, resourceKey) {
      return !!getStore(zr)[resourceKey];
    }

    function getStore(zr) {
      return zr[ATTR] || (zr[ATTR] = {});
    }
    /**
     * payload: {
     *     type: 'takeGlobalCursor',
     *     key: 'dataZoomSelect', or 'brush', or ...,
     *         If no userKey, release global cursor.
     * }
     */


    echarts.registerAction({
      type: 'takeGlobalCursor',
      event: 'globalCursorTaken',
      update: 'update'
    }, function () {});
    var take_1 = take;
    var release_1 = release;
    var isTaken_1 = isTaken;

    var interactionMutex = {
    	take: take_1,
    	release: release_1,
    	isTaken: isTaken_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @alias module:echarts/component/helper/RoamController
     * @constructor
     * @mixin {module:zrender/mixin/Eventful}
     *
     * @param {module:zrender/zrender~ZRender} zr
     */
    function RoamController(zr) {
      /**
       * @type {Function}
       */
      this.pointerChecker;
      /**
       * @type {module:zrender}
       */

      this._zr = zr;
      /**
       * @type {Object}
       */

      this._opt = {}; // Avoid two roamController bind the same handler

      var bind = util.bind;
      var mousedownHandler = bind(mousedown, this);
      var mousemoveHandler = bind(mousemove, this);
      var mouseupHandler = bind(mouseup, this);
      var mousewheelHandler = bind(mousewheel, this);
      var pinchHandler = bind(pinch, this);
      Eventful_1.call(this);
      /**
       * @param {Function} pointerChecker
       *                   input: x, y
       *                   output: boolean
       */

      this.setPointerChecker = function (pointerChecker) {
        this.pointerChecker = pointerChecker;
      };
      /**
       * Notice: only enable needed types. For example, if 'zoom'
       * is not needed, 'zoom' should not be enabled, otherwise
       * default mousewheel behaviour (scroll page) will be disabled.
       *
       * @param  {boolean|string} [controlType=true] Specify the control type,
       *                          which can be null/undefined or true/false
       *                          or 'pan/move' or 'zoom'/'scale'
       * @param {Object} [opt]
       * @param {Object} [opt.zoomOnMouseWheel=true] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.
       * @param {Object} [opt.moveOnMouseMove=true] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.
       * @param {Object} [opt.moveOnMouseWheel=false] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.
       * @param {Object} [opt.preventDefaultMouseMove=true] When pan.
       */


      this.enable = function (controlType, opt) {
        // Disable previous first
        this.disable();
        this._opt = util.defaults(util.clone(opt) || {}, {
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: false,
          preventDefaultMouseMove: true
        });

        if (controlType == null) {
          controlType = true;
        }

        if (controlType === true || controlType === 'move' || controlType === 'pan') {
          zr.on('mousedown', mousedownHandler);
          zr.on('mousemove', mousemoveHandler);
          zr.on('mouseup', mouseupHandler);
        }

        if (controlType === true || controlType === 'scale' || controlType === 'zoom') {
          zr.on('mousewheel', mousewheelHandler);
          zr.on('pinch', pinchHandler);
        }
      };

      this.disable = function () {
        zr.off('mousedown', mousedownHandler);
        zr.off('mousemove', mousemoveHandler);
        zr.off('mouseup', mouseupHandler);
        zr.off('mousewheel', mousewheelHandler);
        zr.off('pinch', pinchHandler);
      };

      this.dispose = this.disable;

      this.isDragging = function () {
        return this._dragging;
      };

      this.isPinching = function () {
        return this._pinching;
      };
    }

    util.mixin(RoamController, Eventful_1);

    function mousedown(e) {
      if (event.isMiddleOrRightButtonOnMouseUpDown(e) || e.target && e.target.draggable) {
        return;
      }

      var x = e.offsetX;
      var y = e.offsetY; // Only check on mosedown, but not mousemove.
      // Mouse can be out of target when mouse moving.

      if (this.pointerChecker && this.pointerChecker(e, x, y)) {
        this._x = x;
        this._y = y;
        this._dragging = true;
      }
    }

    function mousemove(e) {
      if (!this._dragging || !isAvailableBehavior('moveOnMouseMove', e, this._opt) || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {
        return;
      }

      var x = e.offsetX;
      var y = e.offsetY;
      var oldX = this._x;
      var oldY = this._y;
      var dx = x - oldX;
      var dy = y - oldY;
      this._x = x;
      this._y = y;
      this._opt.preventDefaultMouseMove && event.stop(e.event);
      trigger(this, 'pan', 'moveOnMouseMove', e, {
        dx: dx,
        dy: dy,
        oldX: oldX,
        oldY: oldY,
        newX: x,
        newY: y
      });
    }

    function mouseup(e) {
      if (!event.isMiddleOrRightButtonOnMouseUpDown(e)) {
        this._dragging = false;
      }
    }

    function mousewheel(e) {
      var shouldZoom = isAvailableBehavior('zoomOnMouseWheel', e, this._opt);
      var shouldMove = isAvailableBehavior('moveOnMouseWheel', e, this._opt);
      var wheelDelta = e.wheelDelta;
      var absWheelDeltaDelta = Math.abs(wheelDelta);
      var originX = e.offsetX;
      var originY = e.offsetY; // wheelDelta maybe -0 in chrome mac.

      if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
        return;
      } // If both `shouldZoom` and `shouldMove` is true, trigger
      // their event both, and the final behavior is determined
      // by event listener themselves.


      if (shouldZoom) {
        // Convenience:
        // Mac and VM Windows on Mac: scroll up: zoom out.
        // Windows: scroll up: zoom in.
        // FIXME: Should do more test in different environment.
        // wheelDelta is too complicated in difference nvironment
        // (https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel),
        // although it has been normallized by zrender.
        // wheelDelta of mouse wheel is bigger than touch pad.
        var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
        var scale = wheelDelta > 0 ? factor : 1 / factor;
        checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {
          scale: scale,
          originX: originX,
          originY: originY
        });
      }

      if (shouldMove) {
        // FIXME: Should do more test in different environment.
        var absDelta = Math.abs(wheelDelta); // wheelDelta of mouse wheel is bigger than touch pad.

        var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
        checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {
          scrollDelta: scrollDelta,
          originX: originX,
          originY: originY
        });
      }
    }

    function pinch(e) {
      if (interactionMutex.isTaken(this._zr, 'globalPan')) {
        return;
      }

      var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
      checkPointerAndTrigger(this, 'zoom', null, e, {
        scale: scale,
        originX: e.pinchX,
        originY: e.pinchY
      });
    }

    function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
      if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {
        // When mouse is out of roamController rect,
        // default befavoius should not be be disabled, otherwise
        // page sliding is disabled, contrary to expectation.
        event.stop(e.event);
        trigger(controller, eventName, behaviorToCheck, e, contollerEvent);
      }
    }

    function trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
      // Also provide behavior checker for event listener, for some case that
      // multiple components share one listener.
      contollerEvent.isAvailableBehavior = util.bind(isAvailableBehavior, null, behaviorToCheck, e);
      controller.trigger(eventName, contollerEvent);
    } // settings: {
    //     zoomOnMouseWheel
    //     moveOnMouseMove
    //     moveOnMouseWheel
    // }
    // The value can be: true / false / 'shift' / 'ctrl' / 'alt'.


    function isAvailableBehavior(behaviorToCheck, e, settings) {
      var setting = settings[behaviorToCheck];
      return !behaviorToCheck || setting && (!util.isString(setting) || e.event[setting + 'Key']);
    }

    var _default$2b = RoamController;
    var RoamController_1 = _default$2b;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @param {number} [time=500] Time in ms
     * @param {string} [easing='linear']
     * @param {number} [delay=0]
     * @param {Function} [callback]
     *
     * @example
     *  // Animate position
     *  animation
     *      .createWrap()
     *      .add(el1, {position: [10, 10]})
     *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)
     *      .done(function () { // done })
     *      .start('cubicOut');
     */
    function createWrap() {
      var storage = [];
      var elExistsMap = {};
      var doneCallback;
      return {
        /**
         * Caution: a el can only be added once, otherwise 'done'
         * might not be called. This method checks this (by el.id),
         * suppresses adding and returns false when existing el found.
         *
         * @param {modele:zrender/Element} el
         * @param {Object} target
         * @param {number} [time=500]
         * @param {number} [delay=0]
         * @param {string} [easing='linear']
         * @return {boolean} Whether adding succeeded.
         *
         * @example
         *     add(el, target, time, delay, easing);
         *     add(el, target, time, easing);
         *     add(el, target, time);
         *     add(el, target);
         */
        add: function (el, target, time, delay, easing) {
          if (util.isString(delay)) {
            easing = delay;
            delay = 0;
          }

          if (elExistsMap[el.id]) {
            return false;
          }

          elExistsMap[el.id] = 1;
          storage.push({
            el: el,
            target: target,
            time: time,
            delay: delay,
            easing: easing
          });
          return true;
        },

        /**
         * Only execute when animation finished. Will not execute when any
         * of 'stop' or 'stopAnimation' called.
         *
         * @param {Function} callback
         */
        done: function (callback) {
          doneCallback = callback;
          return this;
        },

        /**
         * Will stop exist animation firstly.
         */
        start: function () {
          var count = storage.length;

          for (var i = 0, len = storage.length; i < len; i++) {
            var item = storage[i];
            item.el.animateTo(item.target, item.time, item.delay, item.easing, done);
          }

          return this;

          function done() {
            count--;

            if (!count) {
              storage.length = 0;
              elExistsMap = {};
              doneCallback && doneCallback();
            }
          }
        }
      };
    }

    var createWrap_1 = createWrap;

    var animation = {
    	createWrap: createWrap_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

























    var windowOpen$1 = format$1.windowOpen;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var bind$4 = util.bind;
    var Group$3 = graphic.Group;
    var Rect$1 = graphic.Rect;
    var each$t = util.each;
    var DRAG_THRESHOLD = 3;
    var PATH_LABEL_NOAMAL = ['label'];
    var PATH_LABEL_EMPHASIS = ['emphasis', 'label'];
    var PATH_UPPERLABEL_NORMAL = ['upperLabel'];
    var PATH_UPPERLABEL_EMPHASIS = ['emphasis', 'upperLabel'];
    var Z_BASE = 10; // Should bigger than every z.

    var Z_BG = 1;
    var Z_CONTENT = 2;
    var getItemStyleEmphasis = makeStyleMapper([['fill', 'color'], // `borderColor` and `borderWidth` has been occupied,
    // so use `stroke` to indicate the stroke of the rect.
    ['stroke', 'strokeColor'], ['lineWidth', 'strokeWidth'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);

    var getItemStyleNormal = function (model) {
      // Normal style props should include emphasis style props.
      var itemStyle = getItemStyleEmphasis(model); // Clear styles set by emphasis.

      itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
      return itemStyle;
    };

    var _default$2c = echarts.extendChartView({
      type: 'treemap',

      /**
       * @override
       */
      init: function (o, api) {
        /**
         * @private
         * @type {module:zrender/container/Group}
         */
        this._containerGroup;
        /**
         * @private
         * @type {Object.<string, Array.<module:zrender/container/Group>>}
         */

        this._storage = createStorage();
        /**
         * @private
         * @type {module:echarts/data/Tree}
         */

        this._oldTree;
        /**
         * @private
         * @type {module:echarts/chart/treemap/Breadcrumb}
         */

        this._breadcrumb;
        /**
         * @private
         * @type {module:echarts/component/helper/RoamController}
         */

        this._controller;
        /**
         * 'ready', 'animating'
         * @private
         */

        this._state = 'ready';
      },

      /**
       * @override
       */
      render: function (seriesModel, ecModel, api, payload) {
        var models = ecModel.findComponents({
          mainType: 'series',
          subType: 'treemap',
          query: payload
        });

        if (util.indexOf(models, seriesModel) < 0) {
          return;
        }

        this.seriesModel = seriesModel;
        this.api = api;
        this.ecModel = ecModel;
        var types = ['treemapZoomToNode', 'treemapRootToNode'];
        var targetInfo = treeHelper.retrieveTargetInfo(payload, types, seriesModel);
        var payloadType = payload && payload.type;
        var layoutInfo = seriesModel.layoutInfo;
        var isInit = !this._oldTree;
        var thisStorage = this._storage; // Mark new root when action is treemapRootToNode.

        var reRoot = payloadType === 'treemapRootToNode' && targetInfo && thisStorage ? {
          rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
          direction: payload.direction
        } : null;

        var containerGroup = this._giveContainerGroup(layoutInfo);

        var renderResult = this._doRender(containerGroup, seriesModel, reRoot);

        !isInit && (!payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode') ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();

        this._resetController(api);

        this._renderBreadcrumb(seriesModel, api, targetInfo);
      },

      /**
       * @private
       */
      _giveContainerGroup: function (layoutInfo) {
        var containerGroup = this._containerGroup;

        if (!containerGroup) {
          // FIXME
          // 加一层containerGroup是为了clip，但是现在clip功能并没有实现。
          containerGroup = this._containerGroup = new Group$3();

          this._initEvents(containerGroup);

          this.group.add(containerGroup);
        }

        containerGroup.attr('position', [layoutInfo.x, layoutInfo.y]);
        return containerGroup;
      },

      /**
       * @private
       */
      _doRender: function (containerGroup, seriesModel, reRoot) {
        var thisTree = seriesModel.getData().tree;
        var oldTree = this._oldTree; // Clear last shape records.

        var lastsForAnimation = createStorage();
        var thisStorage = createStorage();
        var oldStorage = this._storage;
        var willInvisibleEls = [];
        var doRenderNode = util.curry(renderNode, seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls); // Notice: when thisTree and oldTree are the same tree (see list.cloneShallow),
        // the oldTree is actually losted, so we can not find all of the old graphic
        // elements from tree. So we use this stragegy: make element storage, move
        // from old storage to new storage, clear old storage.

        dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0); // Process all removing.

        var willDeleteEls = clearStorage(oldStorage);
        this._oldTree = thisTree;
        this._storage = thisStorage;
        return {
          lastsForAnimation: lastsForAnimation,
          willDeleteEls: willDeleteEls,
          renderFinally: renderFinally
        };

        function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
          // When 'render' is triggered by action,
          // 'this' and 'old' may be the same tree,
          // we use rawIndex in that case.
          if (sameTree) {
            oldViewChildren = thisViewChildren;
            each$t(thisViewChildren, function (child, index) {
              !child.isRemoved() && processNode(index, index);
            });
          } // Diff hierarchically (diff only in each subtree, but not whole).
          // because, consistency of view is important.
          else {
              new DataDiffer_1(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove(util.curry(processNode, null)).execute();
            }

          function getKey(node) {
            // Identify by name or raw index.
            return node.getId();
          }

          function processNode(newIndex, oldIndex) {
            var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
            var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
            var group = doRenderNode(thisNode, oldNode, parentGroup, depth);
            group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
          }
        }

        function clearStorage(storage) {
          var willDeleteEls = createStorage();
          storage && each$t(storage, function (store, storageName) {
            var delEls = willDeleteEls[storageName];
            each$t(store, function (el) {
              el && (delEls.push(el), el.__tmWillDelete = 1);
            });
          });
          return willDeleteEls;
        }

        function renderFinally() {
          each$t(willDeleteEls, function (els) {
            each$t(els, function (el) {
              el.parent && el.parent.remove(el);
            });
          });
          each$t(willInvisibleEls, function (el) {
            el.invisible = true; // Setting invisible is for optimizing, so no need to set dirty,
            // just mark as invisible.

            el.dirty();
          });
        }
      },

      /**
       * @private
       */
      _doAnimation: function (containerGroup, renderResult, seriesModel, reRoot) {
        if (!seriesModel.get('animation')) {
          return;
        }

        var duration = seriesModel.get('animationDurationUpdate');
        var easing = seriesModel.get('animationEasing');
        var animationWrap = animation.createWrap(); // Make delete animations.

        each$t(renderResult.willDeleteEls, function (store, storageName) {
          each$t(store, function (el, rawIndex) {
            if (el.invisible) {
              return;
            }

            var parent = el.parent; // Always has parent, and parent is nodeGroup.

            var target;

            if (reRoot && reRoot.direction === 'drillDown') {
              target = parent === reRoot.rootNodeGroup // This is the content element of view root.
              // Only `content` will enter this branch, because
              // `background` and `nodeGroup` will not be deleted.
              ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: parent.__tmNodeWidth,
                  height: parent.__tmNodeHeight
                },
                style: {
                  opacity: 0
                } // Others.

              } : {
                style: {
                  opacity: 0
                }
              };
            } else {
              var targetX = 0;
              var targetY = 0;

              if (!parent.__tmWillDelete) {
                // Let node animate to right-bottom corner, cooperating with fadeout,
                // which is appropriate for user understanding.
                // Divided by 2 for reRoot rolling up effect.
                targetX = parent.__tmNodeWidth / 2;
                targetY = parent.__tmNodeHeight / 2;
              }

              target = storageName === 'nodeGroup' ? {
                position: [targetX, targetY],
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: targetX,
                  y: targetY,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }

            target && animationWrap.add(el, target, duration, easing);
          });
        }); // Make other animations

        each$t(this._storage, function (store, storageName) {
          each$t(store, function (el, rawIndex) {
            var last = renderResult.lastsForAnimation[storageName][rawIndex];
            var target = {};

            if (!last) {
              return;
            }

            if (storageName === 'nodeGroup') {
              if (last.old) {
                target.position = el.position.slice();
                el.attr('position', last.old);
              }
            } else {
              if (last.old) {
                target.shape = util.extend({}, el.shape);
                el.setShape(last.old);
              }

              if (last.fadein) {
                el.setStyle('opacity', 0);
                target.style = {
                  opacity: 1
                };
              } // When animation is stopped for succedent animation starting,
              // el.style.opacity might not be 1
              else if (el.style.opacity !== 1) {
                  target.style = {
                    opacity: 1
                  };
                }
            }

            animationWrap.add(el, target, duration, easing);
          });
        }, this);
        this._state = 'animating';
        animationWrap.done(bind$4(function () {
          this._state = 'ready';
          renderResult.renderFinally();
        }, this)).start();
      },

      /**
       * @private
       */
      _resetController: function (api) {
        var controller = this._controller; // Init controller.

        if (!controller) {
          controller = this._controller = new RoamController_1(api.getZr());
          controller.enable(this.seriesModel.get('roam'));
          controller.on('pan', bind$4(this._onPan, this));
          controller.on('zoom', bind$4(this._onZoom, this));
        }

        var rect = new BoundingRect_1(0, 0, api.getWidth(), api.getHeight());
        controller.setPointerChecker(function (e, x, y) {
          return rect.contain(x, y);
        });
      },

      /**
       * @private
       */
      _clearController: function () {
        var controller = this._controller;

        if (controller) {
          controller.dispose();
          controller = null;
        }
      },

      /**
       * @private
       */
      _onPan: function (e) {
        if (this._state !== 'animating' && (Math.abs(e.dx) > DRAG_THRESHOLD || Math.abs(e.dy) > DRAG_THRESHOLD)) {
          // These param must not be cached.
          var root = this.seriesModel.getData().tree.root;

          if (!root) {
            return;
          }

          var rootLayout = root.getLayout();

          if (!rootLayout) {
            return;
          }

          this.api.dispatchAction({
            type: 'treemapMove',
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: {
              x: rootLayout.x + e.dx,
              y: rootLayout.y + e.dy,
              width: rootLayout.width,
              height: rootLayout.height
            }
          });
        }
      },

      /**
       * @private
       */
      _onZoom: function (e) {
        var mouseX = e.originX;
        var mouseY = e.originY;

        if (this._state !== 'animating') {
          // These param must not be cached.
          var root = this.seriesModel.getData().tree.root;

          if (!root) {
            return;
          }

          var rootLayout = root.getLayout();

          if (!rootLayout) {
            return;
          }

          var rect = new BoundingRect_1(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
          var layoutInfo = this.seriesModel.layoutInfo; // Transform mouse coord from global to containerGroup.

          mouseX -= layoutInfo.x;
          mouseY -= layoutInfo.y; // Scale root bounding rect.

          var m = matrix.create();
          matrix.translate(m, m, [-mouseX, -mouseY]);
          matrix.scale(m, m, [e.scale, e.scale]);
          matrix.translate(m, m, [mouseX, mouseY]);
          rect.applyTransform(m);
          this.api.dispatchAction({
            type: 'treemapRender',
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: {
              x: rect.x,
              y: rect.y,
              width: rect.width,
              height: rect.height
            }
          });
        }
      },

      /**
       * @private
       */
      _initEvents: function (containerGroup) {
        containerGroup.on('click', function (e) {
          if (this._state !== 'ready') {
            return;
          }

          var nodeClick = this.seriesModel.get('nodeClick', true);

          if (!nodeClick) {
            return;
          }

          var targetInfo = this.findTarget(e.offsetX, e.offsetY);

          if (!targetInfo) {
            return;
          }

          var node = targetInfo.node;

          if (node.getLayout().isLeafRoot) {
            this._rootToNode(targetInfo);
          } else {
            if (nodeClick === 'zoomToNode') {
              this._zoomToNode(targetInfo);
            } else if (nodeClick === 'link') {
              var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
              var link = itemModel.get('link', true);
              var linkTarget = itemModel.get('target', true) || 'blank';
              link && windowOpen$1(link, linkTarget);
            }
          }
        }, this);
      },

      /**
       * @private
       */
      _renderBreadcrumb: function (seriesModel, api, targetInfo) {
        if (!targetInfo) {
          targetInfo = seriesModel.get('leafDepth', true) != null ? {
            node: seriesModel.getViewRoot() // FIXME
            // better way?
            // Find breadcrumb tail on center of containerGroup.

          } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);

          if (!targetInfo) {
            targetInfo = {
              node: seriesModel.getData().tree.root
            };
          }
        }

        (this._breadcrumb || (this._breadcrumb = new Breadcrumb_1(this.group))).render(seriesModel, api, targetInfo.node, bind$4(onSelect, this));

        function onSelect(node) {
          if (this._state !== 'animating') {
            treeHelper.aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({
              node: node
            }) : this._zoomToNode({
              node: node
            });
          }
        }
      },

      /**
       * @override
       */
      remove: function () {
        this._clearController();

        this._containerGroup && this._containerGroup.removeAll();
        this._storage = createStorage();
        this._state = 'ready';
        this._breadcrumb && this._breadcrumb.remove();
      },
      dispose: function () {
        this._clearController();
      },

      /**
       * @private
       */
      _zoomToNode: function (targetInfo) {
        this.api.dispatchAction({
          type: 'treemapZoomToNode',
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: targetInfo.node
        });
      },

      /**
       * @private
       */
      _rootToNode: function (targetInfo) {
        this.api.dispatchAction({
          type: 'treemapRootToNode',
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: targetInfo.node
        });
      },

      /**
       * @public
       * @param {number} x Global coord x.
       * @param {number} y Global coord y.
       * @return {Object} info If not found, return undefined;
       * @return {number} info.node Target node.
       * @return {number} info.offsetX x refer to target node.
       * @return {number} info.offsetY y refer to target node.
       */
      findTarget: function (x, y) {
        var targetInfo;
        var viewRoot = this.seriesModel.getViewRoot();
        viewRoot.eachNode({
          attr: 'viewChildren',
          order: 'preorder'
        }, function (node) {
          var bgEl = this._storage.background[node.getRawIndex()]; // If invisible, there might be no element.


          if (bgEl) {
            var point = bgEl.transformCoordToLocal(x, y);
            var shape = bgEl.shape; // For performance consideration, dont use 'getBoundingRect'.

            if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
              targetInfo = {
                node: node,
                offsetX: point[0],
                offsetY: point[1]
              };
            } else {
              return false; // Suppress visit subtree.
            }
          }
        }, this);
        return targetInfo;
      }
    });
    /**
     * @inner
     */


    function createStorage() {
      return {
        nodeGroup: [],
        background: [],
        content: []
      };
    }
    /**
     * @inner
     * @return Return undefined means do not travel further.
     */


    function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
      // Whether under viewRoot.
      if (!thisNode) {
        // Deleting nodes will be performed finally. This method just find
        // element from old storage, or create new element, set them to new
        // storage, and set styles.
        return;
      } // -------------------------------------------------------------------
      // Start of closure variables available in "Procedures in renderNode".


      var thisLayout = thisNode.getLayout();
      var data = seriesModel.getData(); // Only for enabling highlight/downplay. Clear firstly.
      // Because some node will not be rendered.

      data.setItemGraphicEl(thisNode.dataIndex, null);

      if (!thisLayout || !thisLayout.isInView) {
        return;
      }

      var thisWidth = thisLayout.width;
      var thisHeight = thisLayout.height;
      var borderWidth = thisLayout.borderWidth;
      var thisInvisible = thisLayout.invisible;
      var thisRawIndex = thisNode.getRawIndex();
      var oldRawIndex = oldNode && oldNode.getRawIndex();
      var thisViewChildren = thisNode.viewChildren;
      var upperHeight = thisLayout.upperHeight;
      var isParent = thisViewChildren && thisViewChildren.length;
      var itemStyleNormalModel = thisNode.getModel('itemStyle');
      var itemStyleEmphasisModel = thisNode.getModel('emphasis.itemStyle'); // End of closure ariables available in "Procedures in renderNode".
      // -----------------------------------------------------------------
      // Node group

      var group = giveGraphic('nodeGroup', Group$3);

      if (!group) {
        return;
      }

      parentGroup.add(group); // x,y are not set when el is above view root.

      group.attr('position', [thisLayout.x || 0, thisLayout.y || 0]);
      group.__tmNodeWidth = thisWidth;
      group.__tmNodeHeight = thisHeight;

      if (thisLayout.isAboveViewRoot) {
        return group;
      }

      var nodeModel = thisNode.getModel(); // Background

      var bg = giveGraphic('background', Rect$1, depth, Z_BG);
      bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight); // No children, render content.

      if (isParent) {
        // Because of the implementation about "traverse" in graphic hover style, we
        // can not set hover listener on the "group" of non-leaf node. Otherwise the
        // hover event from the descendents will be listenered.
        if (graphic.isHighDownDispatcher(group)) {
          graphic.setAsHighDownDispatcher(group, false);
        }

        if (bg) {
          graphic.setAsHighDownDispatcher(bg, true); // Only for enabling highlight/downplay.

          data.setItemGraphicEl(thisNode.dataIndex, bg);
        }
      } else {
        var content = giveGraphic('content', Rect$1, depth, Z_CONTENT);
        content && renderContent(group, content);

        if (bg && graphic.isHighDownDispatcher(bg)) {
          graphic.setAsHighDownDispatcher(bg, false);
        }

        graphic.setAsHighDownDispatcher(group, true); // Only for enabling highlight/downplay.

        data.setItemGraphicEl(thisNode.dataIndex, group);
      }

      return group; // ----------------------------
      // | Procedures in renderNode |
      // ----------------------------

      function renderBackground(group, bg, useUpperLabel) {
        // For tooltip.
        bg.dataIndex = thisNode.dataIndex;
        bg.seriesIndex = seriesModel.seriesIndex;
        bg.setShape({
          x: 0,
          y: 0,
          width: thisWidth,
          height: thisHeight
        });

        if (thisInvisible) {
          // If invisible, do not set visual, otherwise the element will
          // change immediately before animation. We think it is OK to
          // remain its origin color when moving out of the view window.
          processInvisible(bg);
        } else {
          bg.invisible = false;
          var visualBorderColor = thisNode.getVisual('borderColor', true);
          var emphasisBorderColor = itemStyleEmphasisModel.get('borderColor');
          var normalStyle = getItemStyleNormal(itemStyleNormalModel);
          normalStyle.fill = visualBorderColor;
          var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);
          emphasisStyle.fill = emphasisBorderColor;

          if (useUpperLabel) {
            var upperLabelWidth = thisWidth - 2 * borderWidth;
            prepareText(normalStyle, emphasisStyle, visualBorderColor, upperLabelWidth, upperHeight, {
              x: borderWidth,
              y: 0,
              width: upperLabelWidth,
              height: upperHeight
            });
          } // For old bg.
          else {
              normalStyle.text = emphasisStyle.text = null;
            }

          bg.setStyle(normalStyle);
          graphic.setElementHoverStyle(bg, emphasisStyle);
        }

        group.add(bg);
      }

      function renderContent(group, content) {
        // For tooltip.
        content.dataIndex = thisNode.dataIndex;
        content.seriesIndex = seriesModel.seriesIndex;
        var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
        var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
        content.culling = true;
        content.setShape({
          x: borderWidth,
          y: borderWidth,
          width: contentWidth,
          height: contentHeight
        });

        if (thisInvisible) {
          // If invisible, do not set visual, otherwise the element will
          // change immediately before animation. We think it is OK to
          // remain its origin color when moving out of the view window.
          processInvisible(content);
        } else {
          content.invisible = false;
          var visualColor = thisNode.getVisual('color', true);
          var normalStyle = getItemStyleNormal(itemStyleNormalModel);
          normalStyle.fill = visualColor;
          var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);
          prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight);
          content.setStyle(normalStyle);
          graphic.setElementHoverStyle(content, emphasisStyle);
        }

        group.add(content);
      }

      function processInvisible(element) {
        // Delay invisible setting utill animation finished,
        // avoid element vanish suddenly before animation.
        !element.invisible && willInvisibleEls.push(element);
      }

      function prepareText(normalStyle, emphasisStyle, visualColor, width, height, upperLabelRect) {
        var defaultText = nodeModel.get('name');
        var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
        var emphasisLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_EMPHASIS : PATH_LABEL_EMPHASIS);
        var isShow = normalLabelModel.getShallow('show');
        graphic.setLabelStyle(normalStyle, emphasisStyle, normalLabelModel, emphasisLabelModel, {
          defaultText: isShow ? defaultText : null,
          autoColor: visualColor,
          isRectText: true,
          labelFetcher: seriesModel,
          labelDataIndex: thisNode.dataIndex,
          labelProp: upperLabelRect ? 'upperLabel' : 'label'
        });
        addDrillDownIcon(normalStyle, upperLabelRect, thisLayout);
        addDrillDownIcon(emphasisStyle, upperLabelRect, thisLayout);
        upperLabelRect && (normalStyle.textRect = util.clone(upperLabelRect));
        normalStyle.truncate = isShow && normalLabelModel.get('ellipsis') ? {
          outerWidth: width,
          outerHeight: height,
          minChar: 2
        } : null;
      }

      function addDrillDownIcon(style, upperLabelRect, thisLayout) {
        var text = style.text;

        if (!upperLabelRect && thisLayout.isLeafRoot && text != null) {
          var iconChar = seriesModel.get('drillDownIcon', true);
          style.text = iconChar ? iconChar + ' ' + text : text;
        }
      }

      function giveGraphic(storageName, Ctor, depth, z) {
        var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
        var lasts = lastsForAnimation[storageName];

        if (element) {
          // Remove from oldStorage
          oldStorage[storageName][oldRawIndex] = null;
          prepareAnimationWhenHasOld(lasts, element, storageName);
        } // If invisible and no old element, do not create new element (for optimizing).
        else if (!thisInvisible) {
            element = new Ctor({
              z: calculateZ(depth, z)
            });
            element.__tmDepth = depth;
            element.__tmStorageName = storageName;
            prepareAnimationWhenNoOld(lasts, element, storageName);
          } // Set to thisStorage


        return thisStorage[storageName][thisRawIndex] = element;
      }

      function prepareAnimationWhenHasOld(lasts, element, storageName) {
        var lastCfg = lasts[thisRawIndex] = {};
        lastCfg.old = storageName === 'nodeGroup' ? element.position.slice() : util.extend({}, element.shape);
      } // If a element is new, we need to find the animation start point carefully,
      // otherwise it will looks strange when 'zoomToNode'.


      function prepareAnimationWhenNoOld(lasts, element, storageName) {
        var lastCfg = lasts[thisRawIndex] = {};
        var parentNode = thisNode.parentNode;

        if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {
          var parentOldX = 0;
          var parentOldY = 0; // New nodes appear from right-bottom corner in 'zoomToNode' animation.
          // For convenience, get old bounding rect from background.

          var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];

          if (!reRoot && parentOldBg && parentOldBg.old) {
            parentOldX = parentOldBg.old.width;
            parentOldY = parentOldBg.old.height;
          } // When no parent old shape found, its parent is new too,
          // so we can just use {x:0, y:0}.


          lastCfg.old = storageName === 'nodeGroup' ? [0, parentOldY] : {
            x: parentOldX,
            y: parentOldY,
            width: 0,
            height: 0
          };
        } // Fade in, user can be aware that these nodes are new.


        lastCfg.fadein = storageName !== 'nodeGroup';
      }
    } // We can not set all backgroud with the same z, Because the behaviour of
    // drill down and roll up differ background creation sequence from tree
    // hierarchy sequence, which cause that lowser background element overlap
    // upper ones. So we calculate z based on depth.
    // Moreover, we try to shrink down z interval to [0, 1] to avoid that
    // treemap with large z overlaps other components.


    function calculateZ(depth, zInLevel) {
      var zb = depth * Z_BASE + zInLevel;
      return (zb - 1) / zb;
    }

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @file Treemap action
     */
    var noop$3 = function () {};

    var actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove'];

    for (var i$1 = 0; i$1 < actionTypes.length; i$1++) {
      echarts.registerAction({
        type: actionTypes[i$1],
        update: 'updateView'
      }, noop$3);
    }

    echarts.registerAction({
      type: 'treemapRootToNode',
      update: 'updateView'
    }, function (payload, ecModel) {
      ecModel.eachComponent({
        mainType: 'series',
        subType: 'treemap',
        query: payload
      }, handleRootToNode);

      function handleRootToNode(model, index) {
        var types = ['treemapZoomToNode', 'treemapRootToNode'];
        var targetInfo = treeHelper.retrieveTargetInfo(payload, types, model);

        if (targetInfo) {
          var originViewRoot = model.getViewRoot();

          if (originViewRoot) {
            payload.direction = treeHelper.aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';
          }

          model.resetViewRoot(targetInfo.node);
        }
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var linearMap$3 = number.linearMap;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var each$u = util.each;
    var isObject$f = util.isObject;
    var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
    /**
     * @param {Object} option
     * @param {string} [option.type] See visualHandlers.
     * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'
     * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],
     *                                              required when mappingMethod is 'linear'
     * @param {Array.<Object>=} [option.pieceList] [
     *                                             {value: someValue},
     *                                             {interval: [min1, max1], visual: {...}},
     *                                             {interval: [min2, max2]}
     *                                             ],
     *                                            required when mappingMethod is 'piecewise'.
     *                                            Visual for only each piece can be specified.
     * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']
     *                                            required when mappingMethod is 'category'.
     *                                            If no option.categories, categories is set
     *                                            as [0, 1, 2, ...].
     * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.
     * @param {(Array|Object|*)} [option.visual]  Visual data.
     *                                            when mappingMethod is 'category',
     *                                            visual data can be array or object
     *                                            (like: {cate1: '#222', none: '#fff'})
     *                                            or primary types (which represents
     *                                            defualt category visual), otherwise visual
     *                                            can be array or primary (which will be
     *                                            normalized to array).
     *
     */

    var VisualMapping = function (option) {
      var mappingMethod = option.mappingMethod;
      var visualType = option.type;
      /**
       * @readOnly
       * @type {Object}
       */

      var thisOption = this.option = util.clone(option);
      /**
       * @readOnly
       * @type {string}
       */

      this.type = visualType;
      /**
       * @readOnly
       * @type {string}
       */

      this.mappingMethod = mappingMethod;
      /**
       * @private
       * @type {Function}
       */

      this._normalizeData = normalizers[mappingMethod];
      var visualHandler = visualHandlers[visualType];
      /**
       * @public
       * @type {Function}
       */

      this.applyVisual = visualHandler.applyVisual;
      /**
       * @public
       * @type {Function}
       */

      this.getColorMapper = visualHandler.getColorMapper;
      /**
       * @private
       * @type {Function}
       */

      this._doMap = visualHandler._doMap[mappingMethod];

      if (mappingMethod === 'piecewise') {
        normalizeVisualRange(thisOption);
        preprocessForPiecewise(thisOption);
      } else if (mappingMethod === 'category') {
        thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,
        // which need no more preprocess except normalize visual.
        : normalizeVisualRange(thisOption, true);
      } else {
        // mappingMethod === 'linear' or 'fixed'
        util.assert(mappingMethod !== 'linear' || thisOption.dataExtent);
        normalizeVisualRange(thisOption);
      }
    };

    VisualMapping.prototype = {
      constructor: VisualMapping,
      mapValueToVisual: function (value) {
        var normalized = this._normalizeData(value);

        return this._doMap(normalized, value);
      },
      getNormalizer: function () {
        return util.bind(this._normalizeData, this);
      }
    };
    var visualHandlers = VisualMapping.visualHandlers = {
      color: {
        applyVisual: makeApplyVisual('color'),

        /**
         * Create a mapper function
         * @return {Function}
         */
        getColorMapper: function () {
          var thisOption = this.option;
          return util.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {
            !isNormalized && (value = this._normalizeData(value));
            return doMapCategory.call(this, value);
          } : function (value, isNormalized, out) {
            // If output rgb array
            // which will be much faster and useful in pixel manipulation
            var returnRGBArray = !!out;
            !isNormalized && (value = this._normalizeData(value));
            out = color.fastLerp(value, thisOption.parsedVisual, out);
            return returnRGBArray ? out : color.stringify(out, 'rgba');
          }, this);
        },
        _doMap: {
          linear: function (normalized) {
            return color.stringify(color.fastLerp(normalized, this.option.parsedVisual), 'rgba');
          },
          category: doMapCategory,
          piecewise: function (normalized, value) {
            var result = getSpecifiedVisual.call(this, value);

            if (result == null) {
              result = color.stringify(color.fastLerp(normalized, this.option.parsedVisual), 'rgba');
            }

            return result;
          },
          fixed: doMapFixed
        }
      },
      colorHue: makePartialColorVisualHandler(function (color$1, value) {
        return color.modifyHSL(color$1, value);
      }),
      colorSaturation: makePartialColorVisualHandler(function (color$1, value) {
        return color.modifyHSL(color$1, null, value);
      }),
      colorLightness: makePartialColorVisualHandler(function (color$1, value) {
        return color.modifyHSL(color$1, null, null, value);
      }),
      colorAlpha: makePartialColorVisualHandler(function (color$1, value) {
        return color.modifyAlpha(color$1, value);
      }),
      opacity: {
        applyVisual: makeApplyVisual('opacity'),
        _doMap: makeDoMap([0, 1])
      },
      liftZ: {
        applyVisual: makeApplyVisual('liftZ'),
        _doMap: {
          linear: doMapFixed,
          category: doMapFixed,
          piecewise: doMapFixed,
          fixed: doMapFixed
        }
      },
      symbol: {
        applyVisual: function (value, getter, setter) {
          var symbolCfg = this.mapValueToVisual(value);

          if (util.isString(symbolCfg)) {
            setter('symbol', symbolCfg);
          } else if (isObject$f(symbolCfg)) {
            for (var name in symbolCfg) {
              if (symbolCfg.hasOwnProperty(name)) {
                setter(name, symbolCfg[name]);
              }
            }
          }
        },
        _doMap: {
          linear: doMapToArray,
          category: doMapCategory,
          piecewise: function (normalized, value) {
            var result = getSpecifiedVisual.call(this, value);

            if (result == null) {
              result = doMapToArray.call(this, normalized);
            }

            return result;
          },
          fixed: doMapFixed
        }
      },
      symbolSize: {
        applyVisual: makeApplyVisual('symbolSize'),
        _doMap: makeDoMap([0, 1])
      }
    };

    function preprocessForPiecewise(thisOption) {
      var pieceList = thisOption.pieceList;
      thisOption.hasSpecialVisual = false;
      util.each(pieceList, function (piece, index) {
        piece.originIndex = index; // piece.visual is "result visual value" but not
        // a visual range, so it does not need to be normalized.

        if (piece.visual != null) {
          thisOption.hasSpecialVisual = true;
        }
      });
    }

    function preprocessForSpecifiedCategory(thisOption) {
      // Hash categories.
      var categories = thisOption.categories;
      var visual = thisOption.visual;
      var categoryMap = thisOption.categoryMap = {};
      each$u(categories, function (cate, index) {
        categoryMap[cate] = index;
      }); // Process visual map input.

      if (!util.isArray(visual)) {
        var visualArr = [];

        if (util.isObject(visual)) {
          each$u(visual, function (v, cate) {
            var index = categoryMap[cate];
            visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
          });
        } else {
          // Is primary type, represents default visual.
          visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
        }

        visual = setVisualToOption(thisOption, visualArr);
      } // Remove categories that has no visual,
      // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.


      for (var i = categories.length - 1; i >= 0; i--) {
        if (visual[i] == null) {
          delete categoryMap[categories[i]];
          categories.pop();
        }
      }
    }

    function normalizeVisualRange(thisOption, isCategory) {
      var visual = thisOption.visual;
      var visualArr = [];

      if (util.isObject(visual)) {
        each$u(visual, function (v) {
          visualArr.push(v);
        });
      } else if (visual != null) {
        visualArr.push(visual);
      }

      var doNotNeedPair = {
        color: 1,
        symbol: 1
      };

      if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
        // Do not care visualArr.length === 0, which is illegal.
        visualArr[1] = visualArr[0];
      }

      setVisualToOption(thisOption, visualArr);
    }

    function makePartialColorVisualHandler(applyValue) {
      return {
        applyVisual: function (value, getter, setter) {
          value = this.mapValueToVisual(value); // Must not be array value

          setter('color', applyValue(getter('color'), value));
        },
        _doMap: makeDoMap([0, 1])
      };
    }

    function doMapToArray(normalized) {
      var visual = this.option.visual;
      return visual[Math.round(linearMap$3(normalized, [0, 1], [0, visual.length - 1], true))] || {};
    }

    function makeApplyVisual(visualType) {
      return function (value, getter, setter) {
        setter(visualType, this.mapValueToVisual(value));
      };
    }

    function doMapCategory(normalized) {
      var visual = this.option.visual;
      return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
    }

    function doMapFixed() {
      return this.option.visual[0];
    }

    function makeDoMap(sourceExtent) {
      return {
        linear: function (normalized) {
          return linearMap$3(normalized, sourceExtent, this.option.visual, true);
        },
        category: doMapCategory,
        piecewise: function (normalized, value) {
          var result = getSpecifiedVisual.call(this, value);

          if (result == null) {
            result = linearMap$3(normalized, sourceExtent, this.option.visual, true);
          }

          return result;
        },
        fixed: doMapFixed
      };
    }

    function getSpecifiedVisual(value) {
      var thisOption = this.option;
      var pieceList = thisOption.pieceList;

      if (thisOption.hasSpecialVisual) {
        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
        var piece = pieceList[pieceIndex];

        if (piece && piece.visual) {
          return piece.visual[this.type];
        }
      }
    }

    function setVisualToOption(thisOption, visualArr) {
      thisOption.visual = visualArr;

      if (thisOption.type === 'color') {
        thisOption.parsedVisual = util.map(visualArr, function (item) {
          return color.parse(item);
        });
      }

      return visualArr;
    }
    /**
     * Normalizers by mapping methods.
     */


    var normalizers = {
      linear: function (value) {
        return linearMap$3(value, this.option.dataExtent, [0, 1], true);
      },
      piecewise: function (value) {
        var pieceList = this.option.pieceList;
        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);

        if (pieceIndex != null) {
          return linearMap$3(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
        }
      },
      category: function (value) {
        var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal

        return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
      },
      fixed: util.noop
    };
    /**
     * List available visual types.
     *
     * @public
     * @return {Array.<string>}
     */

    VisualMapping.listVisualTypes = function () {
      var visualTypes = [];
      util.each(visualHandlers, function (handler, key) {
        visualTypes.push(key);
      });
      return visualTypes;
    };
    /**
     * @public
     */


    VisualMapping.addVisualHandler = function (name, handler) {
      visualHandlers[name] = handler;
    };
    /**
     * @public
     */


    VisualMapping.isValidType = function (visualType) {
      return visualHandlers.hasOwnProperty(visualType);
    };
    /**
     * Convinent method.
     * Visual can be Object or Array or primary type.
     *
     * @public
     */


    VisualMapping.eachVisual = function (visual, callback, context) {
      if (util.isObject(visual)) {
        util.each(visual, callback, context);
      } else {
        callback.call(context, visual);
      }
    };

    VisualMapping.mapVisual = function (visual, callback, context) {
      var isPrimary;
      var newVisual = util.isArray(visual) ? [] : util.isObject(visual) ? {} : (isPrimary = true, null);
      VisualMapping.eachVisual(visual, function (v, key) {
        var newVal = callback.call(context, v, key);
        isPrimary ? newVisual = newVal : newVisual[key] = newVal;
      });
      return newVisual;
    };
    /**
     * @public
     * @param {Object} obj
     * @return {Object} new object containers visual values.
     *                 If no visuals, return null.
     */


    VisualMapping.retrieveVisuals = function (obj) {
      var ret = {};
      var hasVisual;
      obj && each$u(visualHandlers, function (h, visualType) {
        if (obj.hasOwnProperty(visualType)) {
          ret[visualType] = obj[visualType];
          hasVisual = true;
        }
      });
      return hasVisual ? ret : null;
    };
    /**
     * Give order to visual types, considering colorSaturation, colorAlpha depends on color.
     *
     * @public
     * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}
     *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']
     * @return {Array.<string>} Sorted visual types.
     */


    VisualMapping.prepareVisualTypes = function (visualTypes) {
      if (isObject$f(visualTypes)) {
        var types = [];
        each$u(visualTypes, function (item, type) {
          types.push(type);
        });
        visualTypes = types;
      } else if (util.isArray(visualTypes)) {
        visualTypes = visualTypes.slice();
      } else {
        return [];
      }

      visualTypes.sort(function (type1, type2) {
        // color should be front of colorSaturation, colorAlpha, ...
        // symbol and symbolSize do not matter.
        return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;
      });
      return visualTypes;
    };
    /**
     * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.
     * Other visuals are only depends on themself.
     *
     * @public
     * @param {string} visualType1
     * @param {string} visualType2
     * @return {boolean}
     */


    VisualMapping.dependsOn = function (visualType1, visualType2) {
      return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
    };
    /**
     * @param {number} value
     * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]
     *                         Always from small to big.
     * @param {boolean} [findClosestWhenOutside=false]
     * @return {number} index
     */


    VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {
      var possibleI;
      var abs = Infinity; // value has the higher priority.

      for (var i = 0, len = pieceList.length; i < len; i++) {
        var pieceValue = pieceList[i].value;

        if (pieceValue != null) {
          if (pieceValue === value // FIXME
          // It is supposed to compare value according to value type of dimension,
          // but currently value type can exactly be string or number.
          // Compromise for numeric-like string (like '12'), especially
          // in the case that visualMap.categories is ['22', '33'].
          || typeof pieceValue === 'string' && pieceValue === value + '') {
            return i;
          }

          findClosestWhenOutside && updatePossible(pieceValue, i);
        }
      }

      for (var i = 0, len = pieceList.length; i < len; i++) {
        var piece = pieceList[i];
        var interval = piece.interval;
        var close = piece.close;

        if (interval) {
          if (interval[0] === -Infinity) {
            if (littleThan(close[1], value, interval[1])) {
              return i;
            }
          } else if (interval[1] === Infinity) {
            if (littleThan(close[0], interval[0], value)) {
              return i;
            }
          } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {
            return i;
          }

          findClosestWhenOutside && updatePossible(interval[0], i);
          findClosestWhenOutside && updatePossible(interval[1], i);
        }
      }

      if (findClosestWhenOutside) {
        return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
      }

      function updatePossible(val, index) {
        var newAbs = Math.abs(val - value);

        if (newAbs < abs) {
          abs = newAbs;
          possibleI = index;
        }
      }
    };

    function littleThan(close, a, b) {
      return close ? a <= b : a < b;
    }

    var _default$2d = VisualMapping;
    var VisualMapping_1 = _default$2d;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var isArray$9 = util.isArray;
    var ITEM_STYLE_NORMAL = 'itemStyle';
    var _default$2e = {
      seriesType: 'treemap',
      reset: function (seriesModel, ecModel, api, payload) {
        var tree = seriesModel.getData().tree;
        var root = tree.root;
        var seriesItemStyleModel = seriesModel.getModel(ITEM_STYLE_NORMAL);

        if (root.isRemoved()) {
          return;
        }

        var levelItemStyles = util.map(tree.levelModels, function (levelModel) {
          return levelModel ? levelModel.get(ITEM_STYLE_NORMAL) : null;
        });
        travelTree(root, // Visual should calculate from tree root but not view root.
        {}, levelItemStyles, seriesItemStyleModel, seriesModel.getViewRoot().getAncestors(), seriesModel);
      }
    };

    function travelTree(node, designatedVisual, levelItemStyles, seriesItemStyleModel, viewRootAncestors, seriesModel) {
      var nodeModel = node.getModel();
      var nodeLayout = node.getLayout(); // Optimize

      if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
        return;
      }

      var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);
      var levelItemStyle = levelItemStyles[node.depth];
      var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel); // calculate border color

      var borderColor = nodeItemStyleModel.get('borderColor');
      var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');
      var thisNodeColor;

      if (borderColorSaturation != null) {
        // For performance, do not always execute 'calculateColor'.
        thisNodeColor = calculateColor(visuals);
        borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
      }

      node.setVisual('borderColor', borderColor);
      var viewChildren = node.viewChildren;

      if (!viewChildren || !viewChildren.length) {
        thisNodeColor = calculateColor(visuals); // Apply visual to this node.

        node.setVisual('color', thisNodeColor);
      } else {
        var mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren); // Designate visual to children.

        util.each(viewChildren, function (child, index) {
          // If higher than viewRoot, only ancestors of viewRoot is needed to visit.
          if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
            var childVisual = mapVisual(nodeModel, visuals, child, index, mapping, seriesModel);
            travelTree(child, childVisual, levelItemStyles, seriesItemStyleModel, viewRootAncestors, seriesModel);
          }
        });
      }
    }

    function buildVisuals(nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel) {
      var visuals = util.extend({}, designatedVisual);
      util.each(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {
        // Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel
        var val = nodeItemStyleModel.get(visualName, true); // Ignore parent

        val == null && levelItemStyle && (val = levelItemStyle[visualName]);
        val == null && (val = designatedVisual[visualName]);
        val == null && (val = seriesItemStyleModel.get(visualName));
        val != null && (visuals[visualName] = val);
      });
      return visuals;
    }

    function calculateColor(visuals) {
      var color$1 = getValueVisualDefine(visuals, 'color');

      if (color$1) {
        var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');
        var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');

        if (colorSaturation) {
          color$1 = color.modifyHSL(color$1, null, null, colorSaturation);
        }

        if (colorAlpha) {
          color$1 = color.modifyAlpha(color$1, colorAlpha);
        }

        return color$1;
      }
    }

    function calculateBorderColor(borderColorSaturation, thisNodeColor) {
      return thisNodeColor != null ? color.modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
    }

    function getValueVisualDefine(visuals, name) {
      var value = visuals[name];

      if (value != null && value !== 'none') {
        return value;
      }
    }

    function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
      if (!viewChildren || !viewChildren.length) {
        return;
      }

      var rangeVisual = getRangeVisual(nodeModel, 'color') || visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation'));

      if (!rangeVisual) {
        return;
      }

      var visualMin = nodeModel.get('visualMin');
      var visualMax = nodeModel.get('visualMax');
      var dataExtent = nodeLayout.dataExtent.slice();
      visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
      visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
      var colorMappingBy = nodeModel.get('colorMappingBy');
      var opt = {
        type: rangeVisual.name,
        dataExtent: dataExtent,
        visual: rangeVisual.range
      };

      if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {
        opt.mappingMethod = 'category';
        opt.loop = true; // categories is ordinal, so do not set opt.categories.
      } else {
        opt.mappingMethod = 'linear';
      }

      var mapping = new VisualMapping_1(opt);
      mapping.__drColorMappingBy = colorMappingBy;
      return mapping;
    } // Notice: If we dont have the attribute 'colorRange', but only use
    // attribute 'color' to represent both concepts of 'colorRange' and 'color',
    // (It means 'colorRange' when 'color' is Array, means 'color' when not array),
    // this problem will be encountered:
    // If a level-1 node dont have children, and its siblings has children,
    // and colorRange is set on level-1, then the node can not be colored.
    // So we separate 'colorRange' and 'color' to different attributes.


    function getRangeVisual(nodeModel, name) {
      // 'colorRange', 'colorARange', 'colorSRange'.
      // If not exsits on this node, fetch from levels and series.
      var range = nodeModel.get(name);
      return isArray$9(range) && range.length ? {
        name: name,
        range: range
      } : null;
    }

    function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
      var childVisuals = util.extend({}, visuals);

      if (mapping) {
        var mappingType = mapping.type;
        var colorMappingBy = mappingType === 'color' && mapping.__drColorMappingBy;
        var value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'));
        childVisuals[mappingType] = mapping.mapValueToVisual(value);
      }

      return childVisuals;
    }

    var treemapVisual = _default$2e;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var parsePercent$8 = number.parsePercent;
    var MAX_SAFE_INTEGER$1 = number.MAX_SAFE_INTEGER;





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /*
    * A third-party license is embeded for some of the code in this file:
    * The treemap layout implementation was originally copied from
    * "d3.js" with some modifications made for this project.
    * (See more details in the comment of the method "squarify" below.)
    * The use of the source code of this file is also subject to the terms
    * and consitions of the license of "d3.js" (BSD-3Clause, see
    * </licenses/LICENSE-d3>).
    */
    var mathMax$5 = Math.max;
    var mathMin$5 = Math.min;
    var retrieveValue = util.retrieve;
    var each$v = util.each;
    var PATH_BORDER_WIDTH = ['itemStyle', 'borderWidth'];
    var PATH_GAP_WIDTH = ['itemStyle', 'gapWidth'];
    var PATH_UPPER_LABEL_SHOW = ['upperLabel', 'show'];
    var PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'height'];
    /**
     * @public
     */

    var _default$2f = {
      seriesType: 'treemap',
      reset: function (seriesModel, ecModel, api, payload) {
        // Layout result in each node:
        // {x, y, width, height, area, borderWidth}
        var ecWidth = api.getWidth();
        var ecHeight = api.getHeight();
        var seriesOption = seriesModel.option;
        var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
        var size = seriesOption.size || []; // Compatible with ec2.

        var containerWidth = parsePercent$8(retrieveValue(layoutInfo.width, size[0]), ecWidth);
        var containerHeight = parsePercent$8(retrieveValue(layoutInfo.height, size[1]), ecHeight); // Fetch payload info.

        var payloadType = payload && payload.type;
        var types = ['treemapZoomToNode', 'treemapRootToNode'];
        var targetInfo = treeHelper.retrieveTargetInfo(payload, types, seriesModel);
        var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;
        var viewRoot = seriesModel.getViewRoot();
        var viewAbovePath = treeHelper.getPathToRoot(viewRoot);

        if (payloadType !== 'treemapMove') {
          var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
          var sort = seriesOption.sort;

          if (sort && sort !== 'asc' && sort !== 'desc') {
            sort = 'desc';
          }

          var options = {
            squareRatio: seriesOption.squareRatio,
            sort: sort,
            leafDepth: seriesOption.leafDepth
          }; // layout should be cleared because using updateView but not update.

          viewRoot.hostTree.clearLayouts(); // TODO
          // optimize: if out of view clip, do not layout.
          // But take care that if do not render node out of view clip,
          // how to calculate start po

          var viewRootLayout = {
            x: 0,
            y: 0,
            width: rootSize[0],
            height: rootSize[1],
            area: rootSize[0] * rootSize[1]
          };
          viewRoot.setLayout(viewRootLayout);
          squarify(viewRoot, options, false, 0); // Supplement layout.

          var viewRootLayout = viewRoot.getLayout();
          each$v(viewAbovePath, function (node, index) {
            var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
            node.setLayout(util.extend({
              dataExtent: [childValue, childValue],
              borderWidth: 0,
              upperHeight: 0
            }, viewRootLayout));
          });
        }

        var treeRoot = seriesModel.getData().tree.root;
        treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
        seriesModel.setLayoutInfo(layoutInfo); // FIXME
        // 现在没有clip功能，暂时取ec高宽。

        prunning(treeRoot, // Transform to base element coordinate system.
        new BoundingRect_1(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);
      }
    };
    /**
     * Layout treemap with squarify algorithm.
     * The original presentation of this algorithm
     * was made by Mark Bruls, Kees Huizing, and Jarke J. van Wijk
     * <https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf>.
     * The implementation of this algorithm was originally copied from "d3.js"
     * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/layout/treemap.js>
     * with some modifications made for this program.
     * See the license statement at the head of this file.
     *
     * @protected
     * @param {module:echarts/data/Tree~TreeNode} node
     * @param {Object} options
     * @param {string} options.sort 'asc' or 'desc'
     * @param {number} options.squareRatio
     * @param {boolean} hideChildren
     * @param {number} depth
     */

    function squarify(node, options, hideChildren, depth) {
      var width;
      var height;

      if (node.isRemoved()) {
        return;
      }

      var thisLayout = node.getLayout();
      width = thisLayout.width;
      height = thisLayout.height; // Considering border and gap

      var nodeModel = node.getModel();
      var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
      var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
      var upperLabelHeight = getUpperLabelHeight(nodeModel);
      var upperHeight = Math.max(borderWidth, upperLabelHeight);
      var layoutOffset = borderWidth - halfGapWidth;
      var layoutOffsetUpper = upperHeight - halfGapWidth;
      var nodeModel = node.getModel();
      node.setLayout({
        borderWidth: borderWidth,
        upperHeight: upperHeight,
        upperLabelHeight: upperLabelHeight
      }, true);
      width = mathMax$5(width - 2 * layoutOffset, 0);
      height = mathMax$5(height - layoutOffset - layoutOffsetUpper, 0);
      var totalArea = width * height;
      var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);

      if (!viewChildren.length) {
        return;
      }

      var rect = {
        x: layoutOffset,
        y: layoutOffsetUpper,
        width: width,
        height: height
      };
      var rowFixedLength = mathMin$5(width, height);
      var best = Infinity; // the best row score so far

      var row = [];
      row.area = 0;

      for (var i = 0, len = viewChildren.length; i < len;) {
        var child = viewChildren[i];
        row.push(child);
        row.area += child.getLayout().area;
        var score = worst(row, rowFixedLength, options.squareRatio); // continue with this orientation

        if (score <= best) {
          i++;
          best = score;
        } // abort, and try a different orientation
        else {
            row.area -= row.pop().getLayout().area;
            position(row, rowFixedLength, rect, halfGapWidth, false);
            rowFixedLength = mathMin$5(rect.width, rect.height);
            row.length = row.area = 0;
            best = Infinity;
          }
      }

      if (row.length) {
        position(row, rowFixedLength, rect, halfGapWidth, true);
      }

      if (!hideChildren) {
        var childrenVisibleMin = nodeModel.get('childrenVisibleMin');

        if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
          hideChildren = true;
        }
      }

      for (var i = 0, len = viewChildren.length; i < len; i++) {
        squarify(viewChildren[i], options, hideChildren, depth + 1);
      }
    }
    /**
     * Set area to each child, and calculate data extent for visual coding.
     */


    function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
      var viewChildren = node.children || [];
      var orderBy = options.sort;
      orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);
      var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth; // leafDepth has higher priority.

      if (hideChildren && !overLeafDepth) {
        return node.viewChildren = [];
      } // Sort children, order by desc.


      viewChildren = util.filter(viewChildren, function (child) {
        return !child.isRemoved();
      });
      sort$1(viewChildren, orderBy);
      var info = statistic(nodeModel, viewChildren, orderBy);

      if (info.sum === 0) {
        return node.viewChildren = [];
      }

      info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);

      if (info.sum === 0) {
        return node.viewChildren = [];
      } // Set area to each child.


      for (var i = 0, len = viewChildren.length; i < len; i++) {
        var area = viewChildren[i].getValue() / info.sum * totalArea; // Do not use setLayout({...}, true), because it is needed to clear last layout.

        viewChildren[i].setLayout({
          area: area
        });
      }

      if (overLeafDepth) {
        viewChildren.length && node.setLayout({
          isLeafRoot: true
        }, true);
        viewChildren.length = 0;
      }

      node.viewChildren = viewChildren;
      node.setLayout({
        dataExtent: info.dataExtent
      }, true);
      return viewChildren;
    }
    /**
     * Consider 'visibleMin'. Modify viewChildren and get new sum.
     */


    function filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {
      // visibleMin is not supported yet when no option.sort.
      if (!orderBy) {
        return sum;
      }

      var visibleMin = nodeModel.get('visibleMin');
      var len = orderedChildren.length;
      var deletePoint = len; // Always travel from little value to big value.

      for (var i = len - 1; i >= 0; i--) {
        var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();

        if (value / sum * totalArea < visibleMin) {
          deletePoint = i;
          sum -= value;
        }
      }

      orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);
      return sum;
    }
    /**
     * Sort
     */


    function sort$1(viewChildren, orderBy) {
      if (orderBy) {
        viewChildren.sort(function (a, b) {
          var diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
          return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;
        });
      }

      return viewChildren;
    }
    /**
     * Statistic
     */


    function statistic(nodeModel, children, orderBy) {
      // Calculate sum.
      var sum = 0;

      for (var i = 0, len = children.length; i < len; i++) {
        sum += children[i].getValue();
      } // Statistic data extent for latter visual coding.
      // Notice: data extent should be calculate based on raw children
      // but not filtered view children, otherwise visual mapping will not
      // be stable when zoom (where children is filtered by visibleMin).


      var dimension = nodeModel.get('visualDimension');
      var dataExtent; // The same as area dimension.

      if (!children || !children.length) {
        dataExtent = [NaN, NaN];
      } else if (dimension === 'value' && orderBy) {
        dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
        orderBy === 'asc' && dataExtent.reverse();
      } // Other dimension.
      else {
          var dataExtent = [Infinity, -Infinity];
          each$v(children, function (child) {
            var value = child.getValue(dimension);
            value < dataExtent[0] && (dataExtent[0] = value);
            value > dataExtent[1] && (dataExtent[1] = value);
          });
        }

      return {
        sum: sum,
        dataExtent: dataExtent
      };
    }
    /**
     * Computes the score for the specified row,
     * as the worst aspect ratio.
     */


    function worst(row, rowFixedLength, ratio) {
      var areaMax = 0;
      var areaMin = Infinity;

      for (var i = 0, area, len = row.length; i < len; i++) {
        area = row[i].getLayout().area;

        if (area) {
          area < areaMin && (areaMin = area);
          area > areaMax && (areaMax = area);
        }
      }

      var squareArea = row.area * row.area;
      var f = rowFixedLength * rowFixedLength * ratio;
      return squareArea ? mathMax$5(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
    }
    /**
     * Positions the specified row of nodes. Modifies `rect`.
     */


    function position(row, rowFixedLength, rect, halfGapWidth, flush) {
      // When rowFixedLength === rect.width,
      // it is horizontal subdivision,
      // rowFixedLength is the width of the subdivision,
      // rowOtherLength is the height of the subdivision,
      // and nodes will be positioned from left to right.
      // wh[idx0WhenH] means: when horizontal,
      //      wh[idx0WhenH] => wh[0] => 'width'.
      //      xy[idx1WhenH] => xy[1] => 'y'.
      var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
      var idx1WhenH = 1 - idx0WhenH;
      var xy = ['x', 'y'];
      var wh = ['width', 'height'];
      var last = rect[xy[idx0WhenH]];
      var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;

      if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
        rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow
      }

      for (var i = 0, rowLen = row.length; i < rowLen; i++) {
        var node = row[i];
        var nodeLayout = {};
        var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
        var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax$5(rowOtherLength - 2 * halfGapWidth, 0); // We use Math.max/min to avoid negative width/height when considering gap width.

        var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
        var modWH = i === rowLen - 1 || remain < step ? remain : step;
        var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax$5(modWH - 2 * halfGapWidth, 0);
        nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin$5(halfGapWidth, wh1 / 2);
        nodeLayout[xy[idx0WhenH]] = last + mathMin$5(halfGapWidth, wh0 / 2);
        last += modWH;
        node.setLayout(nodeLayout, true);
      }

      rect[xy[idx1WhenH]] += rowOtherLength;
      rect[wh[idx1WhenH]] -= rowOtherLength;
    } // Return [containerWidth, containerHeight] as defualt.


    function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
      // If targetInfo.node exists, we zoom to the node,
      // so estimate whold width and heigth by target node.
      var currNode = (targetInfo || {}).node;
      var defaultSize = [containerWidth, containerHeight];

      if (!currNode || currNode === viewRoot) {
        return defaultSize;
      }

      var parent;
      var viewArea = containerWidth * containerHeight;
      var area = viewArea * seriesModel.option.zoomToNodeRatio;

      while (parent = currNode.parentNode) {
        // jshint ignore:line
        var sum = 0;
        var siblings = parent.children;

        for (var i = 0, len = siblings.length; i < len; i++) {
          sum += siblings[i].getValue();
        }

        var currNodeValue = currNode.getValue();

        if (currNodeValue === 0) {
          return defaultSize;
        }

        area *= sum / currNodeValue; // Considering border, suppose aspect ratio is 1.

        var parentModel = parent.getModel();
        var borderWidth = parentModel.get(PATH_BORDER_WIDTH);
        var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));
        area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);
        area > MAX_SAFE_INTEGER$1 && (area = MAX_SAFE_INTEGER$1);
        currNode = parent;
      }

      area < viewArea && (area = viewArea);
      var scale = Math.pow(area / viewArea, 0.5);
      return [containerWidth * scale, containerHeight * scale];
    } // Root postion base on coord of containerGroup


    function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
      if (rootRect) {
        return {
          x: rootRect.x,
          y: rootRect.y
        };
      }

      var defaultPosition = {
        x: 0,
        y: 0
      };

      if (!targetInfo) {
        return defaultPosition;
      } // If targetInfo is fetched by 'retrieveTargetInfo',
      // old tree and new tree are the same tree,
      // so the node still exists and we can visit it.


      var targetNode = targetInfo.node;
      var layout = targetNode.getLayout();

      if (!layout) {
        return defaultPosition;
      } // Transform coord from local to container.


      var targetCenter = [layout.width / 2, layout.height / 2];
      var node = targetNode;

      while (node) {
        var nodeLayout = node.getLayout();
        targetCenter[0] += nodeLayout.x;
        targetCenter[1] += nodeLayout.y;
        node = node.parentNode;
      }

      return {
        x: layoutInfo.width / 2 - targetCenter[0],
        y: layoutInfo.height / 2 - targetCenter[1]
      };
    } // Mark nodes visible for prunning when visual coding and rendering.
    // Prunning depends on layout and root position, so we have to do it after layout.


    function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
      var nodeLayout = node.getLayout();
      var nodeInViewAbovePath = viewAbovePath[depth];
      var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;

      if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
        return;
      }

      node.setLayout({
        // isInView means: viewRoot sub tree + viewAbovePath
        isInView: true,
        // invisible only means: outside view clip so that the node can not
        // see but still layout for animation preparation but not render.
        invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
        isAboveViewRoot: isAboveViewRoot
      }, true); // Transform to child coordinate.

      var childClipRect = new BoundingRect_1(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
      each$v(node.viewChildren || [], function (child) {
        prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
      });
    }

    function getUpperLabelHeight(model) {
      return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
    }

    var treemapLayout = _default$2f;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */













    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    echarts.registerVisual(treemapVisual);
    echarts.registerLayout(treemapLayout);

    /* src\components\Chart\Treemap.svelte generated by Svelte v3.22.3 */
    const file$P = "src\\components\\Chart\\Treemap.svelte";

    // (59:0) {:else}
    function create_else_block$d(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(59:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (52:0) {#if data}
    function create_if_block$k(ctx) {
    	let div1;
    	let t;
    	let div0;
    	let current;
    	let chart_1_props = {};
    	const chart_1 = new Chart$1({ props: chart_1_props, $$inline: true });
    	/*chart_1_binding*/ ctx[7](chart_1);
    	chart_1.$on("render", /*onRender*/ ctx[2]);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			t = text(" \r\n    ");
    			div0 = element("div");
    			create_component(chart_1.$$.fragment);
    			set_style(div0, "margin-top", "-40px");
    			set_style(div0, "height", "calc(100% + 20px)");
    			add_location(div0, file$P, 54, 4, 1050);
    			attr_dev(div1, "class", "h-full");
    			add_location(div1, file$P, 52, 2, 1012);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			mount_component(chart_1, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const chart_1_changes = {};
    			chart_1.$set(chart_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chart_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chart_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*chart_1_binding*/ ctx[7](null);
    			destroy_component(chart_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(52:0) {#if data}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$T(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$k, create_else_block$d];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { name = "Visão geral" } = $$props;
    	let { data } = $$props;
    	let { levels = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { options = undefined } = $$props;
    	let chart;

    	function onRender({ detail: chart }) {
    		chart.showLoading();

    		chart.setOption({
    			tooltip: {
    				trigger: "axis",
    				axisPointer: {
    					type: "cross",
    					crossStyle: { color: "#999" }
    				},
    				...tooltip
    			},
    			series: [
    				{
    					type: "treemap",
    					roam: false,
    					name,
    					data,
    					levels,
    					leafDepth: 1
    				}
    			], //animation: false
    			...options
    		});

    		chart.hideLoading();
    	}

    	const writable_props = ["name", "data", "levels", "tooltip", "options"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Treemap> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Treemap", $$slots, []);

    	function chart_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(1, chart = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("name" in $$props) $$invalidate(3, name = $$props.name);
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("levels" in $$props) $$invalidate(4, levels = $$props.levels);
    		if ("tooltip" in $$props) $$invalidate(5, tooltip = $$props.tooltip);
    		if ("options" in $$props) $$invalidate(6, options = $$props.options);
    	};

    	$$self.$capture_state = () => ({
    		Loading,
    		Chart: Chart$1,
    		name,
    		data,
    		levels,
    		tooltip,
    		options,
    		chart,
    		onRender
    	});

    	$$self.$inject_state = $$props => {
    		if ("name" in $$props) $$invalidate(3, name = $$props.name);
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("levels" in $$props) $$invalidate(4, levels = $$props.levels);
    		if ("tooltip" in $$props) $$invalidate(5, tooltip = $$props.tooltip);
    		if ("options" in $$props) $$invalidate(6, options = $$props.options);
    		if ("chart" in $$props) $$invalidate(1, chart = $$props.chart);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, chart*/ 3) {
    			 if (data && chart) {
    				chart.update();
    			}
    		}
    	};

    	return [data, chart, onRender, name, levels, tooltip, options, chart_1_binding];
    }

    class Treemap extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$S, create_fragment$T, safe_not_equal, {
    			name: 3,
    			data: 0,
    			levels: 4,
    			tooltip: 5,
    			options: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Treemap",
    			options,
    			id: create_fragment$T.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<Treemap> was created without expected prop 'data'");
    		}
    	}

    	get name() {
    		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get levels() {
    		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set levels(value) {
    		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\despesas\_components\Treemap.svelte generated by Svelte v3.22.3 */
    const file$Q = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\despesas\\_components\\Treemap.svelte";

    // (13:2) <span slot="title">
    function create_title_slot$a(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Receitas por natureza";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$Q, 12, 2, 28072);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$a.name,
    		type: "slot",
    		source: "(13:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (14:2) <span slot="tooltip">
    function create_tooltip_slot$9(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Receitas por natureza.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$Q, 13, 2, 28123);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$9.name,
    		type: "slot",
    		source: "(14:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:0) <Widget>
    function create_default_slot$r(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const treemap = new Treemap({
    			props: { data: /*data*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(treemap.$$.fragment);
    			set_style(div, "height", /*height*/ ctx[0]);
    			add_location(div, file$Q, 14, 2, 28177);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(treemap, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*height*/ 1) {
    				set_style(div, "height", /*height*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(treemap.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(treemap.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(treemap);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(12:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$r],
    					tooltip: [create_tooltip_slot$9],
    					title: [create_title_slot$a]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, height*/ 5) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { height = "500px" } = $$props;
    	const data = JSON.parse("[{\"codigoPai\":null,\"codigo\":\"1\",\"name\":\"RECEITAS CORRENTES\",\"value\":66652315.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1\",\"codigo\":\"12\",\"name\":\"CONTRIBUIÇÕES\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"12\",\"codigo\":\"124\",\"name\":\"CONTRIBUIÇÃO PARA O CUSTEIO DO SERVIÇO DE ILUMINAÇÃO PÚBLICA\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"124\",\"codigo\":\"1240\",\"name\":\"CONTRIBUIÇÃO PARA O CUSTEIO DO SERVIÇO DE ILUMINAÇÃO PÚBLICA\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1240\",\"codigo\":\"124000\",\"name\":\"CONTRIBUIÇÃO PARA O CUSTEIO DO SERVIÇO DE ILUMINAÇÃO PÚBLICA\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"124000\",\"codigo\":\"1240001\",\"name\":\"CONTRIBUIÇÃO PARA O CUSTEIO DO SERVIÇO DE ILUMINAÇÃO PÚBLICA\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1240001\",\"codigo\":\"12400011\",\"name\":\"CONTRIBUIÇÃO PARA O CUSTEIO DO SERVIÇO DE ILUMINAÇÃO PÚBLICA - PRINCIPAL\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]},{\"codigoPai\":\"1\",\"codigo\":\"11\",\"name\":\"IMPOSTOS, TAXAS E CONTRIBUIÇÕES DE MELHORIA\",\"value\":3409038.06,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"11\",\"codigo\":\"111\",\"name\":\"IMPOSTOS\",\"value\":2533586.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"111\",\"codigo\":\"1118\",\"name\":\"IMPOSTOS ESPECÍFICOS DE ESTADOS/DF E MUNICÍPIOS\",\"value\":2015497.62,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1118\",\"codigo\":\"111802\",\"name\":\"IMPOSTOS SOBRE A PRODUÇÃO, CIRCULAÇÃO DE MERCADORIAS E SERVIÇOS\",\"value\":1311138.63,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"111802\",\"codigo\":\"1118023\",\"name\":\"IMPOSTO SOBRE SERVIÇOS DE QUALQUER NATUREZA\",\"value\":1311138.63,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1118023\",\"codigo\":\"11180233\",\"name\":\"IMPOSTO SOBRE SERVIÇOS DE QUALQUER NATUREZA - DÍVIDA ATIVA\",\"value\":22689.08,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118023\",\"codigo\":\"11180232\",\"name\":\"IMPOSTO SOBRE SERVIÇOS DE QUALQUER NATUREZA - MULTAS E JUROS DE MORA\",\"value\":22776.42,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118023\",\"codigo\":\"11180234\",\"name\":\"IMPOSTO SOBRE SERVIÇOS DE QUALQUER NATUREZA - MULTAS E JUROS DE MORA DA DÍVIDA ATIVA\",\"value\":7694.44,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118023\",\"codigo\":\"11180231\",\"name\":\"IMPOSTO SOBRE SERVIÇOS DE QUALQUER NATUREZA - PRINCIPAL\",\"value\":1257978.69,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1118\",\"codigo\":\"111801\",\"name\":\"IMPOSTOS SOBRE O PATRIMÔNIO PARA ESTADOS/DF/MUNICÍPIOS\",\"value\":704358.99,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"111801\",\"codigo\":\"1118011\",\"name\":\"IMPOSTO SOBRE A PROPRIEDADE PREDIAL E TERRITORIAL URBANA\",\"value\":366822.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1118011\",\"codigo\":\"11180113\",\"name\":\"IMPOSTO SOBRE A PROPRIEDADE PREDIAL E TERRITORIAL URBANA - DÍVIDA ATIVA\",\"value\":70626.71,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118011\",\"codigo\":\"11180112\",\"name\":\"IMPOSTO SOBRE A PROPRIEDADE PREDIAL E TERRITORIAL URBANA - MULTAS E JUROS DE MORA\",\"value\":7607.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118011\",\"codigo\":\"11180114\",\"name\":\"IMPOSTO SOBRE A PROPRIEDADE PREDIAL E TERRITORIAL URBANA - MULTAS E JUROS DE MORA DA DÍVIDA ATIVA\",\"value\":28828.26,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118011\",\"codigo\":\"11180111\",\"name\":\"IMPOSTO SOBRE A PROPRIEDADE PREDIAL E TERRITORIAL URBANA - PRINCIPAL\",\"value\":259760.05,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"111801\",\"codigo\":\"1118014\",\"name\":\"IMPOSTO SOBRE TRANSMISSÃO “INTER VIVOS” DE BENS IMÓVEIS E DE DIREITOS REAIS SOBRE IMÓVEIS\",\"value\":337536.20,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1118014\",\"codigo\":\"11180141\",\"name\":\"IMPOSTO SOBRE TRANSMISSÃO “INTER VIVOS” DE BENS IMÓVEIS E DE DIREITOS REAIS SOBRE IMÓVEIS - PRINCIPAL\",\"value\":337536.20,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]},{\"codigoPai\":\"111\",\"codigo\":\"1113\",\"name\":\"IMPOSTOS SOBRE A RENDA E PROVENTOS DE QUALQUER NATUREZA\",\"value\":518088.56,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1113\",\"codigo\":\"111303\",\"name\":\"IMPOSTO SOBRE A RENDA - RETIDO NA FONTE\",\"value\":518088.56,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"111303\",\"codigo\":\"1113034\",\"name\":\"IMPOSTO SOBRE A RENDA - RETIDO NA FONTE - OUTROS RENDIMENTOS\",\"value\":58355.57,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1113034\",\"codigo\":\"11130341\",\"name\":\"IMPOSTO SOBRE A RENDA - RETIDO NA FONTE - OUTROS RENDIMENTOS - PRINCIPAL\",\"value\":58355.57,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"111303\",\"codigo\":\"1113031\",\"name\":\"IMPOSTO SOBRE A RENDA - RETIDO NA FONTE - TRABALHO\",\"value\":459732.99,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1113031\",\"codigo\":\"11130311\",\"name\":\"IMPOSTO SOBRE A RENDA - RETIDO NA FONTE - TRABALHO - PRINCIPAL\",\"value\":459732.99,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]},{\"codigoPai\":\"11\",\"codigo\":\"112\",\"name\":\"TAXAS\",\"value\":875451.88,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"112\",\"codigo\":\"1128\",\"name\":\"TAXAS – ESPECÍFICAS DE ESTADOS, DF E MUNICÍPIOS\",\"value\":101487.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1128\",\"codigo\":\"112801\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO\",\"value\":101487.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"112801\",\"codigo\":\"1128019\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO - OUTRAS\",\"value\":101487.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1128019\",\"codigo\":\"11280193\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO - OUTRAS - DÍVIDA ATIVA\",\"value\":10596.15,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1128019\",\"codigo\":\"11280192\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO - OUTRAS - MULTAS E JUROS DE MORA\",\"value\":152.19,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1128019\",\"codigo\":\"11280194\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO - OUTRAS - MULTAS E JUROS DE MORA DA DÍVIDA ATIVA\",\"value\":562.82,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1128019\",\"codigo\":\"11280191\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO - OUTRAS - PRINCIPAL\",\"value\":90176.61,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]},{\"codigoPai\":\"112\",\"codigo\":\"1122\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS\",\"value\":773964.11,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1122\",\"codigo\":\"112201\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS\",\"value\":773964.11,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"112201\",\"codigo\":\"1122011\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS\",\"value\":773964.11,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1122011\",\"codigo\":\"11220113\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS - DÍVIDA ATIVA\",\"value\":114907.56,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1122011\",\"codigo\":\"11220112\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS - MULTAS E JUROS DE MORA\",\"value\":9166.07,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1122011\",\"codigo\":\"11220114\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS - MULTAS E JUROS DE MORA DA DÍVIDA ATIVA\",\"value\":41567.99,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1122011\",\"codigo\":\"11220111\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS - PRINCIPAL\",\"value\":608322.49,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]},{\"codigoPai\":\"1\",\"codigo\":\"19\",\"name\":\"OUTRAS RECEITAS CORRENTES\",\"value\":833077.34,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"19\",\"codigo\":\"199\",\"name\":\"DEMAIS RECEITAS CORRENTES\",\"value\":284744.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"199\",\"codigo\":\"1990\",\"name\":\"DEMAIS RECEITAS CORRENTES\",\"value\":284744.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1990\",\"codigo\":\"199099\",\"name\":\"OUTRAS RECEITAS\",\"value\":284744.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"199099\",\"codigo\":\"1990992\",\"name\":\"OUTRAS RECEITAS - FINANCEIRAS\",\"value\":117.06,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1990992\",\"codigo\":\"19909921\",\"name\":\"OUTRAS RECEITAS - FINANCEIRAS - PRINCIPAL\",\"value\":117.06,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"199099\",\"codigo\":\"1990991\",\"name\":\"OUTRAS RECEITAS - PRIMÁRIAS\",\"value\":284627.61,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1990991\",\"codigo\":\"19909913\",\"name\":\"OUTRAS RECEITAS - PRIMÁRIAS - DÍVIDA ATIVA\",\"value\":106.08,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1990991\",\"codigo\":\"19909911\",\"name\":\"OUTRAS RECEITAS - PRIMÁRIAS - PRINCIPAL\",\"value\":284521.53,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]},{\"codigoPai\":\"19\",\"codigo\":\"192\",\"name\":\"INDENIZAÇÕES, RESTITUIÇÕES E RESSARCIMENTOS\",\"value\":548332.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"192\",\"codigo\":\"1928\",\"name\":\"Indenizações, Restituições e Ressarcimentos - Específicas para Estados/DF/Municípios\",\"value\":548332.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1928\",\"codigo\":\"192802\",\"name\":\"Restituições - Específicas para Estados/DF/Municípios\",\"value\":548332.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"192802\",\"codigo\":\"1928029\",\"name\":\"Outras Restituições - Específicas para Estados/DF/Municípios - Não Especificadas Anteriormente\",\"value\":548332.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1928029\",\"codigo\":\"19280291\",\"name\":\"Outras Restituições - Específicas para Estados/DF/Municípios - Não Especificadas Anteriormente - PRINCIPAL\",\"value\":548332.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]},{\"codigoPai\":\"1\",\"codigo\":\"13\",\"name\":\"RECEITA PATRIMONIAL\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"13\",\"codigo\":\"132\",\"name\":\"VALORES MOBILIÁRIOS\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"132\",\"codigo\":\"1321\",\"name\":\"JUROS E CORREÇÕES MONETÁRIAS\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1321\",\"codigo\":\"132100\",\"name\":\"JUROS E CORREÇÕES MONETÁRIAS\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"132100\",\"codigo\":\"1321001\",\"name\":\"REMUNERAÇÃO DE DEPÓSITOS BANCÁRIOS\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1321001\",\"codigo\":\"13210011\",\"name\":\"REMUNERAÇÃO DE DEPÓSITOS BANCÁRIOS - PRINCIPAL\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]},{\"codigoPai\":\"1\",\"codigo\":\"17\",\"name\":\"TRANSFERÊNCIAS CORRENTES\",\"value\":60702888.01,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"17\",\"codigo\":\"171\",\"name\":\"TRANSFERÊNCIAS DA UNIÃO E DE SUAS ENTIDADES\",\"value\":26374641.52,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171\",\"codigo\":\"1718\",\"name\":\"TRANSFERÊNCIAS DA UNIÃO – ESPECÍFICAS DE ESTADOS, DF E MUNICÍPIOS\",\"value\":26374641.52,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718\",\"codigo\":\"171801\",\"name\":\"PARTICIPAÇÃO NA RECEITA DA UNIÃO\",\"value\":15442558.19,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171801\",\"codigo\":\"1718014\",\"name\":\"COTA-PARTE DO FUNDO DE PARTICIPAÇÃO DOS MUNICÍPIOS - 1% COTA ENTREGUE NO MÊS DE JULHO\",\"value\":949670.80,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718014\",\"codigo\":\"17180141\",\"name\":\"COTA-PARTE DO FUNDO DE PARTICIPAÇÃO DOS MUNICÍPIOS - 1% COTA ENTREGUE NO MÊS DE JULHO - PRINCIPAL\",\"value\":949670.80,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171801\",\"codigo\":\"1718012\",\"name\":\"COTA-PARTE DO FUNDO DE PARTICIPAÇÃO DOS MUNICÍPIOS - COTA MENSAL\",\"value\":14478725.86,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718012\",\"codigo\":\"17180121\",\"name\":\"COTA-PARTE DO FUNDO DE PARTICIPAÇÃO DOS MUNICÍPIOS - COTA MENSAL - PRINCIPAL\",\"value\":14478725.86,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171801\",\"codigo\":\"1718015\",\"name\":\"COTA-PARTE DO IMPOSTO SOBRE A PROPRIEDADE TERRITORIAL RURAL\",\"value\":14161.53,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718015\",\"codigo\":\"17180151\",\"name\":\"COTA-PARTE DO IMPOSTO SOBRE A PROPRIEDADE TERRITORIAL RURAL - PRINCIPAL\",\"value\":14161.53,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1718\",\"codigo\":\"171802\",\"name\":\"TRANSFERÊNCIA DA COMPENSAÇÃO FINANCEIRA PELA EXPLORAÇÃO DE RECURSOS NATURAIS\",\"value\":2485547.70,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171802\",\"codigo\":\"1718026\",\"name\":\"COTA-PARTE DO FUNDO ESPECIAL DO PETRÓLEO – FEP\",\"value\":283484.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718026\",\"codigo\":\"17180261\",\"name\":\"COTA-PARTE DO FUNDO ESPECIAL DO PETRÓLEO – FEP - PRINCIPAL\",\"value\":283484.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171802\",\"codigo\":\"1718024\",\"name\":\"COTA-PARTE ROYALTIES PELO EXCEDENTE DA PRODUÇÃO DO PETRÓLEO – LEI Nº 9.478/97, ARTIGO 49, I E II\",\"value\":2084722.55,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718024\",\"codigo\":\"17180241\",\"name\":\"COTA-PARTE ROYALTIES PELO EXCEDENTE DA PRODUÇÃO DO PETRÓLEO – LEI Nº 9.478/97, ARTIGO 49, I E II - PRINCIPAL\",\"value\":2084722.55,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171802\",\"codigo\":\"1718029\",\"name\":\"OUTRAS TRANSFERÊNCIAS DECORRENTES DE COMPENSAÇÃO FINANCEIRA PELA EXPLORAÇÃO DE RECURSOS NATURAIS\",\"value\":117340.74,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718029\",\"codigo\":\"17180291\",\"name\":\"OUTRAS TRANSFERÊNCIAS DECORRENTES DE COMPENSAÇÃO FINANCEIRA PELA EXPLORAÇÃO DE RECURSOS NATURAIS - PRINCIPAL\",\"value\":117340.74,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1718\",\"codigo\":\"171803\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO SISTEMA ÚNICO DE SAÚDE – SUS – BLOCO CUSTEIO DAS AÇÕES E SERVIÇOS PÚBLICOS DE SAÚDE\",\"value\":6682051.11,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171803\",\"codigo\":\"1718034\",\"name\":\"Transferência de Recursos do SUS – Assistência Farmacêutica\",\"value\":162692.50,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718034\",\"codigo\":\"17180341\",\"name\":\"Transferência de Recursos do SUS – Assistência Farmacêutica - PRINCIPAL\",\"value\":162692.50,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171803\",\"codigo\":\"1718031\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO SUS – ATENÇÃO BÁSICA\",\"value\":2715766.14,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718031\",\"codigo\":\"17180311\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO SUS – ATENÇÃO BÁSICA - PRINCIPAL\",\"value\":2715766.14,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171803\",\"codigo\":\"1718032\",\"name\":\"Transferência de Recursos do SUS – Atenção de Média e Alta Complexidade Ambulatorial e Hospitalar\",\"value\":3318535.03,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718032\",\"codigo\":\"17180321\",\"name\":\"Transferência de Recursos do SUS – Atenção de Média e Alta Complexidade Ambulatorial e Hospitalar - PRINCIPAL\",\"value\":3318535.03,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171803\",\"codigo\":\"1718039\",\"name\":\"Transferência de Recursos do SUS – Outros Programas Financiados por Transferências Fundo a Fundo\",\"value\":230308.05,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718039\",\"codigo\":\"17180391\",\"name\":\"Transferência de Recursos do SUS – Outros Programas Financiados por Transferências Fundo a Fundo - PRINCIPAL\",\"value\":230308.05,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171803\",\"codigo\":\"1718033\",\"name\":\"Transferência de Recursos do SUS – Vigilância em Saúde\",\"value\":254749.39,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718033\",\"codigo\":\"17180331\",\"name\":\"Transferência de Recursos do SUS – Vigilância em Saúde - PRINCIPAL\",\"value\":254749.39,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1718\",\"codigo\":\"171810\",\"name\":\"TRANSFERÊNCIAS DE CONVÊNIOS DA UNIÃO E DE SUAS ENTIDADES\",\"value\":23100.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171810\",\"codigo\":\"1718103\",\"name\":\"TRANSFERÊNCIAS DE CONVÊNIOS DA UNIÃO DESTINADAS A PROGRAMAS DE ASSISTÊNCIA SOCIAL\",\"value\":23100.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718103\",\"codigo\":\"17181031\",\"name\":\"TRANSFERÊNCIAS DE CONVÊNIOS DA UNIÃO DESTINADAS A PROGRAMAS DE ASSISTÊNCIA SOCIAL - PRINCIPAL\",\"value\":23100.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1718\",\"codigo\":\"171812\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO NACIONAL DE ASSISTÊNCIA SOCIAL – FNAS\",\"value\":24500.36,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171812\",\"codigo\":\"1718121\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO NACIONAL DE ASSISTÊNCIA SOCIAL – FNAS\",\"value\":24500.36,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718121\",\"codigo\":\"17181211\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO NACIONAL DE ASSISTÊNCIA SOCIAL – FNAS - PRINCIPAL\",\"value\":24500.36,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1718\",\"codigo\":\"171805\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO NACIONAL DO DESENVOLVIMENTO DA EDUCAÇÃO – FNDE\",\"value\":1716884.16,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171805\",\"codigo\":\"1718059\",\"name\":\"OUTRAS TRANSFERÊNCIAS DIRETAS DO FUNDO NACIONAL DO DESENVOLVIMENTO DA EDUCAÇÃO – FNDE\",\"value\":131477.45,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718059\",\"codigo\":\"17180591\",\"name\":\"OUTRAS TRANSFERÊNCIAS DIRETAS DO FUNDO NACIONAL DO DESENVOLVIMENTO DA EDUCAÇÃO – FNDE - PRINCIPAL\",\"value\":131477.45,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171805\",\"codigo\":\"1718052\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA DINHEIRO DIRETO NA ESCOLA – PDDE\",\"value\":23580.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718052\",\"codigo\":\"17180521\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA DINHEIRO DIRETO NA ESCOLA – PDDE - PRINCIPAL\",\"value\":23580.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171805\",\"codigo\":\"1718053\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA NACIONAL DE ALIMENTAÇÃO ESCOLAR – PNAE\",\"value\":389916.40,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718053\",\"codigo\":\"17180531\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA NACIONAL DE ALIMENTAÇÃO ESCOLAR – PNAE - PRINCIPAL\",\"value\":389916.40,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171805\",\"codigo\":\"1718054\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA NACIONAL DE APOIO AO TRANSPORTE DO ESCOLAR – PNATE\",\"value\":270234.16,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718054\",\"codigo\":\"17180541\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA NACIONAL DE APOIO AO TRANSPORTE DO ESCOLAR – PNATE - PRINCIPAL\",\"value\":270234.16,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171805\",\"codigo\":\"1718051\",\"name\":\"TRANSFERÊNCIAS DO SALÁRIO-EDUCAÇÃO\",\"value\":901676.15,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718051\",\"codigo\":\"17180511\",\"name\":\"TRANSFERÊNCIAS DO SALÁRIO-EDUCAÇÃO - PRINCIPAL\",\"value\":901676.15,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]},{\"codigoPai\":\"17\",\"codigo\":\"175\",\"name\":\"TRANSFERÊNCIAS DE OUTRAS INSTITUIÇÕES PÚBLICAS\",\"value\":13127195.17,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"175\",\"codigo\":\"1758\",\"name\":\"TRANSFERÊNCIAS DE OUTRAS INSTITUIÇÕES PÚBLICAS – ESPECÍFICAS DE ESTADOS, DF E MUNICÍPIOS\",\"value\":13127195.17,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1758\",\"codigo\":\"175801\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO DE MANUTENÇÃO E DESENVOLVIMENTO DA EDUCAÇÃO BÁSICA E DE VALORIZAÇÃO DOS PROFISSIONAIS DA EDUCAÇÃO – FUNDEB\",\"value\":13127195.17,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"175801\",\"codigo\":\"1758011\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO DE MANUTENÇÃO E DESENVOLVIMENTO DA EDUCAÇÃO BÁSICA E DE VALORIZAÇÃO DOS PROFISSIONAIS DA EDUCAÇÃO – FUNDEB\",\"value\":13127195.17,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1758011\",\"codigo\":\"17580111\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO DE MANUTENÇÃO E DESENVOLVIMENTO DA EDUCAÇÃO BÁSICA E DE VALORIZAÇÃO DOS PROFISSIONAIS DA EDUCAÇÃO – FUNDEB - PRINCIPAL\",\"value\":13127195.17,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]},{\"codigoPai\":\"17\",\"codigo\":\"172\",\"name\":\"TRANSFERÊNCIAS DOS ESTADOS E DO DISTRITO FEDERAL E DE SUAS ENTIDADES\",\"value\":21201051.32,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"172\",\"codigo\":\"1728\",\"name\":\"TRANSFERÊNCIAS DOS ESTADOS – ESPECÍFICAS DE ESTADOS, DF E MUNICÍPIOS\",\"value\":21201051.32,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728\",\"codigo\":\"172801\",\"name\":\"PARTICIPAÇÃO NA RECEITA DOS ESTADOS\",\"value\":20066669.53,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"172801\",\"codigo\":\"1728014\",\"name\":\"COTA-PARTE DA CONTRIBUIÇÃO DE INTERVENÇÃO NO DOMÍNIO ECONÔMICO\",\"value\":44759.92,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728014\",\"codigo\":\"17280141\",\"name\":\"COTA-PARTE DA CONTRIBUIÇÃO DE INTERVENÇÃO NO DOMÍNIO ECONÔMICO - PRINCIPAL\",\"value\":44759.92,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"172801\",\"codigo\":\"1728011\",\"name\":\"COTA-PARTE DO ICMS\",\"value\":15866577.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728011\",\"codigo\":\"17280111\",\"name\":\"COTA-PARTE DO ICMS - PRINCIPAL\",\"value\":15866577.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"172801\",\"codigo\":\"1728013\",\"name\":\"COTA-PARTE DO IPI - MUNICÍPIOS\",\"value\":280058.83,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728013\",\"codigo\":\"17280131\",\"name\":\"COTA-PARTE DO IPI - MUNICÍPIOS - PRINCIPAL\",\"value\":280058.83,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"172801\",\"codigo\":\"1728012\",\"name\":\"COTA-PARTE DO IPVA\",\"value\":1285396.19,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728012\",\"codigo\":\"17280121\",\"name\":\"COTA-PARTE DO IPVA - PRINCIPAL\",\"value\":1285396.19,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"172801\",\"codigo\":\"1728019\",\"name\":\"OUTRAS TRANSFERÊNCIAS DOS ESTADOS\",\"value\":2589876.82,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728019\",\"codigo\":\"17280191\",\"name\":\"OUTRAS TRANSFERÊNCIAS DOS ESTADOS - PRINCIPAL\",\"value\":2589876.82,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1728\",\"codigo\":\"172802\",\"name\":\"TRANSFERÊNCIA DA COTA-PARTE DA COMPENSAÇÃO FINANCEIRA (25%)\",\"value\":1053364.29,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"172802\",\"codigo\":\"1728029\",\"name\":\"OUTRAS TRANSFERÊNCIAS DECORRENTES DE COMPENSAÇÕES FINANCEIRAS\",\"value\":1053364.29,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728029\",\"codigo\":\"17280291\",\"name\":\"OUTRAS TRANSFERÊNCIAS DECORRENTES DE COMPENSAÇÕES FINANCEIRAS - PRINCIPAL\",\"value\":1053364.29,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1728\",\"codigo\":\"172803\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO ESTADO PARA PROGRAMAS DE SAÚDE – REPASSE FUNDO A FUNDO\",\"value\":81017.50,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"172803\",\"codigo\":\"1728031\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO ESTADO PARA PROGRAMAS DE SAÚDE – REPASSE FUNDO A FUNDO\",\"value\":81017.50,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728031\",\"codigo\":\"17280311\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO ESTADO PARA PROGRAMAS DE SAÚDE – REPASSE FUNDO A FUNDO - PRINCIPAL\",\"value\":81017.50,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]}]},{\"codigoPai\":null,\"codigo\":\"2\",\"name\":\"RECEITAS DE CAPITAL\",\"value\":2479600.86,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2\",\"codigo\":\"24\",\"name\":\"TRANSFERÊNCIAS DE CAPITAL\",\"value\":2479600.86,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"24\",\"codigo\":\"241\",\"name\":\"TRANSFERÊNCIAS DA UNIÃO E DE SUAS ENTIDADES\",\"value\":1346420.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"241\",\"codigo\":\"2418\",\"name\":\"TRANSFERÊNCIAS DA UNIÃO – ESPECÍFICAS DE ESTADOS, DF E MUNICÍPIOS\",\"value\":1346420.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2418\",\"codigo\":\"241810\",\"name\":\"TRANSFERÊNCIA DE CONVÊNIOS DA UNIÃO E DE SUAS ENTIDADES\",\"value\":892420.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"241810\",\"codigo\":\"2418109\",\"name\":\"OUTRAS TRANSFERÊNCIAS DE CONVÊNIOS DA UNIÃO\",\"value\":892420.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2418109\",\"codigo\":\"24181091\",\"name\":\"OUTRAS TRANSFERÊNCIAS DE CONVÊNIOS DA UNIÃO - PRINCIPAL\",\"value\":892420.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"2418\",\"codigo\":\"241804\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO SISTEMA ÚNICO DE SAÚDE – SUS - BLOCO INVESTIMENTOS NA REDE DE SERVIÇOS PÚBLICOS DE SAÚDE\",\"value\":454000.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"241804\",\"codigo\":\"2418041\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO SISTEMA ÚNICO DE SAÚDE – SUS DESTINADOS À ATENÇÃO BÁSICA\",\"value\":454000.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2418041\",\"codigo\":\"24180411\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO SISTEMA ÚNICO DE SAÚDE – SUS DESTINADOS À ATENÇÃO BÁSICA - PRINCIPAL\",\"value\":454000.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]},{\"codigoPai\":\"24\",\"codigo\":\"242\",\"name\":\"TRANSFERÊNCIAS DOS ESTADOS E DO DISTRITO FEDERAL E DE SUAS ENTIDADES\",\"value\":1133180.07,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"242\",\"codigo\":\"2428\",\"name\":\"TRANSFERÊNCIAS DOS ESTADOS, DISTRITO FEDERAL, E DE SUAS ENTIDADES\",\"value\":1133180.07,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2428\",\"codigo\":\"242810\",\"name\":\"TRANSFERÊNCIAS DE CONVÊNIOS DOS ESTADOS E DO DISTRITO FEDERAL E DE SUAS ENTIDADES\",\"value\":605369.93,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"242810\",\"codigo\":\"2428109\",\"name\":\"OUTRAS TRANSFERÊNCIAS DE CONVÊNIO DOS ESTADOS\",\"value\":605369.93,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2428109\",\"codigo\":\"24281091\",\"name\":\"OUTRAS TRANSFERÊNCIAS DE CONVÊNIO DOS ESTADOS - PRINCIPAL\",\"value\":605369.93,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"2428\",\"codigo\":\"242805\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DESTINADOS A PROGRAMAS DE EDUCAÇÃO\",\"value\":527810.14,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"242805\",\"codigo\":\"2428051\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DESTINADOS A PROGRAMAS DE EDUCAÇÃO\",\"value\":527810.14,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2428051\",\"codigo\":\"24280511\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DESTINADOS A PROGRAMAS DE EDUCAÇÃO - PRINCIPAL\",\"value\":527810.14,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]}]}]");
    	const writable_props = ["height"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Treemap> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Treemap", $$slots, []);

    	$$self.$set = $$props => {
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({ Widget, Treemap, height, data });

    	$$self.$inject_state = $$props => {
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [height, data];
    }

    class Treemap_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$U, safe_not_equal, { height: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Treemap_1",
    			options,
    			id: create_fragment$U.name
    		});
    	}

    	get height() {
    		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function gestaoNumeroHabitantes(ano, municipio) {
      return [
        {
          id: "gestaoNumeroHabitantes",
          run: "Municipio.Gestao.NumeroHabitantes",
          args: [ano, municipio]
        }
      ];
    }

    function gestaoSituacaoPrestacaoContaAnual(ano, municipio) {
      return [
        {
          id: "gestaoSituacaoPrestacaoContaAnual",
          run: "Municipio.Gestao.SituacaoPrestacaoContaAnual",
          args: [ano, municipio]
        }
      ];
    }

    var gestaoApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        gestaoNumeroHabitantes: gestaoNumeroHabitantes,
        gestaoSituacaoPrestacaoContaAnual: gestaoSituacaoPrestacaoContaAnual
    });

    const cache = {};

    function prestacaoContaPCA(ano, ug) {
    	return [
    		{
    			id: "prestacaoContaPCA",
    			run: "PrestacaoConta.PCA",
    			args: [ano, ug]
    		}
    	];
    }

    function prestacaoContaPCB(ano, ug) {
    	if (ug.length === 3) {
    		ug = ug + "E0700001";
    	}

    	return [
    		{
    			id: "prestacaoContaPCB",
    			run: "PrestacaoConta.PCB",
    			args: [ano, ug]
    		}
    	];
    }

    function prestacaoContaEstado(ano, ug) {
    	return [
    		{
    			id: "prestacaoContaEstado",
    			run: "PrestacaoConta.Estado",
    			args: [ano, ug]
    		}
    	];
    }

    function prestacaoContaPCF(ano, ug) {
    	return [
    		{
    			id: "prestacaoContaPCF",
    			run: "PrestacaoConta.PCF",
    			args: [ano, ug]
    		}
    	];
    }

    function prestacaoContaMensal(ano, ug) {
    	return [
    		{
    			id: "prestacaoContaMensal",
    			run: "PrestacaoContaMensal.FiltrarPorAnoECodigo",
    			args: [ano, ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "PrestacaoContaMensal.Atual",
    			args: []
    		}
    	];
    }

    function prestacaoContaPessoal(ano, ug) {
    	return [
    		{
    			id: "prestacaoContaPessoal",
    			run: "PrestacaoConta.Pessoal",
    			args: [ano, ug]
    		}
    	];
    }

    async function get$2(prestacaoContaWorkflow) {
    	const res = await axios$1.post(
    		"http://localhost:9000/api/ControleSocial", //todo: consertar isso
    		prestacaoContaWorkflow
    	);

    	cache[prestacaoContaWorkflow] = res.data;
    	return res.data;
    }

    var prestacaoContaApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        prestacaoContaPCA: prestacaoContaPCA,
        prestacaoContaPCB: prestacaoContaPCB,
        prestacaoContaEstado: prestacaoContaEstado,
        prestacaoContaPCF: prestacaoContaPCF,
        prestacaoContaMensal: prestacaoContaMensal,
        prestacaoContaPessoal: prestacaoContaPessoal,
        get: get$2
    });

    const composicao = {
    	operacoesDeCredito: ano => ano >= anoInicioUsoEmentarioReceita ? ["2111", "2112", "2118", "2119", "2121", "2122", "2128", "2129"] : ["2111", "2114", "2119", "2122", "2123", "2129"],
    	receitasDoMunicipio: ano => ano >= anoInicioUsoEmentarioReceita ? ["11", "12", "13", "14", "15", "16", "19", "22", "23", "29"] : ["11", "12", "13", "14", "15", "16", "19", "22", "23", "25"],
    	transferenciaDaUniao: ano => ano >= anoInicioUsoEmentarioReceita ? ["1718", "2418"] : ["1721", "1761", "2421", "2471"],
    	transferenciaDoEstado: ano => ano >= anoInicioUsoEmentarioReceita ? ["1728", "1758", "2428"] : ["1722", "1724", "1762", "2422", "2472"]
    };
    const anoInicioUsoEmentarioReceita = 2016;

    function receitaArrecadada(ano, ug) {
    	return [
    		{
    			id: "receitaArrecadada",
    			run: "Municipio.Receita.FiltrarPorAnoECodigo",
    			args: [ano, ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Receita.Arrecadada",
    			args: []
    		}
    	];
    }

    function receitaComposicaoArrecadada(ano, ug) {
    	const workflows = [receitaDestaqueOperacoesDeCredito, receitaDestaqueReceitasDoMunicipio, receitaDestaqueTransferenciasDaUniao, receitaDestaqueTransferenciasDoEstado, receitaDestaqueOutrasTransferencias]
    		.map(fnSelectorWorkflow => {
    			const workflow = fnSelectorWorkflow(ano, ug, receitaSumArrecadada);

    			return [
    				{
    					id: workflow[0].id,
    					run: "Municipio.Receita.FiltrarPorAno",
    					args: [ano],
    					continue: true,
    					evaluate: false
    				}
    			].concat(workflow);
    		});
    	return workflows.reduce((acc, prev) => acc.concat(prev), []);
    }

    function receitaDestaqueConveniosDaUniao(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueConveniosDaUniao",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ano >= anoInicioUsoEmentarioReceita ? ["171-----810"] : ["1761"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueConveniosDoEstado(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueConveniosDoEstado",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ano >= anoInicioUsoEmentarioReceita ? ["172-----810"] : ["1762"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueFPM(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueFPM",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ano >= anoInicioUsoEmentarioReceita ? ["171-----80121", "171-----80131", "171-----80141"] : ["17210102", "17210103", "17210104"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueICMS(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueICMS",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ano >= anoInicioUsoEmentarioReceita ? ["172-----80111", "171-----80611"] : ["17220101", "17220103", "17213600"]],
    			continue: true,
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueIPTU(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueIPTU",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ano >= anoInicioUsoEmentarioReceita ? ["111-----8011"] : ["1112020", "1911380", "1913110", "1931110"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueIPVA(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueIPVA",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ano >= anoInicioUsoEmentarioReceita ? ["172-----80121"] : ["17220102"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueISS(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueISS",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ano >= anoInicioUsoEmentarioReceita ? ["111-----8023", "111-----8024"] : ["11130501", "11130502", "19114000", "19131300", "19311300"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueITBI(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueITBI",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ano >= anoInicioUsoEmentarioReceita ? ["111-----8014"] : ["11120800", "19113900", "19131200", "19311200"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueOperacoesDeCredito(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueOperacoesDeCredito",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", composicao.operacoesDeCredito(ano)],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueOutrasTransferencias(
    	ano,
    	ug,
    	fnSelectorWorkflow
    ) {
    	const codigos = composicao.operacoesDeCredito(ano)
    		.concat(composicao.receitasDoMunicipio(ano))
    		.concat(composicao.transferenciaDaUniao(ano))
    		.concat(composicao.transferenciaDoEstado(ano));

    	return [
    		{
    			id: "receitaDestaqueOutrasTransferencias",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", codigos, true], //not
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueReceitasDoMunicipio(
    	ano,
    	ug,
    	fnSelectorWorkflow
    ) {
    	return [
    		{
    			id: "receitaDestaqueReceitasDoMunicipio",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", composicao.receitasDoMunicipio(ano)],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueRoyaltiesDaUniao(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueRoyaltiesDaUniao",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ano > anoInicioUsoEmentarioReceita ? ["1321"] : ano === anoInicioUsoEmentarioReceita ? ["1321"] : ["1325"], true], //not
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.EndsWith",
    			args: ["ClassificacaoFonteRecurso.CodigoFonteReduzida", ano > anoInicioUsoEmentarioReceita ? ["540"] : ano === anoInicioUsoEmentarioReceita ? ["605"] : ["605"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueRoyaltiesDoEstado(ano, ug, fnSelectorWorkflow) {
    	return [
    		{
    			id: "receitaDestaqueRoyaltiesDoEstado",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", ano > anoInicioUsoEmentarioReceita ? ["1321"] : ano === anoInicioUsoEmentarioReceita ? ["1321"] : ["1325"], true], //not
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.EndsWith",
    			args: ["ClassificacaoFonteRecurso.CodigoFonteReduzida", ano > anoInicioUsoEmentarioReceita ? ["140", "240", "530"] : ano === anoInicioUsoEmentarioReceita ? ["120", "207", "604"] : ["604"]],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueTransferenciasDaUniao(
    	ano,
    	ug,
    	fnSelectorWorkflow
    ) {
    	return [
    		{
    			id: "receitaDestaqueTransferenciasDaUniao",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", composicao.transferenciaDaUniao(ano)],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaDestaqueTransferenciasDoEstado(
    	ano,
    	ug,
    	fnSelectorWorkflow
    ) {
    	return [
    		{
    			id: "receitaDestaqueTransferenciasDoEstado",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "String.StartsWith",
    			args: ["ClassificacaoNatureza.CodigoCompleto", composicao.transferenciaDoEstado(ano)],
    			continue: true,
    			evaluate: false
    		},
    		...fnSelectorWorkflow(ano, ug)
    	];
    }

    function receitaEvolucaoAnual(ano, ug, quantidade = 5) {
    	return [
    		{
    			id: "receitaEvolucaoAnual",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Receita.EvolucaoAnual",
    			args: [ano, quantidade]
    		}
    	];
    }

    function receitaEvolucaoMensal(ano, ug) {
    	return [
    		{
    			id: "receitaEvolucaoMensal",
    			run: "Municipio.Receita.FiltrarPorCodigo",
    			args: [ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Receita.EvolucaoMensal",
    			args: [ano]
    		}
    	];
    }

    function receitaPrevisaoInicial(ano, ug) {
    	return [
    		{
    			id: "receitaPrevisaoInicial",
    			run: "Municipio.Receita.FiltrarPorAnoECodigo",
    			args: [ano, ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Receita.PrevisaoInicial",
    			args: []
    		}
    	];
    }

    function receitaRemessaAtual(ano, ug) {
    	return [
    		{
    			id: "receitaRemessaAtual",
    			run: "Municipio.Receita.FiltrarPorAnoECodigo1",
    			args: [ano, ug],
    			continue: true,
    			evaluate: false
    		},
    		{
    			run: "Municipio.Receita.RemessaAtual",
    			args: []
    		}
    	];
    }

    function receitaSumArrecadada() {
    	return [
    		{
    			id: "receitaSumArrecadada",
    			run: "Municipio.Receita.Arrecadada"
    		}
    	];
    }

    var receitaApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        receitaArrecadada: receitaArrecadada,
        receitaComposicaoArrecadada: receitaComposicaoArrecadada,
        receitaDestaqueConveniosDaUniao: receitaDestaqueConveniosDaUniao,
        receitaDestaqueConveniosDoEstado: receitaDestaqueConveniosDoEstado,
        receitaDestaqueFPM: receitaDestaqueFPM,
        receitaDestaqueICMS: receitaDestaqueICMS,
        receitaDestaqueIPTU: receitaDestaqueIPTU,
        receitaDestaqueIPVA: receitaDestaqueIPVA,
        receitaDestaqueISS: receitaDestaqueISS,
        receitaDestaqueITBI: receitaDestaqueITBI,
        receitaDestaqueOperacoesDeCredito: receitaDestaqueOperacoesDeCredito,
        receitaDestaqueOutrasTransferencias: receitaDestaqueOutrasTransferencias,
        receitaDestaqueReceitasDoMunicipio: receitaDestaqueReceitasDoMunicipio,
        receitaDestaqueRoyaltiesDaUniao: receitaDestaqueRoyaltiesDaUniao,
        receitaDestaqueRoyaltiesDoEstado: receitaDestaqueRoyaltiesDoEstado,
        receitaDestaqueTransferenciasDaUniao: receitaDestaqueTransferenciasDaUniao,
        receitaDestaqueTransferenciasDoEstado: receitaDestaqueTransferenciasDoEstado,
        receitaEvolucaoAnual: receitaEvolucaoAnual,
        receitaEvolucaoMensal: receitaEvolucaoMensal,
        receitaPrevisaoInicial: receitaPrevisaoInicial,
        receitaRemessaAtual: receitaRemessaAtual,
        receitaSumArrecadada: receitaSumArrecadada
    });

    /* src\pages\municipio\[ano]\[municipio]\[ug]\despesas\index.svelte generated by Svelte v3.22.3 */

    const { console: console_1 } = globals;
    const file$R = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\despesas\\index.svelte";

    // (86:6) <span slot="title">
    function create_title_slot_2$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução anual da Despesa";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$R, 85, 6, 3500);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_2$1.name,
    		type: "slot",
    		source: "(86:6) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (87:6) <span slot="tooltip">
    function create_tooltip_slot_1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Possibilita comparar os gastos realizados com o montante arrecadado no\r\n        exercício e identificar a ocorrência de déficit (despesa maior que\r\n        receita) ou superávit (receita maior que despesa).";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$R, 86, 6, 3559);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot_1.name,
    		type: "slot",
    		source: "(87:6) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (82:4) <ReceitaXDespesaEvolucaoAnual        view="despesa"        receita={$store.receitaEvolucaoAnual}        despesa={$store.despesaEvolucaoAnual}>
    function create_default_slot_2$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(82:4) <ReceitaXDespesaEvolucaoAnual        view=\\\"despesa\\\"        receita={$store.receitaEvolucaoAnual}        despesa={$store.despesaEvolucaoAnual}>",
    		ctx
    	});

    	return block;
    }

    // (99:6) <span slot="title">
    function create_title_slot_1$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Despesa empenhada em relação ao ano anterior";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$R, 98, 6, 4029);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_1$1.name,
    		type: "slot",
    		source: "(99:6) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (112:6) <span slot="title">
    function create_title_slot$b(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução mensal das Despesas";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$R, 111, 6, 4387);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$b.name,
    		type: "slot",
    		source: "(112:6) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (113:6) <span slot="tooltip">
    function create_tooltip_slot$a(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "PossPossibilita comparar os gastos realizados com o montante arrecadado\r\n        no exercício e identificar a ocorrência de déficit (despesa maior que\r\n        receita) ou superávit (receita maior que despesa).";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$R, 112, 6, 4449);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$a.name,
    		type: "slot",
    		source: "(113:6) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (108:4) <ReceitaXDespesaEvolucaoMensal        view="despesa"        receita={$store.receitaEvolucaoMensal}        despesa={$store.despesaEvolucaoMensal}>
    function create_default_slot$s(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$s.name,
    		type: "slot",
    		source: "(108:4) <ReceitaXDespesaEvolucaoMensal        view=\\\"despesa\\\"        receita={$store.receitaEvolucaoMensal}        despesa={$store.despesaEvolucaoMensal}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let t0;
    	let div0;
    	let t1;
    	let div8;
    	let div1;
    	let t2;
    	let div2;
    	let t3;
    	let div3;
    	let t4;
    	let div4;
    	let t5;
    	let div5;
    	let t6;
    	let div6;
    	let t7;
    	let div7;
    	let current;

    	const prestacaocontamensal = new PrestacaoContaMensal({
    			props: {
    				model: /*$store*/ ctx[0].prestacaoContaMensal
    			},
    			$$inline: true
    		});

    	const cardliquidada = new CardLiquidada({
    			props: {
    				remessa: /*$store*/ ctx[0].despesaRemessaAtual
    			},
    			$$inline: true
    		});

    	const maioresdespesasporfuncao = new MaioresDespesasPorFuncao({
    			props: {
    				despesasPorFuncao: /*$store*/ ctx[0].despesaMaioresLiquidadaPorFuncao
    			},
    			$$inline: true
    		});

    	const receitaxdespesa = new ReceitaXDespesa({
    			props: {
    				remessaReceita: /*$store*/ ctx[0].receitaRemessaAtual,
    				remessaDespesa: /*$store*/ ctx[0].despesaRemessaAtual
    			},
    			$$inline: true
    		});

    	const receitaxdespesaevolucaoanual = new ReceitaXDespesaEvolucaoAnual({
    			props: {
    				view: "despesa",
    				receita: /*$store*/ ctx[0].receitaEvolucaoAnual,
    				despesa: /*$store*/ ctx[0].despesaEvolucaoAnual,
    				$$slots: {
    					default: [create_default_slot_2$b],
    					tooltip: [create_tooltip_slot_1],
    					title: [create_title_slot_2$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const comparacaoanoanterior = new ComparacaoAnoAnterior({
    			props: {
    				model: /*$store*/ ctx[0].despesaEvolucaoAnual,
    				seriesProperty: "empenhada",
    				$$slots: { title: [create_title_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaques = new Destaques({ $$inline: true });

    	const receitaxdespesaevolucaomensal = new ReceitaXDespesaEvolucaoMensal({
    			props: {
    				view: "despesa",
    				receita: /*$store*/ ctx[0].receitaEvolucaoMensal,
    				despesa: /*$store*/ ctx[0].despesaEvolucaoMensal,
    				$$slots: {
    					default: [create_default_slot$s],
    					tooltip: [create_tooltip_slot$a],
    					title: [create_title_slot$b]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			div0 = element("div");
    			create_component(prestacaocontamensal.$$.fragment);
    			t1 = space();
    			div8 = element("div");
    			div1 = element("div");
    			create_component(cardliquidada.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			create_component(maioresdespesasporfuncao.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(receitaxdespesa.$$.fragment);
    			t4 = space();
    			div4 = element("div");
    			create_component(receitaxdespesaevolucaoanual.$$.fragment);
    			t5 = space();
    			div5 = element("div");
    			create_component(comparacaoanoanterior.$$.fragment);
    			t6 = space();
    			div6 = element("div");
    			create_component(destaques.$$.fragment);
    			t7 = space();
    			div7 = element("div");
    			create_component(receitaxdespesaevolucaomensal.$$.fragment);
    			document.title = "CIDADES - PLATAFORMA PARA TRANSPARÊNCIA PÚBLICA";
    			attr_dev(div0, "class", "pl-1");
    			add_location(div0, file$R, 60, 0, 2671);
    			attr_dev(div1, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div1, file$R, 65, 2, 2804);
    			attr_dev(div2, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div2, file$R, 69, 2, 2931);
    			attr_dev(div3, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div3, file$R, 74, 2, 3099);
    			attr_dev(div4, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div4, file$R, 80, 2, 3293);
    			attr_dev(div5, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div5, file$R, 94, 2, 3864);
    			attr_dev(div6, "class", "w-full p-1");
    			add_location(div6, file$R, 102, 2, 4145);
    			attr_dev(div7, "class", "w-full p-1");
    			add_location(div7, file$R, 106, 2, 4204);
    			attr_dev(div8, "class", "flex flex-wrap w-full");
    			add_location(div8, file$R, 64, 0, 2765);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(prestacaocontamensal, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div1);
    			mount_component(cardliquidada, div1, null);
    			append_dev(div8, t2);
    			append_dev(div8, div2);
    			mount_component(maioresdespesasporfuncao, div2, null);
    			append_dev(div8, t3);
    			append_dev(div8, div3);
    			mount_component(receitaxdespesa, div3, null);
    			append_dev(div8, t4);
    			append_dev(div8, div4);
    			mount_component(receitaxdespesaevolucaoanual, div4, null);
    			append_dev(div8, t5);
    			append_dev(div8, div5);
    			mount_component(comparacaoanoanterior, div5, null);
    			append_dev(div8, t6);
    			append_dev(div8, div6);
    			mount_component(destaques, div6, null);
    			append_dev(div8, t7);
    			append_dev(div8, div7);
    			mount_component(receitaxdespesaevolucaomensal, div7, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prestacaocontamensal_changes = {};
    			if (dirty & /*$store*/ 1) prestacaocontamensal_changes.model = /*$store*/ ctx[0].prestacaoContaMensal;
    			prestacaocontamensal.$set(prestacaocontamensal_changes);
    			const cardliquidada_changes = {};
    			if (dirty & /*$store*/ 1) cardliquidada_changes.remessa = /*$store*/ ctx[0].despesaRemessaAtual;
    			cardliquidada.$set(cardliquidada_changes);
    			const maioresdespesasporfuncao_changes = {};
    			if (dirty & /*$store*/ 1) maioresdespesasporfuncao_changes.despesasPorFuncao = /*$store*/ ctx[0].despesaMaioresLiquidadaPorFuncao;
    			maioresdespesasporfuncao.$set(maioresdespesasporfuncao_changes);
    			const receitaxdespesa_changes = {};
    			if (dirty & /*$store*/ 1) receitaxdespesa_changes.remessaReceita = /*$store*/ ctx[0].receitaRemessaAtual;
    			if (dirty & /*$store*/ 1) receitaxdespesa_changes.remessaDespesa = /*$store*/ ctx[0].despesaRemessaAtual;
    			receitaxdespesa.$set(receitaxdespesa_changes);
    			const receitaxdespesaevolucaoanual_changes = {};
    			if (dirty & /*$store*/ 1) receitaxdespesaevolucaoanual_changes.receita = /*$store*/ ctx[0].receitaEvolucaoAnual;
    			if (dirty & /*$store*/ 1) receitaxdespesaevolucaoanual_changes.despesa = /*$store*/ ctx[0].despesaEvolucaoAnual;

    			if (dirty & /*$$scope*/ 16) {
    				receitaxdespesaevolucaoanual_changes.$$scope = { dirty, ctx };
    			}

    			receitaxdespesaevolucaoanual.$set(receitaxdespesaevolucaoanual_changes);
    			const comparacaoanoanterior_changes = {};
    			if (dirty & /*$store*/ 1) comparacaoanoanterior_changes.model = /*$store*/ ctx[0].despesaEvolucaoAnual;

    			if (dirty & /*$$scope*/ 16) {
    				comparacaoanoanterior_changes.$$scope = { dirty, ctx };
    			}

    			comparacaoanoanterior.$set(comparacaoanoanterior_changes);
    			const receitaxdespesaevolucaomensal_changes = {};
    			if (dirty & /*$store*/ 1) receitaxdespesaevolucaomensal_changes.receita = /*$store*/ ctx[0].receitaEvolucaoMensal;
    			if (dirty & /*$store*/ 1) receitaxdespesaevolucaomensal_changes.despesa = /*$store*/ ctx[0].despesaEvolucaoMensal;

    			if (dirty & /*$$scope*/ 16) {
    				receitaxdespesaevolucaomensal_changes.$$scope = { dirty, ctx };
    			}

    			receitaxdespesaevolucaomensal.$set(receitaxdespesaevolucaomensal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prestacaocontamensal.$$.fragment, local);
    			transition_in(cardliquidada.$$.fragment, local);
    			transition_in(maioresdespesasporfuncao.$$.fragment, local);
    			transition_in(receitaxdespesa.$$.fragment, local);
    			transition_in(receitaxdespesaevolucaoanual.$$.fragment, local);
    			transition_in(comparacaoanoanterior.$$.fragment, local);
    			transition_in(destaques.$$.fragment, local);
    			transition_in(receitaxdespesaevolucaomensal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prestacaocontamensal.$$.fragment, local);
    			transition_out(cardliquidada.$$.fragment, local);
    			transition_out(maioresdespesasporfuncao.$$.fragment, local);
    			transition_out(receitaxdespesa.$$.fragment, local);
    			transition_out(receitaxdespesaevolucaoanual.$$.fragment, local);
    			transition_out(comparacaoanoanterior.$$.fragment, local);
    			transition_out(destaques.$$.fragment, local);
    			transition_out(receitaxdespesaevolucaomensal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_component(prestacaocontamensal);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div8);
    			destroy_component(cardliquidada);
    			destroy_component(maioresdespesasporfuncao);
    			destroy_component(receitaxdespesa);
    			destroy_component(receitaxdespesaevolucaoanual);
    			destroy_component(comparacaoanoanterior);
    			destroy_component(destaques);
    			destroy_component(receitaxdespesaevolucaomensal);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let $route;
    	let $store;
    	validate_store(route, "route");
    	component_subscribe($$self, route, $$value => $$invalidate(2, $route = $$value));
    	const store = api.createStore();
    	validate_store(store, "store");
    	component_subscribe($$self, store, value => $$invalidate(0, $store = value));

    	async function refresh({ params }) {
    		console.log("despesas");
    		const ano = parseInt(params.ano);
    		const ug = params.ug;
    		const municipio = ug === "consolidado" ? params.municipio : ug;

    		await api.post(
    			api.getApiUrl("DWControleSocial"),
    			prestacaoContaMensal(ano, ug === "consolidado"
    			? municipio + "E0700001"
    			: municipio).concat(despesaEvolucaoAnual(ano, municipio)).concat(despesaEvolucaoMensal(ano, municipio)).concat(despesaLiquidada(ano, municipio)).concat(despesaMaioresLiquidadaPorFuncao(ano, municipio)).concat(despesaPaga(ano, municipio)).concat(despesaPrevisaoInicial(ano, municipio)).concat(receitaEvolucaoAnual(ano, municipio, 6)).concat(receitaEvolucaoMensal(ano, municipio)).concat(receitaPrevisaoInicial(ano, municipio)),
    			{ store }
    		);

    		set_store_value(
    			store,
    			$store.despesaRemessaAtual = {
    				value: $store.despesaEvolucaoAnual.value.find(o => o.ano === ano)
    			},
    			$store
    		);

    		set_store_value(
    			store,
    			$store.receitaRemessaAtual = {
    				value: $store.receitaEvolucaoAnual.value.find(o => o.ano === ano)
    			},
    			$store
    		);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Despesas> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Despesas", $$slots, []);

    	$$self.$capture_state = () => ({
    		route,
    		api,
    		PrestacaoContaMensal,
    		ReceitaXDespesaEvolucaoAnual,
    		ReceitaXDespesaEvolucaoMensal,
    		ReceitaXDespesa,
    		CardLiquidada,
    		ComparacaoAnoAnterior,
    		Destaques,
    		MaioresDespesasPorFuncao,
    		Treemap: Treemap_1,
    		despesaApi,
    		gestaoApi,
    		prestacaoContaApi,
    		receitaApi,
    		store,
    		refresh,
    		$route,
    		$store
    	});

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$route*/ 4) {
    			 refresh($route);
    		}
    	};

    	return [$store, store];
    }

    class Despesas$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Despesas",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\educacao\_components\EvolucaoAnualAplicacao.svelte generated by Svelte v3.22.3 */
    const file$S = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\educacao\\_components\\EvolucaoAnualAplicacao.svelte";

    // (10:4) <span slot="tooltip">
    function create_tooltip_slot$b(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução dos recursos aplicados em educação nos últimos exercícios.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$S, 9, 4, 314);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$b.name,
    		type: "slot",
    		source: "(10:4) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let div;
    	let current;

    	const evolucaoanual = new EvolucaoAnual({
    			props: {
    				model: /*model*/ ctx[0],
    				seriesName: "Aplicação",
    				seriesProperty: "aplicacao",
    				$$slots: { tooltip: [create_tooltip_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(evolucaoanual.$$.fragment);
    			attr_dev(div, "class", "mb-3");
    			add_location(div, file$S, 7, 0, 213);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(evolucaoanual, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const evolucaoanual_changes = {};
    			if (dirty & /*model*/ 1) evolucaoanual_changes.model = /*model*/ ctx[0];

    			if (dirty & /*$$scope*/ 2) {
    				evolucaoanual_changes.$$scope = { dirty, ctx };
    			}

    			evolucaoanual.$set(evolucaoanual_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(evolucaoanual.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(evolucaoanual.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(evolucaoanual);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	const writable_props = ["model"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoAnualAplicacao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoAnualAplicacao", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    	};

    	$$self.$capture_state = () => ({ EvolucaoAnual, Loading, model });

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model];
    }

    class EvolucaoAnualAplicacao extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$W, safe_not_equal, { model: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoAnualAplicacao",
    			options,
    			id: create_fragment$W.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoAnualAplicacao> was created without expected prop 'model'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoAnualAplicacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoAnualAplicacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\educacao\_components\EvolucaoAnualAplicacaoPerCapita.svelte generated by Svelte v3.22.3 */
    const file$T = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\educacao\\_components\\EvolucaoAnualAplicacaoPerCapita.svelte";

    // (74:2) <span slot="title">
    function create_title_slot$c(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução da aplicação em Receita Arrecadada X Educação";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$T, 73, 2, 1405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$c.name,
    		type: "slot",
    		source: "(74:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (77:2) <span slot="tooltip">
    function create_tooltip_slot$c(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Aplicação em educação: recursos aplicados. Receita Total: É o montante total\r\n    em dinheiro incorporado ao patrimônio do município.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$T, 76, 2, 1499);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$c.name,
    		type: "slot",
    		source: "(77:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (73:0) <Widget>
    function create_default_slot$t(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				grid: /*grid*/ ctx[2],
    				xAxis: /*xAxis*/ ctx[1],
    				yAxis: /*yAxis*/ ctx[3],
    				series: /*series*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(series_1.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$T, 80, 2, 1674);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(series_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 2) series_1_changes.xAxis = /*xAxis*/ ctx[1];
    			if (dirty & /*series*/ 1) series_1_changes.series = /*series*/ ctx[0];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(series_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$t.name,
    		type: "slot",
    		source: "(73:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$X(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$t],
    					tooltip: [create_tooltip_slot$c],
    					title: [create_title_slot$c]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, xAxis, series*/ 67) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	const grid = { left: 90 };
    	let series;
    	let xAxis;

    	const yAxis = [
    		{
    			type: "value",
    			name: "Aplicação média nos municípios per capita",
    			axisLabel: { formatter: "R$ {value}" }
    		},
    		{
    			type: "value",
    			name: "Aplicação per capita",
    			axisLabel: { formatter: "R$ {value}" }
    		}
    	];

    	function render(model) {
    		if (!model) {
    			$$invalidate(0, series = null);
    			return;
    		}

    		const anos = [];
    		const aplicacaoPerCapita = [];
    		const mediaMunicipal = [];

    		model.value.forEach(m => {
    			anos.push(m.ano);
    			aplicacaoPerCapita.push(m.aplicacaoPerCapita);
    			mediaMunicipal.push(m.mediaMunicipal);
    		});

    		$$invalidate(1, xAxis = [
    			{
    				type: "category",
    				data: anos,
    				axisPointer: { type: "shadow" }
    			}
    		]);

    		$$invalidate(0, series = [
    			{
    				type: "line",
    				name: "Aplicação média nos municípios per capita",
    				data: mediaMunicipal
    			},
    			{
    				type: "bar",
    				name: "Aplicação per capita",
    				data: aplicacaoPerCapita
    			}
    		]);
    	}

    	const writable_props = ["model"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoAnualAplicacaoPerCapita> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoAnualAplicacaoPerCapita", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(4, model = $$props.model);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Series: Series$1,
    		model,
    		grid,
    		series,
    		xAxis,
    		yAxis,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(4, model = $$props.model);
    		if ("series" in $$props) $$invalidate(0, series = $$props.series);
    		if ("xAxis" in $$props) $$invalidate(1, xAxis = $$props.xAxis);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*model*/ 16) {
    			 render(model);
    		}
    	};

    	return [series, xAxis, grid, yAxis, model];
    }

    class EvolucaoAnualAplicacaoPerCapita extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$X, safe_not_equal, { model: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoAnualAplicacaoPerCapita",
    			options,
    			id: create_fragment$X.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[4] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoAnualAplicacaoPerCapita> was created without expected prop 'model'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoAnualAplicacaoPerCapita>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoAnualAplicacaoPerCapita>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var addCommas$3 = format$1.addCommas;
    var encodeHTML$3 = format$1.encodeHTML;

    function fillLabel(opt) {
      model.defaultEmphasis(opt, 'label', ['show']);
    }

    var MarkerModel = echarts.extendComponentModel({
      type: 'marker',
      dependencies: ['series', 'grid', 'polar', 'geo'],

      /**
       * @overrite
       */
      init: function (option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel);

        this._mergeOption(option, ecModel, false, true);
      },

      /**
       * @return {boolean}
       */
      isAnimationEnabled: function () {
        if (env_1.node) {
          return false;
        }

        var hostSeries = this.__hostSeries;
        return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();
      },

      /**
       * @overrite
       */
      mergeOption: function (newOpt, ecModel) {
        this._mergeOption(newOpt, ecModel, false, false);
      },
      _mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {
        var MarkerModel = this.constructor;
        var modelPropName = this.mainType + 'Model';

        if (!createdBySelf) {
          ecModel.eachSeries(function (seriesModel) {
            var markerOpt = seriesModel.get(this.mainType, true);
            var markerModel = seriesModel[modelPropName];

            if (!markerOpt || !markerOpt.data) {
              seriesModel[modelPropName] = null;
              return;
            }

            if (!markerModel) {
              if (isInit) {
                // Default label emphasis `position` and `show`
                fillLabel(markerOpt);
              }

              util.each(markerOpt.data, function (item) {
                // FIXME Overwrite fillLabel method ?
                if (item instanceof Array) {
                  fillLabel(item[0]);
                  fillLabel(item[1]);
                } else {
                  fillLabel(item);
                }
              });
              markerModel = new MarkerModel(markerOpt, this, ecModel);
              util.extend(markerModel, {
                mainType: this.mainType,
                // Use the same series index and name
                seriesIndex: seriesModel.seriesIndex,
                name: seriesModel.name,
                createdBySelf: true
              });
              markerModel.__hostSeries = seriesModel;
            } else {
              markerModel._mergeOption(markerOpt, ecModel, true);
            }

            seriesModel[modelPropName] = markerModel;
          }, this);
        }
      },
      formatTooltip: function (dataIndex) {
        var data = this.getData();
        var value = this.getRawValue(dataIndex);
        var formattedValue = util.isArray(value) ? util.map(value, addCommas$3).join(', ') : addCommas$3(value);
        var name = data.getName(dataIndex);
        var html = encodeHTML$3(this.name);

        if (value != null || name) {
          html += '<br />';
        }

        if (name) {
          html += encodeHTML$3(name);

          if (value != null) {
            html += ' : ';
          }
        }

        if (value != null) {
          html += encodeHTML$3(formattedValue);
        }

        return html;
      },
      getData: function () {
        return this._data;
      },
      setData: function (data) {
        this._data = data;
      }
    });
    util.mixin(MarkerModel, dataFormat);
    var _default$2g = MarkerModel;
    var MarkerModel_1 = _default$2g;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var _default$2h = MarkerModel_1.extend({
      type: 'markLine',
      defaultOption: {
        zlevel: 0,
        z: 5,
        symbol: ['circle', 'arrow'],
        symbolSize: [8, 16],
        //symbolRotate: 0,
        precision: 2,
        tooltip: {
          trigger: 'item'
        },
        label: {
          show: true,
          position: 'end',
          distance: 5
        },
        lineStyle: {
          type: 'dashed'
        },
        emphasis: {
          label: {
            show: true
          },
          lineStyle: {
            width: 3
          }
        },
        animationEasing: 'linear'
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    var isDimensionStacked$5 = dataStackHelper.isDimensionStacked;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var indexOf$4 = util.indexOf;

    function hasXOrY(item) {
      return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
    }

    function hasXAndY(item) {
      return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
    } // Make it simple, do not visit all stacked value to count precision.
    // function getPrecision(data, valueAxisDim, dataIndex) {
    //     var precision = -1;
    //     var stackedDim = data.mapDimension(valueAxisDim);
    //     do {
    //         precision = Math.max(
    //             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),
    //             precision
    //         );
    //         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
    //         if (stackedOnSeries) {
    //             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);
    //             data = stackedOnSeries.getData();
    //             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);
    //             stackedDim = data.getCalculationInfo('stackedDimension');
    //         }
    //         else {
    //             data = null;
    //         }
    //     } while (data);
    //     return precision;
    // }


    function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
      var coordArr = [];
      var stacked = isDimensionStacked$5(data, targetDataDim
      /*, otherDataDim*/
      );
      var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;
      var value = numCalculate(data, calcDataDim, mlType);
      var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
      coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
      coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
      var coordArrValue = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.

      var precision = number.getPrecision(data.get(targetDataDim, dataIndex));
      precision = Math.min(precision, 20);

      if (precision >= 0) {
        coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
      }

      return [coordArr, coordArrValue];
    }

    var curry$4 = util.curry; // TODO Specified percent

    var markerTypeCalculator = {
      /**
       * @method
       * @param {module:echarts/data/List} data
       * @param {string} baseAxisDim
       * @param {string} valueAxisDim
       */
      min: curry$4(markerTypeCalculatorWithExtent, 'min'),

      /**
       * @method
       * @param {module:echarts/data/List} data
       * @param {string} baseAxisDim
       * @param {string} valueAxisDim
       */
      max: curry$4(markerTypeCalculatorWithExtent, 'max'),

      /**
       * @method
       * @param {module:echarts/data/List} data
       * @param {string} baseAxisDim
       * @param {string} valueAxisDim
       */
      average: curry$4(markerTypeCalculatorWithExtent, 'average')
    };
    /**
     * Transform markPoint data item to format used in List by do the following
     * 1. Calculate statistic like `max`, `min`, `average`
     * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/coord/*} [coordSys]
     * @param  {Object} item
     * @return {Object}
     */

    function dataTransform(seriesModel, item) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly
      // 2. If `coord` is not a data array. Which uses `xAxis`,
      // `yAxis` to specify the coord on each dimension
      // parseFloat first because item.x and item.y can be percent string like '20%'

      if (item && !hasXAndY(item) && !util.isArray(item.coord) && coordSys) {
        var dims = coordSys.dimensions;
        var axisInfo = getAxisInfo$1(item, data, coordSys, seriesModel); // Clone the option
        // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value

        item = util.clone(item);

        if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
          var otherCoordIndex = indexOf$4(dims, axisInfo.baseAxis.dim);
          var targetCoordIndex = indexOf$4(dims, axisInfo.valueAxis.dim);
          var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
          item.coord = coordInfo[0]; // Force to use the value of calculated value.
          // let item use the value without stack.

          item.value = coordInfo[1];
        } else {
          // FIXME Only has one of xAxis and yAxis.
          var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average

          for (var i = 0; i < 2; i++) {
            if (markerTypeCalculator[coord[i]]) {
              coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
            }
          }

          item.coord = coord;
        }
      }

      return item;
    }

    function getAxisInfo$1(item, data, coordSys, seriesModel) {
      var ret = {};

      if (item.valueIndex != null || item.valueDim != null) {
        ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
        ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
        ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
        ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
      } else {
        ret.baseAxis = seriesModel.getBaseAxis();
        ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
        ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
        ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
      }

      return ret;
    }

    function dataDimToCoordDim(seriesModel, dataDim) {
      var data = seriesModel.getData();
      var dimensions = data.dimensions;
      dataDim = data.getDimension(dataDim);

      for (var i = 0; i < dimensions.length; i++) {
        var dimItem = data.getDimensionInfo(dimensions[i]);

        if (dimItem.name === dataDim) {
          return dimItem.coordDim;
        }
      }
    }
    /**
     * Filter data which is out of coordinateSystem range
     * [dataFilter description]
     * @param  {module:echarts/coord/*} [coordSys]
     * @param  {Object} item
     * @return {boolean}
     */


    function dataFilter$1(coordSys, item) {
      // Alwalys return true if there is no coordSys
      return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
    }

    function dimValueGetter(item, dimName, dataIndex, dimIndex) {
      // x, y, radius, angle
      if (dimIndex < 2) {
        return item.coord && item.coord[dimIndex];
      }

      return item.value;
    }

    function numCalculate(data, valueDataDim, type) {
      if (type === 'average') {
        var sum = 0;
        var count = 0;
        data.each(valueDataDim, function (val, idx) {
          if (!isNaN(val)) {
            sum += val;
            count++;
          }
        });
        return sum / count;
      } else if (type === 'median') {
        return data.getMedian(valueDataDim);
      } else {
        // max & min
        return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];
      }
    }

    var dataTransform_1 = dataTransform;
    var getAxisInfo_1$1 = getAxisInfo$1;
    var dataFilter_1 = dataFilter$1;
    var dimValueGetter_1 = dimValueGetter;
    var numCalculate_1 = numCalculate;

    var markerHelper = {
    	dataTransform: dataTransform_1,
    	getAxisInfo: getAxisInfo_1$1,
    	dataFilter: dataFilter_1,
    	dimValueGetter: dimValueGetter_1,
    	numCalculate: numCalculate_1
    };

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * Line path for bezier and straight line draw
     */
    var straightLineProto = graphic.Line.prototype;
    var bezierCurveProto = graphic.BezierCurve.prototype;

    function isLine(shape) {
      return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
    }

    var _default$2i = graphic.extendShape({
      type: 'ec-line',
      style: {
        stroke: '#000',
        fill: null
      },
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        percent: 1,
        cpx1: null,
        cpy1: null
      },
      buildPath: function (ctx, shape) {
        this[isLine(shape) ? '_buildPathLine' : '_buildPathCurve'](ctx, shape);
      },
      _buildPathLine: straightLineProto.buildPath,
      _buildPathCurve: bezierCurveProto.buildPath,
      pointAt: function (t) {
        return this[isLine(this.shape) ? '_pointAtLine' : '_pointAtCurve'](t);
      },
      _pointAtLine: straightLineProto.pointAt,
      _pointAtCurve: bezierCurveProto.pointAt,
      tangentAt: function (t) {
        var shape = this.shape;
        var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : this._tangentAtCurve(t);
        return vector.normalize(p, p);
      },
      _tangentAtCurve: bezierCurveProto.tangentAt
    });

    var LinePath = _default$2i;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */













    var round$4 = number.round;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @module echarts/chart/helper/Line
     */
    var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];

    function makeSymbolTypeKey(symbolCategory) {
      return '_' + symbolCategory + 'Type';
    }
    /**
     * @inner
     */


    function createSymbol$5(name, lineData, idx) {
      var color = lineData.getItemVisual(idx, 'color');
      var symbolType = lineData.getItemVisual(idx, name);
      var symbolSize = lineData.getItemVisual(idx, name + 'Size');

      if (!symbolType || symbolType === 'none') {
        return;
      }

      if (!util.isArray(symbolSize)) {
        symbolSize = [symbolSize, symbolSize];
      }

      var symbolPath = symbol.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);
      symbolPath.name = name;
      return symbolPath;
    }

    function createLine(points) {
      var line = new LinePath({
        name: 'line',
        subPixelOptimize: true
      });
      setLinePoints(line.shape, points);
      return line;
    }

    function setLinePoints(targetShape, points) {
      targetShape.x1 = points[0][0];
      targetShape.y1 = points[0][1];
      targetShape.x2 = points[1][0];
      targetShape.y2 = points[1][1];
      targetShape.percent = 1;
      var cp1 = points[2];

      if (cp1) {
        targetShape.cpx1 = cp1[0];
        targetShape.cpy1 = cp1[1];
      } else {
        targetShape.cpx1 = NaN;
        targetShape.cpy1 = NaN;
      }
    }

    function updateSymbolAndLabelBeforeLineUpdate() {
      var lineGroup = this;
      var symbolFrom = lineGroup.childOfName('fromSymbol');
      var symbolTo = lineGroup.childOfName('toSymbol');
      var label = lineGroup.childOfName('label'); // Quick reject

      if (!symbolFrom && !symbolTo && label.ignore) {
        return;
      }

      var invScale = 1;
      var parentNode = this.parent;

      while (parentNode) {
        if (parentNode.scale) {
          invScale /= parentNode.scale[0];
        }

        parentNode = parentNode.parent;
      }

      var line = lineGroup.childOfName('line'); // If line not changed
      // FIXME Parent scale changed

      if (!this.__dirty && !line.__dirty) {
        return;
      }

      var percent = line.shape.percent;
      var fromPos = line.pointAt(0);
      var toPos = line.pointAt(percent);
      var d = vector.sub([], toPos, fromPos);
      vector.normalize(d, d);

      if (symbolFrom) {
        symbolFrom.attr('position', fromPos);
        var tangent = line.tangentAt(0);
        symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
        symbolFrom.attr('scale', [invScale * percent, invScale * percent]);
      }

      if (symbolTo) {
        symbolTo.attr('position', toPos);
        var tangent = line.tangentAt(1);
        symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
        symbolTo.attr('scale', [invScale * percent, invScale * percent]);
      }

      if (!label.ignore) {
        label.attr('position', toPos);
        var textPosition;
        var textAlign;
        var textVerticalAlign;
        var textOrigin;
        var distance = label.__labelDistance;
        var distanceX = distance[0] * invScale;
        var distanceY = distance[1] * invScale;
        var halfPercent = percent / 2;
        var tangent = line.tangentAt(halfPercent);
        var n = [tangent[1], -tangent[0]];
        var cp = line.pointAt(halfPercent);

        if (n[1] > 0) {
          n[0] = -n[0];
          n[1] = -n[1];
        }

        var dir = tangent[0] < 0 ? -1 : 1;

        if (label.__position !== 'start' && label.__position !== 'end') {
          var rotation = -Math.atan2(tangent[1], tangent[0]);

          if (toPos[0] < fromPos[0]) {
            rotation = Math.PI + rotation;
          }

          label.attr('rotation', rotation);
        }

        var dy;

        switch (label.__position) {
          case 'insideStartTop':
          case 'insideMiddleTop':
          case 'insideEndTop':
          case 'middle':
            dy = -distanceY;
            textVerticalAlign = 'bottom';
            break;

          case 'insideStartBottom':
          case 'insideMiddleBottom':
          case 'insideEndBottom':
            dy = distanceY;
            textVerticalAlign = 'top';
            break;

          default:
            dy = 0;
            textVerticalAlign = 'middle';
        }

        switch (label.__position) {
          case 'end':
            textPosition = [d[0] * distanceX + toPos[0], d[1] * distanceY + toPos[1]];
            textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';
            textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';
            break;

          case 'start':
            textPosition = [-d[0] * distanceX + fromPos[0], -d[1] * distanceY + fromPos[1]];
            textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';
            textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';
            break;

          case 'insideStartTop':
          case 'insideStart':
          case 'insideStartBottom':
            textPosition = [distanceX * dir + fromPos[0], fromPos[1] + dy];
            textAlign = tangent[0] < 0 ? 'right' : 'left';
            textOrigin = [-distanceX * dir, -dy];
            break;

          case 'insideMiddleTop':
          case 'insideMiddle':
          case 'insideMiddleBottom':
          case 'middle':
            textPosition = [cp[0], cp[1] + dy];
            textAlign = 'center';
            textOrigin = [0, -dy];
            break;

          case 'insideEndTop':
          case 'insideEnd':
          case 'insideEndBottom':
            textPosition = [-distanceX * dir + toPos[0], toPos[1] + dy];
            textAlign = tangent[0] >= 0 ? 'right' : 'left';
            textOrigin = [distanceX * dir, -dy];
            break;
        }

        label.attr({
          style: {
            // Use the user specified text align and baseline first
            textVerticalAlign: label.__verticalAlign || textVerticalAlign,
            textAlign: label.__textAlign || textAlign
          },
          position: textPosition,
          scale: [invScale, invScale],
          origin: textOrigin
        });
      }
    }
    /**
     * @constructor
     * @extends {module:zrender/graphic/Group}
     * @alias {module:echarts/chart/helper/Line}
     */


    function Line$1(lineData, idx, seriesScope) {
      graphic.Group.call(this);

      this._createLine(lineData, idx, seriesScope);
    }

    var lineProto = Line$1.prototype; // Update symbol position and rotation

    lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;

    lineProto._createLine = function (lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var linePoints = lineData.getItemLayout(idx);
      var line = createLine(linePoints);
      line.shape.percent = 0;
      graphic.initProps(line, {
        shape: {
          percent: 1
        }
      }, seriesModel, idx);
      this.add(line);
      var label = new graphic.Text({
        name: 'label',
        // FIXME
        // Temporary solution for `focusNodeAdjacency`.
        // line label do not use the opacity of lineStyle.
        lineLabelOriginalOpacity: 1
      });
      this.add(label);
      util.each(SYMBOL_CATEGORIES, function (symbolCategory) {
        var symbol = createSymbol$5(symbolCategory, lineData, idx); // symbols must added after line to make sure
        // it will be updated after line#update.
        // Or symbol position and rotation update in line#beforeUpdate will be one frame slow

        this.add(symbol);
        this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
      }, this);

      this._updateCommonStl(lineData, idx, seriesScope);
    };

    lineProto.updateData = function (lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childOfName('line');
      var linePoints = lineData.getItemLayout(idx);
      var target = {
        shape: {}
      };
      setLinePoints(target.shape, linePoints);
      graphic.updateProps(line, target, seriesModel, idx);
      util.each(SYMBOL_CATEGORIES, function (symbolCategory) {
        var symbolType = lineData.getItemVisual(idx, symbolCategory);
        var key = makeSymbolTypeKey(symbolCategory); // Symbol changed

        if (this[key] !== symbolType) {
          this.remove(this.childOfName(symbolCategory));
          var symbol = createSymbol$5(symbolCategory, lineData, idx);
          this.add(symbol);
        }

        this[key] = symbolType;
      }, this);

      this._updateCommonStl(lineData, idx, seriesScope);
    };

    lineProto._updateCommonStl = function (lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childOfName('line');
      var lineStyle = seriesScope && seriesScope.lineStyle;
      var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
      var labelModel = seriesScope && seriesScope.labelModel;
      var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset

      if (!seriesScope || lineData.hasItemOption) {
        var itemModel = lineData.getItemModel(idx);
        lineStyle = itemModel.getModel('lineStyle').getLineStyle();
        hoverLineStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();
        labelModel = itemModel.getModel('label');
        hoverLabelModel = itemModel.getModel('emphasis.label');
      }

      var visualColor = lineData.getItemVisual(idx, 'color');
      var visualOpacity = util.retrieve3(lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1);
      line.useStyle(util.defaults({
        strokeNoScale: true,
        fill: 'none',
        stroke: visualColor,
        opacity: visualOpacity
      }, lineStyle));
      line.hoverStyle = hoverLineStyle; // Update symbol

      util.each(SYMBOL_CATEGORIES, function (symbolCategory) {
        var symbol = this.childOfName(symbolCategory);

        if (symbol) {
          symbol.setColor(visualColor);
          symbol.setStyle({
            opacity: visualOpacity
          });
        }
      }, this);
      var showLabel = labelModel.getShallow('show');
      var hoverShowLabel = hoverLabelModel.getShallow('show');
      var label = this.childOfName('label');
      var defaultLabelColor;
      var baseText; // FIXME: the logic below probably should be merged to `graphic.setLabelStyle`.

      if (showLabel || hoverShowLabel) {
        defaultLabelColor = visualColor || '#000';
        baseText = seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType);

        if (baseText == null) {
          var rawVal = seriesModel.getRawValue(idx);
          baseText = rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round$4(rawVal) : rawVal;
        }
      }

      var normalText = showLabel ? baseText : null;
      var emphasisText = hoverShowLabel ? util.retrieve2(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), baseText) : null;
      var labelStyle = label.style; // Always set `textStyle` even if `normalStyle.text` is null, because default
      // values have to be set on `normalStyle`.

      if (normalText != null || emphasisText != null) {
        graphic.setTextStyle(label.style, labelModel, {
          text: normalText
        }, {
          autoColor: defaultLabelColor
        });
        label.__textAlign = labelStyle.textAlign;
        label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end'

        label.__position = labelModel.get('position') || 'middle';
        var distance = labelModel.get('distance');

        if (!util.isArray(distance)) {
          distance = [distance, distance];
        }

        label.__labelDistance = distance;
      }

      if (emphasisText != null) {
        // Only these properties supported in this emphasis style here.
        label.hoverStyle = {
          text: emphasisText,
          textFill: hoverLabelModel.getTextColor(true),
          // For merging hover style to normal style, do not use
          // `hoverLabelModel.getFont()` here.
          fontStyle: hoverLabelModel.getShallow('fontStyle'),
          fontWeight: hoverLabelModel.getShallow('fontWeight'),
          fontSize: hoverLabelModel.getShallow('fontSize'),
          fontFamily: hoverLabelModel.getShallow('fontFamily')
        };
      } else {
        label.hoverStyle = {
          text: null
        };
      }

      label.ignore = !showLabel && !hoverShowLabel;
      graphic.setHoverStyle(this);
    };

    lineProto.highlight = function () {
      this.trigger('emphasis');
    };

    lineProto.downplay = function () {
      this.trigger('normal');
    };

    lineProto.updateLayout = function (lineData, idx) {
      this.setLinePoints(lineData.getItemLayout(idx));
    };

    lineProto.setLinePoints = function (points) {
      var linePath = this.childOfName('line');
      setLinePoints(linePath.shape, points);
      linePath.dirty();
    };

    util.inherits(Line$1, graphic.Group);
    var _default$2j = Line$1;
    var Line_1$1 = _default$2j;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

    /**
     * @module echarts/chart/helper/LineDraw
     */
    // import IncrementalDisplayable from 'zrender/src/graphic/IncrementalDisplayable';

    /**
     * @alias module:echarts/component/marker/LineDraw
     * @constructor
     */
    function LineDraw(ctor) {
      this._ctor = ctor || Line_1$1;
      this.group = new graphic.Group();
    }

    var lineDrawProto = LineDraw.prototype;

    lineDrawProto.isPersistent = function () {
      return true;
    };
    /**
     * @param {module:echarts/data/List} lineData
     */


    lineDrawProto.updateData = function (lineData) {
      var lineDraw = this;
      var group = lineDraw.group;
      var oldLineData = lineDraw._lineData;
      lineDraw._lineData = lineData; // There is no oldLineData only when first rendering or switching from
      // stream mode to normal mode, where previous elements should be removed.

      if (!oldLineData) {
        group.removeAll();
      }

      var seriesScope = makeSeriesScope$1(lineData);
      lineData.diff(oldLineData).add(function (idx) {
        doAdd(lineDraw, lineData, idx, seriesScope);
      }).update(function (newIdx, oldIdx) {
        doUpdate(lineDraw, oldLineData, lineData, oldIdx, newIdx, seriesScope);
      }).remove(function (idx) {
        group.remove(oldLineData.getItemGraphicEl(idx));
      }).execute();
    };

    function doAdd(lineDraw, lineData, idx, seriesScope) {
      var itemLayout = lineData.getItemLayout(idx);

      if (!lineNeedsDraw(itemLayout)) {
        return;
      }

      var el = new lineDraw._ctor(lineData, idx, seriesScope);
      lineData.setItemGraphicEl(idx, el);
      lineDraw.group.add(el);
    }

    function doUpdate(lineDraw, oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
      var itemEl = oldLineData.getItemGraphicEl(oldIdx);

      if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
        lineDraw.group.remove(itemEl);
        return;
      }

      if (!itemEl) {
        itemEl = new lineDraw._ctor(newLineData, newIdx, seriesScope);
      } else {
        itemEl.updateData(newLineData, newIdx, seriesScope);
      }

      newLineData.setItemGraphicEl(newIdx, itemEl);
      lineDraw.group.add(itemEl);
    }

    lineDrawProto.updateLayout = function () {
      var lineData = this._lineData; // Do not support update layout in incremental mode.

      if (!lineData) {
        return;
      }

      lineData.eachItemGraphicEl(function (el, idx) {
        el.updateLayout(lineData, idx);
      }, this);
    };

    lineDrawProto.incrementalPrepareUpdate = function (lineData) {
      this._seriesScope = makeSeriesScope$1(lineData);
      this._lineData = null;
      this.group.removeAll();
    };

    function isEffectObject(el) {
      return el.animators && el.animators.length > 0;
    }

    lineDrawProto.incrementalUpdate = function (taskParams, lineData) {
      function updateIncrementalAndHover(el) {
        if (!el.isGroup && !isEffectObject(el)) {
          el.incremental = el.useHoverLayer = true;
        }
      }

      for (var idx = taskParams.start; idx < taskParams.end; idx++) {
        var itemLayout = lineData.getItemLayout(idx);

        if (lineNeedsDraw(itemLayout)) {
          var el = new this._ctor(lineData, idx, this._seriesScope);
          el.traverse(updateIncrementalAndHover);
          this.group.add(el);
          lineData.setItemGraphicEl(idx, el);
        }
      }
    };

    function makeSeriesScope$1(lineData) {
      var hostModel = lineData.hostModel;
      return {
        lineStyle: hostModel.getModel('lineStyle').getLineStyle(),
        hoverLineStyle: hostModel.getModel('emphasis.lineStyle').getLineStyle(),
        labelModel: hostModel.getModel('label'),
        hoverLabelModel: hostModel.getModel('emphasis.label')
      };
    }

    lineDrawProto.remove = function () {
      this._clearIncremental();

      this._incremental = null;
      this.group.removeAll();
    };

    lineDrawProto._clearIncremental = function () {
      var incremental = this._incremental;

      if (incremental) {
        incremental.clearDisplaybles();
      }
    };

    function isPointNaN(pt) {
      return isNaN(pt[0]) || isNaN(pt[1]);
    }

    function lineNeedsDraw(pts) {
      return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
    }

    var _default$2k = LineDraw;
    var LineDraw_1 = _default$2k;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var _default$2l = echarts.extendComponentView({
      type: 'marker',
      init: function () {
        /**
         * Markline grouped by series
         * @private
         * @type {module:zrender/core/util.HashMap}
         */
        this.markerGroupMap = util.createHashMap();
      },
      render: function (markerModel, ecModel, api) {
        var markerGroupMap = this.markerGroupMap;
        markerGroupMap.each(function (item) {
          item.__keep = false;
        });
        var markerModelKey = this.type + 'Model';
        ecModel.eachSeries(function (seriesModel) {
          var markerModel = seriesModel[markerModelKey];
          markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);
        }, this);
        markerGroupMap.each(function (item) {
          !item.__keep && this.group.remove(item.group);
        }, this);
      },
      renderSeries: function () {}
    });

    var MarkerView = _default$2l;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */















    var getStackedDimension$3 = dataStackHelper.getStackedDimension;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var markLineTransform = function (seriesModel, coordSys, mlModel, item) {
      var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average', 'median'

      var mlType = item.type;

      if (!util.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' // In case
      // data: [{
      //   yAxis: 10
      // }]
      || item.xAxis != null || item.yAxis != null)) {
        var valueAxis;
        var value;

        if (item.yAxis != null || item.xAxis != null) {
          valueAxis = coordSys.getAxis(item.yAxis != null ? 'y' : 'x');
          value = util.retrieve(item.yAxis, item.xAxis);
        } else {
          var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
          valueAxis = axisInfo.valueAxis;
          var valueDataDim = getStackedDimension$3(data, axisInfo.valueDataDim);
          value = markerHelper.numCalculate(data, valueDataDim, mlType);
        }

        var valueIndex = valueAxis.dim === 'x' ? 0 : 1;
        var baseIndex = 1 - valueIndex;
        var mlFrom = util.clone(item);
        var mlTo = {};
        mlFrom.type = null;
        mlFrom.coord = [];
        mlTo.coord = [];
        mlFrom.coord[baseIndex] = -Infinity;
        mlTo.coord[baseIndex] = Infinity;
        var precision = mlModel.get('precision');

        if (precision >= 0 && typeof value === 'number') {
          value = +value.toFixed(Math.min(precision, 20));
        }

        mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
        item = [mlFrom, mlTo, {
          // Extra option for tooltip and label
          type: mlType,
          valueIndex: item.valueIndex,
          // Force to use the value of calculated value.
          value: value
        }];
      }

      item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), util.extend({}, item[2])]; // Avoid line data type is extended by from(to) data type

      item[2].type = item[2].type || ''; // Merge from option and to option into line option

      util.merge(item[2], item[0]);
      util.merge(item[2], item[1]);
      return item;
    };

    function isInifinity(val) {
      return !isNaN(val) && !isFinite(val);
    } // If a markLine has one dim


    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
      var otherDimIndex = 1 - dimIndex;
      var dimName = coordSys.dimensions[dimIndex];
      return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
    }

    function markLineFilter(coordSys, item) {
      if (coordSys.type === 'cartesian2d') {
        var fromCoord = item[0].coord;
        var toCoord = item[1].coord; // In case
        // {
        //  markLine: {
        //    data: [{ yAxis: 2 }]
        //  }
        // }

        if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
          return true;
        }
      }

      return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
    }

    function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var itemModel = data.getItemModel(idx);
      var point;
      var xPx = number.parsePercent(itemModel.get('x'), api.getWidth());
      var yPx = number.parsePercent(itemModel.get('y'), api.getHeight());

      if (!isNaN(xPx) && !isNaN(yPx)) {
        point = [xPx, yPx];
      } else {
        // Chart like bar may have there own marker positioning logic
        if (seriesModel.getMarkerPosition) {
          // Use the getMarkerPoisition
          point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
        } else {
          var dims = coordSys.dimensions;
          var x = data.get(dims[0], idx);
          var y = data.get(dims[1], idx);
          point = coordSys.dataToPoint([x, y]);
        } // Expand line to the edge of grid if value on one axis is Inifnity
        // In case
        //  markLine: {
        //    data: [{
        //      yAxis: 2
        //      // or
        //      type: 'average'
        //    }]
        //  }


        if (coordSys.type === 'cartesian2d') {
          var xAxis = coordSys.getAxis('x');
          var yAxis = coordSys.getAxis('y');
          var dims = coordSys.dimensions;

          if (isInifinity(data.get(dims[0], idx))) {
            point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
          } else if (isInifinity(data.get(dims[1], idx))) {
            point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
          }
        } // Use x, y if has any


        if (!isNaN(xPx)) {
          point[0] = xPx;
        }

        if (!isNaN(yPx)) {
          point[1] = yPx;
        }
      }

      data.setItemLayout(idx, point);
    }

    var _default$2m = MarkerView.extend({
      type: 'markLine',
      // updateLayout: function (markLineModel, ecModel, api) {
      //     ecModel.eachSeries(function (seriesModel) {
      //         var mlModel = seriesModel.markLineModel;
      //         if (mlModel) {
      //             var mlData = mlModel.getData();
      //             var fromData = mlModel.__from;
      //             var toData = mlModel.__to;
      //             // Update visual and layout of from symbol and to symbol
      //             fromData.each(function (idx) {
      //                 updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
      //                 updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
      //             });
      //             // Update layout of line
      //             mlData.each(function (idx) {
      //                 mlData.setItemLayout(idx, [
      //                     fromData.getItemLayout(idx),
      //                     toData.getItemLayout(idx)
      //                 ]);
      //             });
      //             this.markerGroupMap.get(seriesModel.id).updateLayout();
      //         }
      //     }, this);
      // },
      updateTransform: function (markLineModel, ecModel, api) {
        ecModel.eachSeries(function (seriesModel) {
          var mlModel = seriesModel.markLineModel;

          if (mlModel) {
            var mlData = mlModel.getData();
            var fromData = mlModel.__from;
            var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol

            fromData.each(function (idx) {
              updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
              updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
            }); // Update layout of line

            mlData.each(function (idx) {
              mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
            });
            this.markerGroupMap.get(seriesModel.id).updateLayout();
          }
        }, this);
      },
      renderSeries: function (seriesModel, mlModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var seriesId = seriesModel.id;
        var seriesData = seriesModel.getData();
        var lineDrawMap = this.markerGroupMap;
        var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw_1());
        this.group.add(lineDraw.group);
        var mlData = createList$1(coordSys, seriesModel, mlModel);
        var fromData = mlData.from;
        var toData = mlData.to;
        var lineData = mlData.line;
        mlModel.__from = fromData;
        mlModel.__to = toData; // Line data for tooltip and formatter

        mlModel.setData(lineData);
        var symbolType = mlModel.get('symbol');
        var symbolSize = mlModel.get('symbolSize');

        if (!util.isArray(symbolType)) {
          symbolType = [symbolType, symbolType];
        }

        if (typeof symbolSize === 'number') {
          symbolSize = [symbolSize, symbolSize];
        } // Update visual and layout of from symbol and to symbol


        mlData.from.each(function (idx) {
          updateDataVisualAndLayout(fromData, idx, true);
          updateDataVisualAndLayout(toData, idx, false);
        }); // Update visual and layout of line

        lineData.each(function (idx) {
          var lineColor = lineData.getItemModel(idx).get('lineStyle.color');
          lineData.setItemVisual(idx, {
            color: lineColor || fromData.getItemVisual(idx, 'color')
          });
          lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
          lineData.setItemVisual(idx, {
            'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),
            'fromSymbol': fromData.getItemVisual(idx, 'symbol'),
            'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),
            'toSymbol': toData.getItemVisual(idx, 'symbol')
          });
        });
        lineDraw.updateData(lineData); // Set host model for tooltip
        // FIXME

        mlData.line.eachItemGraphicEl(function (el, idx) {
          el.traverse(function (child) {
            child.dataModel = mlModel;
          });
        });

        function updateDataVisualAndLayout(data, idx, isFrom) {
          var itemModel = data.getItemModel(idx);
          updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
          data.setItemVisual(idx, {
            symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],
            symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],
            color: itemModel.get('itemStyle.color') || seriesData.getVisual('color')
          });
        }

        lineDraw.__keep = true;
        lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');
      }
    });
    /**
     * @inner
     * @param {module:echarts/coord/*} coordSys
     * @param {module:echarts/model/Series} seriesModel
     * @param {module:echarts/model/Model} mpModel
     */


    function createList$1(coordSys, seriesModel, mlModel) {
      var coordDimsInfos;

      if (coordSys) {
        coordDimsInfos = util.map(coordSys && coordSys.dimensions, function (coordDim) {
          var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

          return util.defaults({
            name: coordDim
          }, info);
        });
      } else {
        coordDimsInfos = [{
          name: 'value',
          type: 'float'
        }];
      }

      var fromData = new List_1(coordDimsInfos, mlModel);
      var toData = new List_1(coordDimsInfos, mlModel); // No dimensions

      var lineData = new List_1([], mlModel);
      var optData = util.map(mlModel.get('data'), util.curry(markLineTransform, seriesModel, coordSys, mlModel));

      if (coordSys) {
        optData = util.filter(optData, util.curry(markLineFilter, coordSys));
      }

      var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {
        return item.value;
      };
      fromData.initData(util.map(optData, function (item) {
        return item[0];
      }), null, dimValueGetter);
      toData.initData(util.map(optData, function (item) {
        return item[1];
      }), null, dimValueGetter);
      lineData.initData(util.map(optData, function (item) {
        return item[2];
      }));
      lineData.hasItemOption = true;
      return {
        from: fromData,
        to: toData,
        line: lineData
      };
    }

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */







    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    echarts.registerPreprocessor(function (opt) {
      // Make sure markLine component is enabled
      opt.markLine = opt.markLine || {};
    });

    /* src\pages\municipio\[ano]\[municipio]\[ug]\educacao\_components\EvolucaoAnualLimiteConstitucional.svelte generated by Svelte v3.22.3 */
    const file$U = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\educacao\\_components\\EvolucaoAnualLimiteConstitucional.svelte";

    // (57:2) <span slot="title">
    function create_title_slot$d(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução do limite constitucional mínimo aplicado em educação";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$U, 56, 2, 1137);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$d.name,
    		type: "slot",
    		source: "(57:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:2) <span slot="tooltip">
    function create_tooltip_slot$d(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução, em percentuais, dos recursos aplicados em educação nos últimos\r\n    exercícios.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$U, 59, 2, 1238);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$d.name,
    		type: "slot",
    		source: "(60:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (56:0) <Widget>
    function create_default_slot$u(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				xAxis: /*xAxis*/ ctx[0],
    				yAxis: /*yAxis*/ ctx[3],
    				series: /*series*/ ctx[1],
    				options: /*options*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(series_1.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$U, 63, 2, 1369);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(series_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 1) series_1_changes.xAxis = /*xAxis*/ ctx[0];
    			if (dirty & /*series*/ 2) series_1_changes.series = /*series*/ ctx[1];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(series_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$u.name,
    		type: "slot",
    		source: "(56:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$u],
    					tooltip: [create_tooltip_slot$d],
    					title: [create_title_slot$d]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, xAxis, series*/ 67) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	const options = { legend: { show: false } };
    	const yAxis = { show: false };
    	let xAxis;
    	let series;

    	function render(model) {
    		if (!model) {
    			return;
    		}

    		const anos = [];
    		const values = [];

    		model.value.forEach(o => {
    			anos.push(o.ano);
    			values.push(o.limiteConstitucional);
    		});

    		$$invalidate(0, xAxis = [
    			{
    				type: "category",
    				data: anos,
    				axisPointer: { type: "shadow" }
    			}
    		]);

    		$$invalidate(1, series = [
    			{
    				type: "bar",
    				xAxisIndex: 0,
    				yAxisIndex: 0,
    				//name: "Aplicação em educação",
    				data: values,
    				markLine: getHorizontalMarkLine(15, "Limite de 15%")
    			}
    		]);
    	}

    	const writable_props = ["model"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoAnualLimiteConstitucional> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoAnualLimiteConstitucional", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(4, model = $$props.model);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		getHorizontalMarkLine,
    		Series: Series$1,
    		model,
    		options,
    		yAxis,
    		xAxis,
    		series,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(4, model = $$props.model);
    		if ("xAxis" in $$props) $$invalidate(0, xAxis = $$props.xAxis);
    		if ("series" in $$props) $$invalidate(1, series = $$props.series);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*model*/ 16) {
    			 render(model);
    		}
    	};

    	return [xAxis, series, options, yAxis, model];
    }

    class EvolucaoAnualLimiteConstitucional extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$Y, safe_not_equal, { model: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoAnualLimiteConstitucional",
    			options,
    			id: create_fragment$Y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[4] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoAnualLimiteConstitucional> was created without expected prop 'model'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoAnualLimiteConstitucional>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoAnualLimiteConstitucional>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\educacao\_components\EvolucaoAnualReceitaXAplicacao.svelte generated by Svelte v3.22.3 */
    const file$V = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\educacao\\_components\\EvolucaoAnualReceitaXAplicacao.svelte";

    // (82:2) <span slot="title">
    function create_title_slot$e(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução da aplicação em Receita Arrecadada X Educação";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$V, 81, 2, 1458);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$e.name,
    		type: "slot",
    		source: "(82:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (85:2) <span slot="tooltip">
    function create_tooltip_slot$e(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Aplicação em educação: recursos aplicados. Receita Total: É o montante total\r\n    em dinheiro incorporado ao patrimônio do município.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$V, 84, 2, 1552);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$e.name,
    		type: "slot",
    		source: "(85:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (81:0) <Widget>
    function create_default_slot$v(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				grid: /*grid*/ ctx[3],
    				xAxis: /*xAxis*/ ctx[2],
    				yAxis: /*yAxis*/ ctx[4],
    				series: /*series*/ ctx[1],
    				legends: /*legends*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(series_1.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$V, 88, 2, 1727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(series_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 4) series_1_changes.xAxis = /*xAxis*/ ctx[2];
    			if (dirty & /*series*/ 2) series_1_changes.series = /*series*/ ctx[1];
    			if (dirty & /*legends*/ 1) series_1_changes.legends = /*legends*/ ctx[0];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(series_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$v.name,
    		type: "slot",
    		source: "(81:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$v],
    					tooltip: [create_tooltip_slot$e],
    					title: [create_title_slot$e]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, xAxis, series, legends*/ 135) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	const grid = { left: 90 };
    	let legends;
    	let series;
    	let xAxis;

    	const yAxis = [
    		{
    			type: "value",
    			name: "Aplicação em educação",
    			axisLabel: { formatter: "R$ {value}" }
    		},
    		{
    			type: "value",
    			name: "Receita arrecadada",
    			axisLabel: { formatter: "R$ {value}" }
    		}
    	];

    	function render(model) {
    		if (!model) {
    			$$invalidate(1, series = null);
    			return;
    		}

    		const anos = [];
    		const aplicacao = [];
    		const arrecadadas = [];

    		model.value.forEach(m => {
    			anos.push(m.ano);
    			aplicacao.push(m.aplicacao);
    			arrecadadas.push(m.arrecadada);
    		});

    		$$invalidate(2, xAxis = [
    			{
    				type: "category",
    				data: anos,
    				axisPointer: { type: "shadow" }
    			}
    		]);

    		$$invalidate(1, series = [
    			{
    				type: "bar",
    				name: "Aplicação em educação",
    				data: aplicacao
    			},
    			{
    				type: "line",
    				name: "Receita arrecadada",
    				data: arrecadadas
    			}
    		]);

    		$$invalidate(0, legends = {
    			data: series.map(s => s.name),
    			selected: { "Receita arrecadada": false }
    		});
    	}

    	const writable_props = ["model"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoAnualReceitaXAplicacao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoAnualReceitaXAplicacao", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(5, model = $$props.model);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Series: Series$1,
    		model,
    		grid,
    		legends,
    		series,
    		xAxis,
    		yAxis,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(5, model = $$props.model);
    		if ("legends" in $$props) $$invalidate(0, legends = $$props.legends);
    		if ("series" in $$props) $$invalidate(1, series = $$props.series);
    		if ("xAxis" in $$props) $$invalidate(2, xAxis = $$props.xAxis);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*model*/ 32) {
    			 render(model);
    		}
    	};

    	return [legends, series, xAxis, grid, yAxis, model];
    }

    class EvolucaoAnualReceitaXAplicacao extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Z, safe_not_equal, { model: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoAnualReceitaXAplicacao",
    			options,
    			id: create_fragment$Z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[5] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoAnualReceitaXAplicacao> was created without expected prop 'model'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoAnualReceitaXAplicacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoAnualReceitaXAplicacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\educacao\_components\CardAplicacao.svelte generated by Svelte v3.22.3 */
    const file$W = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\educacao\\_components\\CardAplicacao.svelte";

    // (10:2) <span slot="title">
    function create_title_slot$f(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Aplicação";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$W, 9, 2, 250);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$f.name,
    		type: "slot",
    		source: "(10:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:2) <span slot="tooltip">
    function create_tooltip_slot$f(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Este é o valor aplicado em manutenção e desenvolvimento do ensino, exceto o\r\n    gasto com remuneração de professores.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$W, 10, 2, 289);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$f.name,
    		type: "slot",
    		source: "(11:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (33:4) {:else}
    function create_else_block$e(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(33:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#if model && posicaoRanking}
    function create_if_block$l(ctx) {
    	let div0;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = /*model*/ ctx[0].value.aplicacao + "";
    	let t2;
    	let t3;
    	let div1;
    	let span2;
    	let t5;
    	let span3;
    	let t6_value = /*model*/ ctx[0].value.mediaMunicipal + "";
    	let t6;
    	let t7;
    	let div2;
    	let span4;
    	let t9;
    	let span5;
    	let t10_value = /*posicaoRanking*/ ctx[1].value + "";
    	let t10;
    	let t11;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "R$";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			span2 = element("span");
    			span2.textContent = "Média municipal";
    			t5 = space();
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			div2 = element("div");
    			span4 = element("span");
    			span4.textContent = "Posição";
    			t9 = space();
    			span5 = element("span");
    			t10 = text(t10_value);
    			t11 = text("º");
    			attr_dev(span0, "class", "text-sm");
    			add_location(span0, file$W, 17, 8, 545);
    			attr_dev(span1, "class", "text-4xl font-bold");
    			add_location(span1, file$W, 18, 8, 586);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$W, 16, 6, 510);
    			attr_dev(span2, "class", "text-base");
    			add_location(span2, file$W, 21, 8, 686);
    			attr_dev(span3, "class", "text-base float-right font-bold");
    			add_location(span3, file$W, 22, 8, 742);
    			add_location(div1, file$W, 20, 6, 671);
    			attr_dev(span4, "class", "text-base");
    			add_location(span4, file$W, 27, 8, 882);
    			attr_dev(span5, "class", "text-base float-right font-bold");
    			add_location(span5, file$W, 28, 8, 930);
    			add_location(div2, file$W, 26, 6, 867);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span2);
    			append_dev(div1, t5);
    			append_dev(div1, span3);
    			append_dev(span3, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, span4);
    			append_dev(div2, t9);
    			append_dev(div2, span5);
    			append_dev(span5, t10);
    			append_dev(span5, t11);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*model*/ 1 && t2_value !== (t2_value = /*model*/ ctx[0].value.aplicacao + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*model*/ 1 && t6_value !== (t6_value = /*model*/ ctx[0].value.mediaMunicipal + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*posicaoRanking*/ 2 && t10_value !== (t10_value = /*posicaoRanking*/ ctx[1].value + "")) set_data_dev(t10, t10_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(16:4) {#if model && posicaoRanking}",
    		ctx
    	});

    	return block;
    }

    // (9:0) <Widget>
    function create_default_slot$w(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$l, create_else_block$e];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*model*/ ctx[0] && /*posicaoRanking*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$W, 14, 2, 449);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$w.name,
    		type: "slot",
    		source: "(9:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$_(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$w],
    					tooltip: [create_tooltip_slot$f],
    					title: [create_title_slot$f]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, posicaoRanking, model*/ 7) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { posicaoRanking } = $$props;
    	const writable_props = ["model", "posicaoRanking"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardAplicacao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("CardAplicacao", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	$$self.$capture_state = () => ({ Loading, Widget, model, posicaoRanking });

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model, posicaoRanking];
    }

    class CardAplicacao extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$_, safe_not_equal, { model: 0, posicaoRanking: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardAplicacao",
    			options,
    			id: create_fragment$_.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<CardAplicacao> was created without expected prop 'model'");
    		}

    		if (/*posicaoRanking*/ ctx[1] === undefined && !("posicaoRanking" in props)) {
    			console.warn("<CardAplicacao> was created without expected prop 'posicaoRanking'");
    		}
    	}

    	get model() {
    		throw new Error("<CardAplicacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<CardAplicacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get posicaoRanking() {
    		throw new Error("<CardAplicacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set posicaoRanking(value) {
    		throw new Error("<CardAplicacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\educacao\_components\CardAplicacaoPerCapita.svelte generated by Svelte v3.22.3 */
    const file$X = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\educacao\\_components\\CardAplicacaoPerCapita.svelte";

    // (10:2) <span slot="title">
    function create_title_slot$g(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Despesa per capita";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$X, 9, 2, 250);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$g.name,
    		type: "slot",
    		source: "(10:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:2) <span slot="tooltip">
    function create_tooltip_slot$g(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "A Constituição Federal estabelece que o município deve aplicar o limite\r\n    mínimo de 25% da receita resultante de impostos, incluídas transferências de\r\n    impostos, para a manutenção e desenvolvimento do ensino.\"}";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$X, 10, 2, 298);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$g.name,
    		type: "slot",
    		source: "(11:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (34:4) {:else}
    function create_else_block$f(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(34:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:4) {#if model && posicaoRanking}
    function create_if_block$m(ctx) {
    	let div0;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = /*model*/ ctx[0].value.despesaPerCapita + "";
    	let t2;
    	let t3;
    	let div1;
    	let span2;
    	let t5;
    	let span3;
    	let t6_value = /*model*/ ctx[0].value.mediaMunicipal + "";
    	let t6;
    	let t7;
    	let div2;
    	let span4;
    	let t9;
    	let span5;
    	let t10_value = /*posicaoRanking*/ ctx[1].value + "";
    	let t10;
    	let t11;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "R$";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			span2 = element("span");
    			span2.textContent = "Média municipal";
    			t5 = space();
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			div2 = element("div");
    			span4 = element("span");
    			span4.textContent = "Posição";
    			t9 = space();
    			span5 = element("span");
    			t10 = text(t10_value);
    			t11 = text("º");
    			attr_dev(span0, "class", "text-sm");
    			add_location(span0, file$X, 18, 8, 653);
    			attr_dev(span1, "class", "text-4xl font-bold");
    			add_location(span1, file$X, 19, 8, 694);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$X, 17, 6, 618);
    			attr_dev(span2, "class", "text-base");
    			add_location(span2, file$X, 22, 8, 801);
    			attr_dev(span3, "class", "text-base float-right font-bold");
    			add_location(span3, file$X, 23, 8, 857);
    			add_location(div1, file$X, 21, 6, 786);
    			attr_dev(span4, "class", "text-base");
    			add_location(span4, file$X, 28, 8, 997);
    			attr_dev(span5, "class", "text-base float-right font-bold");
    			add_location(span5, file$X, 29, 8, 1045);
    			add_location(div2, file$X, 27, 6, 982);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span2);
    			append_dev(div1, t5);
    			append_dev(div1, span3);
    			append_dev(span3, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, span4);
    			append_dev(div2, t9);
    			append_dev(div2, span5);
    			append_dev(span5, t10);
    			append_dev(span5, t11);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*model*/ 1 && t2_value !== (t2_value = /*model*/ ctx[0].value.despesaPerCapita + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*model*/ 1 && t6_value !== (t6_value = /*model*/ ctx[0].value.mediaMunicipal + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*posicaoRanking*/ 2 && t10_value !== (t10_value = /*posicaoRanking*/ ctx[1].value + "")) set_data_dev(t10, t10_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(17:4) {#if model && posicaoRanking}",
    		ctx
    	});

    	return block;
    }

    // (9:0) <Widget>
    function create_default_slot$x(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$m, create_else_block$f];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*model*/ ctx[0] && /*posicaoRanking*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$X, 15, 2, 557);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$x.name,
    		type: "slot",
    		source: "(9:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$$(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$x],
    					tooltip: [create_tooltip_slot$g],
    					title: [create_title_slot$g]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, posicaoRanking, model*/ 7) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { posicaoRanking } = $$props;
    	const writable_props = ["model", "posicaoRanking"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardAplicacaoPerCapita> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("CardAplicacaoPerCapita", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	$$self.$capture_state = () => ({ Loading, Widget, model, posicaoRanking });

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model, posicaoRanking];
    }

    class CardAplicacaoPerCapita extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$$, safe_not_equal, { model: 0, posicaoRanking: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardAplicacaoPerCapita",
    			options,
    			id: create_fragment$$.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<CardAplicacaoPerCapita> was created without expected prop 'model'");
    		}

    		if (/*posicaoRanking*/ ctx[1] === undefined && !("posicaoRanking" in props)) {
    			console.warn("<CardAplicacaoPerCapita> was created without expected prop 'posicaoRanking'");
    		}
    	}

    	get model() {
    		throw new Error("<CardAplicacaoPerCapita>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<CardAplicacaoPerCapita>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get posicaoRanking() {
    		throw new Error("<CardAplicacaoPerCapita>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set posicaoRanking(value) {
    		throw new Error("<CardAplicacaoPerCapita>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var faThumbsUp$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'thumbs-up';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f164';
    var svgPathData = 'M104 224H24c-13.255 0-24 10.745-24 24v240c0 13.255 10.745 24 24 24h80c13.255 0 24-10.745 24-24V248c0-13.255-10.745-24-24-24zM64 472c-13.255 0-24-10.745-24-24s10.745-24 24-24 24 10.745 24 24-10.745 24-24 24zM384 81.452c0 42.416-25.97 66.208-33.277 94.548h101.723c33.397 0 59.397 27.746 59.553 58.098.084 17.938-7.546 37.249-19.439 49.197l-.11.11c9.836 23.337 8.237 56.037-9.308 79.469 8.681 25.895-.069 57.704-16.382 74.757 4.298 17.598 2.244 32.575-6.148 44.632C440.202 511.587 389.616 512 346.839 512l-2.845-.001c-48.287-.017-87.806-17.598-119.56-31.725-15.957-7.099-36.821-15.887-52.651-16.178-6.54-.12-11.783-5.457-11.783-11.998v-213.77c0-3.2 1.282-6.271 3.558-8.521 39.614-39.144 56.648-80.587 89.117-113.111 14.804-14.832 20.188-37.236 25.393-58.902C282.515 39.293 291.817 0 312 0c24 0 72 8 72 81.452z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faThumbsUp = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faThumbsUp$1);
    var faThumbsUp_1$1 = faThumbsUp$1.definition;
    var faThumbsUp_2$1 = faThumbsUp$1.faThumbsUp;
    var faThumbsUp_3$1 = faThumbsUp$1.prefix;
    var faThumbsUp_4$1 = faThumbsUp$1.iconName;
    var faThumbsUp_5$1 = faThumbsUp$1.width;
    var faThumbsUp_6$1 = faThumbsUp$1.height;
    var faThumbsUp_7$1 = faThumbsUp$1.ligatures;
    var faThumbsUp_8$1 = faThumbsUp$1.unicode;
    var faThumbsUp_9$1 = faThumbsUp$1.svgPathData;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */





    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var GaugeSeries = Series.extend({
      type: 'series.gauge',
      getInitialData: function (option, ecModel) {
        return createListSimply(this, ['value']);
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        // 默认全局居中
        center: ['50%', '50%'],
        legendHoverLink: true,
        radius: '75%',
        startAngle: 225,
        endAngle: -45,
        clockwise: true,
        // 最小值
        min: 0,
        // 最大值
        max: 100,
        // 分割段数，默认为10
        splitNumber: 10,
        // 坐标轴线
        axisLine: {
          // 默认显示，属性show控制显示与否
          show: true,
          lineStyle: {
            // 属性lineStyle控制线条样式
            color: [[0.2, '#91c7ae'], [0.8, '#63869e'], [1, '#c23531']],
            width: 30
          }
        },
        // 分隔线
        splitLine: {
          // 默认显示，属性show控制显示与否
          show: true,
          // 属性length控制线长
          length: 30,
          // 属性lineStyle（详见lineStyle）控制线条样式
          lineStyle: {
            color: '#eee',
            width: 2,
            type: 'solid'
          }
        },
        // 坐标轴小标记
        axisTick: {
          // 属性show控制显示与否，默认不显示
          show: true,
          // 每份split细分多少段
          splitNumber: 5,
          // 属性length控制线长
          length: 8,
          // 属性lineStyle控制线条样式
          lineStyle: {
            color: '#eee',
            width: 1,
            type: 'solid'
          }
        },
        axisLabel: {
          show: true,
          distance: 5,
          // formatter: null,
          color: 'auto'
        },
        pointer: {
          show: true,
          length: '80%',
          width: 8
        },
        itemStyle: {
          color: 'auto'
        },
        title: {
          show: true,
          // x, y，单位px
          offsetCenter: [0, '-40%'],
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: '#333',
          fontSize: 15
        },
        detail: {
          show: true,
          backgroundColor: 'rgba(0,0,0,0)',
          borderWidth: 0,
          borderColor: '#ccc',
          width: 100,
          height: null,
          // self-adaption
          padding: [5, 10],
          // x, y，单位px
          offsetCenter: [0, '40%'],
          // formatter: null,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: 'auto',
          fontSize: 30
        }
      }
    });

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */



    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    var _default$2n = Path_1.extend({
      type: 'echartsGaugePointer',
      shape: {
        angle: 0,
        width: 10,
        r: 10,
        x: 0,
        y: 0
      },
      buildPath: function (ctx, shape) {
        var mathCos = Math.cos;
        var mathSin = Math.sin;
        var r = shape.r;
        var width = shape.width;
        var angle = shape.angle;
        var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);
        var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);
        angle = shape.angle - Math.PI / 2;
        ctx.moveTo(x, y);
        ctx.lineTo(shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width);
        ctx.lineTo(shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r);
        ctx.lineTo(shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width);
        ctx.lineTo(x, y);
        return;
      }
    });

    var PointerPath = _default$2n;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */









    var parsePercent$9 = number.parsePercent;
    var round$5 = number.round;
    var linearMap$4 = number.linearMap;

    /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
    function parsePosition(seriesModel, api) {
      var center = seriesModel.get('center');
      var width = api.getWidth();
      var height = api.getHeight();
      var size = Math.min(width, height);
      var cx = parsePercent$9(center[0], api.getWidth());
      var cy = parsePercent$9(center[1], api.getHeight());
      var r = parsePercent$9(seriesModel.get('radius'), size / 2);
      return {
        cx: cx,
        cy: cy,
        r: r
      };
    }

    function formatLabel(label, labelFormatter) {
      if (labelFormatter) {
        if (typeof labelFormatter === 'string') {
          label = labelFormatter.replace('{value}', label != null ? label : '');
        } else if (typeof labelFormatter === 'function') {
          label = labelFormatter(label);
        }
      }

      return label;
    }

    var PI2$5 = Math.PI * 2;
    var GaugeView = Chart_1.extend({
      type: 'gauge',
      render: function (seriesModel, ecModel, api) {
        this.group.removeAll();
        var colorList = seriesModel.get('axisLine.lineStyle.color');
        var posInfo = parsePosition(seriesModel, api);

        this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
      },
      dispose: function () {},
      _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {
        var group = this.group;
        var axisLineModel = seriesModel.getModel('axisLine');
        var lineStyleModel = axisLineModel.getModel('lineStyle');
        var clockwise = seriesModel.get('clockwise');
        var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;
        var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;
        var angleRangeSpan = (endAngle - startAngle) % PI2$5;
        var prevEndAngle = startAngle;
        var axisLineWidth = lineStyleModel.get('width');
        var showAxis = axisLineModel.get('show');

        for (var i = 0; showAxis && i < colorList.length; i++) {
          // Clamp
          var percent = Math.min(Math.max(colorList[i][0], 0), 1);
          var endAngle = startAngle + angleRangeSpan * percent;
          var sector = new graphic.Sector({
            shape: {
              startAngle: prevEndAngle,
              endAngle: endAngle,
              cx: posInfo.cx,
              cy: posInfo.cy,
              clockwise: clockwise,
              r0: posInfo.r - axisLineWidth,
              r: posInfo.r
            },
            silent: true
          });
          sector.setStyle({
            fill: colorList[i][1]
          });
          sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ['color', 'borderWidth', 'borderColor']));
          group.add(sector);
          prevEndAngle = endAngle;
        }

        var getColor = function (percent) {
          // Less than 0
          if (percent <= 0) {
            return colorList[0][1];
          }

          for (var i = 0; i < colorList.length; i++) {
            if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {
              return colorList[i][1];
            }
          } // More than 1


          return colorList[i - 1][1];
        };

        if (!clockwise) {
          var tmp = startAngle;
          startAngle = endAngle;
          endAngle = tmp;
        }

        this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);

        this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);

        this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);

        this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);
      },
      _renderTicks: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
        var group = this.group;
        var cx = posInfo.cx;
        var cy = posInfo.cy;
        var r = posInfo.r;
        var minVal = +seriesModel.get('min');
        var maxVal = +seriesModel.get('max');
        var splitLineModel = seriesModel.getModel('splitLine');
        var tickModel = seriesModel.getModel('axisTick');
        var labelModel = seriesModel.getModel('axisLabel');
        var splitNumber = seriesModel.get('splitNumber');
        var subSplitNumber = tickModel.get('splitNumber');
        var splitLineLen = parsePercent$9(splitLineModel.get('length'), r);
        var tickLen = parsePercent$9(tickModel.get('length'), r);
        var angle = startAngle;
        var step = (endAngle - startAngle) / splitNumber;
        var subStep = step / subSplitNumber;
        var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();
        var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();

        for (var i = 0; i <= splitNumber; i++) {
          var unitX = Math.cos(angle);
          var unitY = Math.sin(angle); // Split line

          if (splitLineModel.get('show')) {
            var splitLine = new graphic.Line({
              shape: {
                x1: unitX * r + cx,
                y1: unitY * r + cy,
                x2: unitX * (r - splitLineLen) + cx,
                y2: unitY * (r - splitLineLen) + cy
              },
              style: splitLineStyle,
              silent: true
            });

            if (splitLineStyle.stroke === 'auto') {
              splitLine.setStyle({
                stroke: getColor(i / splitNumber)
              });
            }

            group.add(splitLine);
          } // Label


          if (labelModel.get('show')) {
            var label = formatLabel(round$5(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));
            var distance = labelModel.get('distance');
            var autoColor = getColor(i / splitNumber);
            group.add(new graphic.Text({
              style: graphic.setTextStyle({}, labelModel, {
                text: label,
                x: unitX * (r - splitLineLen - distance) + cx,
                y: unitY * (r - splitLineLen - distance) + cy,
                textVerticalAlign: unitY < -0.4 ? 'top' : unitY > 0.4 ? 'bottom' : 'middle',
                textAlign: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'
              }, {
                autoColor: autoColor
              }),
              silent: true
            }));
          } // Axis tick


          if (tickModel.get('show') && i !== splitNumber) {
            for (var j = 0; j <= subSplitNumber; j++) {
              var unitX = Math.cos(angle);
              var unitY = Math.sin(angle);
              var tickLine = new graphic.Line({
                shape: {
                  x1: unitX * r + cx,
                  y1: unitY * r + cy,
                  x2: unitX * (r - tickLen) + cx,
                  y2: unitY * (r - tickLen) + cy
                },
                silent: true,
                style: tickLineStyle
              });

              if (tickLineStyle.stroke === 'auto') {
                tickLine.setStyle({
                  stroke: getColor((i + j / subSplitNumber) / splitNumber)
                });
              }

              group.add(tickLine);
              angle += subStep;
            }

            angle -= subStep;
          } else {
            angle += step;
          }
        }
      },
      _renderPointer: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
        var group = this.group;
        var oldData = this._data;

        if (!seriesModel.get('pointer.show')) {
          // Remove old element
          oldData && oldData.eachItemGraphicEl(function (el) {
            group.remove(el);
          });
          return;
        }

        var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];
        var angleExtent = [startAngle, endAngle];
        var data = seriesModel.getData();
        var valueDim = data.mapDimension('value');
        data.diff(oldData).add(function (idx) {
          var pointer = new PointerPath({
            shape: {
              angle: startAngle
            }
          });
          graphic.initProps(pointer, {
            shape: {
              angle: linearMap$4(data.get(valueDim, idx), valueExtent, angleExtent, true)
            }
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(idx, pointer);
        }).update(function (newIdx, oldIdx) {
          var pointer = oldData.getItemGraphicEl(oldIdx);
          graphic.updateProps(pointer, {
            shape: {
              angle: linearMap$4(data.get(valueDim, newIdx), valueExtent, angleExtent, true)
            }
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(newIdx, pointer);
        }).remove(function (idx) {
          var pointer = oldData.getItemGraphicEl(idx);
          group.remove(pointer);
        }).execute();
        data.eachItemGraphicEl(function (pointer, idx) {
          var itemModel = data.getItemModel(idx);
          var pointerModel = itemModel.getModel('pointer');
          pointer.setShape({
            x: posInfo.cx,
            y: posInfo.cy,
            width: parsePercent$9(pointerModel.get('width'), posInfo.r),
            r: parsePercent$9(pointerModel.get('length'), posInfo.r)
          });
          pointer.useStyle(itemModel.getModel('itemStyle').getItemStyle());

          if (pointer.style.fill === 'auto') {
            pointer.setStyle('fill', getColor(linearMap$4(data.get(valueDim, idx), valueExtent, [0, 1], true)));
          }

          graphic.setHoverStyle(pointer, itemModel.getModel('emphasis.itemStyle').getItemStyle());
        });
        this._data = data;
      },
      _renderTitle: function (seriesModel, ecModel, api, getColor, posInfo) {
        var data = seriesModel.getData();
        var valueDim = data.mapDimension('value');
        var titleModel = seriesModel.getModel('title');

        if (titleModel.get('show')) {
          var offsetCenter = titleModel.get('offsetCenter');
          var x = posInfo.cx + parsePercent$9(offsetCenter[0], posInfo.r);
          var y = posInfo.cy + parsePercent$9(offsetCenter[1], posInfo.r);
          var minVal = +seriesModel.get('min');
          var maxVal = +seriesModel.get('max');
          var value = seriesModel.getData().get(valueDim, 0);
          var autoColor = getColor(linearMap$4(value, [minVal, maxVal], [0, 1], true));
          this.group.add(new graphic.Text({
            silent: true,
            style: graphic.setTextStyle({}, titleModel, {
              x: x,
              y: y,
              // FIXME First data name ?
              text: data.getName(0),
              textAlign: 'center',
              textVerticalAlign: 'middle'
            }, {
              autoColor: autoColor,
              forceRich: true
            })
          }));
        }
      },
      _renderDetail: function (seriesModel, ecModel, api, getColor, posInfo) {
        var detailModel = seriesModel.getModel('detail');
        var minVal = +seriesModel.get('min');
        var maxVal = +seriesModel.get('max');

        if (detailModel.get('show')) {
          var offsetCenter = detailModel.get('offsetCenter');
          var x = posInfo.cx + parsePercent$9(offsetCenter[0], posInfo.r);
          var y = posInfo.cy + parsePercent$9(offsetCenter[1], posInfo.r);
          var width = parsePercent$9(detailModel.get('width'), posInfo.r);
          var height = parsePercent$9(detailModel.get('height'), posInfo.r);
          var data = seriesModel.getData();
          var value = data.get(data.mapDimension('value'), 0);
          var autoColor = getColor(linearMap$4(value, [minVal, maxVal], [0, 1], true));
          this.group.add(new graphic.Text({
            silent: true,
            style: graphic.setTextStyle({}, detailModel, {
              x: x,
              y: y,
              text: formatLabel( // FIXME First data name ?
              value, detailModel.get('formatter')),
              textWidth: isNaN(width) ? null : width,
              textHeight: isNaN(height) ? null : height,
              textAlign: 'center',
              textVerticalAlign: 'middle'
            }, {
              autoColor: autoColor,
              forceRich: true
            })
          }));
        }
      }
    });

    /* src\components\Chart\Gauge.svelte generated by Svelte v3.22.3 */
    const file$Y = "src\\components\\Chart\\Gauge.svelte";

    // (85:0) {:else}
    function create_else_block$g(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(85:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (78:0) {#if serie}
    function create_if_block$n(ctx) {
    	let div1;
    	let t;
    	let div0;
    	let current;
    	let chart_1_props = {};
    	const chart_1 = new Chart$1({ props: chart_1_props, $$inline: true });
    	/*chart_1_binding*/ ctx[5](chart_1);
    	chart_1.$on("render", /*onRender*/ ctx[2]);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			t = text(" \r\n    ");
    			div0 = element("div");
    			create_component(chart_1.$$.fragment);
    			set_style(div0, "margin-top", "-15px");
    			set_style(div0, "height", "100%");
    			add_location(div0, file$Y, 80, 4, 1776);
    			attr_dev(div1, "class", "h-full");
    			add_location(div1, file$Y, 78, 2, 1738);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			mount_component(chart_1, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const chart_1_changes = {};
    			chart_1.$set(chart_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chart_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chart_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*chart_1_binding*/ ctx[5](null);
    			destroy_component(chart_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(78:0) {#if serie}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$n, create_else_block$g];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*serie*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { serie } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { options = undefined } = $$props;

    	let chart = {
    		update: () => {
    			
    		}
    	};

    	function onRender({ detail: chart }) {
    		chart.showLoading();

    		chart.setOption({
    			tooltip: { formatter: "{c} {b}", ...tooltip },
    			series: [
    				{
    					type: "gauge",
    					min: 0,
    					max: 100,
    					startAngle: 180,
    					endAngle: 0,
    					radius: "100%",
    					splitNumber: 1,
    					axisLabel: { show: false },
    					axisLine: { lineStyle: { width: 35 } },
    					axisTick: { show: false },
    					itemStyle: { color: "#000" },
    					pointer: { length: "90%" },
    					splitLine: { show: false },
    					detail: {
    						formatter(value) {
    							value = (value + "").split(".");
    							value.length < 2 && value.push("00");
    							return ("00" + value[0]).slice(-2) + "." + (value[1] + "00").slice(0, 2);
    						},
    						color: "#000",
    						fontWeight: "normal",
    						fontSize: 14
    					},
    					...serie
    				}
    			],
    			...options
    		});

    		chart.hideLoading();
    	}

    	const writable_props = ["serie", "tooltip", "options"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Gauge> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Gauge", $$slots, []);

    	function chart_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(1, chart = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("serie" in $$props) $$invalidate(0, serie = $$props.serie);
    		if ("tooltip" in $$props) $$invalidate(3, tooltip = $$props.tooltip);
    		if ("options" in $$props) $$invalidate(4, options = $$props.options);
    	};

    	$$self.$capture_state = () => ({
    		Loading,
    		Chart: Chart$1,
    		serie,
    		tooltip,
    		options,
    		chart,
    		onRender
    	});

    	$$self.$inject_state = $$props => {
    		if ("serie" in $$props) $$invalidate(0, serie = $$props.serie);
    		if ("tooltip" in $$props) $$invalidate(3, tooltip = $$props.tooltip);
    		if ("options" in $$props) $$invalidate(4, options = $$props.options);
    		if ("chart" in $$props) $$invalidate(1, chart = $$props.chart);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*serie, options, chart*/ 19) {
    			 if (serie || options) {
    				chart.update();
    			}
    		}
    	};

    	return [serie, chart, onRender, tooltip, options, chart_1_binding];
    }

    class Gauge extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$10, safe_not_equal, { serie: 0, tooltip: 3, options: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Gauge",
    			options,
    			id: create_fragment$10.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*serie*/ ctx[0] === undefined && !("serie" in props)) {
    			console.warn("<Gauge> was created without expected prop 'serie'");
    		}
    	}

    	get serie() {
    		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set serie(value) {
    		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\_components\LimiteConstitucionalEducacao.svelte generated by Svelte v3.22.3 */
    const file$Z = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\_components\\LimiteConstitucionalEducacao.svelte";

    // (37:2) <span slot="title">
    function create_title_slot$h(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Educação";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$Z, 36, 2, 969);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$h.name,
    		type: "slot",
    		source: "(37:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:2) <span slot="tooltip">
    function create_tooltip_slot$h(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "A Constituição Federal estabelece que o município deve aplicar o limite\r\n    mínimo de 25% da receita resultante de impostos, incluídas transferências de\r\n    impostos, para a manutenção e desenvolvimento do ensino.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$Z, 37, 2, 1007);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$h.name,
    		type: "slot",
    		source: "(38:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (54:4) {:else}
    function create_else_block$h(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(54:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (44:4) {#if limite}
    function create_if_block$o(ctx) {
    	let div1;
    	let span;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let div0;
    	let current;

    	const icon = new Icon({
    			props: { icon: faThumbsUp_2$1 },
    			$$inline: true
    		});

    	const gauge = new Gauge({
    			props: { serie: /*serie*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			span = element("span");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			t1 = text(/*limite*/ ctx[0]);
    			t2 = text(" %");
    			t3 = space();
    			div0 = element("div");
    			create_component(gauge.$$.fragment);
    			attr_dev(span, "class", "text-3xl");
    			add_location(span, file$Z, 45, 8, 1356);
    			attr_dev(div0, "class", "h-full");
    			set_style(div0, "margin-top", "-.8em");
    			add_location(div0, file$Z, 49, 8, 1466);
    			attr_dev(div1, "class", "text-center h-full");
    			add_location(div1, file$Z, 44, 6, 1314);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			mount_component(icon, span, null);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			mount_component(gauge, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*limite*/ 1) set_data_dev(t1, /*limite*/ ctx[0]);
    			const gauge_changes = {};
    			if (dirty & /*serie*/ 4) gauge_changes.serie = /*serie*/ ctx[2];
    			gauge.$set(gauge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			transition_in(gauge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			transition_out(gauge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(icon);
    			destroy_component(gauge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(44:4) {#if limite}",
    		ctx
    	});

    	return block;
    }

    // (36:0) <Widget>
    function create_default_slot$y(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let div_class_value;
    	let current;
    	const if_block_creators = [create_if_block$o, create_else_block$h];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*limite*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", div_class_value = "h-" + /*height*/ ctx[1]);
    			add_location(div, file$Z, 42, 2, 1264);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (!current || dirty & /*height*/ 2 && div_class_value !== (div_class_value = "h-" + /*height*/ ctx[1])) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$y.name,
    		type: "slot",
    		source: "(36:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$11(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$y],
    					tooltip: [create_tooltip_slot$h],
    					title: [create_title_slot$h]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, height, serie, limite*/ 15) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let { limite } = $$props;
    	let { height = 40 } = $$props;
    	let serie = null;
    	const writable_props = ["limite", "height"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LimiteConstitucionalEducacao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LimiteConstitucionalEducacao", $$slots, []);

    	$$self.$set = $$props => {
    		if ("limite" in $$props) $$invalidate(0, limite = $$props.limite);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		faThumbsUp: faThumbsUp_2$1,
    		Loading,
    		Gauge,
    		Widget,
    		limite,
    		height,
    		serie
    	});

    	$$self.$inject_state = $$props => {
    		if ("limite" in $$props) $$invalidate(0, limite = $$props.limite);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    		if ("serie" in $$props) $$invalidate(2, serie = $$props.serie);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*limite*/ 1) {
    			 $$invalidate(2, serie = {
    				title: { show: false },
    				axisLine: {
    					lineStyle: {
    						width: 35,
    						color: [[0.25, "#e68465"], [1, "#617e8c"]]
    					}
    				},
    				detail: {
    					formatter() {
    						return limite > 25
    						? "Obedeceu o limite mínimo anual de 25% da receita"
    						: "Não obedeceu o limite mínimo de 25% da receita";
    					},
    					color: "#000",
    					fontWeight: "normal",
    					fontSize: 14
    				},
    				data: [{ name: "%", value: limite }]
    			});
    		}
    	};

    	return [limite, height, serie];
    }

    class LimiteConstitucionalEducacao extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$11, safe_not_equal, { limite: 0, height: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LimiteConstitucionalEducacao",
    			options,
    			id: create_fragment$11.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*limite*/ ctx[0] === undefined && !("limite" in props)) {
    			console.warn("<LimiteConstitucionalEducacao> was created without expected prop 'limite'");
    		}
    	}

    	get limite() {
    		throw new Error("<LimiteConstitucionalEducacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limite(value) {
    		throw new Error("<LimiteConstitucionalEducacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LimiteConstitucionalEducacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LimiteConstitucionalEducacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function educacaoEvolucaoAnual(ano, municipio, quantidade = 5) {
      return [
        {
          id: "educacaoEvolucaoAnual",
          run: "Municipio.Educacao.FiltrarPorCodigo",
          args: [municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Educacao.EvolucaoAnual",
          args: [ano, quantidade]
        }
      ];
    }

    function educacaoEvolucaoAnualPerCapita(ano, municipio, quantidade = 5) {
      return [
        {
          id: "educacaoEvolucaoAnualPerCapita",
          run: "Municipio.Educacao.FiltrarPorCodigo",
          args: [municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Educacao.EvolucaoAnualPerCapita",
          args: [ano, quantidade]
        }
      ];
    }

    function educacaoRankingAplicacao(ano, municipio) {
      return [
        {
          id: "educacaoRankingAplicacao",
          run: "Municipio.Educacao.RankingAplicacao",
          args: [ano, municipio]
        }
      ];
    }

    function educacaoRankingAplicacaoPerCapita(ano, municipio) {
      return [
        {
          id: "educacaoRankingAplicacaoPerCapita",
          run: "Municipio.Educacao.RankingAplicacaoPerCapita",
          args: [ano, municipio]
        }
      ];
    }

    var educacaoApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        educacaoEvolucaoAnual: educacaoEvolucaoAnual,
        educacaoEvolucaoAnualPerCapita: educacaoEvolucaoAnualPerCapita,
        educacaoRankingAplicacao: educacaoRankingAplicacao,
        educacaoRankingAplicacaoPerCapita: educacaoRankingAplicacaoPerCapita
    });

    /* src\pages\municipio\[ano]\[municipio]\[ug]\educacao\index.svelte generated by Svelte v3.22.3 */
    const file$_ = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\educacao\\index.svelte";

    function create_fragment$12(ctx) {
    	let t0;
    	let div0;
    	let t1;
    	let div8;
    	let div1;
    	let t2;
    	let div2;
    	let t3;
    	let div3;
    	let t4;
    	let div4;
    	let t5;
    	let div5;
    	let t6;
    	let div6;
    	let t7;
    	let div7;
    	let current;

    	const prestacaocontamensal = new PrestacaoContaMensal({
    			props: { model: /*data*/ ctx[0].prestacaoContaPCB },
    			$$inline: true
    		});

    	const cardaplicacao = new CardAplicacao({
    			props: {
    				model: /*data*/ ctx[0].educacaoAplicacao,
    				posicaoRanking: /*data*/ ctx[0].educacaoRankingAplicacao
    			},
    			$$inline: true
    		});

    	const cardaplicacaopercapita = new CardAplicacaoPerCapita({
    			props: {
    				model: /*data*/ ctx[0].educacaoAplicacaoPerCapita,
    				posicaoRanking: /*data*/ ctx[0].educacaoRankingAplicacaoPerCapita
    			},
    			$$inline: true
    		});

    	const limiteconstitucionaleducacao = new LimiteConstitucionalEducacao({
    			props: { limite: /*limite*/ ctx[1], height: 48 },
    			$$inline: true
    		});

    	const evolucaoanualaplicacao = new EvolucaoAnualAplicacao({
    			props: {
    				model: /*data*/ ctx[0].educacaoEvolucaoAnual
    			},
    			$$inline: true
    		});

    	const evolucaoanualreceitaxaplicacao = new EvolucaoAnualReceitaXAplicacao({
    			props: {
    				model: /*data*/ ctx[0].educacaoEvolucaoAnual
    			},
    			$$inline: true
    		});

    	const evolucaoanuallimiteconstitucional = new EvolucaoAnualLimiteConstitucional({
    			props: {
    				model: /*data*/ ctx[0].educacaoEvolucaoAnual
    			},
    			$$inline: true
    		});

    	const evolucaoanualaplicacaopercapita = new EvolucaoAnualAplicacaoPerCapita({
    			props: {
    				model: /*data*/ ctx[0].educacaoEvolucaoAnualPerCapita
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			div0 = element("div");
    			create_component(prestacaocontamensal.$$.fragment);
    			t1 = space();
    			div8 = element("div");
    			div1 = element("div");
    			create_component(cardaplicacao.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			create_component(cardaplicacaopercapita.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(limiteconstitucionaleducacao.$$.fragment);
    			t4 = space();
    			div4 = element("div");
    			create_component(evolucaoanualaplicacao.$$.fragment);
    			t5 = space();
    			div5 = element("div");
    			create_component(evolucaoanualreceitaxaplicacao.$$.fragment);
    			t6 = space();
    			div6 = element("div");
    			create_component(evolucaoanuallimiteconstitucional.$$.fragment);
    			t7 = space();
    			div7 = element("div");
    			create_component(evolucaoanualaplicacaopercapita.$$.fragment);
    			document.title = "Educação";
    			attr_dev(div0, "class", "pl-1");
    			add_location(div0, file$_, 71, 0, 2585);
    			attr_dev(div1, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div1, file$_, 76, 2, 2713);
    			attr_dev(div2, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div2, file$_, 82, 2, 2895);
    			attr_dev(div3, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div3, file$_, 88, 2, 3104);
    			attr_dev(div4, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div4, file$_, 92, 2, 3230);
    			attr_dev(div5, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div5, file$_, 96, 2, 3364);
    			attr_dev(div6, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div6, file$_, 100, 2, 3506);
    			attr_dev(div7, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div7, file$_, 104, 2, 3651);
    			attr_dev(div8, "class", "flex flex-wrap w-full");
    			add_location(div8, file$_, 75, 0, 2674);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(prestacaocontamensal, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div1);
    			mount_component(cardaplicacao, div1, null);
    			append_dev(div8, t2);
    			append_dev(div8, div2);
    			mount_component(cardaplicacaopercapita, div2, null);
    			append_dev(div8, t3);
    			append_dev(div8, div3);
    			mount_component(limiteconstitucionaleducacao, div3, null);
    			append_dev(div8, t4);
    			append_dev(div8, div4);
    			mount_component(evolucaoanualaplicacao, div4, null);
    			append_dev(div8, t5);
    			append_dev(div8, div5);
    			mount_component(evolucaoanualreceitaxaplicacao, div5, null);
    			append_dev(div8, t6);
    			append_dev(div8, div6);
    			mount_component(evolucaoanuallimiteconstitucional, div6, null);
    			append_dev(div8, t7);
    			append_dev(div8, div7);
    			mount_component(evolucaoanualaplicacaopercapita, div7, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prestacaocontamensal_changes = {};
    			if (dirty & /*data*/ 1) prestacaocontamensal_changes.model = /*data*/ ctx[0].prestacaoContaPCB;
    			prestacaocontamensal.$set(prestacaocontamensal_changes);
    			const cardaplicacao_changes = {};
    			if (dirty & /*data*/ 1) cardaplicacao_changes.model = /*data*/ ctx[0].educacaoAplicacao;
    			if (dirty & /*data*/ 1) cardaplicacao_changes.posicaoRanking = /*data*/ ctx[0].educacaoRankingAplicacao;
    			cardaplicacao.$set(cardaplicacao_changes);
    			const cardaplicacaopercapita_changes = {};
    			if (dirty & /*data*/ 1) cardaplicacaopercapita_changes.model = /*data*/ ctx[0].educacaoAplicacaoPerCapita;
    			if (dirty & /*data*/ 1) cardaplicacaopercapita_changes.posicaoRanking = /*data*/ ctx[0].educacaoRankingAplicacaoPerCapita;
    			cardaplicacaopercapita.$set(cardaplicacaopercapita_changes);
    			const limiteconstitucionaleducacao_changes = {};
    			if (dirty & /*limite*/ 2) limiteconstitucionaleducacao_changes.limite = /*limite*/ ctx[1];
    			limiteconstitucionaleducacao.$set(limiteconstitucionaleducacao_changes);
    			const evolucaoanualaplicacao_changes = {};
    			if (dirty & /*data*/ 1) evolucaoanualaplicacao_changes.model = /*data*/ ctx[0].educacaoEvolucaoAnual;
    			evolucaoanualaplicacao.$set(evolucaoanualaplicacao_changes);
    			const evolucaoanualreceitaxaplicacao_changes = {};
    			if (dirty & /*data*/ 1) evolucaoanualreceitaxaplicacao_changes.model = /*data*/ ctx[0].educacaoEvolucaoAnual;
    			evolucaoanualreceitaxaplicacao.$set(evolucaoanualreceitaxaplicacao_changes);
    			const evolucaoanuallimiteconstitucional_changes = {};
    			if (dirty & /*data*/ 1) evolucaoanuallimiteconstitucional_changes.model = /*data*/ ctx[0].educacaoEvolucaoAnual;
    			evolucaoanuallimiteconstitucional.$set(evolucaoanuallimiteconstitucional_changes);
    			const evolucaoanualaplicacaopercapita_changes = {};
    			if (dirty & /*data*/ 1) evolucaoanualaplicacaopercapita_changes.model = /*data*/ ctx[0].educacaoEvolucaoAnualPerCapita;
    			evolucaoanualaplicacaopercapita.$set(evolucaoanualaplicacaopercapita_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prestacaocontamensal.$$.fragment, local);
    			transition_in(cardaplicacao.$$.fragment, local);
    			transition_in(cardaplicacaopercapita.$$.fragment, local);
    			transition_in(limiteconstitucionaleducacao.$$.fragment, local);
    			transition_in(evolucaoanualaplicacao.$$.fragment, local);
    			transition_in(evolucaoanualreceitaxaplicacao.$$.fragment, local);
    			transition_in(evolucaoanuallimiteconstitucional.$$.fragment, local);
    			transition_in(evolucaoanualaplicacaopercapita.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prestacaocontamensal.$$.fragment, local);
    			transition_out(cardaplicacao.$$.fragment, local);
    			transition_out(cardaplicacaopercapita.$$.fragment, local);
    			transition_out(limiteconstitucionaleducacao.$$.fragment, local);
    			transition_out(evolucaoanualaplicacao.$$.fragment, local);
    			transition_out(evolucaoanualreceitaxaplicacao.$$.fragment, local);
    			transition_out(evolucaoanuallimiteconstitucional.$$.fragment, local);
    			transition_out(evolucaoanualaplicacaopercapita.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_component(prestacaocontamensal);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div8);
    			destroy_component(cardaplicacao);
    			destroy_component(cardaplicacaopercapita);
    			destroy_component(limiteconstitucionaleducacao);
    			destroy_component(evolucaoanualaplicacao);
    			destroy_component(evolucaoanualreceitaxaplicacao);
    			destroy_component(evolucaoanuallimiteconstitucional);
    			destroy_component(evolucaoanualaplicacaopercapita);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(3, $params = $$value));
    	let ano;
    	let data = {};
    	let limite;

    	function refresh(params) {
    		ano = parseInt(params.ano);
    		const ug = params.ug;
    		const municipio = ug === "consolidado" ? params.municipio : ug;
    		$$invalidate(0, data = {});
    		api.post(api.getApiUrl("ControleSocial"), educacaoEvolucaoAnual(ano, municipio).concat(educacaoEvolucaoAnualPerCapita(ano, municipio)).concat(educacaoRankingAplicacao(ano, municipio)).concat(educacaoRankingAplicacaoPerCapita(ano, municipio)).concat(prestacaoContaPCB(ano, municipio)));
    	}

    	function onResult({ detail: json }) {
    		if (!data[json.id]) {
    			switch (json.id) {
    				case "educacaoEvolucaoAnual":
    					$$invalidate(
    						0,
    						data["educacaoAplicacao"] = {
    							id: "educacaoAplicacao",
    							value: json.value.find(o => o.ano === ano)
    						},
    						data
    					);
    					$$invalidate(0, data[json.id] = json, data);
    					break;
    				case "educacaoEvolucaoAnualPerCapita":
    					$$invalidate(
    						0,
    						data["educacaoAplicacaoPerCapita"] = {
    							id: "educacaoAplicacaoPerCapita",
    							value: json.value.find(o => o.ano === ano)
    						},
    						data
    					);
    					$$invalidate(0, data[json.id] = json, data);
    					break;
    				default:
    					$$invalidate(0, data[json.id] = json, data);
    					break;
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Educacao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Educacao", $$slots, []);

    	$$self.$capture_state = () => ({
    		params,
    		api,
    		EvolucaoAnualAplicacao,
    		EvolucaoAnualAplicacaoPerCapita,
    		EvolucaoAnualLimiteConstitucional,
    		EvolucaoAnualReceitaXAplicacao,
    		CardAplicacao,
    		CardAplicacaoPerCapita,
    		LimiteConstitucionalEducacao,
    		PrestacaoContaMensal,
    		prestacaoContaApi,
    		educacaoApi,
    		ano,
    		data,
    		limite,
    		refresh,
    		onResult,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("ano" in $$props) ano = $$props.ano;
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("limite" in $$props) $$invalidate(1, limite = $$props.limite);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 8) {
    			 api && refresh($params);
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 if (data.educacaoAplicacao) {
    				$$invalidate(1, limite = data.educacaoAplicacao.value.limiteConstitucional);
    			}
    		}
    	};

    	return [data, limite];
    }

    class Educacao$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$12, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Educacao",
    			options,
    			id: create_fragment$12.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\iegm\index.svelte generated by Svelte v3.22.3 */

    function create_fragment$13(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Iegm> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Iegm", $$slots, []);
    	return [];
    }

    class Iegm$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$13, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Iegm",
    			options,
    			id: create_fragment$13.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\obrigacoes\index.svelte generated by Svelte v3.22.3 */
    const file$$ = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\obrigacoes\\index.svelte";

    function create_fragment$14(ctx) {
    	let t0;
    	let p;
    	let t2;
    	let div3;
    	let div0;
    	let t3;
    	let div1;
    	let t4;
    	let div2;

    	const block = {
    		c: function create() {
    			t0 = space();
    			p = element("p");
    			p.textContent = "Situações das remessas de dados obrigatórias dos órgãos públicos do município\r\n  para o Tribunal de Contas";
    			t2 = space();
    			div3 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div1 = element("div");
    			t4 = space();
    			div2 = element("div");
    			document.title = "Obrigações junto ao TCE-ES";
    			attr_dev(p, "class", "text-lg m-2 border-b");
    			add_location(p, file$$, 24, 0, 629);
    			attr_dev(div0, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div0, file$$, 30, 2, 820);
    			attr_dev(div1, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div1, file$$, 32, 2, 879);
    			attr_dev(div2, "class", "w-full p-1");
    			add_location(div2, file$$, 34, 2, 938);
    			attr_dev(div3, "class", "flex flex-wrap w-full");
    			add_location(div3, file$$, 29, 0, 781);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, p, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(0, $params = $$value));

    	function refresh(params) {
    		const ano = parseInt(params.ano);
    		const ug = params.ug;
    		const municipio = ug === "consolidado" ? params.municipio : ug;
    		api.post(api.getApiUrl("DWControleSocial"), prestacaoContaMensal(ano, municipio));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Obrigacoes> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Obrigacoes", $$slots, []);

    	$$self.$capture_state = () => ({
    		params,
    		api,
    		prestacaoContaApi,
    		refresh,
    		$params
    	});

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 1) {
    			 refresh($params);
    		}
    	};

    	return [];
    }

    class Obrigacoes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$14, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Obrigacoes",
    			options,
    			id: create_fragment$14.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\pessoal\_components\EvolucaoAnualDespesa.svelte generated by Svelte v3.22.3 */
    const file$10 = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\pessoal\\_components\\EvolucaoAnualDespesa.svelte";

    // (10:4) <span slot="tooltip">
    function create_tooltip_slot$i(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução dos recursos aplicados em saúde nos últimos exercícios.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$10, 9, 4, 310);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$i.name,
    		type: "slot",
    		source: "(10:4) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$15(ctx) {
    	let div;
    	let current;

    	const evolucaoanual = new EvolucaoAnual({
    			props: {
    				model: /*model*/ ctx[0],
    				seriesName: "Despesa",
    				seriesProperty: "despesa",
    				$$slots: { tooltip: [create_tooltip_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(evolucaoanual.$$.fragment);
    			attr_dev(div, "class", "mb-3");
    			add_location(div, file$10, 7, 0, 213);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(evolucaoanual, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const evolucaoanual_changes = {};
    			if (dirty & /*model*/ 1) evolucaoanual_changes.model = /*model*/ ctx[0];

    			if (dirty & /*$$scope*/ 2) {
    				evolucaoanual_changes.$$scope = { dirty, ctx };
    			}

    			evolucaoanual.$set(evolucaoanual_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(evolucaoanual.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(evolucaoanual.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(evolucaoanual);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	const writable_props = ["model"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoAnualDespesa> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoAnualDespesa", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    	};

    	$$self.$capture_state = () => ({ EvolucaoAnual, Loading, model });

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model];
    }

    class EvolucaoAnualDespesa extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$15, safe_not_equal, { model: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoAnualDespesa",
    			options,
    			id: create_fragment$15.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoAnualDespesa> was created without expected prop 'model'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoAnualDespesa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoAnualDespesa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\pessoal\_components\CardDespesa.svelte generated by Svelte v3.22.3 */
    const file$11 = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\pessoal\\_components\\CardDespesa.svelte";

    // (10:2) <span slot="title">
    function create_title_slot$i(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Despesa";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$11, 9, 2, 250);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$i.name,
    		type: "slot",
    		source: "(10:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:2) <span slot="tooltip">
    function create_tooltip_slot$j(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Este é o valor aplicado em saúde, com recursos próprios (impostos e\r\n    transferências), não considerados os recursos de convênios. O valor da\r\n    aplicação per capita (por pessoa) é calculado de acordo com o número de\r\n    habitantes informados pelo IBGE.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$11, 10, 2, 287);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$j.name,
    		type: "slot",
    		source: "(11:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (35:4) {:else}
    function create_else_block$i(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$i.name,
    		type: "else",
    		source: "(35:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#if model && posicaoRanking}
    function create_if_block$p(ctx) {
    	let div0;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = /*model*/ ctx[0].value.despesa + "";
    	let t2;
    	let t3;
    	let div1;
    	let span2;
    	let t5;
    	let span3;
    	let t6_value = /*model*/ ctx[0].value.mediaMunicipal + "";
    	let t6;
    	let t7;
    	let div2;
    	let span4;
    	let t9;
    	let span5;
    	let t10_value = /*posicaoRanking*/ ctx[1].value + "";
    	let t10;
    	let t11;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "R$";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			span2 = element("span");
    			span2.textContent = "Média municipal";
    			t5 = space();
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			div2 = element("div");
    			span4 = element("span");
    			span4.textContent = "Posição";
    			t9 = space();
    			span5 = element("span");
    			t10 = text(t10_value);
    			t11 = text("º");
    			attr_dev(span0, "class", "text-sm");
    			add_location(span0, file$11, 19, 8, 683);
    			attr_dev(span1, "class", "text-4xl font-bold");
    			add_location(span1, file$11, 20, 8, 724);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$11, 18, 6, 648);
    			attr_dev(span2, "class", "text-base");
    			add_location(span2, file$11, 23, 8, 822);
    			attr_dev(span3, "class", "text-base float-right font-bold");
    			add_location(span3, file$11, 24, 8, 878);
    			add_location(div1, file$11, 22, 6, 807);
    			attr_dev(span4, "class", "text-base");
    			add_location(span4, file$11, 29, 8, 1018);
    			attr_dev(span5, "class", "text-base float-right font-bold");
    			add_location(span5, file$11, 30, 8, 1066);
    			add_location(div2, file$11, 28, 6, 1003);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span2);
    			append_dev(div1, t5);
    			append_dev(div1, span3);
    			append_dev(span3, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, span4);
    			append_dev(div2, t9);
    			append_dev(div2, span5);
    			append_dev(span5, t10);
    			append_dev(span5, t11);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*model*/ 1 && t2_value !== (t2_value = /*model*/ ctx[0].value.despesa + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*model*/ 1 && t6_value !== (t6_value = /*model*/ ctx[0].value.mediaMunicipal + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*posicaoRanking*/ 2 && t10_value !== (t10_value = /*posicaoRanking*/ ctx[1].value + "")) set_data_dev(t10, t10_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(18:4) {#if model && posicaoRanking}",
    		ctx
    	});

    	return block;
    }

    // (9:0) <Widget>
    function create_default_slot$z(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$p, create_else_block$i];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*model*/ ctx[0] && /*posicaoRanking*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$11, 16, 2, 587);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$z.name,
    		type: "slot",
    		source: "(9:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$16(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$z],
    					tooltip: [create_tooltip_slot$j],
    					title: [create_title_slot$i]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, posicaoRanking, model*/ 7) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { posicaoRanking } = $$props;
    	const writable_props = ["model", "posicaoRanking"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardDespesa> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("CardDespesa", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	$$self.$capture_state = () => ({ Loading, Widget, model, posicaoRanking });

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model, posicaoRanking];
    }

    class CardDespesa extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$16, safe_not_equal, { model: 0, posicaoRanking: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardDespesa",
    			options,
    			id: create_fragment$16.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<CardDespesa> was created without expected prop 'model'");
    		}

    		if (/*posicaoRanking*/ ctx[1] === undefined && !("posicaoRanking" in props)) {
    			console.warn("<CardDespesa> was created without expected prop 'posicaoRanking'");
    		}
    	}

    	get model() {
    		throw new Error("<CardDespesa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<CardDespesa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get posicaoRanking() {
    		throw new Error("<CardDespesa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set posicaoRanking(value) {
    		throw new Error("<CardDespesa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\pessoal\_components\CardDespesaPerCapita.svelte generated by Svelte v3.22.3 */
    const file$12 = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\pessoal\\_components\\CardDespesaPerCapita.svelte";

    // (10:2) <span slot="title">
    function create_title_slot$j(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Despesa per capita";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$12, 9, 2, 250);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$j.name,
    		type: "slot",
    		source: "(10:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:2) <span slot="tooltip">
    function create_tooltip_slot$k(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Este é o valor aplicado em saúde, com recursos próprios (impostos e\r\n    transferências), não considerados os recursos de convênios. O valor da\r\n    aplicação per capita (por pessoa) é calculado de acordo com o número de\r\n    habitantes informados pelo IBGE.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$12, 10, 2, 298);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$k.name,
    		type: "slot",
    		source: "(11:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (35:4) {:else}
    function create_else_block$j(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$j.name,
    		type: "else",
    		source: "(35:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#if model && posicaoRanking}
    function create_if_block$q(ctx) {
    	let div0;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = /*model*/ ctx[0].value.despesaPerCapita + "";
    	let t2;
    	let t3;
    	let div1;
    	let span2;
    	let t5;
    	let span3;
    	let t6_value = /*model*/ ctx[0].value.mediaMunicipal + "";
    	let t6;
    	let t7;
    	let div2;
    	let span4;
    	let t9;
    	let span5;
    	let t10_value = /*posicaoRanking*/ ctx[1].value + "";
    	let t10;
    	let t11;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "R$";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			span2 = element("span");
    			span2.textContent = "Média municipal";
    			t5 = space();
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			div2 = element("div");
    			span4 = element("span");
    			span4.textContent = "Posição";
    			t9 = space();
    			span5 = element("span");
    			t10 = text(t10_value);
    			t11 = text("º");
    			attr_dev(span0, "class", "text-sm");
    			add_location(span0, file$12, 19, 8, 694);
    			attr_dev(span1, "class", "text-4xl font-bold");
    			add_location(span1, file$12, 20, 8, 735);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$12, 18, 6, 659);
    			attr_dev(span2, "class", "text-base");
    			add_location(span2, file$12, 23, 8, 842);
    			attr_dev(span3, "class", "text-base float-right font-bold");
    			add_location(span3, file$12, 24, 8, 898);
    			add_location(div1, file$12, 22, 6, 827);
    			attr_dev(span4, "class", "text-base");
    			add_location(span4, file$12, 29, 8, 1038);
    			attr_dev(span5, "class", "text-base float-right font-bold");
    			add_location(span5, file$12, 30, 8, 1086);
    			add_location(div2, file$12, 28, 6, 1023);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span2);
    			append_dev(div1, t5);
    			append_dev(div1, span3);
    			append_dev(span3, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, span4);
    			append_dev(div2, t9);
    			append_dev(div2, span5);
    			append_dev(span5, t10);
    			append_dev(span5, t11);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*model*/ 1 && t2_value !== (t2_value = /*model*/ ctx[0].value.despesaPerCapita + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*model*/ 1 && t6_value !== (t6_value = /*model*/ ctx[0].value.mediaMunicipal + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*posicaoRanking*/ 2 && t10_value !== (t10_value = /*posicaoRanking*/ ctx[1].value + "")) set_data_dev(t10, t10_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(18:4) {#if model && posicaoRanking}",
    		ctx
    	});

    	return block;
    }

    // (9:0) <Widget>
    function create_default_slot$A(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$q, create_else_block$j];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*model*/ ctx[0] && /*posicaoRanking*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$12, 16, 2, 598);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$A.name,
    		type: "slot",
    		source: "(9:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$17(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$A],
    					tooltip: [create_tooltip_slot$k],
    					title: [create_title_slot$j]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, posicaoRanking, model*/ 7) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { posicaoRanking } = $$props;
    	const writable_props = ["model", "posicaoRanking"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardDespesaPerCapita> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("CardDespesaPerCapita", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	$$self.$capture_state = () => ({ Loading, Widget, model, posicaoRanking });

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model, posicaoRanking];
    }

    class CardDespesaPerCapita extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$17, safe_not_equal, { model: 0, posicaoRanking: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardDespesaPerCapita",
    			options,
    			id: create_fragment$17.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<CardDespesaPerCapita> was created without expected prop 'model'");
    		}

    		if (/*posicaoRanking*/ ctx[1] === undefined && !("posicaoRanking" in props)) {
    			console.warn("<CardDespesaPerCapita> was created without expected prop 'posicaoRanking'");
    		}
    	}

    	get model() {
    		throw new Error("<CardDespesaPerCapita>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<CardDespesaPerCapita>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get posicaoRanking() {
    		throw new Error("<CardDespesaPerCapita>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set posicaoRanking(value) {
    		throw new Error("<CardDespesaPerCapita>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\pessoal\_components\LinhaPoder.svelte generated by Svelte v3.22.3 */
    const file$13 = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\pessoal\\_components\\LinhaPoder.svelte";
    const get_limite_slot_changes = dirty => ({});
    const get_limite_slot_context = ctx => ({});

    function create_fragment$18(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let hr;
    	let t2;
    	let div5;
    	let div1;
    	let t3;
    	let div2;
    	let t4;
    	let div3;
    	let t5;
    	let div4;
    	let current;

    	const carddespesa = new CardDespesa({
    			props: {
    				model: /*pessoalDespesa*/ ctx[1],
    				posicaoRanking: /*rankingDespesa*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const carddespesapercapita = new CardDespesaPerCapita({
    			props: {
    				model: /*pessoalDespesaPerCapita*/ ctx[3],
    				posicaoRanking: /*rankingDespesaPerCapita*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const limite_slot_template = /*$$slots*/ ctx[7].limite;
    	const limite_slot = create_slot(limite_slot_template, ctx, /*$$scope*/ ctx[6], get_limite_slot_context);

    	const evolucaoanualdespesa = new EvolucaoAnualDespesa({
    			props: { model: /*evolucaoAnual*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = text(/*titulo*/ ctx[0]);
    			t1 = space();
    			hr = element("hr");
    			t2 = space();
    			div5 = element("div");
    			div1 = element("div");
    			create_component(carddespesa.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			create_component(carddespesapercapita.$$.fragment);
    			t4 = space();
    			div3 = element("div");
    			if (limite_slot) limite_slot.c();
    			t5 = space();
    			div4 = element("div");
    			create_component(evolucaoanualdespesa.$$.fragment);
    			add_location(hr, file$13, 16, 2, 446);
    			attr_dev(div0, "class", "text-xl p-1");
    			add_location(div0, file$13, 14, 0, 405);
    			attr_dev(div1, "class", "xl:w-1/5 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div1, file$13, 19, 2, 501);
    			attr_dev(div2, "class", "xl:w-1/5 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div2, file$13, 23, 2, 644);
    			attr_dev(div3, "class", "xl:w-1/5 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div3, file$13, 29, 2, 828);
    			attr_dev(div4, "class", "xl:w-2/5 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div4, file$13, 33, 2, 923);
    			attr_dev(div5, "class", "flex flex-wrap w-full");
    			add_location(div5, file$13, 18, 0, 462);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, hr);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div1);
    			mount_component(carddespesa, div1, null);
    			append_dev(div5, t3);
    			append_dev(div5, div2);
    			mount_component(carddespesapercapita, div2, null);
    			append_dev(div5, t4);
    			append_dev(div5, div3);

    			if (limite_slot) {
    				limite_slot.m(div3, null);
    			}

    			append_dev(div5, t5);
    			append_dev(div5, div4);
    			mount_component(evolucaoanualdespesa, div4, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*titulo*/ 1) set_data_dev(t0, /*titulo*/ ctx[0]);
    			const carddespesa_changes = {};
    			if (dirty & /*pessoalDespesa*/ 2) carddespesa_changes.model = /*pessoalDespesa*/ ctx[1];
    			if (dirty & /*rankingDespesa*/ 4) carddespesa_changes.posicaoRanking = /*rankingDespesa*/ ctx[2];
    			carddespesa.$set(carddespesa_changes);
    			const carddespesapercapita_changes = {};
    			if (dirty & /*pessoalDespesaPerCapita*/ 8) carddespesapercapita_changes.model = /*pessoalDespesaPerCapita*/ ctx[3];
    			if (dirty & /*rankingDespesaPerCapita*/ 16) carddespesapercapita_changes.posicaoRanking = /*rankingDespesaPerCapita*/ ctx[4];
    			carddespesapercapita.$set(carddespesapercapita_changes);

    			if (limite_slot) {
    				if (limite_slot.p && dirty & /*$$scope*/ 64) {
    					limite_slot.p(get_slot_context(limite_slot_template, ctx, /*$$scope*/ ctx[6], get_limite_slot_context), get_slot_changes(limite_slot_template, /*$$scope*/ ctx[6], dirty, get_limite_slot_changes));
    				}
    			}

    			const evolucaoanualdespesa_changes = {};
    			if (dirty & /*evolucaoAnual*/ 32) evolucaoanualdespesa_changes.model = /*evolucaoAnual*/ ctx[5];
    			evolucaoanualdespesa.$set(evolucaoanualdespesa_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carddespesa.$$.fragment, local);
    			transition_in(carddespesapercapita.$$.fragment, local);
    			transition_in(limite_slot, local);
    			transition_in(evolucaoanualdespesa.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carddespesa.$$.fragment, local);
    			transition_out(carddespesapercapita.$$.fragment, local);
    			transition_out(limite_slot, local);
    			transition_out(evolucaoanualdespesa.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div5);
    			destroy_component(carddespesa);
    			destroy_component(carddespesapercapita);
    			if (limite_slot) limite_slot.d(detaching);
    			destroy_component(evolucaoanualdespesa);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	let { titulo } = $$props;
    	let { pessoalDespesa } = $$props;
    	let { rankingDespesa } = $$props;
    	let { pessoalDespesaPerCapita } = $$props;
    	let { rankingDespesaPerCapita } = $$props;
    	let { evolucaoAnual } = $$props;

    	const writable_props = [
    		"titulo",
    		"pessoalDespesa",
    		"rankingDespesa",
    		"pessoalDespesaPerCapita",
    		"rankingDespesaPerCapita",
    		"evolucaoAnual"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LinhaPoder> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LinhaPoder", $$slots, ['limite']);

    	$$self.$set = $$props => {
    		if ("titulo" in $$props) $$invalidate(0, titulo = $$props.titulo);
    		if ("pessoalDespesa" in $$props) $$invalidate(1, pessoalDespesa = $$props.pessoalDespesa);
    		if ("rankingDespesa" in $$props) $$invalidate(2, rankingDespesa = $$props.rankingDespesa);
    		if ("pessoalDespesaPerCapita" in $$props) $$invalidate(3, pessoalDespesaPerCapita = $$props.pessoalDespesaPerCapita);
    		if ("rankingDespesaPerCapita" in $$props) $$invalidate(4, rankingDespesaPerCapita = $$props.rankingDespesaPerCapita);
    		if ("evolucaoAnual" in $$props) $$invalidate(5, evolucaoAnual = $$props.evolucaoAnual);
    		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		EvolucaoAnualDespesa,
    		CardDespesa,
    		CardDespesaPerCapita,
    		titulo,
    		pessoalDespesa,
    		rankingDespesa,
    		pessoalDespesaPerCapita,
    		rankingDespesaPerCapita,
    		evolucaoAnual
    	});

    	$$self.$inject_state = $$props => {
    		if ("titulo" in $$props) $$invalidate(0, titulo = $$props.titulo);
    		if ("pessoalDespesa" in $$props) $$invalidate(1, pessoalDespesa = $$props.pessoalDespesa);
    		if ("rankingDespesa" in $$props) $$invalidate(2, rankingDespesa = $$props.rankingDespesa);
    		if ("pessoalDespesaPerCapita" in $$props) $$invalidate(3, pessoalDespesaPerCapita = $$props.pessoalDespesaPerCapita);
    		if ("rankingDespesaPerCapita" in $$props) $$invalidate(4, rankingDespesaPerCapita = $$props.rankingDespesaPerCapita);
    		if ("evolucaoAnual" in $$props) $$invalidate(5, evolucaoAnual = $$props.evolucaoAnual);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		titulo,
    		pessoalDespesa,
    		rankingDespesa,
    		pessoalDespesaPerCapita,
    		rankingDespesaPerCapita,
    		evolucaoAnual,
    		$$scope,
    		$$slots
    	];
    }

    class LinhaPoder extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$17, create_fragment$18, safe_not_equal, {
    			titulo: 0,
    			pessoalDespesa: 1,
    			rankingDespesa: 2,
    			pessoalDespesaPerCapita: 3,
    			rankingDespesaPerCapita: 4,
    			evolucaoAnual: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LinhaPoder",
    			options,
    			id: create_fragment$18.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*titulo*/ ctx[0] === undefined && !("titulo" in props)) {
    			console.warn("<LinhaPoder> was created without expected prop 'titulo'");
    		}

    		if (/*pessoalDespesa*/ ctx[1] === undefined && !("pessoalDespesa" in props)) {
    			console.warn("<LinhaPoder> was created without expected prop 'pessoalDespesa'");
    		}

    		if (/*rankingDespesa*/ ctx[2] === undefined && !("rankingDespesa" in props)) {
    			console.warn("<LinhaPoder> was created without expected prop 'rankingDespesa'");
    		}

    		if (/*pessoalDespesaPerCapita*/ ctx[3] === undefined && !("pessoalDespesaPerCapita" in props)) {
    			console.warn("<LinhaPoder> was created without expected prop 'pessoalDespesaPerCapita'");
    		}

    		if (/*rankingDespesaPerCapita*/ ctx[4] === undefined && !("rankingDespesaPerCapita" in props)) {
    			console.warn("<LinhaPoder> was created without expected prop 'rankingDespesaPerCapita'");
    		}

    		if (/*evolucaoAnual*/ ctx[5] === undefined && !("evolucaoAnual" in props)) {
    			console.warn("<LinhaPoder> was created without expected prop 'evolucaoAnual'");
    		}
    	}

    	get titulo() {
    		throw new Error("<LinhaPoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titulo(value) {
    		throw new Error("<LinhaPoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pessoalDespesa() {
    		throw new Error("<LinhaPoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pessoalDespesa(value) {
    		throw new Error("<LinhaPoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rankingDespesa() {
    		throw new Error("<LinhaPoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rankingDespesa(value) {
    		throw new Error("<LinhaPoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pessoalDespesaPerCapita() {
    		throw new Error("<LinhaPoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pessoalDespesaPerCapita(value) {
    		throw new Error("<LinhaPoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rankingDespesaPerCapita() {
    		throw new Error("<LinhaPoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rankingDespesaPerCapita(value) {
    		throw new Error("<LinhaPoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get evolucaoAnual() {
    		throw new Error("<LinhaPoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set evolucaoAnual(value) {
    		throw new Error("<LinhaPoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\_components\LimiteConstitucionalPessoalConsolidado.svelte generated by Svelte v3.22.3 */
    const file$14 = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\_components\\LimiteConstitucionalPessoalConsolidado.svelte";

    // (38:2) <span slot="title">
    function create_title_slot$k(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Pessoal - Consolidado";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$14, 37, 2, 846);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$k.name,
    		type: "slot",
    		source: "(38:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (39:2) <span slot="tooltip">
    function create_tooltip_slot$l(ctx) {
    	let span;
    	let t0;
    	let br0;
    	let t1;
    	let br1;
    	let t2;
    	let br2;
    	let t3;
    	let br3;
    	let t4;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text("De acordo com a LRF (Lei de Responsabilidade Fiscal) as despesas com pessoal\r\n    nos municípios não podem ultrapassar 60% da RCL (Receita Corrente Líquida)\r\n    do Município.\r\n    ");
    			br0 = element("br");
    			t1 = space();
    			br1 = element("br");
    			t2 = text("\r\n    Caso esses gastos atinjam 57% da RCL o município entra no limite prudencial.\r\n    ");
    			br2 = element("br");
    			t3 = space();
    			br3 = element("br");
    			t4 = text("\r\n    Caso esses gastos atinjam 54% da RCL o Tribunal de Contas emitirá parecer de\r\n    alerta.");
    			add_location(br0, file$14, 42, 4, 1105);
    			add_location(br1, file$14, 43, 4, 1117);
    			add_location(br2, file$14, 45, 4, 1211);
    			add_location(br3, file$14, 46, 4, 1223);
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$14, 38, 2, 897);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, br0);
    			append_dev(span, t1);
    			append_dev(span, br1);
    			append_dev(span, t2);
    			append_dev(span, br2);
    			append_dev(span, t3);
    			append_dev(span, br3);
    			append_dev(span, t4);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$l.name,
    		type: "slot",
    		source: "(39:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:0) <Widget>
    function create_default_slot$B(ctx) {
    	let t0;
    	let t1;
    	let div1;
    	let span;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let div0;
    	let div1_class_value;
    	let current;

    	const icon = new Icon({
    			props: { icon: faThumbsUp_2$1 },
    			$$inline: true
    		});

    	const gauge = new Gauge({
    			props: { serie: /*serie*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div1 = element("div");
    			span = element("span");
    			create_component(icon.$$.fragment);
    			t2 = space();
    			t3 = text(/*limite*/ ctx[0]);
    			t4 = text(" %");
    			t5 = space();
    			div0 = element("div");
    			create_component(gauge.$$.fragment);
    			attr_dev(span, "class", "text-3xl");
    			add_location(span, file$14, 51, 4, 1381);
    			attr_dev(div0, "class", "h-full");
    			set_style(div0, "margin-top", "-.8em");
    			add_location(div0, file$14, 55, 4, 1475);
    			attr_dev(div1, "class", div1_class_value = "h-" + /*height*/ ctx[1] + " text-center");
    			add_location(div1, file$14, 50, 2, 1339);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			mount_component(icon, span, null);
    			append_dev(span, t2);
    			append_dev(span, t3);
    			append_dev(span, t4);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			mount_component(gauge, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*limite*/ 1) set_data_dev(t3, /*limite*/ ctx[0]);

    			if (!current || dirty & /*height*/ 2 && div1_class_value !== (div1_class_value = "h-" + /*height*/ ctx[1] + " text-center")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			transition_in(gauge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			transition_out(gauge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(icon);
    			destroy_component(gauge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$B.name,
    		type: "slot",
    		source: "(37:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$19(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$B],
    					tooltip: [create_tooltip_slot$l],
    					title: [create_title_slot$k]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, height, limite*/ 11) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let { limite } = $$props;
    	let { height = 40 } = $$props;

    	const serie = {
    		title: { show: false },
    		axisLine: {
    			lineStyle: {
    				width: 35,
    				color: [[0.54, "#617e8c"], [0.57, "#eff170"], [0.6, "#f4b351"], [1, "#e68465"]]
    			}
    		},
    		detail: {
    			formatter() {
    				return "Limite LRF";
    			},
    			color: "#000",
    			fontWeight: "normal",
    			fontSize: 14
    		},
    		data: [{ name: "Limite LRF", value: limite }]
    	};

    	const writable_props = ["limite", "height"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LimiteConstitucionalPessoalConsolidado> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LimiteConstitucionalPessoalConsolidado", $$slots, []);

    	$$self.$set = $$props => {
    		if ("limite" in $$props) $$invalidate(0, limite = $$props.limite);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		faThumbsUp: faThumbsUp_2$1,
    		Gauge,
    		Widget,
    		limite,
    		height,
    		serie
    	});

    	$$self.$inject_state = $$props => {
    		if ("limite" in $$props) $$invalidate(0, limite = $$props.limite);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [limite, height, serie];
    }

    class LimiteConstitucionalPessoalConsolidado extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$19, safe_not_equal, { limite: 0, height: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LimiteConstitucionalPessoalConsolidado",
    			options,
    			id: create_fragment$19.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*limite*/ ctx[0] === undefined && !("limite" in props)) {
    			console.warn("<LimiteConstitucionalPessoalConsolidado> was created without expected prop 'limite'");
    		}
    	}

    	get limite() {
    		throw new Error("<LimiteConstitucionalPessoalConsolidado>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limite(value) {
    		throw new Error("<LimiteConstitucionalPessoalConsolidado>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LimiteConstitucionalPessoalConsolidado>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LimiteConstitucionalPessoalConsolidado>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\_components\LimiteConstitucionalPessoalExecutivo.svelte generated by Svelte v3.22.3 */
    const file$15 = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\_components\\LimiteConstitucionalPessoalExecutivo.svelte";

    // (38:2) <span slot="title">
    function create_title_slot$l(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Pessoal - Executivo";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$15, 37, 2, 849);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$l.name,
    		type: "slot",
    		source: "(38:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (39:2) <span slot="tooltip">
    function create_tooltip_slot$m(ctx) {
    	let span;
    	let t0;
    	let br0;
    	let t1;
    	let br1;
    	let t2;
    	let br2;
    	let t3;
    	let br3;
    	let t4;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text("De acordo com a LRF (Lei de Responsabilidade Fiscal) as despesas com pessoal\r\n    no Poder Executivo não podem ultrapassar 54% da RCL (Receita Corrente\r\n    Líquida) do Município.\r\n    ");
    			br0 = element("br");
    			t1 = space();
    			br1 = element("br");
    			t2 = text("\r\n    Caso esses gastos atinjam 51,3% da RCL o município entra no limite\r\n    prudencial.\r\n    ");
    			br2 = element("br");
    			t3 = space();
    			br3 = element("br");
    			t4 = text("\r\n    Caso esses gastos atinjam 48,6% da RCL o Tribunal de Contas emitirá parecer\r\n    de alerta.");
    			add_location(br0, file$15, 42, 4, 1110);
    			add_location(br1, file$15, 43, 4, 1122);
    			add_location(br2, file$15, 46, 4, 1223);
    			add_location(br3, file$15, 47, 4, 1235);
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$15, 38, 2, 898);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, br0);
    			append_dev(span, t1);
    			append_dev(span, br1);
    			append_dev(span, t2);
    			append_dev(span, br2);
    			append_dev(span, t3);
    			append_dev(span, br3);
    			append_dev(span, t4);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$m.name,
    		type: "slot",
    		source: "(39:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:0) <Widget>
    function create_default_slot$C(ctx) {
    	let t0;
    	let t1;
    	let div1;
    	let span;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let div0;
    	let div1_class_value;
    	let current;

    	const icon = new Icon({
    			props: { icon: faThumbsUp_2$1 },
    			$$inline: true
    		});

    	const gauge = new Gauge({
    			props: { serie: /*serie*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div1 = element("div");
    			span = element("span");
    			create_component(icon.$$.fragment);
    			t2 = space();
    			t3 = text(/*limite*/ ctx[0]);
    			t4 = text(" %");
    			t5 = space();
    			div0 = element("div");
    			create_component(gauge.$$.fragment);
    			attr_dev(span, "class", "text-3xl");
    			add_location(span, file$15, 52, 4, 1395);
    			attr_dev(div0, "class", "h-full");
    			set_style(div0, "margin-top", "-.8em");
    			add_location(div0, file$15, 56, 4, 1489);
    			attr_dev(div1, "class", div1_class_value = "h-" + /*height*/ ctx[1] + " text-center");
    			add_location(div1, file$15, 51, 2, 1353);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			mount_component(icon, span, null);
    			append_dev(span, t2);
    			append_dev(span, t3);
    			append_dev(span, t4);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			mount_component(gauge, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*limite*/ 1) set_data_dev(t3, /*limite*/ ctx[0]);

    			if (!current || dirty & /*height*/ 2 && div1_class_value !== (div1_class_value = "h-" + /*height*/ ctx[1] + " text-center")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			transition_in(gauge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			transition_out(gauge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(icon);
    			destroy_component(gauge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$C.name,
    		type: "slot",
    		source: "(37:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1a(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$C],
    					tooltip: [create_tooltip_slot$m],
    					title: [create_title_slot$l]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, height, limite*/ 11) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { limite } = $$props;
    	let { height = 40 } = $$props;

    	const serie = {
    		title: { show: false },
    		axisLine: {
    			lineStyle: {
    				width: 35,
    				color: [
    					[0.486, "#617e8c"],
    					[0.513, "#eff170"],
    					[0.54, "#f4b351"],
    					[1, "#e68465"]
    				]
    			}
    		},
    		detail: {
    			formatter() {
    				return "Limite LRF";
    			},
    			color: "#000",
    			fontWeight: "normal",
    			fontSize: 14
    		},
    		data: [{ name: "Limite LRF", value: limite }]
    	};

    	const writable_props = ["limite", "height"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LimiteConstitucionalPessoalExecutivo> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LimiteConstitucionalPessoalExecutivo", $$slots, []);

    	$$self.$set = $$props => {
    		if ("limite" in $$props) $$invalidate(0, limite = $$props.limite);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		faThumbsUp: faThumbsUp_2$1,
    		Gauge,
    		Widget,
    		limite,
    		height,
    		serie
    	});

    	$$self.$inject_state = $$props => {
    		if ("limite" in $$props) $$invalidate(0, limite = $$props.limite);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [limite, height, serie];
    }

    class LimiteConstitucionalPessoalExecutivo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$1a, safe_not_equal, { limite: 0, height: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LimiteConstitucionalPessoalExecutivo",
    			options,
    			id: create_fragment$1a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*limite*/ ctx[0] === undefined && !("limite" in props)) {
    			console.warn("<LimiteConstitucionalPessoalExecutivo> was created without expected prop 'limite'");
    		}
    	}

    	get limite() {
    		throw new Error("<LimiteConstitucionalPessoalExecutivo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limite(value) {
    		throw new Error("<LimiteConstitucionalPessoalExecutivo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LimiteConstitucionalPessoalExecutivo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LimiteConstitucionalPessoalExecutivo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\_components\LimiteConstitucionalPessoalLegislativo.svelte generated by Svelte v3.22.3 */
    const file$16 = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\_components\\LimiteConstitucionalPessoalLegislativo.svelte";

    // (40:2) <span slot="title">
    function create_title_slot$m(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Pessoal - Legislativo";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$16, 39, 2, 904);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$m.name,
    		type: "slot",
    		source: "(40:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (41:2) <span slot="tooltip">
    function create_tooltip_slot$n(ctx) {
    	let span;
    	let t0;
    	let br0;
    	let t1;
    	let br1;
    	let t2;
    	let br2;
    	let t3;
    	let br3;
    	let t4;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text("De acordo com a LRF (Lei de Responsabilidade Fiscal) as despesas com pessoal\r\n    do Poder Legislativo não podem ultrapassar 6% da RCL (Receita Corrente\r\n    Líquida) do Município.\r\n    ");
    			br0 = element("br");
    			t1 = space();
    			br1 = element("br");
    			t2 = text("\r\n    Caso esses gastos atinjam 5,4% da RCL o Tribunal de Contas emitirá parecer\r\n    de alerta.\r\n    ");
    			br2 = element("br");
    			t3 = space();
    			br3 = element("br");
    			t4 = text("\r\n    Caso esses gastos atinjam 5,7% da RCL o município entra no limite\r\n    prudencial.");
    			add_location(br0, file$16, 44, 4, 1168);
    			add_location(br1, file$16, 45, 4, 1180);
    			add_location(br2, file$16, 48, 4, 1288);
    			add_location(br3, file$16, 49, 4, 1300);
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$16, 40, 2, 955);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, br0);
    			append_dev(span, t1);
    			append_dev(span, br1);
    			append_dev(span, t2);
    			append_dev(span, br2);
    			append_dev(span, t3);
    			append_dev(span, br3);
    			append_dev(span, t4);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$n.name,
    		type: "slot",
    		source: "(41:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (39:0) <Widget>
    function create_default_slot$D(ctx) {
    	let t0;
    	let t1;
    	let div1;
    	let span;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let div0;
    	let div1_class_value;
    	let current;

    	const icon = new Icon({
    			props: { icon: faThumbsUp_2$1 },
    			$$inline: true
    		});

    	const gauge = new Gauge({
    			props: { serie: /*serie*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div1 = element("div");
    			span = element("span");
    			create_component(icon.$$.fragment);
    			t2 = space();
    			t3 = text(/*limite*/ ctx[0]);
    			t4 = text(" %");
    			t5 = space();
    			div0 = element("div");
    			create_component(gauge.$$.fragment);
    			attr_dev(span, "class", "text-3xl");
    			add_location(span, file$16, 54, 4, 1451);
    			attr_dev(div0, "class", "h-full");
    			set_style(div0, "margin-top", "-.8em");
    			add_location(div0, file$16, 58, 4, 1545);
    			attr_dev(div1, "class", div1_class_value = "h-" + /*height*/ ctx[1] + " text-center");
    			add_location(div1, file$16, 53, 2, 1409);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			mount_component(icon, span, null);
    			append_dev(span, t2);
    			append_dev(span, t3);
    			append_dev(span, t4);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			mount_component(gauge, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*limite*/ 1) set_data_dev(t3, /*limite*/ ctx[0]);

    			if (!current || dirty & /*height*/ 2 && div1_class_value !== (div1_class_value = "h-" + /*height*/ ctx[1] + " text-center")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			transition_in(gauge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			transition_out(gauge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(icon);
    			destroy_component(gauge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$D.name,
    		type: "slot",
    		source: "(39:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1b(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$D],
    					tooltip: [create_tooltip_slot$n],
    					title: [create_title_slot$m]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, height, limite*/ 11) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let { limite } = $$props;
    	let { height = 40 } = $$props;

    	const serie = {
    		max: limite > 10 ? limite : 10,
    		title: { show: false },
    		splitNumber: 4,
    		axisLine: {
    			lineStyle: {
    				width: 35,
    				color: [[0.54, "#617e8c"], [0.57, "#eff170"], [0.6, "#f4b351"], [1, "#e68465"]]
    			}
    		},
    		detail: {
    			formatter() {
    				return "Limite LRF";
    			},
    			color: "#000",
    			fontWeight: "normal",
    			fontSize: 14
    		},
    		data: [{ name: "Limite LRF", value: limite }]
    	};

    	const writable_props = ["limite", "height"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LimiteConstitucionalPessoalLegislativo> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LimiteConstitucionalPessoalLegislativo", $$slots, []);

    	$$self.$set = $$props => {
    		if ("limite" in $$props) $$invalidate(0, limite = $$props.limite);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		faThumbsUp: faThumbsUp_2$1,
    		Gauge,
    		Widget,
    		limite,
    		height,
    		serie
    	});

    	$$self.$inject_state = $$props => {
    		if ("limite" in $$props) $$invalidate(0, limite = $$props.limite);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [limite, height, serie];
    }

    class LimiteConstitucionalPessoalLegislativo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1b, safe_not_equal, { limite: 0, height: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LimiteConstitucionalPessoalLegislativo",
    			options,
    			id: create_fragment$1b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*limite*/ ctx[0] === undefined && !("limite" in props)) {
    			console.warn("<LimiteConstitucionalPessoalLegislativo> was created without expected prop 'limite'");
    		}
    	}

    	get limite() {
    		throw new Error("<LimiteConstitucionalPessoalLegislativo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limite(value) {
    		throw new Error("<LimiteConstitucionalPessoalLegislativo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LimiteConstitucionalPessoalLegislativo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LimiteConstitucionalPessoalLegislativo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function pessoalConsolidadoDespesa(ano, municipio) {
      return [
        {
          id: "pessoalConsolidadoDespesa",
          run: "Municipio.Pessoal.Consolidado.FiltrarPorAnoECodigo",
          args: [ano, municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Pessoal.Consolidado.Despesa",
          args: []
        }
      ];
    }

    function pessoalConsolidadoDespesaPerCapita(ano, municipio) {
      return [
        {
          id: "pessoalConsolidadoDespesaPerCapita",
          run: "Municipio.Pessoal.Consolidado.FiltrarPorAnoECodigo",
          args: [ano, municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Pessoal.Consolidado.DespesaPerCapita",
          args: []
        }
      ];
    }

    function pessoalConsolidadoEvolucaoAnual(
      ano,
      municipio,
      quantidade = 5
    ) {
      return [
        {
          id: "pessoalConsolidadoEvolucaoAnual",
          run: "Municipio.Pessoal.Consolidado.FiltrarPorCodigo",
          args: [municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Pessoal.Consolidado.EvolucaoAnual",
          args: [ano, quantidade]
        }
      ];
    }

    function pessoalConsolidadoRankingDespesa(ano, municipio) {
      return [
        {
          id: "pessoalConsolidadoRankingDespesa",
          run: "Municipio.Pessoal.Consolidado.RankingDespesa",
          args: [ano, municipio]
        }
      ];
    }

    function pessoalConsolidadoRankingDespesaPerCapita(ano, municipio) {
      return [
        {
          id: "pessoalConsolidadoRankingDespesaPerCapita",
          run: "Municipio.Pessoal.Consolidado.RankingDespesaPerCapita",
          args: [ano, municipio]
        }
      ];
    }

    var pessoalConsolidadoApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        pessoalConsolidadoDespesa: pessoalConsolidadoDespesa,
        pessoalConsolidadoDespesaPerCapita: pessoalConsolidadoDespesaPerCapita,
        pessoalConsolidadoEvolucaoAnual: pessoalConsolidadoEvolucaoAnual,
        pessoalConsolidadoRankingDespesa: pessoalConsolidadoRankingDespesa,
        pessoalConsolidadoRankingDespesaPerCapita: pessoalConsolidadoRankingDespesaPerCapita
    });

    function pessoalExecutivoDespesa(ano, municipio) {
      return [
        {
          id: "pessoalExecutivoDespesa",
          run: "Municipio.Pessoal.Executivo.FiltrarPorAnoECodigo",
          args: [ano, municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Pessoal.Executivo.Despesa",
          args: []
        }
      ];
    }

    function pessoalExecutivoDespesaPerCapita(ano, municipio) {
      return [
        {
          id: "pessoalExecutivoDespesaPerCapita",
          run: "Municipio.Pessoal.Executivo.FiltrarPorAnoECodigo",
          args: [ano, municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Pessoal.Executivo.DespesaPerCapita",
          args: []
        }
      ];
    }

    function pessoalExecutivoEvolucaoAnual(ano, municipio, quantidade = 5) {
      return [
        {
          id: "pessoalExecutivoEvolucaoAnual",
          run: "Municipio.Pessoal.Executivo.FiltrarPorCodigo",
          args: [municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Pessoal.Executivo.EvolucaoAnual",
          args: [ano, quantidade]
        }
      ];
    }

    function pessoalExecutivoRankingDespesa(ano, municipio) {
      return [
        {
          id: "pessoalExecutivoRankingDespesa",
          run: "Municipio.Pessoal.Executivo.RankingDespesa",
          args: [ano, municipio]
        }
      ];
    }

    function pessoalExecutivoRankingDespesaPerCapita(ano, municipio) {
      return [
        {
          id: "pessoalExecutivoRankingDespesaPerCapita",
          run: "Municipio.Pessoal.Executivo.RankingDespesaPerCapita",
          args: [ano, municipio]
        }
      ];
    }

    var pessoalExecutivoApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        pessoalExecutivoDespesa: pessoalExecutivoDespesa,
        pessoalExecutivoDespesaPerCapita: pessoalExecutivoDespesaPerCapita,
        pessoalExecutivoEvolucaoAnual: pessoalExecutivoEvolucaoAnual,
        pessoalExecutivoRankingDespesa: pessoalExecutivoRankingDespesa,
        pessoalExecutivoRankingDespesaPerCapita: pessoalExecutivoRankingDespesaPerCapita
    });

    function pessoalLegislativoDespesa(ano, municipio) {
      return [
        {
          id: "pessoalLegislativoDespesa",
          run: "Municipio.Pessoal.Legislativo.FiltrarPorAnoECodigo",
          args: [ano, municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Pessoal.Legislativo.Despesa",
          args: []
        }
      ];
    }

    function pessoalLegislativoDespesaPerCapita(ano, municipio) {
      return [
        {
          id: "pessoalLegislativoDespesaPerCapita",
          run: "Municipio.Pessoal.Legislativo.FiltrarPorAnoECodigo",
          args: [ano, municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Pessoal.Legislativo.DespesaPerCapita",
          args: []
        }
      ];
    }

    function pessoalLegislativoEvolucaoAnual(
      ano,
      municipio,
      quantidade = 5
    ) {
      return [
        {
          id: "pessoalLegislativoEvolucaoAnual",
          run: "Municipio.Pessoal.Legislativo.FiltrarPorCodigo",
          args: [municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Pessoal.Legislativo.EvolucaoAnual",
          args: [ano, quantidade]
        }
      ];
    }

    function pessoalLegislativoRankingDespesa(ano, municipio) {
      return [
        {
          id: "pessoalLegislativoRankingDespesa",
          run: "Municipio.Pessoal.Legislativo.RankingDespesa",
          args: [ano, municipio]
        }
      ];
    }

    function pessoalLegislativoRankingDespesaPerCapita(ano, municipio) {
      return [
        {
          id: "pessoalLegislativoRankingDespesaPerCapita",
          run: "Municipio.Pessoal.Legislativo.RankingDespesaPerCapita",
          args: [ano, municipio]
        }
      ];
    }

    var pessoalLegislativoApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        pessoalLegislativoDespesa: pessoalLegislativoDespesa,
        pessoalLegislativoDespesaPerCapita: pessoalLegislativoDespesaPerCapita,
        pessoalLegislativoEvolucaoAnual: pessoalLegislativoEvolucaoAnual,
        pessoalLegislativoRankingDespesa: pessoalLegislativoRankingDespesa,
        pessoalLegislativoRankingDespesaPerCapita: pessoalLegislativoRankingDespesaPerCapita
    });

    /* src\pages\municipio\[ano]\[municipio]\[ug]\pessoal\index.svelte generated by Svelte v3.22.3 */
    const file$17 = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\pessoal\\index.svelte";

    // (1:0) <script>    import { params }
    function create_catch_block_2(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_2.name,
    		type: "catch",
    		source: "(1:0) <script>    import { params }",
    		ctx
    	});

    	return block;
    }

    // (110:0) {:then dataConsolidado}
    function create_then_block_2(ctx) {
    	let current;

    	const linhapoder = new LinhaPoder({
    			props: {
    				titulo: "Consolidado",
    				pessoalDespesa: /*dataConsolidado*/ ctx[9].pessoalConsolidadoDespesa,
    				rankingDespesa: /*dataConsolidado*/ ctx[9].pessoalConsolidadoRankingDespesa,
    				pessoalDespesaPerCapita: /*dataConsolidado*/ ctx[9].pessoalConsolidadoDespesaPerCapita,
    				rankingDespesaPerCapita: /*dataConsolidado*/ ctx[9].pessoalConsolidadoRankingDespesaPerCapita,
    				evolucaoAnual: /*dataConsolidado*/ ctx[9].pessoalConsolidadoEvolucaoAnual,
    				$$slots: { limite: [create_limite_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(linhapoder.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(linhapoder, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const linhapoder_changes = {};
    			if (dirty & /*promiseConsolidado*/ 1) linhapoder_changes.pessoalDespesa = /*dataConsolidado*/ ctx[9].pessoalConsolidadoDespesa;
    			if (dirty & /*promiseConsolidado*/ 1) linhapoder_changes.rankingDespesa = /*dataConsolidado*/ ctx[9].pessoalConsolidadoRankingDespesa;
    			if (dirty & /*promiseConsolidado*/ 1) linhapoder_changes.pessoalDespesaPerCapita = /*dataConsolidado*/ ctx[9].pessoalConsolidadoDespesaPerCapita;
    			if (dirty & /*promiseConsolidado*/ 1) linhapoder_changes.rankingDespesaPerCapita = /*dataConsolidado*/ ctx[9].pessoalConsolidadoRankingDespesaPerCapita;
    			if (dirty & /*promiseConsolidado*/ 1) linhapoder_changes.evolucaoAnual = /*dataConsolidado*/ ctx[9].pessoalConsolidadoEvolucaoAnual;

    			if (dirty & /*$$scope, promiseConsolidado*/ 1025) {
    				linhapoder_changes.$$scope = { dirty, ctx };
    			}

    			linhapoder.$set(linhapoder_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linhapoder.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linhapoder.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linhapoder, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_2.name,
    		type: "then",
    		source: "(110:0) {:then dataConsolidado}",
    		ctx
    	});

    	return block;
    }

    // (118:4) <span slot="limite">
    function create_limite_slot_2(ctx) {
    	let span;
    	let current;

    	const limiteconstitucionalpessoalconsolidado = new LimiteConstitucionalPessoalConsolidado({
    			props: {
    				limite: /*dataConsolidado*/ ctx[9].pessoalConsolidadoDespesa.value.limiteConstitucional,
    				height: 48
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(limiteconstitucionalpessoalconsolidado.$$.fragment);
    			attr_dev(span, "slot", "limite");
    			add_location(span, file$17, 117, 4, 4134);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(limiteconstitucionalpessoalconsolidado, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const limiteconstitucionalpessoalconsolidado_changes = {};
    			if (dirty & /*promiseConsolidado*/ 1) limiteconstitucionalpessoalconsolidado_changes.limite = /*dataConsolidado*/ ctx[9].pessoalConsolidadoDespesa.value.limiteConstitucional;
    			limiteconstitucionalpessoalconsolidado.$set(limiteconstitucionalpessoalconsolidado_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(limiteconstitucionalpessoalconsolidado.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(limiteconstitucionalpessoalconsolidado.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(limiteconstitucionalpessoalconsolidado);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_limite_slot_2.name,
    		type: "slot",
    		source: "(118:4) <span slot=\\\"limite\\\">",
    		ctx
    	});

    	return block;
    }

    // (108:27)     <Loading />  {:then dataConsolidado}
    function create_pending_block_2(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_2.name,
    		type: "pending",
    		source: "(108:27)     <Loading />  {:then dataConsolidado}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>    import { params }
    function create_catch_block_1(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1.name,
    		type: "catch",
    		source: "(1:0) <script>    import { params }",
    		ctx
    	});

    	return block;
    }

    // (128:0) {:then dataExecutivo}
    function create_then_block_1(ctx) {
    	let current;

    	const linhapoder = new LinhaPoder({
    			props: {
    				titulo: "Executivo",
    				pessoalDespesa: /*dataExecutivo*/ ctx[8].pessoalExecutivoDespesa,
    				rankingDespesa: /*dataExecutivo*/ ctx[8].pessoalExecutivoRankingDespesa,
    				pessoalDespesaPerCapita: /*dataExecutivo*/ ctx[8].pessoalExecutivoDespesaPerCapita,
    				rankingDespesaPerCapita: /*dataExecutivo*/ ctx[8].pessoalExecutivoRankingDespesaPerCapita,
    				evolucaoAnual: /*dataExecutivo*/ ctx[8].pessoalExecutivoEvolucaoAnual,
    				$$slots: { limite: [create_limite_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(linhapoder.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(linhapoder, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const linhapoder_changes = {};
    			if (dirty & /*promiseExecutivo*/ 2) linhapoder_changes.pessoalDespesa = /*dataExecutivo*/ ctx[8].pessoalExecutivoDespesa;
    			if (dirty & /*promiseExecutivo*/ 2) linhapoder_changes.rankingDespesa = /*dataExecutivo*/ ctx[8].pessoalExecutivoRankingDespesa;
    			if (dirty & /*promiseExecutivo*/ 2) linhapoder_changes.pessoalDespesaPerCapita = /*dataExecutivo*/ ctx[8].pessoalExecutivoDespesaPerCapita;
    			if (dirty & /*promiseExecutivo*/ 2) linhapoder_changes.rankingDespesaPerCapita = /*dataExecutivo*/ ctx[8].pessoalExecutivoRankingDespesaPerCapita;
    			if (dirty & /*promiseExecutivo*/ 2) linhapoder_changes.evolucaoAnual = /*dataExecutivo*/ ctx[8].pessoalExecutivoEvolucaoAnual;

    			if (dirty & /*$$scope, promiseExecutivo*/ 1026) {
    				linhapoder_changes.$$scope = { dirty, ctx };
    			}

    			linhapoder.$set(linhapoder_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linhapoder.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linhapoder.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linhapoder, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1.name,
    		type: "then",
    		source: "(128:0) {:then dataExecutivo}",
    		ctx
    	});

    	return block;
    }

    // (136:4) <span slot="limite">
    function create_limite_slot_1(ctx) {
    	let span;
    	let current;

    	const limiteconstitucionalpessoalexecutivo = new LimiteConstitucionalPessoalExecutivo({
    			props: {
    				limite: /*dataExecutivo*/ ctx[8].pessoalExecutivoDespesa.value.limiteConstitucional,
    				height: 48
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(limiteconstitucionalpessoalexecutivo.$$.fragment);
    			attr_dev(span, "slot", "limite");
    			add_location(span, file$17, 135, 4, 4820);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(limiteconstitucionalpessoalexecutivo, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const limiteconstitucionalpessoalexecutivo_changes = {};
    			if (dirty & /*promiseExecutivo*/ 2) limiteconstitucionalpessoalexecutivo_changes.limite = /*dataExecutivo*/ ctx[8].pessoalExecutivoDespesa.value.limiteConstitucional;
    			limiteconstitucionalpessoalexecutivo.$set(limiteconstitucionalpessoalexecutivo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(limiteconstitucionalpessoalexecutivo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(limiteconstitucionalpessoalexecutivo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(limiteconstitucionalpessoalexecutivo);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_limite_slot_1.name,
    		type: "slot",
    		source: "(136:4) <span slot=\\\"limite\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:25)     <Loading />  {:then dataExecutivo}
    function create_pending_block_1(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1.name,
    		type: "pending",
    		source: "(126:25)     <Loading />  {:then dataExecutivo}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>    import { params }
    function create_catch_block(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(1:0) <script>    import { params }",
    		ctx
    	});

    	return block;
    }

    // (146:0) {:then dataLegislativo}
    function create_then_block(ctx) {
    	let current;

    	const linhapoder = new LinhaPoder({
    			props: {
    				titulo: "Legislativo",
    				pessoalDespesa: /*dataLegislativo*/ ctx[7].pessoalLegislativoDespesa,
    				rankingDespesa: /*dataLegislativo*/ ctx[7].pessoalLegislativoRankingDespesa,
    				pessoalDespesaPerCapita: /*dataLegislativo*/ ctx[7].pessoalLegislativoDespesaPerCapita,
    				rankingDespesaPerCapita: /*dataLegislativo*/ ctx[7].pessoalLegislativoRankingDespesaPerCapita,
    				evolucaoAnual: /*dataLegislativo*/ ctx[7].pessoalLegislativoEvolucaoAnual,
    				$$slots: { limite: [create_limite_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(linhapoder.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(linhapoder, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const linhapoder_changes = {};
    			if (dirty & /*promiseLegislativo*/ 4) linhapoder_changes.pessoalDespesa = /*dataLegislativo*/ ctx[7].pessoalLegislativoDespesa;
    			if (dirty & /*promiseLegislativo*/ 4) linhapoder_changes.rankingDespesa = /*dataLegislativo*/ ctx[7].pessoalLegislativoRankingDespesa;
    			if (dirty & /*promiseLegislativo*/ 4) linhapoder_changes.pessoalDespesaPerCapita = /*dataLegislativo*/ ctx[7].pessoalLegislativoDespesaPerCapita;
    			if (dirty & /*promiseLegislativo*/ 4) linhapoder_changes.rankingDespesaPerCapita = /*dataLegislativo*/ ctx[7].pessoalLegislativoRankingDespesaPerCapita;
    			if (dirty & /*promiseLegislativo*/ 4) linhapoder_changes.evolucaoAnual = /*dataLegislativo*/ ctx[7].pessoalLegislativoEvolucaoAnual;

    			if (dirty & /*$$scope, promiseLegislativo*/ 1028) {
    				linhapoder_changes.$$scope = { dirty, ctx };
    			}

    			linhapoder.$set(linhapoder_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linhapoder.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linhapoder.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linhapoder, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(146:0) {:then dataLegislativo}",
    		ctx
    	});

    	return block;
    }

    // (154:4) <span slot="limite">
    function create_limite_slot(ctx) {
    	let span;
    	let current;

    	const limiteconstitucionalpessoallegislativo = new LimiteConstitucionalPessoalLegislativo({
    			props: {
    				limite: /*dataLegislativo*/ ctx[7].pessoalLegislativoDespesa.value.limiteConstitucional,
    				height: 48
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(limiteconstitucionalpessoallegislativo.$$.fragment);
    			attr_dev(span, "slot", "limite");
    			add_location(span, file$17, 153, 4, 5526);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(limiteconstitucionalpessoallegislativo, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const limiteconstitucionalpessoallegislativo_changes = {};
    			if (dirty & /*promiseLegislativo*/ 4) limiteconstitucionalpessoallegislativo_changes.limite = /*dataLegislativo*/ ctx[7].pessoalLegislativoDespesa.value.limiteConstitucional;
    			limiteconstitucionalpessoallegislativo.$set(limiteconstitucionalpessoallegislativo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(limiteconstitucionalpessoallegislativo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(limiteconstitucionalpessoallegislativo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(limiteconstitucionalpessoallegislativo);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_limite_slot.name,
    		type: "slot",
    		source: "(154:4) <span slot=\\\"limite\\\">",
    		ctx
    	});

    	return block;
    }

    // (144:27)     <Loading />  {:then dataLegislativo}
    function create_pending_block(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(144:27)     <Loading />  {:then dataLegislativo}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1c(ctx) {
    	let t0;
    	let promise;
    	let t1;
    	let promise_1;
    	let t2;
    	let await_block2_anchor;
    	let promise_2;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block_2,
    		then: create_then_block_2,
    		catch: create_catch_block_2,
    		value: 9,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*promiseConsolidado*/ ctx[0], info);

    	let info_1 = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block_1,
    		then: create_then_block_1,
    		catch: create_catch_block_1,
    		value: 8,
    		blocks: [,,,]
    	};

    	handle_promise(promise_1 = /*promiseExecutivo*/ ctx[1], info_1);

    	let info_2 = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 7,
    		blocks: [,,,]
    	};

    	handle_promise(promise_2 = /*promiseLegislativo*/ ctx[2], info_2);

    	const block = {
    		c: function create() {
    			t0 = space();
    			info.block.c();
    			t1 = space();
    			info_1.block.c();
    			t2 = space();
    			await_block2_anchor = empty();
    			info_2.block.c();
    			document.title = "Pessoal";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => t1.parentNode;
    			info.anchor = t1;
    			insert_dev(target, t1, anchor);
    			info_1.block.m(target, info_1.anchor = anchor);
    			info_1.mount = () => t2.parentNode;
    			info_1.anchor = t2;
    			insert_dev(target, t2, anchor);
    			insert_dev(target, await_block2_anchor, anchor);
    			info_2.block.m(target, info_2.anchor = anchor);
    			info_2.mount = () => await_block2_anchor.parentNode;
    			info_2.anchor = await_block2_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*promiseConsolidado*/ 1 && promise !== (promise = /*promiseConsolidado*/ ctx[0]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[9] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}

    			info_1.ctx = ctx;

    			if (dirty & /*promiseExecutivo*/ 2 && promise_1 !== (promise_1 = /*promiseExecutivo*/ ctx[1]) && handle_promise(promise_1, info_1)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[8] = info_1.resolved;
    				info_1.block.p(child_ctx, dirty);
    			}

    			info_2.ctx = ctx;

    			if (dirty & /*promiseLegislativo*/ 4 && promise_2 !== (promise_2 = /*promiseLegislativo*/ ctx[2]) && handle_promise(promise_2, info_2)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[7] = info_2.resolved;
    				info_2.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			transition_in(info_1.block);
    			transition_in(info_2.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			for (let i = 0; i < 3; i += 1) {
    				const block = info_1.blocks[i];
    				transition_out(block);
    			}

    			for (let i = 0; i < 3; i += 1) {
    				const block = info_2.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    			if (detaching) detach_dev(t1);
    			info_1.block.d(detaching);
    			info_1.token = null;
    			info_1 = null;
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(await_block2_anchor);
    			info_2.block.d(detaching);
    			info_2.token = null;
    			info_2 = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(4, $params = $$value));
    	let ano;
    	let promiseConsolidado;
    	let promiseExecutivo;
    	let promiseLegislativo;

    	function refresh(params) {
    		ano = parseInt(params.ano);
    		const municipio = params.municipio;
    		const workflowsConsolidado = pessoalConsolidadoDespesa(ano, municipio).concat(pessoalConsolidadoDespesaPerCapita(ano, municipio)).concat(pessoalConsolidadoEvolucaoAnual(ano, municipio)).concat(pessoalConsolidadoRankingDespesa(ano, municipio)).concat(pessoalConsolidadoRankingDespesaPerCapita(ano, municipio));
    		const workflowsExecutivo = pessoalExecutivoDespesa(ano, municipio).concat(pessoalExecutivoDespesaPerCapita(ano, municipio)).concat(pessoalExecutivoEvolucaoAnual(ano, municipio)).concat(pessoalExecutivoRankingDespesa(ano, municipio)).concat(pessoalExecutivoRankingDespesaPerCapita(ano, municipio));
    		const workflowsLegislativo = pessoalLegislativoDespesa(ano, municipio).concat(pessoalLegislativoDespesaPerCapita(ano, municipio)).concat(pessoalLegislativoEvolucaoAnual(ano, municipio)).concat(pessoalLegislativoRankingDespesa(ano, municipio)).concat(pessoalLegislativoRankingDespesaPerCapita(ano, municipio));
    		$$invalidate(0, promiseConsolidado = getData(workflowsConsolidado));
    		$$invalidate(1, promiseExecutivo = getData(workflowsExecutivo));
    		$$invalidate(2, promiseLegislativo = getData(workflowsLegislativo));
    	}

    	async function getData(workflows) {
    		return axios$1.post(api.getApiUrl("ControleSocial"), workflows).then(r => {
    			const data = {};

    			for (let i in r.data) {
    				data[r.data[i].id] = r.data[i];
    			}

    			return data;
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Pessoal> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Pessoal", $$slots, []);

    	$$self.$capture_state = () => ({
    		params,
    		axios: axios$1,
    		api,
    		Loading,
    		LinhaPoder,
    		PrestacaoContaMensal,
    		LimiteConstitucionalPessoalConsolidado,
    		LimiteConstitucionalPessoalExecutivo,
    		LimiteConstitucionalPessoalLegislativo,
    		prestacaoContaApi,
    		pessoalConsolidadoApi,
    		pessoalExecutivoApi,
    		pessoalLegislativoApi,
    		ano,
    		promiseConsolidado,
    		promiseExecutivo,
    		promiseLegislativo,
    		refresh,
    		getData,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("ano" in $$props) ano = $$props.ano;
    		if ("promiseConsolidado" in $$props) $$invalidate(0, promiseConsolidado = $$props.promiseConsolidado);
    		if ("promiseExecutivo" in $$props) $$invalidate(1, promiseExecutivo = $$props.promiseExecutivo);
    		if ("promiseLegislativo" in $$props) $$invalidate(2, promiseLegislativo = $$props.promiseLegislativo);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 16) {
    			 refresh($params);
    		}
    	};

    	return [promiseConsolidado, promiseExecutivo, promiseLegislativo];
    }

    class Pessoal$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pessoal",
    			options,
    			id: create_fragment$1c.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\previdencia\despesa\index.svelte generated by Svelte v3.22.3 */
    const file$18 = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\previdencia\\despesa\\index.svelte";

    // (36:4) <span slot="title">
    function create_title_slot$n(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Saúde";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$18, 35, 4, 865);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$n.name,
    		type: "slot",
    		source: "(36:4) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:4) <span slot="tooltip">
    function create_tooltip_slot$o(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "A Constituição Federal estabelece que o município deve aplicar o limite\r\n      mínimo de 15% da soma dos recursos de impostos e transferências em ações e\r\n      serviços públicos de saúde.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$18, 36, 4, 902);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$o.name,
    		type: "slot",
    		source: "(37:4) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (35:2) <Widget class="xl:w-1/4 lg:w-1/3 sm:w-1/2 w-full">
    function create_default_slot$E(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const gauge = new Gauge({
    			props: { data: /*data*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(gauge.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$18, 41, 4, 1138);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(gauge, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const gauge_changes = {};
    			if (dirty & /*data*/ 1) gauge_changes.data = /*data*/ ctx[0];
    			gauge.$set(gauge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(gauge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(gauge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(gauge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$E.name,
    		type: "slot",
    		source: "(35:2) <Widget class=\\\"xl:w-1/4 lg:w-1/3 sm:w-1/2 w-full\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1d(ctx) {
    	let t;
    	let div;
    	let current;

    	const widget = new Widget({
    			props: {
    				class: "xl:w-1/4 lg:w-1/3 sm:w-1/2 w-full",
    				$$slots: {
    					default: [create_default_slot$E],
    					tooltip: [create_tooltip_slot$o],
    					title: [create_title_slot$n]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			div = element("div");
    			create_component(widget.$$.fragment);
    			document.title = "Despesas - Previdência";
    			attr_dev(div, "class", "flex flex-wrap w-full");
    			add_location(div, file$18, 33, 0, 770);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(widget, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, data*/ 5) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_component(widget);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function preload(page, session) {
    	return { params: page.params };
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let { params } = $$props;
    	let data;

    	onMount(async () => {
    		const { ano, municipio, ug } = params;
    		const res = await fetch(`municipio/${ano}/${municipio}/${ug}/despesa/data.json`);

    		if (res.status === 200) {
    			$$invalidate(0, data = await res.json());
    		} //this.error(res.status, data.message);
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Despesa> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Despesa", $$slots, []);

    	$$self.$set = $$props => {
    		if ("params" in $$props) $$invalidate(1, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		preload,
    		onMount,
    		Widget,
    		Gauge,
    		params,
    		data
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(1, params = $$props.params);
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data, params];
    }

    class Despesa extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1d, safe_not_equal, { params: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Despesa",
    			options,
    			id: create_fragment$1d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*params*/ ctx[1] === undefined && !("params" in props)) {
    			console.warn("<Despesa> was created without expected prop 'params'");
    		}
    	}

    	get params() {
    		throw new Error("<Despesa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Despesa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\previdencia\index.svelte generated by Svelte v3.22.3 */

    const { console: console_1$1 } = globals;

    function create_fragment$1e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Regime geral de previdência social (INSS). O município por ser optante pelo\r\nregime geral não gerencia nem executa despesas com benefícios previdenciários de\r\nseus servidores.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	onMount(() => {
    		console.log("m");
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Previdencia> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Previdencia", $$slots, []);
    	$$self.$capture_state = () => ({ onMount });
    	return [];
    }

    class Previdencia extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Previdencia",
    			options,
    			id: create_fragment$1e.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\previdencia\receita\index.svelte generated by Svelte v3.22.3 */

    function create_fragment$1f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("receita previdencia");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Receita> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Receita", $$slots, []);
    	return [];
    }

    class Receita extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Receita",
    			options,
    			id: create_fragment$1f.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\receitas\_components\CardArrecadada.svelte generated by Svelte v3.22.3 */
    const file$19 = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\receitas\\_components\\CardArrecadada.svelte";

    // (11:2) <span slot="title">
    function create_title_slot$o(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Receita arrecadada";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$19, 10, 2, 323);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$o.name,
    		type: "slot",
    		source: "(11:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:2) <span slot="tooltip">
    function create_tooltip_slot$p(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "É o montante total (impostos, taxas, contribuições e outras fontes de\r\n    recursos) incorporado ao patrimônio que serve para custear as despesas\r\n    públicas e as necessidades de investimentos públicos.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$19, 11, 2, 371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$p.name,
    		type: "slot",
    		source: "(12:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (31:4) {:else}
    function create_else_block$k(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$k.name,
    		type: "else",
    		source: "(31:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#if remessa}
    function create_if_block$r(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = format(/*remessa*/ ctx[0].value.arrecadada) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "R$";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			attr_dev(span0, "class", "text-sm");
    			add_location(span0, file$19, 19, 8, 697);
    			attr_dev(span1, "class", "text-4xl font-bold");
    			add_location(span1, file$19, 20, 8, 738);
    			attr_dev(div, "class", "text-center");
    			add_location(div, file$19, 18, 6, 662);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*remessa*/ 1 && t2_value !== (t2_value = format(/*remessa*/ ctx[0].value.arrecadada) + "")) set_data_dev(t2, t2_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(18:4) {#if remessa}",
    		ctx
    	});

    	return block;
    }

    // (10:0) <Widget>
    function create_default_slot$F(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$r, create_else_block$k];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*remessa*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$19, 16, 2, 617);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$F.name,
    		type: "slot",
    		source: "(10:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1g(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$F],
    					tooltip: [create_tooltip_slot$p],
    					title: [create_title_slot$o]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, remessa*/ 3) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let { remessa } = $$props;
    	const writable_props = ["remessa"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardArrecadada> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("CardArrecadada", $$slots, []);

    	$$self.$set = $$props => {
    		if ("remessa" in $$props) $$invalidate(0, remessa = $$props.remessa);
    	};

    	$$self.$capture_state = () => ({ Loading, Widget, format, remessa });

    	$$self.$inject_state = $$props => {
    		if ("remessa" in $$props) $$invalidate(0, remessa = $$props.remessa);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [remessa];
    }

    class CardArrecadada extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1g, safe_not_equal, { remessa: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardArrecadada",
    			options,
    			id: create_fragment$1g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*remessa*/ ctx[0] === undefined && !("remessa" in props)) {
    			console.warn("<CardArrecadada> was created without expected prop 'remessa'");
    		}
    	}

    	get remessa() {
    		throw new Error("<CardArrecadada>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set remessa(value) {
    		throw new Error("<CardArrecadada>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\receitas\_components\ComposicaoArrecadada.svelte generated by Svelte v3.22.3 */

    const { console: console_1$2 } = globals;
    const file$1a = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\receitas\\_components\\ComposicaoArrecadada.svelte";

    // (43:2) <span slot="title">
    function create_title_slot$p(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Composição da receita arrecadada";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1a, 42, 2, 1071);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$p.name,
    		type: "slot",
    		source: "(43:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:2) <span slot="tooltip">
    function create_tooltip_slot$q(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Distribuição da origem das receitas do município. Este indicador demonstra o\r\n    grau de dependência que o município tem de transferências do Estado e da\r\n    União, apontando se possui arrecadação sustentável ou não.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1a, 43, 2, 1133);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$q.name,
    		type: "slot",
    		source: "(44:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (42:0) <Widget>
    function create_default_slot$G(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const doughnut = new Doughnut({
    			props: { data: /*data*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(doughnut.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$1a, 48, 2, 1393);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(doughnut, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const doughnut_changes = {};
    			if (dirty & /*data*/ 1) doughnut_changes.data = /*data*/ ctx[0];
    			doughnut.$set(doughnut_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(doughnut.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(doughnut.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(doughnut);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$G.name,
    		type: "slot",
    		source: "(42:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1h(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$G],
    					tooltip: [create_tooltip_slot$q],
    					title: [create_title_slot$p]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, data*/ 9) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let { composicaoArrecadada } = $$props;
    	let data;

    	function render(composicaoArrecadada) {
    		if (!composicaoArrecadada) {
    			return;
    		}

    		console.log(composicaoArrecadada);

    		$$invalidate(0, data = [
    			{
    				name: "Receitas do município",
    				value: composicaoArrecadada.value.receitasDoMunicipio
    			},
    			{
    				name: "Transferências do estado",
    				value: composicaoArrecadada.value.transferenciaDoEstado
    			},
    			{
    				name: "Transferências da união",
    				value: composicaoArrecadada.value.transferenciaDaUniao
    			},
    			{
    				name: "Operações de crédito",
    				value: composicaoArrecadada.value.operacoesDeCredito
    			},
    			{
    				name: "Outras transferências",
    				value: composicaoArrecadada.value.outrasTransferencias
    			}
    		]);
    	}

    	const writable_props = ["composicaoArrecadada"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<ComposicaoArrecadada> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComposicaoArrecadada", $$slots, []);

    	$$self.$set = $$props => {
    		if ("composicaoArrecadada" in $$props) $$invalidate(1, composicaoArrecadada = $$props.composicaoArrecadada);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Doughnut,
    		composicaoArrecadada,
    		data,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("composicaoArrecadada" in $$props) $$invalidate(1, composicaoArrecadada = $$props.composicaoArrecadada);
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*composicaoArrecadada*/ 2) {
    			 render(composicaoArrecadada);
    		}
    	};

    	return [data, composicaoArrecadada];
    }

    class ComposicaoArrecadada extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1h, safe_not_equal, { composicaoArrecadada: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComposicaoArrecadada",
    			options,
    			id: create_fragment$1h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*composicaoArrecadada*/ ctx[1] === undefined && !("composicaoArrecadada" in props)) {
    			console_1$2.warn("<ComposicaoArrecadada> was created without expected prop 'composicaoArrecadada'");
    		}
    	}

    	get composicaoArrecadada() {
    		throw new Error("<ComposicaoArrecadada>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set composicaoArrecadada(value) {
    		throw new Error("<ComposicaoArrecadada>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var faCar = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'car';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f1b9';
    var svgPathData = 'M499.99 176h-59.87l-16.64-41.6C406.38 91.63 365.57 64 319.5 64h-127c-46.06 0-86.88 27.63-103.99 70.4L71.87 176H12.01C4.2 176-1.53 183.34.37 190.91l6 24C7.7 220.25 12.5 224 18.01 224h20.07C24.65 235.73 16 252.78 16 272v48c0 16.12 6.16 30.67 16 41.93V416c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32v-32h256v32c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32v-54.07c9.84-11.25 16-25.8 16-41.93v-48c0-19.22-8.65-36.27-22.07-48H494c5.51 0 10.31-3.75 11.64-9.09l6-24c1.89-7.57-3.84-14.91-11.65-14.91zm-352.06-17.83c7.29-18.22 24.94-30.17 44.57-30.17h127c19.63 0 37.28 11.95 44.57 30.17L384 208H128l19.93-49.83zM96 319.8c-19.2 0-32-12.76-32-31.9S76.8 256 96 256s48 28.71 48 47.85-28.8 15.95-48 15.95zm320 0c-19.2 0-48 3.19-48-15.95S396.8 256 416 256s32 12.76 32 31.9-12.8 31.9-32 31.9z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faCar = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faCar);
    var faCar_1 = faCar.definition;
    var faCar_2 = faCar.faCar;
    var faCar_3 = faCar.prefix;
    var faCar_4 = faCar.iconName;
    var faCar_5 = faCar.width;
    var faCar_6 = faCar.height;
    var faCar_7 = faCar.ligatures;
    var faCar_8 = faCar.unicode;
    var faCar_9 = faCar.svgPathData;

    var faCogs = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'cogs';
    var width = 640;
    var height = 512;
    var ligatures = [];
    var unicode = 'f085';
    var svgPathData = 'M512.1 191l-8.2 14.3c-3 5.3-9.4 7.5-15.1 5.4-11.8-4.4-22.6-10.7-32.1-18.6-4.6-3.8-5.8-10.5-2.8-15.7l8.2-14.3c-6.9-8-12.3-17.3-15.9-27.4h-16.5c-6 0-11.2-4.3-12.2-10.3-2-12-2.1-24.6 0-37.1 1-6 6.2-10.4 12.2-10.4h16.5c3.6-10.1 9-19.4 15.9-27.4l-8.2-14.3c-3-5.2-1.9-11.9 2.8-15.7 9.5-7.9 20.4-14.2 32.1-18.6 5.7-2.1 12.1.1 15.1 5.4l8.2 14.3c10.5-1.9 21.2-1.9 31.7 0L552 6.3c3-5.3 9.4-7.5 15.1-5.4 11.8 4.4 22.6 10.7 32.1 18.6 4.6 3.8 5.8 10.5 2.8 15.7l-8.2 14.3c6.9 8 12.3 17.3 15.9 27.4h16.5c6 0 11.2 4.3 12.2 10.3 2 12 2.1 24.6 0 37.1-1 6-6.2 10.4-12.2 10.4h-16.5c-3.6 10.1-9 19.4-15.9 27.4l8.2 14.3c3 5.2 1.9 11.9-2.8 15.7-9.5 7.9-20.4 14.2-32.1 18.6-5.7 2.1-12.1-.1-15.1-5.4l-8.2-14.3c-10.4 1.9-21.2 1.9-31.7 0zm-10.5-58.8c38.5 29.6 82.4-14.3 52.8-52.8-38.5-29.7-82.4 14.3-52.8 52.8zM386.3 286.1l33.7 16.8c10.1 5.8 14.5 18.1 10.5 29.1-8.9 24.2-26.4 46.4-42.6 65.8-7.4 8.9-20.2 11.1-30.3 5.3l-29.1-16.8c-16 13.7-34.6 24.6-54.9 31.7v33.6c0 11.6-8.3 21.6-19.7 23.6-24.6 4.2-50.4 4.4-75.9 0-11.5-2-20-11.9-20-23.6V418c-20.3-7.2-38.9-18-54.9-31.7L74 403c-10 5.8-22.9 3.6-30.3-5.3-16.2-19.4-33.3-41.6-42.2-65.7-4-10.9.4-23.2 10.5-29.1l33.3-16.8c-3.9-20.9-3.9-42.4 0-63.4L12 205.8c-10.1-5.8-14.6-18.1-10.5-29 8.9-24.2 26-46.4 42.2-65.8 7.4-8.9 20.2-11.1 30.3-5.3l29.1 16.8c16-13.7 34.6-24.6 54.9-31.7V57.1c0-11.5 8.2-21.5 19.6-23.5 24.6-4.2 50.5-4.4 76-.1 11.5 2 20 11.9 20 23.6v33.6c20.3 7.2 38.9 18 54.9 31.7l29.1-16.8c10-5.8 22.9-3.6 30.3 5.3 16.2 19.4 33.2 41.6 42.1 65.8 4 10.9.1 23.2-10 29.1l-33.7 16.8c3.9 21 3.9 42.5 0 63.5zm-117.6 21.1c59.2-77-28.7-164.9-105.7-105.7-59.2 77 28.7 164.9 105.7 105.7zm243.4 182.7l-8.2 14.3c-3 5.3-9.4 7.5-15.1 5.4-11.8-4.4-22.6-10.7-32.1-18.6-4.6-3.8-5.8-10.5-2.8-15.7l8.2-14.3c-6.9-8-12.3-17.3-15.9-27.4h-16.5c-6 0-11.2-4.3-12.2-10.3-2-12-2.1-24.6 0-37.1 1-6 6.2-10.4 12.2-10.4h16.5c3.6-10.1 9-19.4 15.9-27.4l-8.2-14.3c-3-5.2-1.9-11.9 2.8-15.7 9.5-7.9 20.4-14.2 32.1-18.6 5.7-2.1 12.1.1 15.1 5.4l8.2 14.3c10.5-1.9 21.2-1.9 31.7 0l8.2-14.3c3-5.3 9.4-7.5 15.1-5.4 11.8 4.4 22.6 10.7 32.1 18.6 4.6 3.8 5.8 10.5 2.8 15.7l-8.2 14.3c6.9 8 12.3 17.3 15.9 27.4h16.5c6 0 11.2 4.3 12.2 10.3 2 12 2.1 24.6 0 37.1-1 6-6.2 10.4-12.2 10.4h-16.5c-3.6 10.1-9 19.4-15.9 27.4l8.2 14.3c3 5.2 1.9 11.9-2.8 15.7-9.5 7.9-20.4 14.2-32.1 18.6-5.7 2.1-12.1-.1-15.1-5.4l-8.2-14.3c-10.4 1.9-21.2 1.9-31.7 0zM501.6 431c38.5 29.6 82.4-14.3 52.8-52.8-38.5-29.6-82.4 14.3-52.8 52.8z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faCogs = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faCogs);
    var faCogs_1 = faCogs.definition;
    var faCogs_2 = faCogs.faCogs;
    var faCogs_3 = faCogs.prefix;
    var faCogs_4 = faCogs.iconName;
    var faCogs_5 = faCogs.width;
    var faCogs_6 = faCogs.height;
    var faCogs_7 = faCogs.ligatures;
    var faCogs_8 = faCogs.unicode;
    var faCogs_9 = faCogs.svgPathData;

    var faExchangeAlt = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'exchange-alt';
    var width = 512;
    var height = 512;
    var ligatures = [];
    var unicode = 'f362';
    var svgPathData = 'M0 168v-16c0-13.255 10.745-24 24-24h360V80c0-21.367 25.899-32.042 40.971-16.971l80 80c9.372 9.373 9.372 24.569 0 33.941l-80 80C409.956 271.982 384 261.456 384 240v-48H24c-13.255 0-24-10.745-24-24zm488 152H128v-48c0-21.314-25.862-32.08-40.971-16.971l-80 80c-9.372 9.373-9.372 24.569 0 33.941l80 80C102.057 463.997 128 453.437 128 432v-48h360c13.255 0 24-10.745 24-24v-16c0-13.255-10.745-24-24-24z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faExchangeAlt = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faExchangeAlt);
    var faExchangeAlt_1 = faExchangeAlt.definition;
    var faExchangeAlt_2 = faExchangeAlt.faExchangeAlt;
    var faExchangeAlt_3 = faExchangeAlt.prefix;
    var faExchangeAlt_4 = faExchangeAlt.iconName;
    var faExchangeAlt_5 = faExchangeAlt.width;
    var faExchangeAlt_6 = faExchangeAlt.height;
    var faExchangeAlt_7 = faExchangeAlt.ligatures;
    var faExchangeAlt_8 = faExchangeAlt.unicode;
    var faExchangeAlt_9 = faExchangeAlt.svgPathData;

    var faHandHoldingUsd = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'hand-holding-usd';
    var width = 576;
    var height = 512;
    var ligatures = [];
    var unicode = 'f4c0';
    var svgPathData = 'M271.06,144.3l54.27,14.3a8.59,8.59,0,0,1,6.63,8.1c0,4.6-4.09,8.4-9.12,8.4h-35.6a30,30,0,0,1-11.19-2.2c-5.24-2.2-11.28-1.7-15.3,2l-19,17.5a11.68,11.68,0,0,0-2.25,2.66,11.42,11.42,0,0,0,3.88,15.74,83.77,83.77,0,0,0,34.51,11.5V240c0,8.8,7.83,16,17.37,16h17.37c9.55,0,17.38-7.2,17.38-16V222.4c32.93-3.6,57.84-31,53.5-63-3.15-23-22.46-41.3-46.56-47.7L282.68,97.4a8.59,8.59,0,0,1-6.63-8.1c0-4.6,4.09-8.4,9.12-8.4h35.6A30,30,0,0,1,332,83.1c5.23,2.2,11.28,1.7,15.3-2l19-17.5A11.31,11.31,0,0,0,368.47,61a11.43,11.43,0,0,0-3.84-15.78,83.82,83.82,0,0,0-34.52-11.5V16c0-8.8-7.82-16-17.37-16H295.37C285.82,0,278,7.2,278,16V33.6c-32.89,3.6-57.85,31-53.51,63C227.63,119.6,247,137.9,271.06,144.3ZM565.27,328.1c-11.8-10.7-30.2-10-42.6,0L430.27,402a63.64,63.64,0,0,1-40,14H272a16,16,0,0,1,0-32h78.29c15.9,0,30.71-10.9,33.25-26.6a31.2,31.2,0,0,0,.46-5.46A32,32,0,0,0,352,320H192a117.66,117.66,0,0,0-74.1,26.29L71.4,384H16A16,16,0,0,0,0,400v96a16,16,0,0,0,16,16H372.77a64,64,0,0,0,40-14L564,377a32,32,0,0,0,1.28-48.9Z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faHandHoldingUsd = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faHandHoldingUsd);
    var faHandHoldingUsd_1 = faHandHoldingUsd.definition;
    var faHandHoldingUsd_2 = faHandHoldingUsd.faHandHoldingUsd;
    var faHandHoldingUsd_3 = faHandHoldingUsd.prefix;
    var faHandHoldingUsd_4 = faHandHoldingUsd.iconName;
    var faHandHoldingUsd_5 = faHandHoldingUsd.width;
    var faHandHoldingUsd_6 = faHandHoldingUsd.height;
    var faHandHoldingUsd_7 = faHandHoldingUsd.ligatures;
    var faHandHoldingUsd_8 = faHandHoldingUsd.unicode;
    var faHandHoldingUsd_9 = faHandHoldingUsd.svgPathData;

    var faHandshake = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'handshake';
    var width = 640;
    var height = 512;
    var ligatures = [];
    var unicode = 'f2b5';
    var svgPathData = 'M434.7 64h-85.9c-8 0-15.7 3-21.6 8.4l-98.3 90c-.1.1-.2.3-.3.4-16.6 15.6-16.3 40.5-2.1 56 12.7 13.9 39.4 17.6 56.1 2.7.1-.1.3-.1.4-.2l79.9-73.2c6.5-5.9 16.7-5.5 22.6 1 6 6.5 5.5 16.6-1 22.6l-26.1 23.9L504 313.8c2.9 2.4 5.5 5 7.9 7.7V128l-54.6-54.6c-5.9-6-14.1-9.4-22.6-9.4zM544 128.2v223.9c0 17.7 14.3 32 32 32h64V128.2h-96zm48 223.9c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16zM0 384h64c17.7 0 32-14.3 32-32V128.2H0V384zm48-63.9c8.8 0 16 7.2 16 16s-7.2 16-16 16-16-7.2-16-16c0-8.9 7.2-16 16-16zm435.9 18.6L334.6 217.5l-30 27.5c-29.7 27.1-75.2 24.5-101.7-4.4-26.9-29.4-24.8-74.9 4.4-101.7L289.1 64h-83.8c-8.5 0-16.6 3.4-22.6 9.4L128 128v223.9h18.3l90.5 81.9c27.4 22.3 67.7 18.1 90-9.3l.2-.2 17.9 15.5c15.9 13 39.4 10.5 52.3-5.4l31.4-38.6 5.4 4.4c13.7 11.1 33.9 9.1 45-4.7l9.5-11.7c11.2-13.8 9.1-33.9-4.6-45.1z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faHandshake = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faHandshake);
    var faHandshake_1 = faHandshake.definition;
    var faHandshake_2 = faHandshake.faHandshake;
    var faHandshake_3 = faHandshake.prefix;
    var faHandshake_4 = faHandshake.iconName;
    var faHandshake_5 = faHandshake.width;
    var faHandshake_6 = faHandshake.height;
    var faHandshake_7 = faHandshake.ligatures;
    var faHandshake_8 = faHandshake.unicode;
    var faHandshake_9 = faHandshake.svgPathData;

    var faHouseDamage = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'house-damage';
    var width = 576;
    var height = 512;
    var ligatures = [];
    var unicode = 'f6f1';
    var svgPathData = 'M288 114.96L69.47 307.71c-1.62 1.46-3.69 2.14-5.47 3.35V496c0 8.84 7.16 16 16 16h149.23L192 439.19l104.11-64-60.16-119.22L384 392.75l-104.11 64L319.81 512H496c8.84 0 16-7.16 16-16V311.1c-1.7-1.16-3.72-1.82-5.26-3.2L288 114.96zm282.69 121.32L512 184.45V48c0-8.84-7.16-16-16-16h-64c-8.84 0-16 7.16-16 16v51.69L314.75 10.31C307.12 3.45 297.56.01 288 0s-19.1 3.41-26.7 10.27L5.31 236.28c-6.57 5.91-7.12 16.02-1.21 22.6l21.4 23.82c5.9 6.57 16.02 7.12 22.6 1.21L277.42 81.63c6.05-5.33 15.12-5.33 21.17 0L527.91 283.9c6.57 5.9 16.69 5.36 22.6-1.21l21.4-23.82c5.9-6.57 5.36-16.69-1.22-22.59z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faHouseDamage = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faHouseDamage);
    var faHouseDamage_1 = faHouseDamage.definition;
    var faHouseDamage_2 = faHouseDamage.faHouseDamage;
    var faHouseDamage_3 = faHouseDamage.prefix;
    var faHouseDamage_4 = faHouseDamage.iconName;
    var faHouseDamage_5 = faHouseDamage.width;
    var faHouseDamage_6 = faHouseDamage.height;
    var faHouseDamage_7 = faHouseDamage.ligatures;
    var faHouseDamage_8 = faHouseDamage.unicode;
    var faHouseDamage_9 = faHouseDamage.svgPathData;

    var faShoppingCart = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'shopping-cart';
    var width = 576;
    var height = 512;
    var ligatures = [];
    var unicode = 'f07a';
    var svgPathData = 'M528.12 301.319l47.273-208C578.806 78.301 567.391 64 551.99 64H159.208l-9.166-44.81C147.758 8.021 137.93 0 126.529 0H24C10.745 0 0 10.745 0 24v16c0 13.255 10.745 24 24 24h69.883l70.248 343.435C147.325 417.1 136 435.222 136 456c0 30.928 25.072 56 56 56s56-25.072 56-56c0-15.674-6.447-29.835-16.824-40h209.647C430.447 426.165 424 440.326 424 456c0 30.928 25.072 56 56 56s56-25.072 56-56c0-22.172-12.888-41.332-31.579-50.405l5.517-24.276c3.413-15.018-8.002-29.319-23.403-29.319H218.117l-6.545-32h293.145c11.206 0 20.92-7.754 23.403-18.681z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faShoppingCart = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    });

    unwrapExports(faShoppingCart);
    var faShoppingCart_1 = faShoppingCart.definition;
    var faShoppingCart_2 = faShoppingCart.faShoppingCart;
    var faShoppingCart_3 = faShoppingCart.prefix;
    var faShoppingCart_4 = faShoppingCart.iconName;
    var faShoppingCart_5 = faShoppingCart.width;
    var faShoppingCart_6 = faShoppingCart.height;
    var faShoppingCart_7 = faShoppingCart.ligatures;
    var faShoppingCart_8 = faShoppingCart.unicode;
    var faShoppingCart_9 = faShoppingCart.svgPathData;

    /* src\components\Icons\OilRig.svelte generated by Svelte v3.22.3 */

    const file$1b = "src\\components\\Icons\\OilRig.svelte";

    function create_fragment$1i(ctx) {
    	let svg;
    	let g1;
    	let g0;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let polygon0;
    	let polygon1;
    	let polygon2;
    	let polygon3;
    	let polygon4;
    	let polygon5;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			polygon0 = svg_element("polygon");
    			polygon1 = svg_element("polygon");
    			polygon2 = svg_element("polygon");
    			polygon3 = svg_element("polygon");
    			polygon4 = svg_element("polygon");
    			polygon5 = svg_element("polygon");
    			attr_dev(path0, "d", "M207.594,123.406c0,0,4.431-36.9-7.895-61.225c-7.169-14.147-21.447-17.498-29.49-16.025\r\n        c-13.793,2.526-23.965,14.613-22.469,28.556C151.016,105.262,197.188,97.697,207.594,123.406z");
    			add_location(path0, file$1b, 14, 6, 320);
    			attr_dev(path1, "d", "M243.121,115.248c2.687-5.408,0.38-11.808-4.812-14.887c-3.028-1.794-9.296-2.572-14.304,2.073\r\n        c-8.609,7.984-12.327,23.55-12.327,23.55C219.72,117.153,237.24,127.099,243.121,115.248z");
    			add_location(path1, file$1b, 17, 6, 535);
    			attr_dev(path2, "d", "M254.621,60.702c0-9.79-7.959-17.42-17.721-18.149c-5.693-0.422-15.354,2.966-19.276,13.319\r\n        c-6.744,17.802-0.921,43.084-0.921,43.084C222.011,80.337,254.621,82.152,254.621,60.702z");
    			add_location(path2, file$1b, 20, 6, 752);
    			attr_dev(path3, "d", "M207.95,56.438c0,0,5.824-25.283-0.921-43.083c-3.923-10.354-13.583-13.743-19.276-13.32\r\n        c-9.762,0.729-17.722,8.36-17.722,18.149C170.031,39.631,202.642,37.818,207.95,56.438z");
    			add_location(path3, file$1b, 23, 6, 966);
    			attr_dev(polygon0, "points", "244.414,133.231 180.857,133.231 178.509,156.191 250.527,192.94 ");
    			add_location(polygon0, file$1b, 26, 6, 1175);
    			attr_dev(polygon1, "points", "179.027,276.244 262.328,308.179 253.451,221.477 ");
    			add_location(polygon1, file$1b, 28, 6, 1276);
    			attr_dev(polygon2, "points", "267.717,360.866 264.845,332.807 220.179,360.866 ");
    			add_location(polygon2, file$1b, 29, 6, 1353);
    			attr_dev(polygon3, "points", "167.184,266.775 247.705,207.524 176.95,171.421 ");
    			add_location(polygon3, file$1b, 30, 6, 1430);
    			attr_dev(polygon4, "points", "157.551,360.866 192.975,360.866 256.447,320.996 165.218,286.021 ");
    			add_location(polygon4, file$1b, 31, 6, 1506);
    			attr_dev(polygon5, "points", "141.262,374.366 141.262,397.935 161.396,397.935 161.396,425.268\r\n        179.197,425.268 179.197,397.935 246.07,397.935 246.07,425.268\r\n        263.872,425.268 263.872,397.935 284.006,397.935 284.006,374.366 ");
    			add_location(polygon5, file$1b, 33, 6, 1608);
    			add_location(g0, file$1b, 13, 4, 309);
    			add_location(g1, file$1b, 12, 2, 300);
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "x", "0px");
    			attr_dev(svg, "y", "0px");
    			attr_dev(svg, "width", "30px");
    			attr_dev(svg, "height", "57px");
    			attr_dev(svg, "viewBox", "0 0 425.268 425.268");
    			set_style(svg, "enable-background", "new 0 0 425.268 425.268");
    			attr_dev(svg, "xml:space", "preserve");
    			attr_dev(svg, "class", "fill-current");
    			add_location(svg, file$1b, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			append_dev(g0, path0);
    			append_dev(g0, path1);
    			append_dev(g0, path2);
    			append_dev(g0, path3);
    			append_dev(g0, polygon0);
    			append_dev(g0, polygon1);
    			append_dev(g0, polygon2);
    			append_dev(g0, polygon3);
    			append_dev(g0, polygon4);
    			append_dev(g0, polygon5);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OilRig> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("OilRig", $$slots, []);
    	return [];
    }

    class OilRig extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OilRig",
    			options,
    			id: create_fragment$1i.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\receitas\_components\Destaque.svelte generated by Svelte v3.22.3 */

    const file$1c = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\receitas\\_components\\Destaque.svelte";
    const get_title_slot_changes$6 = dirty => ({});
    const get_title_slot_context$6 = ctx => ({});
    const get_icon_slot_changes$3 = dirty => ({});
    const get_icon_slot_context$3 = ctx => ({});

    // (22:2) <span slot="icon">
    function create_icon_slot$3(ctx) {
    	let span;
    	let current;
    	const icon_slot_template = /*$$slots*/ ctx[3].icon;
    	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[4], get_icon_slot_context$3);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (icon_slot) icon_slot.c();
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1c, 21, 2, 480);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (icon_slot) {
    				icon_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (icon_slot) {
    				if (icon_slot.p && dirty & /*$$scope*/ 16) {
    					icon_slot.p(get_slot_context(icon_slot_template, ctx, /*$$scope*/ ctx[4], get_icon_slot_context$3), get_slot_changes(icon_slot_template, /*$$scope*/ ctx[4], dirty, get_icon_slot_changes$3));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (icon_slot) icon_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot$3.name,
    		type: "slot",
    		source: "(22:2) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (25:2) <span slot="title">
    function create_title_slot$q(ctx) {
    	let span;
    	let current;
    	const title_slot_template = /*$$slots*/ ctx[3].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[4], get_title_slot_context$6);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (title_slot) title_slot.c();
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1c, 24, 2, 539);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (title_slot) {
    				title_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && dirty & /*$$scope*/ 16) {
    					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[4], get_title_slot_context$6), get_slot_changes(title_slot_template, /*$$scope*/ ctx[4], dirty, get_title_slot_changes$6));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$q.name,
    		type: "slot",
    		source: "(25:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (14:0) <Destaque    {model}    {workflow}    workflowAnual={receitaEvolucaoAnual}    workflowMensal={receitaEvolucaoMensal}    {title}    seriesName="Receita arrecadada"    seriesProperty="arrecadada">
    function create_default_slot$H(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$H.name,
    		type: "slot",
    		source: "(14:0) <Destaque    {model}    {workflow}    workflowAnual={receitaEvolucaoAnual}    workflowMensal={receitaEvolucaoMensal}    {title}    seriesName=\\\"Receita arrecadada\\\"    seriesProperty=\\\"arrecadada\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1j(ctx) {
    	let current;

    	const destaque = new Destaque({
    			props: {
    				model: /*model*/ ctx[0],
    				workflow: /*workflow*/ ctx[1],
    				workflowAnual: receitaEvolucaoAnual,
    				workflowMensal: receitaEvolucaoMensal,
    				title: /*title*/ ctx[2],
    				seriesName: "Receita arrecadada",
    				seriesProperty: "arrecadada",
    				$$slots: {
    					default: [create_default_slot$H],
    					title: [create_title_slot$q],
    					icon: [create_icon_slot$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(destaque.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(destaque, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const destaque_changes = {};
    			if (dirty & /*model*/ 1) destaque_changes.model = /*model*/ ctx[0];
    			if (dirty & /*workflow*/ 2) destaque_changes.workflow = /*workflow*/ ctx[1];
    			if (dirty & /*title*/ 4) destaque_changes.title = /*title*/ ctx[2];

    			if (dirty & /*$$scope*/ 16) {
    				destaque_changes.$$scope = { dirty, ctx };
    			}

    			destaque.$set(destaque_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(destaque.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(destaque.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(destaque, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { workflow } = $$props;
    	let { title } = $$props;
    	const writable_props = ["model", "workflow", "title"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Destaque> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Destaque", $$slots, ['icon','title']);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("workflow" in $$props) $$invalidate(1, workflow = $$props.workflow);
    		if ("title" in $$props) $$invalidate(2, title = $$props.title);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Destaque,
    		receitaEvolucaoAnual,
    		receitaEvolucaoMensal,
    		model,
    		workflow,
    		title
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("workflow" in $$props) $$invalidate(1, workflow = $$props.workflow);
    		if ("title" in $$props) $$invalidate(2, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model, workflow, title, $$slots, $$scope];
    }

    class Destaque_1$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1j, safe_not_equal, { model: 0, workflow: 1, title: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Destaque_1",
    			options,
    			id: create_fragment$1j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<Destaque> was created without expected prop 'model'");
    		}

    		if (/*workflow*/ ctx[1] === undefined && !("workflow" in props)) {
    			console.warn("<Destaque> was created without expected prop 'workflow'");
    		}

    		if (/*title*/ ctx[2] === undefined && !("title" in props)) {
    			console.warn("<Destaque> was created without expected prop 'title'");
    		}
    	}

    	get model() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get workflow() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set workflow(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Destaque>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Destaque>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\receitas\_components\Destaques.svelte generated by Svelte v3.22.3 */
    const file$1d = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\receitas\\_components\\Destaques.svelte";

    // (144:6) <span slot="title">
    function create_title_slot_12(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Receitas próprias do Município em destaque";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 143, 6, 4278);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_12.name,
    		type: "slot",
    		source: "(144:6) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (145:6) <span slot="tooltip">
    function create_tooltip_slot_2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Destaque das mais relevantes receitas arrecadadas pelo próprio\r\n        Município.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1d, 144, 6, 4354);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot_2.name,
    		type: "slot",
    		source: "(145:6) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (155:12) <span slot="icon">
    function create_icon_slot_9(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faHouseDamage_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1d, 154, 12, 4733);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_9.name,
    		type: "slot",
    		source: "(155:12) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (158:12) <span slot="title">
    function create_title_slot_11(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "IPTU";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 157, 12, 4831);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_11.name,
    		type: "slot",
    		source: "(158:12) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (151:10) <Destaque              model={$store.receitaDestaqueIPTU}              workflow={receitaApi.receitaDestaqueIPTU}              title={titles.iptu}>
    function create_default_slot_12(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(151:10) <Destaque              model={$store.receitaDestaqueIPTU}              workflow={receitaApi.receitaDestaqueIPTU}              title={titles.iptu}>",
    		ctx
    	});

    	return block;
    }

    // (167:12) <span slot="icon">
    function create_icon_slot_8(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faExchangeAlt_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1d, 166, 12, 5128);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_8.name,
    		type: "slot",
    		source: "(167:12) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (170:12) <span slot="title">
    function create_title_slot_10(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "ITBI";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 169, 12, 5226);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_10.name,
    		type: "slot",
    		source: "(170:12) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (163:10) <Destaque              model={$store.receitaDestaqueITBI}              workflow={receitaApi.receitaDestaqueITBI}              title={titles.itbi}>
    function create_default_slot_11(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(163:10) <Destaque              model={$store.receitaDestaqueITBI}              workflow={receitaApi.receitaDestaqueITBI}              title={titles.itbi}>",
    		ctx
    	});

    	return block;
    }

    // (179:12) <span slot="icon">
    function create_icon_slot_7(ctx) {
    	let span;
    	let current;
    	const icon = new Icon({ props: { icon: faCogs_2 }, $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1d, 178, 12, 5519);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_7.name,
    		type: "slot",
    		source: "(179:12) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (182:12) <span slot="title">
    function create_title_slot_9(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "ISS";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 181, 12, 5610);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_9.name,
    		type: "slot",
    		source: "(182:12) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (175:10) <Destaque              model={$store.receitaDestaqueISS}              workflow={receitaApi.receitaDestaqueISS}              title={titles.iss}>
    function create_default_slot_10(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(175:10) <Destaque              model={$store.receitaDestaqueISS}              workflow={receitaApi.receitaDestaqueISS}              title={titles.iss}>",
    		ctx
    	});

    	return block;
    }

    // (143:4) <Widget>
    function create_default_slot_9(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let span0;
    	let span0_title_value;
    	let t2;
    	let span1;
    	let span1_title_value;
    	let t3;
    	let span2;
    	let span2_title_value;
    	let current;

    	const destaque0 = new Destaque_1$1({
    			props: {
    				model: /*$store*/ ctx[0].receitaDestaqueIPTU,
    				workflow: receitaDestaqueIPTU,
    				title: /*titles*/ ctx[1].iptu,
    				$$slots: {
    					default: [create_default_slot_12],
    					title: [create_title_slot_11],
    					icon: [create_icon_slot_9]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaque1 = new Destaque_1$1({
    			props: {
    				model: /*$store*/ ctx[0].receitaDestaqueITBI,
    				workflow: receitaDestaqueITBI,
    				title: /*titles*/ ctx[1].itbi,
    				$$slots: {
    					default: [create_default_slot_11],
    					title: [create_title_slot_10],
    					icon: [create_icon_slot_8]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaque2 = new Destaque_1$1({
    			props: {
    				model: /*$store*/ ctx[0].receitaDestaqueISS,
    				workflow: receitaDestaqueISS,
    				title: /*titles*/ ctx[1].iss,
    				$$slots: {
    					default: [create_default_slot_10],
    					title: [create_title_slot_9],
    					icon: [create_icon_slot_7]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			span0 = element("span");
    			create_component(destaque0.$$.fragment);
    			t2 = space();
    			span1 = element("span");
    			create_component(destaque1.$$.fragment);
    			t3 = space();
    			span2 = element("span");
    			create_component(destaque2.$$.fragment);
    			attr_dev(span0, "class", "destaque svelte-105c4dl");
    			attr_dev(span0, "title", span0_title_value = /*titles*/ ctx[1].iptu);
    			add_location(span0, file$1d, 149, 8, 4518);
    			attr_dev(span1, "class", "destaque svelte-105c4dl");
    			attr_dev(span1, "title", span1_title_value = /*titles*/ ctx[1].itbi);
    			add_location(span1, file$1d, 161, 8, 4913);
    			attr_dev(span2, "class", "destaque svelte-105c4dl");
    			attr_dev(span2, "title", span2_title_value = /*titles*/ ctx[1].iss);
    			add_location(span2, file$1d, 173, 8, 5308);
    			attr_dev(div, "class", "h-32");
    			add_location(div, file$1d, 148, 6, 4490);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			mount_component(destaque0, span0, null);
    			append_dev(div, t2);
    			append_dev(div, span1);
    			mount_component(destaque1, span1, null);
    			append_dev(div, t3);
    			append_dev(div, span2);
    			mount_component(destaque2, span2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const destaque0_changes = {};
    			if (dirty & /*$store*/ 1) destaque0_changes.model = /*$store*/ ctx[0].receitaDestaqueIPTU;

    			if (dirty & /*$$scope*/ 64) {
    				destaque0_changes.$$scope = { dirty, ctx };
    			}

    			destaque0.$set(destaque0_changes);
    			const destaque1_changes = {};
    			if (dirty & /*$store*/ 1) destaque1_changes.model = /*$store*/ ctx[0].receitaDestaqueITBI;

    			if (dirty & /*$$scope*/ 64) {
    				destaque1_changes.$$scope = { dirty, ctx };
    			}

    			destaque1.$set(destaque1_changes);
    			const destaque2_changes = {};
    			if (dirty & /*$store*/ 1) destaque2_changes.model = /*$store*/ ctx[0].receitaDestaqueISS;

    			if (dirty & /*$$scope*/ 64) {
    				destaque2_changes.$$scope = { dirty, ctx };
    			}

    			destaque2.$set(destaque2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(destaque0.$$.fragment, local);
    			transition_in(destaque1.$$.fragment, local);
    			transition_in(destaque2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(destaque0.$$.fragment, local);
    			transition_out(destaque1.$$.fragment, local);
    			transition_out(destaque2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(destaque0);
    			destroy_component(destaque1);
    			destroy_component(destaque2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(143:4) <Widget>",
    		ctx
    	});

    	return block;
    }

    // (191:6) <span slot="title">
    function create_title_slot_8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Transferências do Estado em destaque";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 190, 6, 5796);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_8.name,
    		type: "slot",
    		source: "(191:6) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (192:6) <span slot="tooltip">
    function create_tooltip_slot_1$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Destaque das mais relevantes transferências realizadas pelo Estado para\r\n        o Município para amenizar as desigualdades regionais e promover o\r\n        equilíbrio sócio-econômico entre os municípios.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1d, 191, 6, 5866);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot_1$1.name,
    		type: "slot",
    		source: "(192:6) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (203:12) <span slot="icon">
    function create_icon_slot_6(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faShoppingCart_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1d, 202, 12, 6365);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_6.name,
    		type: "slot",
    		source: "(203:12) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (206:12) <span slot="title">
    function create_title_slot_7(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "ICMS";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 205, 12, 6464);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_7.name,
    		type: "slot",
    		source: "(206:12) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (199:10) <Destaque              model={$store.receitaDestaqueICMS}              workflow={receitaApi.receitaDestaqueICMS}              title={titles.icms}>
    function create_default_slot_8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(199:10) <Destaque              model={$store.receitaDestaqueICMS}              workflow={receitaApi.receitaDestaqueICMS}              title={titles.icms}>",
    		ctx
    	});

    	return block;
    }

    // (215:12) <span slot="icon">
    function create_icon_slot_5(ctx) {
    	let span;
    	let current;
    	const icon = new Icon({ props: { icon: faCar_2 }, $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1d, 214, 12, 6759);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_5.name,
    		type: "slot",
    		source: "(215:12) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (218:12) <span slot="title">
    function create_title_slot_6(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "IPVA";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 217, 12, 6849);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_6.name,
    		type: "slot",
    		source: "(218:12) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (211:10) <Destaque              model={$store.receitaDestaqueIPVA}              workflow={receitaApi.receitaDestaqueIPVA}              title={titles.ipva}>
    function create_default_slot_7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(211:10) <Destaque              model={$store.receitaDestaqueIPVA}              workflow={receitaApi.receitaDestaqueIPVA}              title={titles.ipva}>",
    		ctx
    	});

    	return block;
    }

    // (227:12) <span slot="icon">
    function create_icon_slot_4(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faHandshake_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1d, 226, 12, 7196);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_4.name,
    		type: "slot",
    		source: "(227:12) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (230:12) <span slot="title">
    function create_title_slot_5(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Convênios";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 229, 12, 7292);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_5.name,
    		type: "slot",
    		source: "(230:12) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (223:10) <Destaque              model={$store.receitaDestaqueConveniosDoEstado}              workflow={receitaApi.receitaDestaqueConveniosDoEstado}              title={titles.conveniosDoEstado}>
    function create_default_slot_6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(223:10) <Destaque              model={$store.receitaDestaqueConveniosDoEstado}              workflow={receitaApi.receitaDestaqueConveniosDoEstado}              title={titles.conveniosDoEstado}>",
    		ctx
    	});

    	return block;
    }

    // (239:12) <span slot="icon">
    function create_icon_slot_3$1(ctx) {
    	let span;
    	let current;
    	const oilrig = new OilRig({ $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(oilrig.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1d, 238, 12, 7644);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(oilrig, span, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(oilrig.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(oilrig.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(oilrig);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_3$1.name,
    		type: "slot",
    		source: "(239:12) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (242:12) <span slot="title">
    function create_title_slot_4$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Petróleo";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 241, 12, 7723);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_4$1.name,
    		type: "slot",
    		source: "(242:12) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (235:10) <Destaque              model={$store.receitaDestaqueRoyaltiesDoEstado}              workflow={receitaApi.receitaDestaqueRoyaltiesDoEstado}              title={titles.royaltiesDoEstado}>
    function create_default_slot_5$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(235:10) <Destaque              model={$store.receitaDestaqueRoyaltiesDoEstado}              workflow={receitaApi.receitaDestaqueRoyaltiesDoEstado}              title={titles.royaltiesDoEstado}>",
    		ctx
    	});

    	return block;
    }

    // (190:4) <Widget>
    function create_default_slot_4$3(ctx) {
    	let t0;
    	let t1;
    	let div4;
    	let div0;
    	let div0_title_value;
    	let t2;
    	let div1;
    	let div1_title_value;
    	let t3;
    	let div2;
    	let div2_title_value;
    	let t4;
    	let div3;
    	let div3_title_value;
    	let current;

    	const destaque0 = new Destaque_1$1({
    			props: {
    				model: /*$store*/ ctx[0].receitaDestaqueICMS,
    				workflow: receitaDestaqueICMS,
    				title: /*titles*/ ctx[1].icms,
    				$$slots: {
    					default: [create_default_slot_8],
    					title: [create_title_slot_7],
    					icon: [create_icon_slot_6]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaque1 = new Destaque_1$1({
    			props: {
    				model: /*$store*/ ctx[0].receitaDestaqueIPVA,
    				workflow: receitaDestaqueIPVA,
    				title: /*titles*/ ctx[1].ipva,
    				$$slots: {
    					default: [create_default_slot_7],
    					title: [create_title_slot_6],
    					icon: [create_icon_slot_5]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaque2 = new Destaque_1$1({
    			props: {
    				model: /*$store*/ ctx[0].receitaDestaqueConveniosDoEstado,
    				workflow: receitaDestaqueConveniosDoEstado,
    				title: /*titles*/ ctx[1].conveniosDoEstado,
    				$$slots: {
    					default: [create_default_slot_6],
    					title: [create_title_slot_5],
    					icon: [create_icon_slot_4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaque3 = new Destaque_1$1({
    			props: {
    				model: /*$store*/ ctx[0].receitaDestaqueRoyaltiesDoEstado,
    				workflow: receitaDestaqueRoyaltiesDoEstado,
    				title: /*titles*/ ctx[1].royaltiesDoEstado,
    				$$slots: {
    					default: [create_default_slot_5$1],
    					title: [create_title_slot_4$1],
    					icon: [create_icon_slot_3$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div4 = element("div");
    			div0 = element("div");
    			create_component(destaque0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(destaque1.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			create_component(destaque2.$$.fragment);
    			t4 = space();
    			div3 = element("div");
    			create_component(destaque3.$$.fragment);
    			attr_dev(div0, "class", "destaque svelte-105c4dl");
    			attr_dev(div0, "title", div0_title_value = /*titles*/ ctx[1].icms);
    			add_location(div0, file$1d, 197, 8, 6151);
    			attr_dev(div1, "class", "destaque svelte-105c4dl");
    			attr_dev(div1, "title", div1_title_value = /*titles*/ ctx[1].ipva);
    			add_location(div1, file$1d, 209, 8, 6545);
    			attr_dev(div2, "class", "destaque svelte-105c4dl");
    			attr_dev(div2, "title", div2_title_value = /*titles*/ ctx[1].conveniosDoEstado);
    			add_location(div2, file$1d, 221, 8, 6930);
    			attr_dev(div3, "class", "destaque svelte-105c4dl");
    			attr_dev(div3, "title", div3_title_value = /*titles*/ ctx[1].royaltiesDoEstado);
    			add_location(div3, file$1d, 233, 8, 7378);
    			attr_dev(div4, "class", "h-32");
    			add_location(div4, file$1d, 196, 6, 6123);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			mount_component(destaque0, div0, null);
    			append_dev(div4, t2);
    			append_dev(div4, div1);
    			mount_component(destaque1, div1, null);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			mount_component(destaque2, div2, null);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			mount_component(destaque3, div3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const destaque0_changes = {};
    			if (dirty & /*$store*/ 1) destaque0_changes.model = /*$store*/ ctx[0].receitaDestaqueICMS;

    			if (dirty & /*$$scope*/ 64) {
    				destaque0_changes.$$scope = { dirty, ctx };
    			}

    			destaque0.$set(destaque0_changes);
    			const destaque1_changes = {};
    			if (dirty & /*$store*/ 1) destaque1_changes.model = /*$store*/ ctx[0].receitaDestaqueIPVA;

    			if (dirty & /*$$scope*/ 64) {
    				destaque1_changes.$$scope = { dirty, ctx };
    			}

    			destaque1.$set(destaque1_changes);
    			const destaque2_changes = {};
    			if (dirty & /*$store*/ 1) destaque2_changes.model = /*$store*/ ctx[0].receitaDestaqueConveniosDoEstado;

    			if (dirty & /*$$scope*/ 64) {
    				destaque2_changes.$$scope = { dirty, ctx };
    			}

    			destaque2.$set(destaque2_changes);
    			const destaque3_changes = {};
    			if (dirty & /*$store*/ 1) destaque3_changes.model = /*$store*/ ctx[0].receitaDestaqueRoyaltiesDoEstado;

    			if (dirty & /*$$scope*/ 64) {
    				destaque3_changes.$$scope = { dirty, ctx };
    			}

    			destaque3.$set(destaque3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(destaque0.$$.fragment, local);
    			transition_in(destaque1.$$.fragment, local);
    			transition_in(destaque2.$$.fragment, local);
    			transition_in(destaque3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(destaque0.$$.fragment, local);
    			transition_out(destaque1.$$.fragment, local);
    			transition_out(destaque2.$$.fragment, local);
    			transition_out(destaque3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div4);
    			destroy_component(destaque0);
    			destroy_component(destaque1);
    			destroy_component(destaque2);
    			destroy_component(destaque3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(190:4) <Widget>",
    		ctx
    	});

    	return block;
    }

    // (251:6) <span slot="title">
    function create_title_slot_3$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Transferências da União em destaque";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 250, 6, 7913);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_3$1.name,
    		type: "slot",
    		source: "(251:6) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (252:6) <span slot="tooltip">
    function create_tooltip_slot$r(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Destaque das mais relevantes transferências realizadas pela União para o\r\n        Município para amenizar as desigualdades regionais e promover o\r\n        equilíbrio sócio-econômico entre os municípios.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1d, 251, 6, 7982);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$r.name,
    		type: "slot",
    		source: "(252:6) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (263:12) <span slot="icon">
    function create_icon_slot_2$1(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faHandHoldingUsd_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1d, 262, 12, 8476);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_2$1.name,
    		type: "slot",
    		source: "(263:12) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (266:12) <span slot="title">
    function create_title_slot_2$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "FPM";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 265, 12, 8577);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_2$2.name,
    		type: "slot",
    		source: "(266:12) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (259:10) <Destaque              model={$store.receitaDestaqueFPM}              workflow={receitaApi.receitaDestaqueFPM}              title={titles.fpm}>
    function create_default_slot_3$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(259:10) <Destaque              model={$store.receitaDestaqueFPM}              workflow={receitaApi.receitaDestaqueFPM}              title={titles.fpm}>",
    		ctx
    	});

    	return block;
    }

    // (275:12) <span slot="icon">
    function create_icon_slot_1$1(ctx) {
    	let span;
    	let current;

    	const icon = new Icon({
    			props: { icon: faHandshake_2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1d, 274, 12, 8919);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot_1$1.name,
    		type: "slot",
    		source: "(275:12) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (278:12) <span slot="title">
    function create_title_slot_1$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Convênios";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 277, 12, 9015);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_1$2.name,
    		type: "slot",
    		source: "(278:12) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (271:10) <Destaque              model={$store.receitaDestaqueConveniosDaUniao}              workflow={receitaApi.receitaDestaqueConveniosDaUniao}              title={titles.conveniosDaUniao}>
    function create_default_slot_2$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$c.name,
    		type: "slot",
    		source: "(271:10) <Destaque              model={$store.receitaDestaqueConveniosDaUniao}              workflow={receitaApi.receitaDestaqueConveniosDaUniao}              title={titles.conveniosDaUniao}>",
    		ctx
    	});

    	return block;
    }

    // (287:12) <span slot="icon">
    function create_icon_slot$4(ctx) {
    	let span;
    	let current;
    	const oilrig = new OilRig({ $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(oilrig.$$.fragment);
    			attr_dev(span, "slot", "icon");
    			add_location(span, file$1d, 286, 12, 9363);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(oilrig, span, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(oilrig.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(oilrig.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(oilrig);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot$4.name,
    		type: "slot",
    		source: "(287:12) <span slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (290:12) <span slot="title">
    function create_title_slot$r(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Petróleo";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1d, 289, 12, 9442);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$r.name,
    		type: "slot",
    		source: "(290:12) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (283:10) <Destaque              model={$store.receitaDestaqueRoyaltiesDaUniao}              workflow={receitaApi.receitaDestaqueRoyaltiesDaUniao}              title={titles.royaltiesDaUniao}>
    function create_default_slot_1$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(283:10) <Destaque              model={$store.receitaDestaqueRoyaltiesDaUniao}              workflow={receitaApi.receitaDestaqueRoyaltiesDaUniao}              title={titles.royaltiesDaUniao}>",
    		ctx
    	});

    	return block;
    }

    // (250:4) <Widget>
    function create_default_slot$I(ctx) {
    	let t0;
    	let t1;
    	let div3;
    	let div0;
    	let div0_title_value;
    	let t2;
    	let div1;
    	let div1_title_value;
    	let t3;
    	let div2;
    	let div2_title_value;
    	let current;

    	const destaque0 = new Destaque_1$1({
    			props: {
    				model: /*$store*/ ctx[0].receitaDestaqueFPM,
    				workflow: receitaDestaqueFPM,
    				title: /*titles*/ ctx[1].fpm,
    				$$slots: {
    					default: [create_default_slot_3$5],
    					title: [create_title_slot_2$2],
    					icon: [create_icon_slot_2$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaque1 = new Destaque_1$1({
    			props: {
    				model: /*$store*/ ctx[0].receitaDestaqueConveniosDaUniao,
    				workflow: receitaDestaqueConveniosDaUniao,
    				title: /*titles*/ ctx[1].conveniosDaUniao,
    				$$slots: {
    					default: [create_default_slot_2$c],
    					title: [create_title_slot_1$2],
    					icon: [create_icon_slot_1$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaque2 = new Destaque_1$1({
    			props: {
    				model: /*$store*/ ctx[0].receitaDestaqueRoyaltiesDaUniao,
    				workflow: receitaDestaqueRoyaltiesDaUniao,
    				title: /*titles*/ ctx[1].royaltiesDaUniao,
    				$$slots: {
    					default: [create_default_slot_1$e],
    					title: [create_title_slot$r],
    					icon: [create_icon_slot$4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div3 = element("div");
    			div0 = element("div");
    			create_component(destaque0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(destaque1.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			create_component(destaque2.$$.fragment);
    			attr_dev(div0, "class", "destaque svelte-105c4dl");
    			attr_dev(div0, "title", div0_title_value = /*titles*/ ctx[1].fpm);
    			add_location(div0, file$1d, 257, 8, 8266);
    			attr_dev(div1, "class", "destaque svelte-105c4dl");
    			attr_dev(div1, "title", div1_title_value = /*titles*/ ctx[1].conveniosDaUniao);
    			add_location(div1, file$1d, 269, 8, 8657);
    			attr_dev(div2, "class", "destaque svelte-105c4dl");
    			attr_dev(div2, "title", div2_title_value = /*titles*/ ctx[1].royaltiesDaUniao);
    			add_location(div2, file$1d, 281, 8, 9101);
    			attr_dev(div3, "class", "h-32");
    			add_location(div3, file$1d, 256, 6, 8238);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			mount_component(destaque0, div0, null);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			mount_component(destaque1, div1, null);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			mount_component(destaque2, div2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const destaque0_changes = {};
    			if (dirty & /*$store*/ 1) destaque0_changes.model = /*$store*/ ctx[0].receitaDestaqueFPM;

    			if (dirty & /*$$scope*/ 64) {
    				destaque0_changes.$$scope = { dirty, ctx };
    			}

    			destaque0.$set(destaque0_changes);
    			const destaque1_changes = {};
    			if (dirty & /*$store*/ 1) destaque1_changes.model = /*$store*/ ctx[0].receitaDestaqueConveniosDaUniao;

    			if (dirty & /*$$scope*/ 64) {
    				destaque1_changes.$$scope = { dirty, ctx };
    			}

    			destaque1.$set(destaque1_changes);
    			const destaque2_changes = {};
    			if (dirty & /*$store*/ 1) destaque2_changes.model = /*$store*/ ctx[0].receitaDestaqueRoyaltiesDaUniao;

    			if (dirty & /*$$scope*/ 64) {
    				destaque2_changes.$$scope = { dirty, ctx };
    			}

    			destaque2.$set(destaque2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(destaque0.$$.fragment, local);
    			transition_in(destaque1.$$.fragment, local);
    			transition_in(destaque2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(destaque0.$$.fragment, local);
    			transition_out(destaque1.$$.fragment, local);
    			transition_out(destaque2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div3);
    			destroy_component(destaque0);
    			destroy_component(destaque1);
    			destroy_component(destaque2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$I.name,
    		type: "slot",
    		source: "(250:4) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1k(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let current;

    	const widget0 = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot_9],
    					tooltip: [create_tooltip_slot_2],
    					title: [create_title_slot_12]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const widget1 = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot_4$3],
    					tooltip: [create_tooltip_slot_1$1],
    					title: [create_title_slot_8]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const widget2 = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$I],
    					tooltip: [create_tooltip_slot$r],
    					title: [create_title_slot_3$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			create_component(widget0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(widget1.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(widget2.$$.fragment);
    			attr_dev(div0, "class", "lg:w-1/3 w-full float-left py-2 pr-1");
    			add_location(div0, file$1d, 141, 2, 4206);
    			attr_dev(div1, "class", "lg:w-1/3 w-full float-left py-2 px-1");
    			add_location(div1, file$1d, 188, 2, 5724);
    			attr_dev(div2, "class", "lg:w-1/3 w-full float-left py-2 pl-1");
    			add_location(div2, file$1d, 248, 2, 7841);
    			add_location(div3, file$1d, 140, 0, 4197);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			mount_component(widget0, div0, null);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			mount_component(widget1, div1, null);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			mount_component(widget2, div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget0_changes = {};

    			if (dirty & /*$$scope, $store*/ 65) {
    				widget0_changes.$$scope = { dirty, ctx };
    			}

    			widget0.$set(widget0_changes);
    			const widget1_changes = {};

    			if (dirty & /*$$scope, $store*/ 65) {
    				widget1_changes.$$scope = { dirty, ctx };
    			}

    			widget1.$set(widget1_changes);
    			const widget2_changes = {};

    			if (dirty & /*$$scope, $store*/ 65) {
    				widget2_changes.$$scope = { dirty, ctx };
    			}

    			widget2.$set(widget2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget0.$$.fragment, local);
    			transition_in(widget1.$$.fragment, local);
    			transition_in(widget2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget0.$$.fragment, local);
    			transition_out(widget1.$$.fragment, local);
    			transition_out(widget2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(widget0);
    			destroy_component(widget1);
    			destroy_component(widget2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let $params;
    	let $store;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(3, $params = $$value));

    	const titles = {
    		conveniosDaUniao: "Valor recebido a partir convênios entre a União e o Município",
    		conveniosDoEstado: "Valor recebido a partir convênios entre o Estado e o Município",
    		fpm: "Fundo de Participação dos Municípios",
    		icms: "Imposto sobre Operações relativas à Circulação de Mercadorias e Prestação de Serviços de Transporte Interestadual e Intermunicipal e de Comunicação",
    		iptu: "Imposto Predial e Territorial Urbano",
    		ipva: "Imposto sobre a Propriedade de Veículos Automotores",
    		iss: "Imposto Sobre Serviço",
    		itbi: "Imposto sobre a Transmissão de Bens Imóveis",
    		royaltiesDaUniao: "Royalties de Petróleo",
    		royaltiesDoEstado: "Royalties de Petróleo"
    	};

    	const store = api.createStore();
    	validate_store(store, "store");
    	component_subscribe($$self, store, value => $$invalidate(0, $store = value));

    	async function refresh(params) {
    		const ano = parseInt(params.ano);
    		const ug = params.ug;
    		const municipio = ug === "consolidado" ? params.municipio : ug;
    		await api.post(api.getApiUrl("DWControleSocial"), getDestaqueSumArrecadada(receitaDestaqueConveniosDaUniao, ano, municipio).concat(getDestaqueSumArrecadada(receitaDestaqueConveniosDoEstado, ano, municipio)).concat(getDestaqueSumArrecadada(receitaDestaqueFPM, ano, municipio)).concat(getDestaqueSumArrecadada(receitaDestaqueICMS, ano, municipio)).concat(getDestaqueSumArrecadada(receitaDestaqueIPTU, ano, municipio)).concat(getDestaqueSumArrecadada(receitaDestaqueIPVA, ano, municipio)).concat(getDestaqueSumArrecadada(receitaDestaqueISS, ano, municipio)).concat(getDestaqueSumArrecadada(receitaDestaqueITBI, ano, municipio)).concat(getDestaqueSumArrecadada(receitaDestaqueRoyaltiesDaUniao, ano, municipio)).concat(getDestaqueSumArrecadada(receitaDestaqueRoyaltiesDoEstado, ano, municipio)), { store });
    	}

    	function getDestaqueSumArrecadada(destaque, ano, municipio) {
    		const workflow = destaque(ano, municipio, receitaSumArrecadada);

    		return [
    			{
    				id: workflow[0].id,
    				run: "Municipio.Receita.FiltrarPorAno",
    				args: [ano],
    				continue: true,
    				evaluate: false
    			}
    		].concat(workflow);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Destaques> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Destaques", $$slots, []);

    	$$self.$capture_state = () => ({
    		params,
    		api,
    		Icon,
    		faCar: faCar_2,
    		faCogs: faCogs_2,
    		faExchangeAlt: faExchangeAlt_2,
    		faHandHoldingUsd: faHandHoldingUsd_2,
    		faHandshake: faHandshake_2,
    		faHouseDamage: faHouseDamage_2,
    		faShoppingCart: faShoppingCart_2,
    		OilRig,
    		Widget,
    		Destaque: Destaque_1$1,
    		receitaApi,
    		titles,
    		store,
    		refresh,
    		getDestaqueSumArrecadada,
    		$params,
    		$store
    	});

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 8) {
    			 refresh($params);
    		}
    	};

    	return [$store, titles, store];
    }

    class Destaques$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Destaques",
    			options,
    			id: create_fragment$1k.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\receitas\_components\Treemap.svelte generated by Svelte v3.22.3 */
    const file$1e = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\receitas\\_components\\Treemap.svelte";

    // (13:2) <span slot="title">
    function create_title_slot$s(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Receitas por natureza";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1e, 12, 2, 28072);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$s.name,
    		type: "slot",
    		source: "(13:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (14:2) <span slot="tooltip">
    function create_tooltip_slot$s(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Receitas por natureza.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1e, 13, 2, 28123);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$s.name,
    		type: "slot",
    		source: "(14:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:0) <Widget>
    function create_default_slot$J(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const treemap = new Treemap({
    			props: { data: /*data*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(treemap.$$.fragment);
    			set_style(div, "height", /*height*/ ctx[0]);
    			add_location(div, file$1e, 14, 2, 28177);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(treemap, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*height*/ 1) {
    				set_style(div, "height", /*height*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(treemap.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(treemap.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(treemap);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$J.name,
    		type: "slot",
    		source: "(12:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1l(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$J],
    					tooltip: [create_tooltip_slot$s],
    					title: [create_title_slot$s]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, height*/ 5) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let { height = "500px" } = $$props;
    	const data = JSON.parse("[{\"codigoPai\":null,\"codigo\":\"1\",\"name\":\"RECEITAS CORRENTES\",\"value\":66652315.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1\",\"codigo\":\"12\",\"name\":\"CONTRIBUIÇÕES\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"12\",\"codigo\":\"124\",\"name\":\"CONTRIBUIÇÃO PARA O CUSTEIO DO SERVIÇO DE ILUMINAÇÃO PÚBLICA\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"124\",\"codigo\":\"1240\",\"name\":\"CONTRIBUIÇÃO PARA O CUSTEIO DO SERVIÇO DE ILUMINAÇÃO PÚBLICA\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1240\",\"codigo\":\"124000\",\"name\":\"CONTRIBUIÇÃO PARA O CUSTEIO DO SERVIÇO DE ILUMINAÇÃO PÚBLICA\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"124000\",\"codigo\":\"1240001\",\"name\":\"CONTRIBUIÇÃO PARA O CUSTEIO DO SERVIÇO DE ILUMINAÇÃO PÚBLICA\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1240001\",\"codigo\":\"12400011\",\"name\":\"CONTRIBUIÇÃO PARA O CUSTEIO DO SERVIÇO DE ILUMINAÇÃO PÚBLICA - PRINCIPAL\",\"value\":1052553.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]},{\"codigoPai\":\"1\",\"codigo\":\"11\",\"name\":\"IMPOSTOS, TAXAS E CONTRIBUIÇÕES DE MELHORIA\",\"value\":3409038.06,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"11\",\"codigo\":\"111\",\"name\":\"IMPOSTOS\",\"value\":2533586.18,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"111\",\"codigo\":\"1118\",\"name\":\"IMPOSTOS ESPECÍFICOS DE ESTADOS/DF E MUNICÍPIOS\",\"value\":2015497.62,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1118\",\"codigo\":\"111802\",\"name\":\"IMPOSTOS SOBRE A PRODUÇÃO, CIRCULAÇÃO DE MERCADORIAS E SERVIÇOS\",\"value\":1311138.63,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"111802\",\"codigo\":\"1118023\",\"name\":\"IMPOSTO SOBRE SERVIÇOS DE QUALQUER NATUREZA\",\"value\":1311138.63,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1118023\",\"codigo\":\"11180233\",\"name\":\"IMPOSTO SOBRE SERVIÇOS DE QUALQUER NATUREZA - DÍVIDA ATIVA\",\"value\":22689.08,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118023\",\"codigo\":\"11180232\",\"name\":\"IMPOSTO SOBRE SERVIÇOS DE QUALQUER NATUREZA - MULTAS E JUROS DE MORA\",\"value\":22776.42,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118023\",\"codigo\":\"11180234\",\"name\":\"IMPOSTO SOBRE SERVIÇOS DE QUALQUER NATUREZA - MULTAS E JUROS DE MORA DA DÍVIDA ATIVA\",\"value\":7694.44,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118023\",\"codigo\":\"11180231\",\"name\":\"IMPOSTO SOBRE SERVIÇOS DE QUALQUER NATUREZA - PRINCIPAL\",\"value\":1257978.69,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1118\",\"codigo\":\"111801\",\"name\":\"IMPOSTOS SOBRE O PATRIMÔNIO PARA ESTADOS/DF/MUNICÍPIOS\",\"value\":704358.99,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"111801\",\"codigo\":\"1118011\",\"name\":\"IMPOSTO SOBRE A PROPRIEDADE PREDIAL E TERRITORIAL URBANA\",\"value\":366822.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1118011\",\"codigo\":\"11180113\",\"name\":\"IMPOSTO SOBRE A PROPRIEDADE PREDIAL E TERRITORIAL URBANA - DÍVIDA ATIVA\",\"value\":70626.71,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118011\",\"codigo\":\"11180112\",\"name\":\"IMPOSTO SOBRE A PROPRIEDADE PREDIAL E TERRITORIAL URBANA - MULTAS E JUROS DE MORA\",\"value\":7607.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118011\",\"codigo\":\"11180114\",\"name\":\"IMPOSTO SOBRE A PROPRIEDADE PREDIAL E TERRITORIAL URBANA - MULTAS E JUROS DE MORA DA DÍVIDA ATIVA\",\"value\":28828.26,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1118011\",\"codigo\":\"11180111\",\"name\":\"IMPOSTO SOBRE A PROPRIEDADE PREDIAL E TERRITORIAL URBANA - PRINCIPAL\",\"value\":259760.05,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"111801\",\"codigo\":\"1118014\",\"name\":\"IMPOSTO SOBRE TRANSMISSÃO “INTER VIVOS” DE BENS IMÓVEIS E DE DIREITOS REAIS SOBRE IMÓVEIS\",\"value\":337536.20,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1118014\",\"codigo\":\"11180141\",\"name\":\"IMPOSTO SOBRE TRANSMISSÃO “INTER VIVOS” DE BENS IMÓVEIS E DE DIREITOS REAIS SOBRE IMÓVEIS - PRINCIPAL\",\"value\":337536.20,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]},{\"codigoPai\":\"111\",\"codigo\":\"1113\",\"name\":\"IMPOSTOS SOBRE A RENDA E PROVENTOS DE QUALQUER NATUREZA\",\"value\":518088.56,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1113\",\"codigo\":\"111303\",\"name\":\"IMPOSTO SOBRE A RENDA - RETIDO NA FONTE\",\"value\":518088.56,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"111303\",\"codigo\":\"1113034\",\"name\":\"IMPOSTO SOBRE A RENDA - RETIDO NA FONTE - OUTROS RENDIMENTOS\",\"value\":58355.57,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1113034\",\"codigo\":\"11130341\",\"name\":\"IMPOSTO SOBRE A RENDA - RETIDO NA FONTE - OUTROS RENDIMENTOS - PRINCIPAL\",\"value\":58355.57,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"111303\",\"codigo\":\"1113031\",\"name\":\"IMPOSTO SOBRE A RENDA - RETIDO NA FONTE - TRABALHO\",\"value\":459732.99,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1113031\",\"codigo\":\"11130311\",\"name\":\"IMPOSTO SOBRE A RENDA - RETIDO NA FONTE - TRABALHO - PRINCIPAL\",\"value\":459732.99,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]},{\"codigoPai\":\"11\",\"codigo\":\"112\",\"name\":\"TAXAS\",\"value\":875451.88,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"112\",\"codigo\":\"1128\",\"name\":\"TAXAS – ESPECÍFICAS DE ESTADOS, DF E MUNICÍPIOS\",\"value\":101487.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1128\",\"codigo\":\"112801\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO\",\"value\":101487.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"112801\",\"codigo\":\"1128019\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO - OUTRAS\",\"value\":101487.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1128019\",\"codigo\":\"11280193\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO - OUTRAS - DÍVIDA ATIVA\",\"value\":10596.15,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1128019\",\"codigo\":\"11280192\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO - OUTRAS - MULTAS E JUROS DE MORA\",\"value\":152.19,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1128019\",\"codigo\":\"11280194\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO - OUTRAS - MULTAS E JUROS DE MORA DA DÍVIDA ATIVA\",\"value\":562.82,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1128019\",\"codigo\":\"11280191\",\"name\":\"TAXAS DE INSPEÇÃO, CONTROLE E FISCALIZAÇÃO - OUTRAS - PRINCIPAL\",\"value\":90176.61,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]},{\"codigoPai\":\"112\",\"codigo\":\"1122\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS\",\"value\":773964.11,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1122\",\"codigo\":\"112201\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS\",\"value\":773964.11,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"112201\",\"codigo\":\"1122011\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS\",\"value\":773964.11,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1122011\",\"codigo\":\"11220113\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS - DÍVIDA ATIVA\",\"value\":114907.56,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1122011\",\"codigo\":\"11220112\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS - MULTAS E JUROS DE MORA\",\"value\":9166.07,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1122011\",\"codigo\":\"11220114\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS - MULTAS E JUROS DE MORA DA DÍVIDA ATIVA\",\"value\":41567.99,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1122011\",\"codigo\":\"11220111\",\"name\":\"TAXAS PELA PRESTAÇÃO DE SERVIÇOS - PRINCIPAL\",\"value\":608322.49,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]},{\"codigoPai\":\"1\",\"codigo\":\"19\",\"name\":\"OUTRAS RECEITAS CORRENTES\",\"value\":833077.34,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"19\",\"codigo\":\"199\",\"name\":\"DEMAIS RECEITAS CORRENTES\",\"value\":284744.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"199\",\"codigo\":\"1990\",\"name\":\"DEMAIS RECEITAS CORRENTES\",\"value\":284744.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1990\",\"codigo\":\"199099\",\"name\":\"OUTRAS RECEITAS\",\"value\":284744.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"199099\",\"codigo\":\"1990992\",\"name\":\"OUTRAS RECEITAS - FINANCEIRAS\",\"value\":117.06,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1990992\",\"codigo\":\"19909921\",\"name\":\"OUTRAS RECEITAS - FINANCEIRAS - PRINCIPAL\",\"value\":117.06,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"199099\",\"codigo\":\"1990991\",\"name\":\"OUTRAS RECEITAS - PRIMÁRIAS\",\"value\":284627.61,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1990991\",\"codigo\":\"19909913\",\"name\":\"OUTRAS RECEITAS - PRIMÁRIAS - DÍVIDA ATIVA\",\"value\":106.08,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]},{\"codigoPai\":\"1990991\",\"codigo\":\"19909911\",\"name\":\"OUTRAS RECEITAS - PRIMÁRIAS - PRINCIPAL\",\"value\":284521.53,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]},{\"codigoPai\":\"19\",\"codigo\":\"192\",\"name\":\"INDENIZAÇÕES, RESTITUIÇÕES E RESSARCIMENTOS\",\"value\":548332.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"192\",\"codigo\":\"1928\",\"name\":\"Indenizações, Restituições e Ressarcimentos - Específicas para Estados/DF/Municípios\",\"value\":548332.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1928\",\"codigo\":\"192802\",\"name\":\"Restituições - Específicas para Estados/DF/Municípios\",\"value\":548332.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"192802\",\"codigo\":\"1928029\",\"name\":\"Outras Restituições - Específicas para Estados/DF/Municípios - Não Especificadas Anteriormente\",\"value\":548332.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1928029\",\"codigo\":\"19280291\",\"name\":\"Outras Restituições - Específicas para Estados/DF/Municípios - Não Especificadas Anteriormente - PRINCIPAL\",\"value\":548332.67,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]},{\"codigoPai\":\"1\",\"codigo\":\"13\",\"name\":\"RECEITA PATRIMONIAL\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"13\",\"codigo\":\"132\",\"name\":\"VALORES MOBILIÁRIOS\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"132\",\"codigo\":\"1321\",\"name\":\"JUROS E CORREÇÕES MONETÁRIAS\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1321\",\"codigo\":\"132100\",\"name\":\"JUROS E CORREÇÕES MONETÁRIAS\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"132100\",\"codigo\":\"1321001\",\"name\":\"REMUNERAÇÃO DE DEPÓSITOS BANCÁRIOS\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1321001\",\"codigo\":\"13210011\",\"name\":\"REMUNERAÇÃO DE DEPÓSITOS BANCÁRIOS - PRINCIPAL\",\"value\":654758.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]},{\"codigoPai\":\"1\",\"codigo\":\"17\",\"name\":\"TRANSFERÊNCIAS CORRENTES\",\"value\":60702888.01,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"17\",\"codigo\":\"171\",\"name\":\"TRANSFERÊNCIAS DA UNIÃO E DE SUAS ENTIDADES\",\"value\":26374641.52,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171\",\"codigo\":\"1718\",\"name\":\"TRANSFERÊNCIAS DA UNIÃO – ESPECÍFICAS DE ESTADOS, DF E MUNICÍPIOS\",\"value\":26374641.52,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718\",\"codigo\":\"171801\",\"name\":\"PARTICIPAÇÃO NA RECEITA DA UNIÃO\",\"value\":15442558.19,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171801\",\"codigo\":\"1718014\",\"name\":\"COTA-PARTE DO FUNDO DE PARTICIPAÇÃO DOS MUNICÍPIOS - 1% COTA ENTREGUE NO MÊS DE JULHO\",\"value\":949670.80,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718014\",\"codigo\":\"17180141\",\"name\":\"COTA-PARTE DO FUNDO DE PARTICIPAÇÃO DOS MUNICÍPIOS - 1% COTA ENTREGUE NO MÊS DE JULHO - PRINCIPAL\",\"value\":949670.80,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171801\",\"codigo\":\"1718012\",\"name\":\"COTA-PARTE DO FUNDO DE PARTICIPAÇÃO DOS MUNICÍPIOS - COTA MENSAL\",\"value\":14478725.86,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718012\",\"codigo\":\"17180121\",\"name\":\"COTA-PARTE DO FUNDO DE PARTICIPAÇÃO DOS MUNICÍPIOS - COTA MENSAL - PRINCIPAL\",\"value\":14478725.86,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171801\",\"codigo\":\"1718015\",\"name\":\"COTA-PARTE DO IMPOSTO SOBRE A PROPRIEDADE TERRITORIAL RURAL\",\"value\":14161.53,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718015\",\"codigo\":\"17180151\",\"name\":\"COTA-PARTE DO IMPOSTO SOBRE A PROPRIEDADE TERRITORIAL RURAL - PRINCIPAL\",\"value\":14161.53,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1718\",\"codigo\":\"171802\",\"name\":\"TRANSFERÊNCIA DA COMPENSAÇÃO FINANCEIRA PELA EXPLORAÇÃO DE RECURSOS NATURAIS\",\"value\":2485547.70,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171802\",\"codigo\":\"1718026\",\"name\":\"COTA-PARTE DO FUNDO ESPECIAL DO PETRÓLEO – FEP\",\"value\":283484.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718026\",\"codigo\":\"17180261\",\"name\":\"COTA-PARTE DO FUNDO ESPECIAL DO PETRÓLEO – FEP - PRINCIPAL\",\"value\":283484.41,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171802\",\"codigo\":\"1718024\",\"name\":\"COTA-PARTE ROYALTIES PELO EXCEDENTE DA PRODUÇÃO DO PETRÓLEO – LEI Nº 9.478/97, ARTIGO 49, I E II\",\"value\":2084722.55,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718024\",\"codigo\":\"17180241\",\"name\":\"COTA-PARTE ROYALTIES PELO EXCEDENTE DA PRODUÇÃO DO PETRÓLEO – LEI Nº 9.478/97, ARTIGO 49, I E II - PRINCIPAL\",\"value\":2084722.55,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171802\",\"codigo\":\"1718029\",\"name\":\"OUTRAS TRANSFERÊNCIAS DECORRENTES DE COMPENSAÇÃO FINANCEIRA PELA EXPLORAÇÃO DE RECURSOS NATURAIS\",\"value\":117340.74,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718029\",\"codigo\":\"17180291\",\"name\":\"OUTRAS TRANSFERÊNCIAS DECORRENTES DE COMPENSAÇÃO FINANCEIRA PELA EXPLORAÇÃO DE RECURSOS NATURAIS - PRINCIPAL\",\"value\":117340.74,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1718\",\"codigo\":\"171803\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO SISTEMA ÚNICO DE SAÚDE – SUS – BLOCO CUSTEIO DAS AÇÕES E SERVIÇOS PÚBLICOS DE SAÚDE\",\"value\":6682051.11,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171803\",\"codigo\":\"1718034\",\"name\":\"Transferência de Recursos do SUS – Assistência Farmacêutica\",\"value\":162692.50,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718034\",\"codigo\":\"17180341\",\"name\":\"Transferência de Recursos do SUS – Assistência Farmacêutica - PRINCIPAL\",\"value\":162692.50,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171803\",\"codigo\":\"1718031\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO SUS – ATENÇÃO BÁSICA\",\"value\":2715766.14,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718031\",\"codigo\":\"17180311\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO SUS – ATENÇÃO BÁSICA - PRINCIPAL\",\"value\":2715766.14,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171803\",\"codigo\":\"1718032\",\"name\":\"Transferência de Recursos do SUS – Atenção de Média e Alta Complexidade Ambulatorial e Hospitalar\",\"value\":3318535.03,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718032\",\"codigo\":\"17180321\",\"name\":\"Transferência de Recursos do SUS – Atenção de Média e Alta Complexidade Ambulatorial e Hospitalar - PRINCIPAL\",\"value\":3318535.03,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171803\",\"codigo\":\"1718039\",\"name\":\"Transferência de Recursos do SUS – Outros Programas Financiados por Transferências Fundo a Fundo\",\"value\":230308.05,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718039\",\"codigo\":\"17180391\",\"name\":\"Transferência de Recursos do SUS – Outros Programas Financiados por Transferências Fundo a Fundo - PRINCIPAL\",\"value\":230308.05,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171803\",\"codigo\":\"1718033\",\"name\":\"Transferência de Recursos do SUS – Vigilância em Saúde\",\"value\":254749.39,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718033\",\"codigo\":\"17180331\",\"name\":\"Transferência de Recursos do SUS – Vigilância em Saúde - PRINCIPAL\",\"value\":254749.39,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1718\",\"codigo\":\"171810\",\"name\":\"TRANSFERÊNCIAS DE CONVÊNIOS DA UNIÃO E DE SUAS ENTIDADES\",\"value\":23100.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171810\",\"codigo\":\"1718103\",\"name\":\"TRANSFERÊNCIAS DE CONVÊNIOS DA UNIÃO DESTINADAS A PROGRAMAS DE ASSISTÊNCIA SOCIAL\",\"value\":23100.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718103\",\"codigo\":\"17181031\",\"name\":\"TRANSFERÊNCIAS DE CONVÊNIOS DA UNIÃO DESTINADAS A PROGRAMAS DE ASSISTÊNCIA SOCIAL - PRINCIPAL\",\"value\":23100.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1718\",\"codigo\":\"171812\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO NACIONAL DE ASSISTÊNCIA SOCIAL – FNAS\",\"value\":24500.36,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171812\",\"codigo\":\"1718121\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO NACIONAL DE ASSISTÊNCIA SOCIAL – FNAS\",\"value\":24500.36,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718121\",\"codigo\":\"17181211\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO NACIONAL DE ASSISTÊNCIA SOCIAL – FNAS - PRINCIPAL\",\"value\":24500.36,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1718\",\"codigo\":\"171805\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO NACIONAL DO DESENVOLVIMENTO DA EDUCAÇÃO – FNDE\",\"value\":1716884.16,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"171805\",\"codigo\":\"1718059\",\"name\":\"OUTRAS TRANSFERÊNCIAS DIRETAS DO FUNDO NACIONAL DO DESENVOLVIMENTO DA EDUCAÇÃO – FNDE\",\"value\":131477.45,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718059\",\"codigo\":\"17180591\",\"name\":\"OUTRAS TRANSFERÊNCIAS DIRETAS DO FUNDO NACIONAL DO DESENVOLVIMENTO DA EDUCAÇÃO – FNDE - PRINCIPAL\",\"value\":131477.45,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171805\",\"codigo\":\"1718052\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA DINHEIRO DIRETO NA ESCOLA – PDDE\",\"value\":23580.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718052\",\"codigo\":\"17180521\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA DINHEIRO DIRETO NA ESCOLA – PDDE - PRINCIPAL\",\"value\":23580.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171805\",\"codigo\":\"1718053\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA NACIONAL DE ALIMENTAÇÃO ESCOLAR – PNAE\",\"value\":389916.40,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718053\",\"codigo\":\"17180531\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA NACIONAL DE ALIMENTAÇÃO ESCOLAR – PNAE - PRINCIPAL\",\"value\":389916.40,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171805\",\"codigo\":\"1718054\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA NACIONAL DE APOIO AO TRANSPORTE DO ESCOLAR – PNATE\",\"value\":270234.16,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718054\",\"codigo\":\"17180541\",\"name\":\"TRANSFERÊNCIAS DIRETAS DO FNDE REFERENTES AO PROGRAMA NACIONAL DE APOIO AO TRANSPORTE DO ESCOLAR – PNATE - PRINCIPAL\",\"value\":270234.16,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"171805\",\"codigo\":\"1718051\",\"name\":\"TRANSFERÊNCIAS DO SALÁRIO-EDUCAÇÃO\",\"value\":901676.15,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1718051\",\"codigo\":\"17180511\",\"name\":\"TRANSFERÊNCIAS DO SALÁRIO-EDUCAÇÃO - PRINCIPAL\",\"value\":901676.15,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]},{\"codigoPai\":\"17\",\"codigo\":\"175\",\"name\":\"TRANSFERÊNCIAS DE OUTRAS INSTITUIÇÕES PÚBLICAS\",\"value\":13127195.17,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"175\",\"codigo\":\"1758\",\"name\":\"TRANSFERÊNCIAS DE OUTRAS INSTITUIÇÕES PÚBLICAS – ESPECÍFICAS DE ESTADOS, DF E MUNICÍPIOS\",\"value\":13127195.17,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1758\",\"codigo\":\"175801\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO DE MANUTENÇÃO E DESENVOLVIMENTO DA EDUCAÇÃO BÁSICA E DE VALORIZAÇÃO DOS PROFISSIONAIS DA EDUCAÇÃO – FUNDEB\",\"value\":13127195.17,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"175801\",\"codigo\":\"1758011\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO DE MANUTENÇÃO E DESENVOLVIMENTO DA EDUCAÇÃO BÁSICA E DE VALORIZAÇÃO DOS PROFISSIONAIS DA EDUCAÇÃO – FUNDEB\",\"value\":13127195.17,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1758011\",\"codigo\":\"17580111\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO FUNDO DE MANUTENÇÃO E DESENVOLVIMENTO DA EDUCAÇÃO BÁSICA E DE VALORIZAÇÃO DOS PROFISSIONAIS DA EDUCAÇÃO – FUNDEB - PRINCIPAL\",\"value\":13127195.17,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]},{\"codigoPai\":\"17\",\"codigo\":\"172\",\"name\":\"TRANSFERÊNCIAS DOS ESTADOS E DO DISTRITO FEDERAL E DE SUAS ENTIDADES\",\"value\":21201051.32,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"172\",\"codigo\":\"1728\",\"name\":\"TRANSFERÊNCIAS DOS ESTADOS – ESPECÍFICAS DE ESTADOS, DF E MUNICÍPIOS\",\"value\":21201051.32,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728\",\"codigo\":\"172801\",\"name\":\"PARTICIPAÇÃO NA RECEITA DOS ESTADOS\",\"value\":20066669.53,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"172801\",\"codigo\":\"1728014\",\"name\":\"COTA-PARTE DA CONTRIBUIÇÃO DE INTERVENÇÃO NO DOMÍNIO ECONÔMICO\",\"value\":44759.92,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728014\",\"codigo\":\"17280141\",\"name\":\"COTA-PARTE DA CONTRIBUIÇÃO DE INTERVENÇÃO NO DOMÍNIO ECONÔMICO - PRINCIPAL\",\"value\":44759.92,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"172801\",\"codigo\":\"1728011\",\"name\":\"COTA-PARTE DO ICMS\",\"value\":15866577.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728011\",\"codigo\":\"17280111\",\"name\":\"COTA-PARTE DO ICMS - PRINCIPAL\",\"value\":15866577.77,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"172801\",\"codigo\":\"1728013\",\"name\":\"COTA-PARTE DO IPI - MUNICÍPIOS\",\"value\":280058.83,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728013\",\"codigo\":\"17280131\",\"name\":\"COTA-PARTE DO IPI - MUNICÍPIOS - PRINCIPAL\",\"value\":280058.83,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"172801\",\"codigo\":\"1728012\",\"name\":\"COTA-PARTE DO IPVA\",\"value\":1285396.19,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728012\",\"codigo\":\"17280121\",\"name\":\"COTA-PARTE DO IPVA - PRINCIPAL\",\"value\":1285396.19,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]},{\"codigoPai\":\"172801\",\"codigo\":\"1728019\",\"name\":\"OUTRAS TRANSFERÊNCIAS DOS ESTADOS\",\"value\":2589876.82,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728019\",\"codigo\":\"17280191\",\"name\":\"OUTRAS TRANSFERÊNCIAS DOS ESTADOS - PRINCIPAL\",\"value\":2589876.82,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1728\",\"codigo\":\"172802\",\"name\":\"TRANSFERÊNCIA DA COTA-PARTE DA COMPENSAÇÃO FINANCEIRA (25%)\",\"value\":1053364.29,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"172802\",\"codigo\":\"1728029\",\"name\":\"OUTRAS TRANSFERÊNCIAS DECORRENTES DE COMPENSAÇÕES FINANCEIRAS\",\"value\":1053364.29,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728029\",\"codigo\":\"17280291\",\"name\":\"OUTRAS TRANSFERÊNCIAS DECORRENTES DE COMPENSAÇÕES FINANCEIRAS - PRINCIPAL\",\"value\":1053364.29,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"1728\",\"codigo\":\"172803\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO ESTADO PARA PROGRAMAS DE SAÚDE – REPASSE FUNDO A FUNDO\",\"value\":81017.50,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"172803\",\"codigo\":\"1728031\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO ESTADO PARA PROGRAMAS DE SAÚDE – REPASSE FUNDO A FUNDO\",\"value\":81017.50,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"1728031\",\"codigo\":\"17280311\",\"name\":\"TRANSFERÊNCIA DE RECURSOS DO ESTADO PARA PROGRAMAS DE SAÚDE – REPASSE FUNDO A FUNDO - PRINCIPAL\",\"value\":81017.50,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]}]},{\"codigoPai\":null,\"codigo\":\"2\",\"name\":\"RECEITAS DE CAPITAL\",\"value\":2479600.86,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2\",\"codigo\":\"24\",\"name\":\"TRANSFERÊNCIAS DE CAPITAL\",\"value\":2479600.86,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"24\",\"codigo\":\"241\",\"name\":\"TRANSFERÊNCIAS DA UNIÃO E DE SUAS ENTIDADES\",\"value\":1346420.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"241\",\"codigo\":\"2418\",\"name\":\"TRANSFERÊNCIAS DA UNIÃO – ESPECÍFICAS DE ESTADOS, DF E MUNICÍPIOS\",\"value\":1346420.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2418\",\"codigo\":\"241810\",\"name\":\"TRANSFERÊNCIA DE CONVÊNIOS DA UNIÃO E DE SUAS ENTIDADES\",\"value\":892420.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"241810\",\"codigo\":\"2418109\",\"name\":\"OUTRAS TRANSFERÊNCIAS DE CONVÊNIOS DA UNIÃO\",\"value\":892420.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2418109\",\"codigo\":\"24181091\",\"name\":\"OUTRAS TRANSFERÊNCIAS DE CONVÊNIOS DA UNIÃO - PRINCIPAL\",\"value\":892420.79,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"2418\",\"codigo\":\"241804\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO SISTEMA ÚNICO DE SAÚDE – SUS - BLOCO INVESTIMENTOS NA REDE DE SERVIÇOS PÚBLICOS DE SAÚDE\",\"value\":454000.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"241804\",\"codigo\":\"2418041\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO SISTEMA ÚNICO DE SAÚDE – SUS DESTINADOS À ATENÇÃO BÁSICA\",\"value\":454000.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2418041\",\"codigo\":\"24180411\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DO SISTEMA ÚNICO DE SAÚDE – SUS DESTINADOS À ATENÇÃO BÁSICA - PRINCIPAL\",\"value\":454000.00,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]},{\"codigoPai\":\"24\",\"codigo\":\"242\",\"name\":\"TRANSFERÊNCIAS DOS ESTADOS E DO DISTRITO FEDERAL E DE SUAS ENTIDADES\",\"value\":1133180.07,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"242\",\"codigo\":\"2428\",\"name\":\"TRANSFERÊNCIAS DOS ESTADOS, DISTRITO FEDERAL, E DE SUAS ENTIDADES\",\"value\":1133180.07,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2428\",\"codigo\":\"242810\",\"name\":\"TRANSFERÊNCIAS DE CONVÊNIOS DOS ESTADOS E DO DISTRITO FEDERAL E DE SUAS ENTIDADES\",\"value\":605369.93,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"242810\",\"codigo\":\"2428109\",\"name\":\"OUTRAS TRANSFERÊNCIAS DE CONVÊNIO DOS ESTADOS\",\"value\":605369.93,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2428109\",\"codigo\":\"24281091\",\"name\":\"OUTRAS TRANSFERÊNCIAS DE CONVÊNIO DOS ESTADOS - PRINCIPAL\",\"value\":605369.93,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]},{\"codigoPai\":\"2428\",\"codigo\":\"242805\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DESTINADOS A PROGRAMAS DE EDUCAÇÃO\",\"value\":527810.14,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"242805\",\"codigo\":\"2428051\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DESTINADOS A PROGRAMAS DE EDUCAÇÃO\",\"value\":527810.14,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[{\"codigoPai\":\"2428051\",\"codigo\":\"24280511\",\"name\":\"TRANSFERÊNCIAS DE RECURSOS DESTINADOS A PROGRAMAS DE EDUCAÇÃO - PRINCIPAL\",\"value\":527810.14,\"canDrillDown\":false,\"fillcolor\":null,\"children\":[]}]}]}]}]}]}]}]");
    	const writable_props = ["height"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Treemap> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Treemap", $$slots, []);

    	$$self.$set = $$props => {
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({ Widget, Treemap, height, data });

    	$$self.$inject_state = $$props => {
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [height, data];
    }

    class Treemap_1$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1l, safe_not_equal, { height: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Treemap_1",
    			options,
    			id: create_fragment$1l.name
    		});
    	}

    	get height() {
    		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\receitas\index.svelte generated by Svelte v3.22.3 */

    const { console: console_1$3 } = globals;
    const file$1f = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\receitas\\index.svelte";

    // (97:6) <span slot="title">
    function create_title_slot_2$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução anual da Receita";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1f, 96, 6, 3976);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_2$3.name,
    		type: "slot",
    		source: "(97:6) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (98:6) <span slot="tooltip">
    function create_tooltip_slot_1$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Possibilita comparar os gastos realizados com o montante arrecadado no\r\n        exercício e identificar a ocorrência de déficit (despesa maior que\r\n        receita) ou superávit (receita maior que despesa).";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1f, 97, 6, 4035);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot_1$2.name,
    		type: "slot",
    		source: "(98:6) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (93:4) <ReceitaXDespesaEvolucaoAnual        view="receita"        receita={$store.receitaEvolucaoAnual}        despesa={$store.despesaEvolucaoAnual}>
    function create_default_slot_2$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$d.name,
    		type: "slot",
    		source: "(93:4) <ReceitaXDespesaEvolucaoAnual        view=\\\"receita\\\"        receita={$store.receitaEvolucaoAnual}        despesa={$store.despesaEvolucaoAnual}>",
    		ctx
    	});

    	return block;
    }

    // (110:6) <span slot="title">
    function create_title_slot_1$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Arrecadação comparada ao ano anterior";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1f, 109, 6, 4506);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_1$3.name,
    		type: "slot",
    		source: "(110:6) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (123:6) <span slot="title">
    function create_title_slot$t(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução mensal da Receita";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1f, 122, 6, 4857);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$t.name,
    		type: "slot",
    		source: "(123:6) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:6) <span slot="tooltip">
    function create_tooltip_slot$t(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Possibilita comparar os gastos realizados com o montante arrecadado no\r\n        exercício e identificar a ocorrência de déficit (despesa maior que\r\n        receita) ou superávit (receita maior que despesa).";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1f, 123, 6, 4917);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$t.name,
    		type: "slot",
    		source: "(124:6) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (119:4) <ReceitaXDespesaEvolucaoMensal        view="receita"        receita={$store.receitaEvolucaoMensal}        despesa={$store.despesaEvolucaoMensal}>
    function create_default_slot$K(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$K.name,
    		type: "slot",
    		source: "(119:4) <ReceitaXDespesaEvolucaoMensal        view=\\\"receita\\\"        receita={$store.receitaEvolucaoMensal}        despesa={$store.despesaEvolucaoMensal}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1m(ctx) {
    	let t0;
    	let div0;
    	let t1;
    	let div8;
    	let div1;
    	let t2;
    	let div2;
    	let t3;
    	let div3;
    	let t4;
    	let div4;
    	let t5;
    	let div5;
    	let t6;
    	let div6;
    	let t7;
    	let div7;
    	let current;

    	const prestacaocontamensal = new PrestacaoContaMensal({
    			props: {
    				model: /*$store*/ ctx[0].prestacaoContaMensal
    			},
    			$$inline: true
    		});

    	const cardarrecadada = new CardArrecadada({
    			props: {
    				remessa: /*$store*/ ctx[0].receitaRemessaAtual
    			},
    			$$inline: true
    		});

    	const composicaoarrecadada = new ComposicaoArrecadada({
    			props: {
    				composicaoArrecadada: /*$store*/ ctx[0].receitaComposicaoArrecadada
    			},
    			$$inline: true
    		});

    	const receitaxdespesa = new ReceitaXDespesa({
    			props: {
    				remessaReceita: /*$store*/ ctx[0].receitaRemessaAtual,
    				remessaDespesa: /*$store*/ ctx[0].despesaRemessaAtual
    			},
    			$$inline: true
    		});

    	const receitaxdespesaevolucaoanual = new ReceitaXDespesaEvolucaoAnual({
    			props: {
    				view: "receita",
    				receita: /*$store*/ ctx[0].receitaEvolucaoAnual,
    				despesa: /*$store*/ ctx[0].despesaEvolucaoAnual,
    				$$slots: {
    					default: [create_default_slot_2$d],
    					tooltip: [create_tooltip_slot_1$2],
    					title: [create_title_slot_2$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const comparacaoanoanterior = new ComparacaoAnoAnterior({
    			props: {
    				model: /*$store*/ ctx[0].receitaEvolucaoAnual,
    				seriesProperty: "arrecadada",
    				$$slots: { title: [create_title_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const destaques = new Destaques$1({ $$inline: true });

    	const receitaxdespesaevolucaomensal = new ReceitaXDespesaEvolucaoMensal({
    			props: {
    				view: "receita",
    				receita: /*$store*/ ctx[0].receitaEvolucaoMensal,
    				despesa: /*$store*/ ctx[0].despesaEvolucaoMensal,
    				$$slots: {
    					default: [create_default_slot$K],
    					tooltip: [create_tooltip_slot$t],
    					title: [create_title_slot$t]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			div0 = element("div");
    			create_component(prestacaocontamensal.$$.fragment);
    			t1 = space();
    			div8 = element("div");
    			div1 = element("div");
    			create_component(cardarrecadada.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			create_component(composicaoarrecadada.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(receitaxdespesa.$$.fragment);
    			t4 = space();
    			div4 = element("div");
    			create_component(receitaxdespesaevolucaoanual.$$.fragment);
    			t5 = space();
    			div5 = element("div");
    			create_component(comparacaoanoanterior.$$.fragment);
    			t6 = space();
    			div6 = element("div");
    			create_component(destaques.$$.fragment);
    			t7 = space();
    			div7 = element("div");
    			create_component(receitaxdespesaevolucaomensal.$$.fragment);
    			document.title = "CIDADES - PLATAFORMA PARA TRANSPARÊNCIA PÚBLICA";
    			attr_dev(div0, "class", "pl-1");
    			add_location(div0, file$1f, 71, 0, 3152);
    			attr_dev(div1, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div1, file$1f, 76, 2, 3285);
    			attr_dev(div2, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div2, file$1f, 80, 2, 3413);
    			attr_dev(div3, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div3, file$1f, 85, 2, 3575);
    			attr_dev(div4, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div4, file$1f, 91, 2, 3769);
    			attr_dev(div5, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div5, file$1f, 105, 2, 4340);
    			attr_dev(div6, "class", "w-full p-1");
    			add_location(div6, file$1f, 113, 2, 4615);
    			attr_dev(div7, "class", "w-full p-1");
    			add_location(div7, file$1f, 117, 2, 4674);
    			attr_dev(div8, "class", "flex flex-wrap w-full");
    			add_location(div8, file$1f, 75, 0, 3246);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(prestacaocontamensal, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div1);
    			mount_component(cardarrecadada, div1, null);
    			append_dev(div8, t2);
    			append_dev(div8, div2);
    			mount_component(composicaoarrecadada, div2, null);
    			append_dev(div8, t3);
    			append_dev(div8, div3);
    			mount_component(receitaxdespesa, div3, null);
    			append_dev(div8, t4);
    			append_dev(div8, div4);
    			mount_component(receitaxdespesaevolucaoanual, div4, null);
    			append_dev(div8, t5);
    			append_dev(div8, div5);
    			mount_component(comparacaoanoanterior, div5, null);
    			append_dev(div8, t6);
    			append_dev(div8, div6);
    			mount_component(destaques, div6, null);
    			append_dev(div8, t7);
    			append_dev(div8, div7);
    			mount_component(receitaxdespesaevolucaomensal, div7, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prestacaocontamensal_changes = {};
    			if (dirty & /*$store*/ 1) prestacaocontamensal_changes.model = /*$store*/ ctx[0].prestacaoContaMensal;
    			prestacaocontamensal.$set(prestacaocontamensal_changes);
    			const cardarrecadada_changes = {};
    			if (dirty & /*$store*/ 1) cardarrecadada_changes.remessa = /*$store*/ ctx[0].receitaRemessaAtual;
    			cardarrecadada.$set(cardarrecadada_changes);
    			const composicaoarrecadada_changes = {};
    			if (dirty & /*$store*/ 1) composicaoarrecadada_changes.composicaoArrecadada = /*$store*/ ctx[0].receitaComposicaoArrecadada;
    			composicaoarrecadada.$set(composicaoarrecadada_changes);
    			const receitaxdespesa_changes = {};
    			if (dirty & /*$store*/ 1) receitaxdespesa_changes.remessaReceita = /*$store*/ ctx[0].receitaRemessaAtual;
    			if (dirty & /*$store*/ 1) receitaxdespesa_changes.remessaDespesa = /*$store*/ ctx[0].despesaRemessaAtual;
    			receitaxdespesa.$set(receitaxdespesa_changes);
    			const receitaxdespesaevolucaoanual_changes = {};
    			if (dirty & /*$store*/ 1) receitaxdespesaevolucaoanual_changes.receita = /*$store*/ ctx[0].receitaEvolucaoAnual;
    			if (dirty & /*$store*/ 1) receitaxdespesaevolucaoanual_changes.despesa = /*$store*/ ctx[0].despesaEvolucaoAnual;

    			if (dirty & /*$$scope*/ 16) {
    				receitaxdespesaevolucaoanual_changes.$$scope = { dirty, ctx };
    			}

    			receitaxdespesaevolucaoanual.$set(receitaxdespesaevolucaoanual_changes);
    			const comparacaoanoanterior_changes = {};
    			if (dirty & /*$store*/ 1) comparacaoanoanterior_changes.model = /*$store*/ ctx[0].receitaEvolucaoAnual;

    			if (dirty & /*$$scope*/ 16) {
    				comparacaoanoanterior_changes.$$scope = { dirty, ctx };
    			}

    			comparacaoanoanterior.$set(comparacaoanoanterior_changes);
    			const receitaxdespesaevolucaomensal_changes = {};
    			if (dirty & /*$store*/ 1) receitaxdespesaevolucaomensal_changes.receita = /*$store*/ ctx[0].receitaEvolucaoMensal;
    			if (dirty & /*$store*/ 1) receitaxdespesaevolucaomensal_changes.despesa = /*$store*/ ctx[0].despesaEvolucaoMensal;

    			if (dirty & /*$$scope*/ 16) {
    				receitaxdespesaevolucaomensal_changes.$$scope = { dirty, ctx };
    			}

    			receitaxdespesaevolucaomensal.$set(receitaxdespesaevolucaomensal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prestacaocontamensal.$$.fragment, local);
    			transition_in(cardarrecadada.$$.fragment, local);
    			transition_in(composicaoarrecadada.$$.fragment, local);
    			transition_in(receitaxdespesa.$$.fragment, local);
    			transition_in(receitaxdespesaevolucaoanual.$$.fragment, local);
    			transition_in(comparacaoanoanterior.$$.fragment, local);
    			transition_in(destaques.$$.fragment, local);
    			transition_in(receitaxdespesaevolucaomensal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prestacaocontamensal.$$.fragment, local);
    			transition_out(cardarrecadada.$$.fragment, local);
    			transition_out(composicaoarrecadada.$$.fragment, local);
    			transition_out(receitaxdespesa.$$.fragment, local);
    			transition_out(receitaxdespesaevolucaoanual.$$.fragment, local);
    			transition_out(comparacaoanoanterior.$$.fragment, local);
    			transition_out(destaques.$$.fragment, local);
    			transition_out(receitaxdespesaevolucaomensal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_component(prestacaocontamensal);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div8);
    			destroy_component(cardarrecadada);
    			destroy_component(composicaoarrecadada);
    			destroy_component(receitaxdespesa);
    			destroy_component(receitaxdespesaevolucaoanual);
    			destroy_component(comparacaoanoanterior);
    			destroy_component(destaques);
    			destroy_component(receitaxdespesaevolucaomensal);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	let $route;
    	let $store;
    	validate_store(route, "route");
    	component_subscribe($$self, route, $$value => $$invalidate(2, $route = $$value));
    	const store = api.createStore();
    	validate_store(store, "store");
    	component_subscribe($$self, store, value => $$invalidate(0, $store = value));

    	async function refresh({ params }) {
    		console.log("receitas");
    		const ano = parseInt(params.ano);
    		const ug = params.ug;
    		const municipio = ug === "consolidado" ? params.municipio : ug;

    		await api.post(
    			api.getApiUrl("DWControleSocial"),
    			prestacaoContaMensal(ano, ug === "consolidado"
    			? municipio + "E0700001"
    			: municipio).concat(despesaEvolucaoAnual(ano, municipio)).concat(despesaEvolucaoMensal(ano, municipio)).concat(despesaLiquidada(ano, municipio)).concat(despesaPaga(ano, municipio)).concat(despesaPrevisaoInicial(ano, municipio)).concat(receitaComposicaoArrecadada(ano, municipio)).concat(receitaEvolucaoAnual(ano, municipio, 6)).concat(receitaEvolucaoMensal(ano, municipio)).concat(receitaPrevisaoInicial(ano, municipio)),
    			{ store }
    		);

    		set_store_value(
    			store,
    			$store.despesaRemessaAtual = {
    				value: $store.despesaEvolucaoAnual.value.find(o => o.ano === ano)
    			},
    			$store
    		);

    		set_store_value(
    			store,
    			$store.receitaRemessaAtual = {
    				value: $store.receitaEvolucaoAnual.value.find(o => o.ano === ano)
    			},
    			$store
    		);

    		set_store_value(
    			store,
    			$store.receitaComposicaoArrecadada = {
    				value: {
    					operacoesDeCredito: $store.receitaDestaqueOperacoesDeCredito.value,
    					receitasDoMunicipio: $store.receitaDestaqueReceitasDoMunicipio.value,
    					transferenciaDaUniao: $store.receitaDestaqueTransferenciasDaUniao.value,
    					transferenciaDoEstado: $store.receitaDestaqueTransferenciasDoEstado.value,
    					outrasTransferencias: $store.receitaDestaqueOutrasTransferencias.value
    				}
    			},
    			$store
    		);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Receitas> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Receitas", $$slots, []);

    	$$self.$capture_state = () => ({
    		route,
    		api,
    		PrestacaoContaMensal,
    		ReceitaXDespesaEvolucaoAnual,
    		ReceitaXDespesaEvolucaoMensal,
    		ReceitaXDespesa,
    		CardArrecadada,
    		ComparacaoAnoAnterior,
    		ComposicaoArrecadada,
    		Destaques: Destaques$1,
    		Treemap: Treemap_1$1,
    		despesaApi,
    		gestaoApi,
    		prestacaoContaApi,
    		receitaApi,
    		store,
    		refresh,
    		$route,
    		$store
    	});

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$route*/ 4) {
    			 refresh($route);
    		}
    	};

    	return [$store, store];
    }

    class Receitas$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Receitas",
    			options,
    			id: create_fragment$1m.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\saude\_components\EvolucaoAnualAplicacao.svelte generated by Svelte v3.22.3 */
    const file$1g = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\saude\\_components\\EvolucaoAnualAplicacao.svelte";

    // (10:4) <span slot="tooltip">
    function create_tooltip_slot$u(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução dos recursos aplicados em saúde nos últimos exercícios.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1g, 9, 4, 314);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$u.name,
    		type: "slot",
    		source: "(10:4) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1n(ctx) {
    	let div;
    	let current;

    	const evolucaoanual = new EvolucaoAnual({
    			props: {
    				model: /*model*/ ctx[0],
    				seriesName: "Aplicação",
    				seriesProperty: "aplicacao",
    				$$slots: { tooltip: [create_tooltip_slot$u] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(evolucaoanual.$$.fragment);
    			attr_dev(div, "class", "mb-3");
    			add_location(div, file$1g, 7, 0, 213);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(evolucaoanual, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const evolucaoanual_changes = {};
    			if (dirty & /*model*/ 1) evolucaoanual_changes.model = /*model*/ ctx[0];

    			if (dirty & /*$$scope*/ 2) {
    				evolucaoanual_changes.$$scope = { dirty, ctx };
    			}

    			evolucaoanual.$set(evolucaoanual_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(evolucaoanual.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(evolucaoanual.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(evolucaoanual);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	const writable_props = ["model"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoAnualAplicacao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoAnualAplicacao", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    	};

    	$$self.$capture_state = () => ({ EvolucaoAnual, Loading, model });

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model];
    }

    class EvolucaoAnualAplicacao$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1n, safe_not_equal, { model: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoAnualAplicacao",
    			options,
    			id: create_fragment$1n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoAnualAplicacao> was created without expected prop 'model'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoAnualAplicacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoAnualAplicacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\saude\_components\EvolucaoAnualAplicacaoPerCapita.svelte generated by Svelte v3.22.3 */
    const file$1h = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\saude\\_components\\EvolucaoAnualAplicacaoPerCapita.svelte";

    // (74:2) <span slot="title">
    function create_title_slot$u(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução da aplicação em Receita Arrecadada X Saúde";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1h, 73, 2, 1405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$u.name,
    		type: "slot",
    		source: "(74:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (75:2) <span slot="tooltip">
    function create_tooltip_slot$v(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Aplicação em saúde: recursos aplicados. Receita Total: É o montante total em\r\n    dinheiro incorporado ao patrimônio do município.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1h, 74, 2, 1486);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$v.name,
    		type: "slot",
    		source: "(75:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (73:0) <Widget>
    function create_default_slot$L(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				grid: /*grid*/ ctx[2],
    				xAxis: /*xAxis*/ ctx[1],
    				yAxis: /*yAxis*/ ctx[3],
    				series: /*series*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(series_1.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$1h, 78, 2, 1658);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(series_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 2) series_1_changes.xAxis = /*xAxis*/ ctx[1];
    			if (dirty & /*series*/ 1) series_1_changes.series = /*series*/ ctx[0];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(series_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$L.name,
    		type: "slot",
    		source: "(73:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1o(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$L],
    					tooltip: [create_tooltip_slot$v],
    					title: [create_title_slot$u]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, xAxis, series*/ 67) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	const grid = { left: 90 };
    	let series;
    	let xAxis;

    	const yAxis = [
    		{
    			type: "value",
    			name: "Aplicação média nos municípios per capita",
    			axisLabel: { formatter: "R$ {value}" }
    		},
    		{
    			type: "value",
    			name: "Aplicação per capita",
    			axisLabel: { formatter: "R$ {value}" }
    		}
    	];

    	function render(model) {
    		if (!model) {
    			$$invalidate(0, series = null);
    			return;
    		}

    		const anos = [];
    		const aplicacaoPerCapita = [];
    		const mediaMunicipal = [];

    		model.value.forEach(m => {
    			anos.push(m.ano);
    			aplicacaoPerCapita.push(m.aplicacaoPerCapita);
    			mediaMunicipal.push(m.mediaMunicipal);
    		});

    		$$invalidate(1, xAxis = [
    			{
    				type: "category",
    				data: anos,
    				axisPointer: { type: "shadow" }
    			}
    		]);

    		$$invalidate(0, series = [
    			{
    				type: "line",
    				name: "Aplicação média nos municípios per capita",
    				data: mediaMunicipal
    			},
    			{
    				type: "bar",
    				name: "Aplicação per capita",
    				data: aplicacaoPerCapita
    			}
    		]);
    	}

    	const writable_props = ["model"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoAnualAplicacaoPerCapita> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoAnualAplicacaoPerCapita", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(4, model = $$props.model);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Series: Series$1,
    		model,
    		grid,
    		series,
    		xAxis,
    		yAxis,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(4, model = $$props.model);
    		if ("series" in $$props) $$invalidate(0, series = $$props.series);
    		if ("xAxis" in $$props) $$invalidate(1, xAxis = $$props.xAxis);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*model*/ 16) {
    			 render(model);
    		}
    	};

    	return [series, xAxis, grid, yAxis, model];
    }

    class EvolucaoAnualAplicacaoPerCapita$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1n, create_fragment$1o, safe_not_equal, { model: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoAnualAplicacaoPerCapita",
    			options,
    			id: create_fragment$1o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[4] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoAnualAplicacaoPerCapita> was created without expected prop 'model'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoAnualAplicacaoPerCapita>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoAnualAplicacaoPerCapita>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\saude\_components\EvolucaoAnualLimiteConstitucional.svelte generated by Svelte v3.22.3 */
    const file$1i = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\saude\\_components\\EvolucaoAnualLimiteConstitucional.svelte";

    // (57:2) <span slot="title">
    function create_title_slot$v(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução do limite constitucional mínimo aplicado em saúde";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1i, 56, 2, 1134);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$v.name,
    		type: "slot",
    		source: "(57:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:2) <span slot="tooltip">
    function create_tooltip_slot$w(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução, em percentuais, dos recursos aplicados em saúde nos últimos\r\n    exercícios.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1i, 59, 2, 1232);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$w.name,
    		type: "slot",
    		source: "(60:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (56:0) <Widget>
    function create_default_slot$M(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				xAxis: /*xAxis*/ ctx[0],
    				yAxis: /*yAxis*/ ctx[3],
    				series: /*series*/ ctx[1],
    				options: /*options*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(series_1.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$1i, 63, 2, 1360);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(series_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 1) series_1_changes.xAxis = /*xAxis*/ ctx[0];
    			if (dirty & /*series*/ 2) series_1_changes.series = /*series*/ ctx[1];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(series_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$M.name,
    		type: "slot",
    		source: "(56:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1p(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$M],
    					tooltip: [create_tooltip_slot$w],
    					title: [create_title_slot$v]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, xAxis, series*/ 67) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	const options = { legend: { show: false } };
    	const yAxis = { show: false };
    	let xAxis;
    	let series;

    	function render(model) {
    		if (!model) {
    			return;
    		}

    		const anos = [];
    		const values = [];

    		model.value.forEach(o => {
    			anos.push(o.ano);
    			values.push(o.limiteConstitucional);
    		});

    		$$invalidate(0, xAxis = [
    			{
    				type: "category",
    				data: anos,
    				axisPointer: { type: "shadow" }
    			}
    		]);

    		$$invalidate(1, series = [
    			{
    				type: "bar",
    				xAxisIndex: 0,
    				yAxisIndex: 0,
    				//name: "Aplicação em saúde",
    				data: values,
    				markLine: getHorizontalMarkLine(15, "Limite de 15%")
    			}
    		]);
    	}

    	const writable_props = ["model"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoAnualLimiteConstitucional> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoAnualLimiteConstitucional", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(4, model = $$props.model);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		getHorizontalMarkLine,
    		Series: Series$1,
    		model,
    		options,
    		yAxis,
    		xAxis,
    		series,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(4, model = $$props.model);
    		if ("xAxis" in $$props) $$invalidate(0, xAxis = $$props.xAxis);
    		if ("series" in $$props) $$invalidate(1, series = $$props.series);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*model*/ 16) {
    			 render(model);
    		}
    	};

    	return [xAxis, series, options, yAxis, model];
    }

    class EvolucaoAnualLimiteConstitucional$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1o, create_fragment$1p, safe_not_equal, { model: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoAnualLimiteConstitucional",
    			options,
    			id: create_fragment$1p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[4] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoAnualLimiteConstitucional> was created without expected prop 'model'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoAnualLimiteConstitucional>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoAnualLimiteConstitucional>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\saude\_components\EvolucaoAnualReceitaXAplicacao.svelte generated by Svelte v3.22.3 */
    const file$1j = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\saude\\_components\\EvolucaoAnualReceitaXAplicacao.svelte";

    // (82:2) <span slot="title">
    function create_title_slot$w(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Evolução da aplicação em Receita Arrecadada X Saúde";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1j, 81, 2, 1452);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$w.name,
    		type: "slot",
    		source: "(82:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (83:2) <span slot="tooltip">
    function create_tooltip_slot$x(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Aplicação em saúde: recursos aplicados. Receita Total: É o montante total em\r\n    dinheiro incorporado ao patrimônio do município.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1j, 82, 2, 1533);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$x.name,
    		type: "slot",
    		source: "(83:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (81:0) <Widget>
    function create_default_slot$N(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current;

    	const series_1 = new Series$1({
    			props: {
    				grid: /*grid*/ ctx[3],
    				xAxis: /*xAxis*/ ctx[2],
    				yAxis: /*yAxis*/ ctx[4],
    				series: /*series*/ ctx[1],
    				legends: /*legends*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			create_component(series_1.$$.fragment);
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$1j, 86, 2, 1705);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(series_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const series_1_changes = {};
    			if (dirty & /*xAxis*/ 4) series_1_changes.xAxis = /*xAxis*/ ctx[2];
    			if (dirty & /*series*/ 2) series_1_changes.series = /*series*/ ctx[1];
    			if (dirty & /*legends*/ 1) series_1_changes.legends = /*legends*/ ctx[0];
    			series_1.$set(series_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(series_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(series_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(series_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$N.name,
    		type: "slot",
    		source: "(81:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1q(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$N],
    					tooltip: [create_tooltip_slot$x],
    					title: [create_title_slot$w]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, xAxis, series, legends*/ 135) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	const grid = { left: 90 };
    	let legends;
    	let series;
    	let xAxis;

    	const yAxis = [
    		{
    			type: "value",
    			name: "Aplicação em saúde",
    			axisLabel: { formatter: "R$ {value}" }
    		},
    		{
    			type: "value",
    			name: "Receita arrecadada",
    			axisLabel: { formatter: "R$ {value}" }
    		}
    	];

    	function render(model) {
    		if (!model) {
    			$$invalidate(1, series = null);
    			return;
    		}

    		const anos = [];
    		const aplicacao = [];
    		const arrecadadas = [];

    		model.value.forEach(m => {
    			anos.push(m.ano);
    			aplicacao.push(m.aplicacao);
    			arrecadadas.push(m.arrecadada);
    		});

    		$$invalidate(2, xAxis = [
    			{
    				type: "category",
    				data: anos,
    				axisPointer: { type: "shadow" }
    			}
    		]);

    		$$invalidate(1, series = [
    			{
    				type: "bar",
    				name: "Aplicação em saúde",
    				data: aplicacao
    			},
    			{
    				type: "line",
    				name: "Receita arrecadada",
    				data: arrecadadas
    			}
    		]);

    		$$invalidate(0, legends = {
    			data: series.map(s => s.name),
    			selected: { "Receita arrecadada": false }
    		});
    	}

    	const writable_props = ["model"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EvolucaoAnualReceitaXAplicacao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EvolucaoAnualReceitaXAplicacao", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(5, model = $$props.model);
    	};

    	$$self.$capture_state = () => ({
    		Widget,
    		Series: Series$1,
    		model,
    		grid,
    		legends,
    		series,
    		xAxis,
    		yAxis,
    		render
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(5, model = $$props.model);
    		if ("legends" in $$props) $$invalidate(0, legends = $$props.legends);
    		if ("series" in $$props) $$invalidate(1, series = $$props.series);
    		if ("xAxis" in $$props) $$invalidate(2, xAxis = $$props.xAxis);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*model*/ 32) {
    			 render(model);
    		}
    	};

    	return [legends, series, xAxis, grid, yAxis, model];
    }

    class EvolucaoAnualReceitaXAplicacao$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1p, create_fragment$1q, safe_not_equal, { model: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EvolucaoAnualReceitaXAplicacao",
    			options,
    			id: create_fragment$1q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[5] === undefined && !("model" in props)) {
    			console.warn("<EvolucaoAnualReceitaXAplicacao> was created without expected prop 'model'");
    		}
    	}

    	get model() {
    		throw new Error("<EvolucaoAnualReceitaXAplicacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<EvolucaoAnualReceitaXAplicacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\saude\_components\CardAplicacao.svelte generated by Svelte v3.22.3 */
    const file$1k = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\saude\\_components\\CardAplicacao.svelte";

    // (10:2) <span slot="title">
    function create_title_slot$x(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Aplicação";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1k, 9, 2, 250);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$x.name,
    		type: "slot",
    		source: "(10:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:2) <span slot="tooltip">
    function create_tooltip_slot$y(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Este é o valor aplicado em saúde, com recursos próprios (impostos e\r\n    transferências), não considerados os recursos de convênios. O valor da\r\n    aplicação per capita (por pessoa) é calculado de acordo com o número de\r\n    habitantes informados pelo IBGE.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1k, 10, 2, 289);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$y.name,
    		type: "slot",
    		source: "(11:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (35:4) {:else}
    function create_else_block$l(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$l.name,
    		type: "else",
    		source: "(35:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#if model && posicaoRanking}
    function create_if_block$s(ctx) {
    	let div0;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = /*model*/ ctx[0].value.aplicacao + "";
    	let t2;
    	let t3;
    	let div1;
    	let span2;
    	let t5;
    	let span3;
    	let t6_value = /*model*/ ctx[0].value.mediaMunicipal + "";
    	let t6;
    	let t7;
    	let div2;
    	let span4;
    	let t9;
    	let span5;
    	let t10_value = /*posicaoRanking*/ ctx[1].value + "";
    	let t10;
    	let t11;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "R$";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			span2 = element("span");
    			span2.textContent = "Média municipal";
    			t5 = space();
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			div2 = element("div");
    			span4 = element("span");
    			span4.textContent = "Posição";
    			t9 = space();
    			span5 = element("span");
    			t10 = text(t10_value);
    			t11 = text("º");
    			attr_dev(span0, "class", "text-sm");
    			add_location(span0, file$1k, 19, 8, 685);
    			attr_dev(span1, "class", "text-4xl font-bold");
    			add_location(span1, file$1k, 20, 8, 726);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$1k, 18, 6, 650);
    			attr_dev(span2, "class", "text-base");
    			add_location(span2, file$1k, 23, 8, 826);
    			attr_dev(span3, "class", "text-base float-right font-bold");
    			add_location(span3, file$1k, 24, 8, 882);
    			add_location(div1, file$1k, 22, 6, 811);
    			attr_dev(span4, "class", "text-base");
    			add_location(span4, file$1k, 29, 8, 1022);
    			attr_dev(span5, "class", "text-base float-right font-bold");
    			add_location(span5, file$1k, 30, 8, 1070);
    			add_location(div2, file$1k, 28, 6, 1007);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span2);
    			append_dev(div1, t5);
    			append_dev(div1, span3);
    			append_dev(span3, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, span4);
    			append_dev(div2, t9);
    			append_dev(div2, span5);
    			append_dev(span5, t10);
    			append_dev(span5, t11);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*model*/ 1 && t2_value !== (t2_value = /*model*/ ctx[0].value.aplicacao + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*model*/ 1 && t6_value !== (t6_value = /*model*/ ctx[0].value.mediaMunicipal + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*posicaoRanking*/ 2 && t10_value !== (t10_value = /*posicaoRanking*/ ctx[1].value + "")) set_data_dev(t10, t10_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(18:4) {#if model && posicaoRanking}",
    		ctx
    	});

    	return block;
    }

    // (9:0) <Widget>
    function create_default_slot$O(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$s, create_else_block$l];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*model*/ ctx[0] && /*posicaoRanking*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$1k, 16, 2, 589);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$O.name,
    		type: "slot",
    		source: "(9:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1r(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$O],
    					tooltip: [create_tooltip_slot$y],
    					title: [create_title_slot$x]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, posicaoRanking, model*/ 7) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1q($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { posicaoRanking } = $$props;
    	const writable_props = ["model", "posicaoRanking"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardAplicacao> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("CardAplicacao", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	$$self.$capture_state = () => ({ Loading, Widget, model, posicaoRanking });

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model, posicaoRanking];
    }

    class CardAplicacao$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1q, create_fragment$1r, safe_not_equal, { model: 0, posicaoRanking: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardAplicacao",
    			options,
    			id: create_fragment$1r.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<CardAplicacao> was created without expected prop 'model'");
    		}

    		if (/*posicaoRanking*/ ctx[1] === undefined && !("posicaoRanking" in props)) {
    			console.warn("<CardAplicacao> was created without expected prop 'posicaoRanking'");
    		}
    	}

    	get model() {
    		throw new Error("<CardAplicacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<CardAplicacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get posicaoRanking() {
    		throw new Error("<CardAplicacao>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set posicaoRanking(value) {
    		throw new Error("<CardAplicacao>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\saude\_components\CardAplicacaoPerCapita.svelte generated by Svelte v3.22.3 */
    const file$1l = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\saude\\_components\\CardAplicacaoPerCapita.svelte";

    // (10:2) <span slot="title">
    function create_title_slot$y(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Aplicação per capita";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1l, 9, 2, 250);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$y.name,
    		type: "slot",
    		source: "(10:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:2) <span slot="tooltip">
    function create_tooltip_slot$z(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Este é o valor aplicado em saúde, com recursos próprios (impostos e\r\n    transferências), não considerados os recursos de convênios. O valor da\r\n    aplicação per capita (por pessoa) é calculado de acordo com o número de\r\n    habitantes informados pelo IBGE.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1l, 10, 2, 300);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$z.name,
    		type: "slot",
    		source: "(11:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (35:4) {:else}
    function create_else_block$m(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$m.name,
    		type: "else",
    		source: "(35:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#if model && posicaoRanking}
    function create_if_block$t(ctx) {
    	let div0;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = /*model*/ ctx[0].value.aplicacaoPerCapita + "";
    	let t2;
    	let t3;
    	let div1;
    	let span2;
    	let t5;
    	let span3;
    	let t6_value = /*model*/ ctx[0].value.mediaMunicipal + "";
    	let t6;
    	let t7;
    	let div2;
    	let span4;
    	let t9;
    	let span5;
    	let t10_value = /*posicaoRanking*/ ctx[1].value + "";
    	let t10;
    	let t11;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "R$";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			span2 = element("span");
    			span2.textContent = "Média municipal";
    			t5 = space();
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			div2 = element("div");
    			span4 = element("span");
    			span4.textContent = "Posição";
    			t9 = space();
    			span5 = element("span");
    			t10 = text(t10_value);
    			t11 = text("º");
    			attr_dev(span0, "class", "text-sm");
    			add_location(span0, file$1l, 19, 8, 696);
    			attr_dev(span1, "class", "text-4xl font-bold");
    			add_location(span1, file$1l, 20, 8, 737);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$1l, 18, 6, 661);
    			attr_dev(span2, "class", "text-base");
    			add_location(span2, file$1l, 23, 8, 846);
    			attr_dev(span3, "class", "text-base float-right font-bold");
    			add_location(span3, file$1l, 24, 8, 902);
    			add_location(div1, file$1l, 22, 6, 831);
    			attr_dev(span4, "class", "text-base");
    			add_location(span4, file$1l, 29, 8, 1042);
    			attr_dev(span5, "class", "text-base float-right font-bold");
    			add_location(span5, file$1l, 30, 8, 1090);
    			add_location(div2, file$1l, 28, 6, 1027);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span2);
    			append_dev(div1, t5);
    			append_dev(div1, span3);
    			append_dev(span3, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, span4);
    			append_dev(div2, t9);
    			append_dev(div2, span5);
    			append_dev(span5, t10);
    			append_dev(span5, t11);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*model*/ 1 && t2_value !== (t2_value = /*model*/ ctx[0].value.aplicacaoPerCapita + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*model*/ 1 && t6_value !== (t6_value = /*model*/ ctx[0].value.mediaMunicipal + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*posicaoRanking*/ 2 && t10_value !== (t10_value = /*posicaoRanking*/ ctx[1].value + "")) set_data_dev(t10, t10_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(18:4) {#if model && posicaoRanking}",
    		ctx
    	});

    	return block;
    }

    // (9:0) <Widget>
    function create_default_slot$P(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$t, create_else_block$m];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*model*/ ctx[0] && /*posicaoRanking*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "h-48");
    			add_location(div, file$1l, 16, 2, 600);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$P.name,
    		type: "slot",
    		source: "(9:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1s(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$P],
    					tooltip: [create_tooltip_slot$z],
    					title: [create_title_slot$y]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, posicaoRanking, model*/ 7) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	let { model } = $$props;
    	let { posicaoRanking } = $$props;
    	const writable_props = ["model", "posicaoRanking"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardAplicacaoPerCapita> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("CardAplicacaoPerCapita", $$slots, []);

    	$$self.$set = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	$$self.$capture_state = () => ({ Loading, Widget, model, posicaoRanking });

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("posicaoRanking" in $$props) $$invalidate(1, posicaoRanking = $$props.posicaoRanking);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [model, posicaoRanking];
    }

    class CardAplicacaoPerCapita$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1r, create_fragment$1s, safe_not_equal, { model: 0, posicaoRanking: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardAplicacaoPerCapita",
    			options,
    			id: create_fragment$1s.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*model*/ ctx[0] === undefined && !("model" in props)) {
    			console.warn("<CardAplicacaoPerCapita> was created without expected prop 'model'");
    		}

    		if (/*posicaoRanking*/ ctx[1] === undefined && !("posicaoRanking" in props)) {
    			console.warn("<CardAplicacaoPerCapita> was created without expected prop 'posicaoRanking'");
    		}
    	}

    	get model() {
    		throw new Error("<CardAplicacaoPerCapita>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set model(value) {
    		throw new Error("<CardAplicacaoPerCapita>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get posicaoRanking() {
    		throw new Error("<CardAplicacaoPerCapita>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set posicaoRanking(value) {
    		throw new Error("<CardAplicacaoPerCapita>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\_components\LimiteConstitucionalSaude.svelte generated by Svelte v3.22.3 */
    const file$1m = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\_components\\LimiteConstitucionalSaude.svelte";

    // (37:2) <span slot="title">
    function create_title_slot$z(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Saúde";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$1m, 36, 2, 958);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$z.name,
    		type: "slot",
    		source: "(37:2) <span slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:2) <span slot="tooltip">
    function create_tooltip_slot$A(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "A Constituição Federal estabelece que o município deve aplicar o limite\r\n    mínimo de 15% da soma dos recursos de impostos e transferências em ações e\r\n    serviços públicos de saúde.";
    			attr_dev(span, "slot", "tooltip");
    			add_location(span, file$1m, 37, 2, 993);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_tooltip_slot$A.name,
    		type: "slot",
    		source: "(38:2) <span slot=\\\"tooltip\\\">",
    		ctx
    	});

    	return block;
    }

    // (54:4) {:else}
    function create_else_block$n(ctx) {
    	let current;
    	const loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$n.name,
    		type: "else",
    		source: "(54:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (44:4) {#if limite}
    function create_if_block$u(ctx) {
    	let div1;
    	let span;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let div0;
    	let current;

    	const icon = new Icon({
    			props: { icon: faThumbsUp_2$1 },
    			$$inline: true
    		});

    	const gauge = new Gauge({
    			props: { serie: /*serie*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			span = element("span");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			t1 = text(/*limite*/ ctx[0]);
    			t2 = text(" %");
    			t3 = space();
    			div0 = element("div");
    			create_component(gauge.$$.fragment);
    			attr_dev(span, "class", "text-3xl");
    			add_location(span, file$1m, 45, 8, 1311);
    			attr_dev(div0, "class", "h-full");
    			set_style(div0, "margin-top", "-.8em");
    			add_location(div0, file$1m, 49, 8, 1421);
    			attr_dev(div1, "class", "text-center h-full");
    			add_location(div1, file$1m, 44, 6, 1269);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			mount_component(icon, span, null);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			mount_component(gauge, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*limite*/ 1) set_data_dev(t1, /*limite*/ ctx[0]);
    			const gauge_changes = {};
    			if (dirty & /*serie*/ 4) gauge_changes.serie = /*serie*/ ctx[2];
    			gauge.$set(gauge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			transition_in(gauge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			transition_out(gauge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(icon);
    			destroy_component(gauge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(44:4) {#if limite}",
    		ctx
    	});

    	return block;
    }

    // (36:0) <Widget>
    function create_default_slot$Q(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let div_class_value;
    	let current;
    	const if_block_creators = [create_if_block$u, create_else_block$n];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*limite*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", div_class_value = "h-" + /*height*/ ctx[1]);
    			add_location(div, file$1m, 42, 2, 1219);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (!current || dirty & /*height*/ 2 && div_class_value !== (div_class_value = "h-" + /*height*/ ctx[1])) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$Q.name,
    		type: "slot",
    		source: "(36:0) <Widget>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1t(ctx) {
    	let current;

    	const widget = new Widget({
    			props: {
    				$$slots: {
    					default: [create_default_slot$Q],
    					tooltip: [create_tooltip_slot$A],
    					title: [create_title_slot$z]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(widget.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(widget, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const widget_changes = {};

    			if (dirty & /*$$scope, height, serie, limite*/ 15) {
    				widget_changes.$$scope = { dirty, ctx };
    			}

    			widget.$set(widget_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(widget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(widget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(widget, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	let { limite } = $$props;
    	let { height = 40 } = $$props;
    	let serie = null;
    	const writable_props = ["limite", "height"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LimiteConstitucionalSaude> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LimiteConstitucionalSaude", $$slots, []);

    	$$self.$set = $$props => {
    		if ("limite" in $$props) $$invalidate(0, limite = $$props.limite);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		faThumbsUp: faThumbsUp_2$1,
    		Loading,
    		Gauge,
    		Widget,
    		limite,
    		height,
    		serie
    	});

    	$$self.$inject_state = $$props => {
    		if ("limite" in $$props) $$invalidate(0, limite = $$props.limite);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    		if ("serie" in $$props) $$invalidate(2, serie = $$props.serie);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*limite*/ 1) {
    			 $$invalidate(2, serie = {
    				title: { show: false },
    				axisLine: {
    					lineStyle: {
    						width: 35,
    						color: [[0.15, "#e68465"], [1, "#617e8c"]]
    					}
    				},
    				detail: {
    					formatter() {
    						return limite > 15
    						? "Obedeceu o limite mínimo anual de 15% da receita"
    						: "Não obedeceu o limite mínimo de 15% da receita";
    					},
    					color: "#000",
    					fontWeight: "normal",
    					fontSize: 14
    				},
    				data: [{ value: limite }]
    			});
    		}
    	};

    	return [limite, height, serie];
    }

    class LimiteConstitucionalSaude extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1s, create_fragment$1t, safe_not_equal, { limite: 0, height: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LimiteConstitucionalSaude",
    			options,
    			id: create_fragment$1t.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*limite*/ ctx[0] === undefined && !("limite" in props)) {
    			console.warn("<LimiteConstitucionalSaude> was created without expected prop 'limite'");
    		}
    	}

    	get limite() {
    		throw new Error("<LimiteConstitucionalSaude>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limite(value) {
    		throw new Error("<LimiteConstitucionalSaude>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LimiteConstitucionalSaude>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LimiteConstitucionalSaude>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function saudeEvolucaoAnual(ano, municipio, quantidade = 5) {
      return [
        {
          id: "saudeEvolucaoAnual",
          run: "Municipio.Saude.FiltrarPorCodigo",
          args: [municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Saude.EvolucaoAnual",
          args: [ano, quantidade]
        }
      ];
    }

    function saudeEvolucaoAnualPerCapita(ano, municipio, quantidade = 5) {
      return [
        {
          id: "saudeEvolucaoAnualPerCapita",
          run: "Municipio.Saude.FiltrarPorCodigo",
          args: [municipio],
          continue: true,
          evaluate: false
        },
        {
          run: "Municipio.Saude.EvolucaoAnualPerCapita",
          args: [ano, quantidade]
        }
      ];
    }

    function saudeRankingAplicacao(ano, municipio) {
      return [
        {
          id: "saudeRankingAplicacao",
          run: "Municipio.Saude.RankingAplicacao",
          args: [ano, municipio]
        }
      ];
    }

    function saudeRankingAplicacaoPerCapita(ano, municipio) {
      return [
        {
          id: "saudeRankingAplicacaoPerCapita",
          run: "Municipio.Saude.RankingAplicacaoPerCapita",
          args: [ano, municipio]
        }
      ];
    }

    var saudeApi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        saudeEvolucaoAnual: saudeEvolucaoAnual,
        saudeEvolucaoAnualPerCapita: saudeEvolucaoAnualPerCapita,
        saudeRankingAplicacao: saudeRankingAplicacao,
        saudeRankingAplicacaoPerCapita: saudeRankingAplicacaoPerCapita
    });

    /* src\pages\municipio\[ano]\[municipio]\[ug]\saude\index.svelte generated by Svelte v3.22.3 */
    const file$1n = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\saude\\index.svelte";

    function create_fragment$1u(ctx) {
    	let t0;
    	let div0;
    	let t1;
    	let div8;
    	let div1;
    	let t2;
    	let div2;
    	let t3;
    	let div3;
    	let t4;
    	let div4;
    	let t5;
    	let div5;
    	let t6;
    	let div6;
    	let t7;
    	let div7;
    	let current;

    	const prestacaocontamensal = new PrestacaoContaMensal({
    			props: { model: /*data*/ ctx[0].prestacaoContaPCB },
    			$$inline: true
    		});

    	const cardaplicacao = new CardAplicacao$1({
    			props: {
    				model: /*data*/ ctx[0].saudeAplicacao,
    				posicaoRanking: /*data*/ ctx[0].saudeRankingAplicacao
    			},
    			$$inline: true
    		});

    	const cardaplicacaopercapita = new CardAplicacaoPerCapita$1({
    			props: {
    				model: /*data*/ ctx[0].saudeAplicacaoPerCapita,
    				posicaoRanking: /*data*/ ctx[0].saudeRankingAplicacaoPerCapita
    			},
    			$$inline: true
    		});

    	const limiteconstitucionalsaude = new LimiteConstitucionalSaude({
    			props: { limite: /*limite*/ ctx[1], height: 48 },
    			$$inline: true
    		});

    	const evolucaoanualaplicacao = new EvolucaoAnualAplicacao$1({
    			props: {
    				model: /*data*/ ctx[0].saudeEvolucaoAnual
    			},
    			$$inline: true
    		});

    	const evolucaoanualreceitaxaplicacao = new EvolucaoAnualReceitaXAplicacao$1({
    			props: {
    				model: /*data*/ ctx[0].saudeEvolucaoAnual
    			},
    			$$inline: true
    		});

    	const evolucaoanuallimiteconstitucional = new EvolucaoAnualLimiteConstitucional$1({
    			props: {
    				model: /*data*/ ctx[0].saudeEvolucaoAnual
    			},
    			$$inline: true
    		});

    	const evolucaoanualaplicacaopercapita = new EvolucaoAnualAplicacaoPerCapita$1({
    			props: {
    				model: /*data*/ ctx[0].saudeEvolucaoAnualPerCapita
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			div0 = element("div");
    			create_component(prestacaocontamensal.$$.fragment);
    			t1 = space();
    			div8 = element("div");
    			div1 = element("div");
    			create_component(cardaplicacao.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			create_component(cardaplicacaopercapita.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(limiteconstitucionalsaude.$$.fragment);
    			t4 = space();
    			div4 = element("div");
    			create_component(evolucaoanualaplicacao.$$.fragment);
    			t5 = space();
    			div5 = element("div");
    			create_component(evolucaoanualreceitaxaplicacao.$$.fragment);
    			t6 = space();
    			div6 = element("div");
    			create_component(evolucaoanuallimiteconstitucional.$$.fragment);
    			t7 = space();
    			div7 = element("div");
    			create_component(evolucaoanualaplicacaopercapita.$$.fragment);
    			document.title = "Saúde";
    			attr_dev(div0, "class", "pl-1");
    			add_location(div0, file$1n, 71, 0, 2522);
    			attr_dev(div1, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div1, file$1n, 76, 2, 2650);
    			attr_dev(div2, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div2, file$1n, 82, 2, 2826);
    			attr_dev(div3, "class", "xl:w-1/3 lg:w-1/3 sm:w-1/2 w-full p-1");
    			add_location(div3, file$1n, 88, 2, 3029);
    			attr_dev(div4, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div4, file$1n, 92, 2, 3152);
    			attr_dev(div5, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div5, file$1n, 96, 2, 3283);
    			attr_dev(div6, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div6, file$1n, 100, 2, 3422);
    			attr_dev(div7, "class", "xl:w-1/2 lg:w-1/2 sm:w-1/2 w-full p-1");
    			add_location(div7, file$1n, 104, 2, 3564);
    			attr_dev(div8, "class", "flex flex-wrap w-full");
    			add_location(div8, file$1n, 75, 0, 2611);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(prestacaocontamensal, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div1);
    			mount_component(cardaplicacao, div1, null);
    			append_dev(div8, t2);
    			append_dev(div8, div2);
    			mount_component(cardaplicacaopercapita, div2, null);
    			append_dev(div8, t3);
    			append_dev(div8, div3);
    			mount_component(limiteconstitucionalsaude, div3, null);
    			append_dev(div8, t4);
    			append_dev(div8, div4);
    			mount_component(evolucaoanualaplicacao, div4, null);
    			append_dev(div8, t5);
    			append_dev(div8, div5);
    			mount_component(evolucaoanualreceitaxaplicacao, div5, null);
    			append_dev(div8, t6);
    			append_dev(div8, div6);
    			mount_component(evolucaoanuallimiteconstitucional, div6, null);
    			append_dev(div8, t7);
    			append_dev(div8, div7);
    			mount_component(evolucaoanualaplicacaopercapita, div7, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prestacaocontamensal_changes = {};
    			if (dirty & /*data*/ 1) prestacaocontamensal_changes.model = /*data*/ ctx[0].prestacaoContaPCB;
    			prestacaocontamensal.$set(prestacaocontamensal_changes);
    			const cardaplicacao_changes = {};
    			if (dirty & /*data*/ 1) cardaplicacao_changes.model = /*data*/ ctx[0].saudeAplicacao;
    			if (dirty & /*data*/ 1) cardaplicacao_changes.posicaoRanking = /*data*/ ctx[0].saudeRankingAplicacao;
    			cardaplicacao.$set(cardaplicacao_changes);
    			const cardaplicacaopercapita_changes = {};
    			if (dirty & /*data*/ 1) cardaplicacaopercapita_changes.model = /*data*/ ctx[0].saudeAplicacaoPerCapita;
    			if (dirty & /*data*/ 1) cardaplicacaopercapita_changes.posicaoRanking = /*data*/ ctx[0].saudeRankingAplicacaoPerCapita;
    			cardaplicacaopercapita.$set(cardaplicacaopercapita_changes);
    			const limiteconstitucionalsaude_changes = {};
    			if (dirty & /*limite*/ 2) limiteconstitucionalsaude_changes.limite = /*limite*/ ctx[1];
    			limiteconstitucionalsaude.$set(limiteconstitucionalsaude_changes);
    			const evolucaoanualaplicacao_changes = {};
    			if (dirty & /*data*/ 1) evolucaoanualaplicacao_changes.model = /*data*/ ctx[0].saudeEvolucaoAnual;
    			evolucaoanualaplicacao.$set(evolucaoanualaplicacao_changes);
    			const evolucaoanualreceitaxaplicacao_changes = {};
    			if (dirty & /*data*/ 1) evolucaoanualreceitaxaplicacao_changes.model = /*data*/ ctx[0].saudeEvolucaoAnual;
    			evolucaoanualreceitaxaplicacao.$set(evolucaoanualreceitaxaplicacao_changes);
    			const evolucaoanuallimiteconstitucional_changes = {};
    			if (dirty & /*data*/ 1) evolucaoanuallimiteconstitucional_changes.model = /*data*/ ctx[0].saudeEvolucaoAnual;
    			evolucaoanuallimiteconstitucional.$set(evolucaoanuallimiteconstitucional_changes);
    			const evolucaoanualaplicacaopercapita_changes = {};
    			if (dirty & /*data*/ 1) evolucaoanualaplicacaopercapita_changes.model = /*data*/ ctx[0].saudeEvolucaoAnualPerCapita;
    			evolucaoanualaplicacaopercapita.$set(evolucaoanualaplicacaopercapita_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prestacaocontamensal.$$.fragment, local);
    			transition_in(cardaplicacao.$$.fragment, local);
    			transition_in(cardaplicacaopercapita.$$.fragment, local);
    			transition_in(limiteconstitucionalsaude.$$.fragment, local);
    			transition_in(evolucaoanualaplicacao.$$.fragment, local);
    			transition_in(evolucaoanualreceitaxaplicacao.$$.fragment, local);
    			transition_in(evolucaoanuallimiteconstitucional.$$.fragment, local);
    			transition_in(evolucaoanualaplicacaopercapita.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prestacaocontamensal.$$.fragment, local);
    			transition_out(cardaplicacao.$$.fragment, local);
    			transition_out(cardaplicacaopercapita.$$.fragment, local);
    			transition_out(limiteconstitucionalsaude.$$.fragment, local);
    			transition_out(evolucaoanualaplicacao.$$.fragment, local);
    			transition_out(evolucaoanualreceitaxaplicacao.$$.fragment, local);
    			transition_out(evolucaoanuallimiteconstitucional.$$.fragment, local);
    			transition_out(evolucaoanualaplicacaopercapita.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_component(prestacaocontamensal);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div8);
    			destroy_component(cardaplicacao);
    			destroy_component(cardaplicacaopercapita);
    			destroy_component(limiteconstitucionalsaude);
    			destroy_component(evolucaoanualaplicacao);
    			destroy_component(evolucaoanualreceitaxaplicacao);
    			destroy_component(evolucaoanuallimiteconstitucional);
    			destroy_component(evolucaoanualaplicacaopercapita);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1t($$self, $$props, $$invalidate) {
    	let $params;
    	validate_store(params, "params");
    	component_subscribe($$self, params, $$value => $$invalidate(3, $params = $$value));
    	let ano;
    	let data = {};
    	let limite;

    	function refresh(params) {
    		ano = parseInt(params.ano);
    		const ug = params.ug;
    		const municipio = ug === "consolidado" ? params.municipio : ug;
    		$$invalidate(0, data = {});
    		api.post(api.getApiUrl("ControleSocial"), saudeEvolucaoAnual(ano, municipio).concat(saudeEvolucaoAnualPerCapita(ano, municipio)).concat(saudeRankingAplicacao(ano, municipio)).concat(saudeRankingAplicacaoPerCapita(ano, municipio)).concat(prestacaoContaPCB(ano, municipio)));
    	}

    	function onResult({ detail: json }) {
    		if (!data[json.id]) {
    			switch (json.id) {
    				case "saudeEvolucaoAnual":
    					$$invalidate(
    						0,
    						data["saudeAplicacao"] = {
    							id: "saudeAplicacao",
    							value: json.value.find(o => o.ano === ano)
    						},
    						data
    					);
    					$$invalidate(0, data[json.id] = json, data);
    					break;
    				case "saudeEvolucaoAnualPerCapita":
    					$$invalidate(
    						0,
    						data["saudeAplicacaoPerCapita"] = {
    							id: "saudeAplicacaoPerCapita",
    							value: json.value.find(o => o.ano === ano)
    						},
    						data
    					);
    					$$invalidate(0, data[json.id] = json, data);
    					break;
    				default:
    					$$invalidate(0, data[json.id] = json, data);
    					break;
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Saude> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Saude", $$slots, []);

    	$$self.$capture_state = () => ({
    		params,
    		api,
    		EvolucaoAnualAplicacao: EvolucaoAnualAplicacao$1,
    		EvolucaoAnualAplicacaoPerCapita: EvolucaoAnualAplicacaoPerCapita$1,
    		EvolucaoAnualLimiteConstitucional: EvolucaoAnualLimiteConstitucional$1,
    		EvolucaoAnualReceitaXAplicacao: EvolucaoAnualReceitaXAplicacao$1,
    		CardAplicacao: CardAplicacao$1,
    		CardAplicacaoPerCapita: CardAplicacaoPerCapita$1,
    		LimiteConstitucionalSaude,
    		PrestacaoContaMensal,
    		prestacaoContaApi,
    		saudeApi,
    		ano,
    		data,
    		limite,
    		refresh,
    		onResult,
    		$params
    	});

    	$$self.$inject_state = $$props => {
    		if ("ano" in $$props) ano = $$props.ano;
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("limite" in $$props) $$invalidate(1, limite = $$props.limite);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$params*/ 8) {
    			 api && refresh($params);
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 if (data.saudeAplicacao) {
    				$$invalidate(1, limite = data.saudeAplicacao.value.limiteConstitucional);
    			}
    		}
    	};

    	return [data, limite];
    }

    class Saude$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1t, create_fragment$1u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Saude",
    			options,
    			id: create_fragment$1u.name
    		});
    	}
    }

    /* src\pages\municipio\[ano]\[municipio]\[ug]\visao-geral\index.svelte generated by Svelte v3.22.3 */

    function create_fragment$1v(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1u($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Visao_geral> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Visao_geral", $$slots, []);
    	return [];
    }

    class Visao_geral extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1u, create_fragment$1v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Visao_geral",
    			options,
    			id: create_fragment$1v.name
    		});
    	}
    }

    var menu$1 = [
    	// {
    	//   label: "Visão geral",
    	//   title: "Visão geral do município",
    	//   path: "visao-geral"
    	// },
    	// {
    	//   label: "Obrigações junto ao TCE-ES",
    	//   title: "Obrigações junto ao TCE-ES",
    	//   path: "obrigacoes"
    	// },
    	{
    		label: "Despesas",
    		title: "Despesas do município",
    		path: "despesas"
    	},
    	{
    		label: "Receitas",
    		title: "Receitas do município",
    		path: "receitas"
    	},
    	// {
    	//   label: '<span class="rotate-x">&#8629;</span> Destino do dinheiro',
    	//   title: "Despesas do município",
    	//   path: "despesas/destino-do-dinheiro"
    	// },
    	// {
    	//   label: "Leis do orçamento",
    	//   title: "Leis do Orçamento",
    	//   path: "leis-do-orcamento"
    	// },
    	// {
    	//   label: "Saúde",
    	//   title: "Aplicação em saúde",
    	//   path: "saude"
    	// },
    	// {
    	//   label: "Educação",
    	//   title: "Aplicação em educação",
    	//   path: "educacao"
    	// },
    	// {
    	//   label: '<span class="rotate-x">&#8629;</span> FUNDEB',
    	//   title: "Educação - FUNDEB",
    	//   path: "educacao/fundeb"
    	// },
    	// {
    	//   label: "Pessoal",
    	//   title: "Despesas com pessoal",
    	//   path: "pessoal"
    	// },
    	// {
    	//   label: "Previdência",
    	//   title: "Previdência",
    	//   path: "previdencia",
    	//   children: [
    	//     {
    	//       label: "Consolidado",
    	//       title: "Consolidado do município",
    	//       path: "previdencia"
    	//     },
    	//     {
    	//       label: "Receitas",
    	//       title: "Receitas do município",
    	//       path: "previdencia/receita"
    	//     },
    	//     {
    	//       label: "Despesas",
    	//       title: "Despesas do município",
    	//       path: "previdencia/despesa"
    	//     }
    	//   ]
    	// },
    	// {
    	//   label: "IEGM",
    	//   title: "Índice de Efetividade da Gestão Municipal",
    	//   path: "iegm"
    	// }
    ];

    /* src\pages\municipio\[ano]\[municipio]\[ug]\_layout.svelte generated by Svelte v3.22.3 */
    const file$1o = "src\\pages\\municipio\\[ano]\\[municipio]\\[ug]\\_layout.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (42:12) <Link                href={`/municipio/${ano}/${item.value}/${ug}/${segments}`}                title={item.label}>
    function create_default_slot_6$1(ctx) {
    	let html_tag;
    	let raw_value = /*item*/ ctx[10].label + "";

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(raw_value, null);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(target, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items*/ 512 && raw_value !== (raw_value = /*item*/ ctx[10].label + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(42:12) <Link                href={`/municipio/${ano}/${item.value}/${ug}/${segments}`}                title={item.label}>",
    		ctx
    	});

    	return block;
    }

    // (40:8) {#each items as item}
    function create_each_block_3(ctx) {
    	let li;
    	let t;
    	let current;

    	const link = new Link({
    			props: {
    				href: `/municipio/${/*ano*/ ctx[0]}/${/*item*/ ctx[10].value}/${/*ug*/ ctx[3]}/${/*segments*/ ctx[2]}`,
    				title: /*item*/ ctx[10].label,
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			t = space();
    			toggle_class(li, "active", /*item*/ ctx[10].selected);
    			add_location(li, file$1o, 40, 10, 1344);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*ano, items, ug, segments*/ 525) link_changes.href = `/municipio/${/*ano*/ ctx[0]}/${/*item*/ ctx[10].value}/${/*ug*/ ctx[3]}/${/*segments*/ ctx[2]}`;
    			if (dirty & /*items*/ 512) link_changes.title = /*item*/ ctx[10].label;

    			if (dirty & /*$$scope, items*/ 768) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);

    			if (dirty & /*items*/ 512) {
    				toggle_class(li, "active", /*item*/ ctx[10].selected);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(40:8) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    // (39:6) <DropdownLista items={settings.municipios.get(municipio)} let:items>
    function create_default_slot_5$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_3 = /*items*/ ctx[9];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items, ano, ug, segments*/ 525) {
    				each_value_3 = /*items*/ ctx[9];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(39:6) <DropdownLista items={settings.municipios.get(municipio)} let:items>",
    		ctx
    	});

    	return block;
    }

    // (56:14) <Link                  href={`/municipio/${ano}/${municipio}/${ug}/${item.path}`}                  title={item.title}>
    function create_default_slot_4$4(ctx) {
    	let html_tag;
    	let raw_value = /*item*/ ctx[10].label + "";

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(raw_value, null);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(target, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items*/ 512 && raw_value !== (raw_value = /*item*/ ctx[10].label + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(56:14) <Link                  href={`/municipio/${ano}/${municipio}/${ug}/${item.path}`}                  title={item.title}>",
    		ctx
    	});

    	return block;
    }

    // (54:10) {#each items as item}
    function create_each_block_2$1(ctx) {
    	let li;
    	let current;

    	const link = new Link({
    			props: {
    				href: `/municipio/${/*ano*/ ctx[0]}/${/*municipio*/ ctx[1]}/${/*ug*/ ctx[3]}/${/*item*/ ctx[10].path}`,
    				title: /*item*/ ctx[10].title,
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			toggle_class(li, "active", /*item*/ ctx[10].selected);
    			add_location(li, file$1o, 54, 12, 1791);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*ano, municipio, ug, items*/ 523) link_changes.href = `/municipio/${/*ano*/ ctx[0]}/${/*municipio*/ ctx[1]}/${/*ug*/ ctx[3]}/${/*item*/ ctx[10].path}`;
    			if (dirty & /*items*/ 512) link_changes.title = /*item*/ ctx[10].title;

    			if (dirty & /*$$scope, items*/ 768) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);

    			if (dirty & /*items*/ 512) {
    				toggle_class(li, "active", /*item*/ ctx[10].selected);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(54:10) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    // (53:8) <DropdownLista items={menu} let:items>
    function create_default_slot_3$6(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*items*/ ctx[9];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items, ano, municipio, ug*/ 523) {
    				each_value_2 = /*items*/ ctx[9];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(53:8) <DropdownLista items={menu} let:items>",
    		ctx
    	});

    	return block;
    }

    // (51:4) {#each $menuStore as menu}
    function create_each_block_1$3(ctx) {
    	let span;
    	let current;

    	const dropdownlista = new Lista({
    			props: {
    				items: /*menu*/ ctx[13],
    				$$slots: {
    					default: [
    						create_default_slot_3$6,
    						({ items }) => ({ 9: items }),
    						({ items }) => items ? 512 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(dropdownlista.$$.fragment);
    			attr_dev(span, "class", "w-1/2 mx-1");
    			add_location(span, file$1o, 51, 6, 1671);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(dropdownlista, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownlista_changes = {};
    			if (dirty & /*$menuStore*/ 16) dropdownlista_changes.items = /*menu*/ ctx[13];

    			if (dirty & /*$$scope, items, ano, municipio, ug*/ 779) {
    				dropdownlista_changes.$$scope = { dirty, ctx };
    			}

    			dropdownlista.$set(dropdownlista_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownlista.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownlista.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(dropdownlista);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(51:4) {#each $menuStore as menu}",
    		ctx
    	});

    	return block;
    }

    // (70:12) <Link                href={`/municipio/${item.value}/${municipio}/${ug}/${segments}`}                title={item.label}>
    function create_default_slot_2$e(ctx) {
    	let html_tag;
    	let raw_value = /*item*/ ctx[10].label + "";

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(raw_value, null);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(target, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items*/ 512 && raw_value !== (raw_value = /*item*/ ctx[10].label + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$e.name,
    		type: "slot",
    		source: "(70:12) <Link                href={`/municipio/${item.value}/${municipio}/${ug}/${segments}`}                title={item.label}>",
    		ctx
    	});

    	return block;
    }

    // (68:8) {#each items as item}
    function create_each_block$f(ctx) {
    	let li;
    	let t;
    	let current;

    	const link = new Link({
    			props: {
    				href: `/municipio/${/*item*/ ctx[10].value}/${/*municipio*/ ctx[1]}/${/*ug*/ ctx[3]}/${/*segments*/ ctx[2]}`,
    				title: /*item*/ ctx[10].label,
    				$$slots: { default: [create_default_slot_2$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			t = space();
    			toggle_class(li, "active", /*item*/ ctx[10].selected);
    			add_location(li, file$1o, 68, 10, 2257);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*items, municipio, ug, segments*/ 526) link_changes.href = `/municipio/${/*item*/ ctx[10].value}/${/*municipio*/ ctx[1]}/${/*ug*/ ctx[3]}/${/*segments*/ ctx[2]}`;
    			if (dirty & /*items*/ 512) link_changes.title = /*item*/ ctx[10].label;

    			if (dirty & /*$$scope, items*/ 768) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);

    			if (dirty & /*items*/ 512) {
    				toggle_class(li, "active", /*item*/ ctx[10].selected);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(68:8) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    // (67:6) <DropdownLista items={settings.anos.get(ano, segments)} let:items>
    function create_default_slot_1$f(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*items*/ ctx[9];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items, municipio, ug, segments*/ 526) {
    				each_value = /*items*/ ctx[9];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(67:6) <DropdownLista items={settings.anos.get(ano, segments)} let:items>",
    		ctx
    	});

    	return block;
    }

    // (37:2) <Breadcrumb>
    function create_default_slot$R(ctx) {
    	let span0;
    	let t0;
    	let t1;
    	let span1;
    	let current;

    	const dropdownlista0 = new Lista({
    			props: {
    				items: settings.municipios.get(/*municipio*/ ctx[1]),
    				$$slots: {
    					default: [
    						create_default_slot_5$2,
    						({ items }) => ({ 9: items }),
    						({ items }) => items ? 512 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value_1 = /*$menuStore*/ ctx[4];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const dropdownlista1 = new Lista({
    			props: {
    				items: settings.anos.get(/*ano*/ ctx[0], /*segments*/ ctx[2]),
    				$$slots: {
    					default: [
    						create_default_slot_1$f,
    						({ items }) => ({ 9: items }),
    						({ items }) => items ? 512 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			create_component(dropdownlista0.$$.fragment);
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			span1 = element("span");
    			create_component(dropdownlista1.$$.fragment);
    			attr_dev(span0, "class", "w-1/2 mr-1");
    			add_location(span0, file$1o, 37, 4, 1200);
    			attr_dev(span1, "class", "w-1/2 mx-1");
    			add_location(span1, file$1o, 65, 4, 2115);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			mount_component(dropdownlista0, span0, null);
    			insert_dev(target, t0, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			insert_dev(target, span1, anchor);
    			mount_component(dropdownlista1, span1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownlista0_changes = {};
    			if (dirty & /*municipio*/ 2) dropdownlista0_changes.items = settings.municipios.get(/*municipio*/ ctx[1]);

    			if (dirty & /*$$scope, items, ano, ug, segments*/ 781) {
    				dropdownlista0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownlista0.$set(dropdownlista0_changes);

    			if (dirty & /*$menuStore, items, ano, municipio, ug*/ 539) {
    				each_value_1 = /*$menuStore*/ ctx[4];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t1.parentNode, t1);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const dropdownlista1_changes = {};
    			if (dirty & /*ano, segments*/ 5) dropdownlista1_changes.items = settings.anos.get(/*ano*/ ctx[0], /*segments*/ ctx[2]);

    			if (dirty & /*$$scope, items, municipio, ug, segments*/ 782) {
    				dropdownlista1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownlista1.$set(dropdownlista1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownlista0.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(dropdownlista1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownlista0.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(dropdownlista1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			destroy_component(dropdownlista0);
    			if (detaching) detach_dev(t0);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span1);
    			destroy_component(dropdownlista1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$R.name,
    		type: "slot",
    		source: "(37:2) <Breadcrumb>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1w(ctx) {
    	let div0;
    	let t;
    	let div1;
    	let current;

    	const breadcrumb = new Breadcrumb({
    			props: {
    				$$slots: { default: [create_default_slot$R] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const default_slot_template = /*$$slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(breadcrumb.$$.fragment);
    			t = space();
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "breadcrumb fixed w-full h-12 pt-2 px-3 bg-white z-40");
    			add_location(div0, file$1o, 35, 0, 1112);
    			attr_dev(div1, "class", "w-full px-2 pt-12 pb-2");
    			add_location(div1, file$1o, 84, 0, 2682);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(breadcrumb, div0, null);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const breadcrumb_changes = {};

    			if (dirty & /*$$scope, ano, segments, municipio, ug, $menuStore*/ 287) {
    				breadcrumb_changes.$$scope = { dirty, ctx };
    			}

    			breadcrumb.$set(breadcrumb_changes);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 256) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[8], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(breadcrumb.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(breadcrumb.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(breadcrumb);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1v($$self, $$props, $$invalidate) {
    	let $route;
    	let $menuStore;
    	validate_store(route, "route");
    	component_subscribe($$self, route, $$value => $$invalidate(5, $route = $$value));
    	validate_store(menus, "menuStore");
    	component_subscribe($$self, menus, $$value => $$invalidate(4, $menuStore = $$value));
    	let ano;
    	let municipio;
    	let segments;
    	let ug;

    	function refresh({ params, path }) {
    		const _segments = path.replace("/municipio/:ano/:municipio/:ug/", "").split("/");
    		$$invalidate(0, ano = parseInt(params.ano));
    		$$invalidate(1, municipio = params.municipio);

    		$$invalidate(2, segments = (_segments[_segments.length - 1].toLowerCase() === "index"
    		? _segments.slice(0, _segments.length - 1)
    		: _segments).join("/"));

    		$$invalidate(3, ug = params.ug);
    		menus.set(updateMenu(menu$1, _segments));
    		window.scrollTo(0, 0);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layout> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Layout", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		route,
    		settings,
    		Breadcrumb,
    		DropdownLista: Lista,
    		Link,
    		Gear,
    		menu: menu$1,
    		menuStore: menus,
    		updateMenu,
    		ano,
    		municipio,
    		segments,
    		ug,
    		refresh,
    		$route,
    		$menuStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("ano" in $$props) $$invalidate(0, ano = $$props.ano);
    		if ("municipio" in $$props) $$invalidate(1, municipio = $$props.municipio);
    		if ("segments" in $$props) $$invalidate(2, segments = $$props.segments);
    		if ("ug" in $$props) $$invalidate(3, ug = $$props.ug);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$route*/ 32) {
    			 refresh($route);
    		}
    	};

    	return [ano, municipio, segments, ug, $menuStore, $route, refresh, $$slots, $$scope];
    }

    class Layout$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1v, create_fragment$1w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Layout",
    			options,
    			id: create_fragment$1w.name
    		});
    	}
    }

    /* src\pages\_fallback.svelte generated by Svelte v3.22.3 */
    const file$1p = "src\\pages\\_fallback.svelte";

    function create_fragment$1x(ctx) {
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let t2;
    	let a;
    	let t3;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "404";
    			t1 = space();
    			div1 = element("div");
    			t2 = text("Page not found. \r\n  \r\n  ");
    			a = element("a");
    			t3 = text("Go back");
    			attr_dev(div0, "class", "huge svelte-1hsahkb");
    			add_location(div0, file$1p, 18, 2, 286);
    			attr_dev(a, "href", a_href_value = /*$url*/ ctx[0]("../"));
    			add_location(a, file$1p, 21, 2, 412);
    			attr_dev(div1, "class", "big");
    			add_location(div1, file$1p, 19, 2, 317);
    			attr_dev(div2, "class", "e404 svelte-1hsahkb");
    			add_location(div2, file$1p, 17, 0, 264);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div1, a);
    			append_dev(a, t3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$url*/ 1 && a_href_value !== (a_href_value = /*$url*/ ctx[0]("../"))) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1w($$self, $$props, $$invalidate) {
    	let $url;
    	validate_store(url, "url");
    	component_subscribe($$self, url, $$value => $$invalidate(0, $url = $$value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Fallback> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Fallback", $$slots, []);
    	$$self.$capture_state = () => ({ url, $url });
    	return [$url];
    }

    class Fallback extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1w, create_fragment$1x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Fallback",
    			options,
    			id: create_fragment$1x.name
    		});
    	}
    }

    const progress = writable(false);

    /* src\components\Header\Header.svelte generated by Svelte v3.22.3 */
    const file$1q = "src\\components\\Header\\Header.svelte";
    const get_right_slot_changes$1 = dirty => ({});
    const get_right_slot_context$1 = ctx => ({});
    const get_left_slot_changes = dirty => ({});
    const get_left_slot_context = ctx => ({});

    // (37:4) <Link href="/">
    function create_default_slot$S(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "/assets/images/logo-cidades.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo CidadES");
    			attr_dev(img, "class", "fill-current");
    			attr_dev(img, "width", "121");
    			add_location(img, file$1q, 37, 6, 998);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$S.name,
    		type: "slot",
    		source: "(37:4) <Link href=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1y(ctx) {
    	let nav;
    	let div0;
    	let button;
    	let svg;
    	let title;
    	let t0;
    	let path;
    	let t1;
    	let div1;
    	let t2;
    	let div3;
    	let div2;
    	let t3;
    	let current;
    	let dispose;

    	const link = new Link({
    			props: {
    				href: "/",
    				$$slots: { default: [create_default_slot$S] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const left_slot_template = /*$$slots*/ ctx[1].left;
    	const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[2], get_left_slot_context);
    	const right_slot_template = /*$$slots*/ ctx[1].right;
    	const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[2], get_right_slot_context$1);

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			div0 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			title = svg_element("title");
    			t0 = text("Menu");
    			path = svg_element("path");
    			t1 = space();
    			div1 = element("div");
    			create_component(link.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			div2 = element("div");
    			if (left_slot) left_slot.c();
    			t3 = space();
    			if (right_slot) right_slot.c();
    			add_location(title, file$1q, 30, 8, 813);
    			attr_dev(path, "d", "M0 3h20v2H0V3zm0 6h20v2H0V9zm0 6h20v2H0v-2z");
    			add_location(path, file$1q, 31, 8, 842);
    			attr_dev(svg, "class", "fill-current h-3 w-3");
    			attr_dev(svg, "viewBox", "0 0 20 20");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$1q, 26, 6, 687);
    			attr_dev(button, "class", "items-center px-3 py-2 border rounded border-teal-400\r\n      hover:border-white");
    			add_location(button, file$1q, 23, 4, 576);
    			attr_dev(div0, "class", "sm:block mt-1");
    			add_location(div0, file$1q, 22, 2, 518);
    			attr_dev(div1, "class", "m-auto md:mx-2");
    			add_location(div1, file$1q, 35, 2, 941);
    			attr_dev(div2, "class", "text-sm lg:flex-grow");
    			add_location(div2, file$1q, 45, 4, 1237);
    			attr_dev(div3, "class", "flex-grow lg:flex lg:items-center lg:w-auto sm:block hidden");
    			add_location(div3, file$1q, 44, 2, 1158);
    			attr_dev(nav, "class", "flex items-center flex-wrap px-3 z-30 Header h-16 svelte-1lf1pgg");
    			add_location(nav, file$1q, 21, 0, 451);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, div0);
    			append_dev(div0, button);
    			append_dev(button, svg);
    			append_dev(svg, title);
    			append_dev(title, t0);
    			append_dev(svg, path);
    			append_dev(nav, t1);
    			append_dev(nav, div1);
    			mount_component(link, div1, null);
    			append_dev(nav, t2);
    			append_dev(nav, div3);
    			append_dev(div3, div2);

    			if (left_slot) {
    				left_slot.m(div2, null);
    			}

    			append_dev(div2, t3);

    			if (right_slot) {
    				right_slot.m(div2, null);
    			}

    			current = true;
    			if (remount) dispose();
    			dispose = listen_dev(div0, "click", /*onClickHeader*/ ctx[0], false, false, false);
    		},
    		p: function update(ctx, [dirty]) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);

    			if (left_slot) {
    				if (left_slot.p && dirty & /*$$scope*/ 4) {
    					left_slot.p(get_slot_context(left_slot_template, ctx, /*$$scope*/ ctx[2], get_left_slot_context), get_slot_changes(left_slot_template, /*$$scope*/ ctx[2], dirty, get_left_slot_changes));
    				}
    			}

    			if (right_slot) {
    				if (right_slot.p && dirty & /*$$scope*/ 4) {
    					right_slot.p(get_slot_context(right_slot_template, ctx, /*$$scope*/ ctx[2], get_right_slot_context$1), get_slot_changes(right_slot_template, /*$$scope*/ ctx[2], dirty, get_right_slot_changes$1));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			transition_in(left_slot, local);
    			transition_in(right_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			transition_out(left_slot, local);
    			transition_out(right_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			destroy_component(link);
    			if (left_slot) left_slot.d(detaching);
    			if (right_slot) right_slot.d(detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1x($$self, $$props, $$invalidate) {
    	function onClickHeader(e) {
    		e.stopPropagation();
    		closeAllDropdowns();
    		toggleDrawer();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Header", $$slots, ['left','right']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Link,
    		toggleDrawer,
    		closeAllDropdowns,
    		onClickHeader
    	});

    	return [onClickHeader, $$slots, $$scope];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1x, create_fragment$1y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$1y.name
    		});
    	}
    }

    class UserNotification {
      constructor(title, body, data, dir = "ltr") {
        this.title = title;
        this.settings = {
          body,
          dir,
          data
        };
      }
      emit() {
        this.notificationEmit = new Notification(this.title, this.settings);
      }
      close() {
        this.notificationEmit.close();
      }
      onClick(callbackFunction) {
        this.notificationEmit.addEventListener("click", e => {
          callbackFunction(e);
        });
      }
    }

    async function notify(title, body, data) {
      if (Notification === undefined) {
        console.log("Este navegador não suporta notificações");
        return;
      }

      let permission = Notification.permission;

      if (permission !== "granted") {
        permission = await Notification.requestPermission();
      }

      if (permission) {
        emit(title, body, data);
      }
    }

    function emit(title, body, data) {
      const notification = new UserNotification(title, body, data);

      notification.emit();

      if (data) {
        notification.onClick(e => window.open(e.target.data));
      }
    }

    /* src\pages\_layout.svelte generated by Svelte v3.22.3 */
    const file$1r = "src\\pages\\_layout.svelte";

    // (94:6) {:else}
    function create_else_block$o(ctx) {
    	let current;

    	const link = new Link({
    			props: {
    				href: `/admin`,
    				class: "header-link",
    				$$slots: { default: [create_default_slot_4$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$o.name,
    		type: "else",
    		source: "(94:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (92:6) {#if isAuthenticated}
    function create_if_block$v(ctx) {
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Sair";
    			attr_dev(button, "class", "header-link");
    			add_location(button, file$1r, 92, 8, 2590);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			if (remount) dispose();
    			dispose = listen_dev(button, "click", /*signOut*/ ctx[4], false, false, false);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(92:6) {#if isAuthenticated}",
    		ctx
    	});

    	return block;
    }

    // (95:8) <Link href={`/admin`} class="header-link">
    function create_default_slot_4$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Admin");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$5.name,
    		type: "slot",
    		source: "(95:8) <Link href={`/admin`} class=\\\"header-link\\\">",
    		ctx
    	});

    	return block;
    }

    // (70:2) <ul class="header list-none" slot="left">
    function create_left_slot(ctx) {
    	let ul;
    	let li;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$v, create_else_block$o];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isAuthenticated*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li = element("li");
    			if_block.c();
    			attr_dev(li, "class", "float-right");
    			add_location(li, file$1r, 90, 4, 2527);
    			attr_dev(ul, "class", "header list-none svelte-1r7md2o");
    			attr_dev(ul, "slot", "left");
    			add_location(ul, file$1r, 69, 2, 1526);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li);
    			if_blocks[current_block_type_index].m(li, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(li, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_left_slot.name,
    		type: "slot",
    		source: "(70:2) <ul class=\\\"header list-none\\\" slot=\\\"left\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:6) <Link href={`/municipio/${ano}/${municipio}/${ug}/receitas`}>
    function create_default_slot_2$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Receitas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$f.name,
    		type: "slot",
    		source: "(110:6) <Link href={`/municipio/${ano}/${municipio}/${ug}/receitas`}>",
    		ctx
    	});

    	return block;
    }

    // (115:6) <Link href={`/municipio/${ano}/${municipio}/${ug}/despesas`}>
    function create_default_slot_1$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Despesas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(115:6) <Link href={`/municipio/${ano}/${municipio}/${ug}/despesas`}>",
    		ctx
    	});

    	return block;
    }

    // (100:0) <Drawer>
    function create_default_slot$T(ctx) {
    	let ul;
    	let li0;
    	let t;
    	let li1;
    	let current;

    	const link0 = new Link({
    			props: {
    				href: `/municipio/${/*ano*/ ctx[1]}/${/*municipio*/ ctx[2]}/${/*ug*/ ctx[3]}/receitas`,
    				$$slots: { default: [create_default_slot_2$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const link1 = new Link({
    			props: {
    				href: `/municipio/${/*ano*/ ctx[1]}/${/*municipio*/ ctx[2]}/${/*ug*/ ctx[3]}/despesas`,
    				$$slots: { default: [create_default_slot_1$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			create_component(link0.$$.fragment);
    			t = space();
    			li1 = element("li");
    			create_component(link1.$$.fragment);
    			attr_dev(li0, "class", "navbar-link");
    			add_location(li0, file$1r, 108, 4, 3024);
    			attr_dev(li1, "class", "navbar-link");
    			add_location(li1, file$1r, 113, 4, 3167);
    			attr_dev(ul, "class", "drawer list-none text-white svelte-1r7md2o");
    			add_location(ul, file$1r, 100, 2, 2787);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			mount_component(link0, li0, null);
    			append_dev(ul, t);
    			append_dev(ul, li1);
    			mount_component(link1, li1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_component(link0);
    			destroy_component(link1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$T.name,
    		type: "slot",
    		source: "(100:0) <Drawer>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1z(ctx) {
    	let t0;
    	let t1;
    	let main;
    	let current;

    	const header = new Header({
    			props: {
    				$$slots: { left: [create_left_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const drawer = new Drawer({
    			props: {
    				$$slots: { default: [create_default_slot$T] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const default_slot_template = /*$$slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			create_component(header.$$.fragment);
    			t0 = space();
    			create_component(drawer.$$.fragment);
    			t1 = space();
    			main = element("main");
    			if (default_slot) default_slot.c();
    			attr_dev(main, "class", "Main svelte-1r7md2o");
    			add_location(main, file$1r, 128, 0, 3596);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(header, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(drawer, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, main, anchor);

    			if (default_slot) {
    				default_slot.m(main, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const header_changes = {};

    			if (dirty & /*$$scope, isAuthenticated*/ 513) {
    				header_changes.$$scope = { dirty, ctx };
    			}

    			header.$set(header_changes);
    			const drawer_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				drawer_changes.$$scope = { dirty, ctx };
    			}

    			drawer.$set(drawer_changes);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 512) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[9], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(drawer.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(drawer.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(header, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(drawer, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(main);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1y($$self, $$props, $$invalidate) {
    	let $route;
    	let $token;
    	validate_store(route, "route");
    	component_subscribe($$self, route, $$value => $$invalidate(5, $route = $$value));
    	validate_store(token, "token");
    	component_subscribe($$self, token, $$value => $$invalidate(6, $token = $$value));
    	let isAuthenticated;
    	let ano = 2020;
    	let municipio = "001";
    	let ug = "consolidado";

    	function refresh(route) {
    		progress.set(false);
    	}

    	onMount(async () => {
    		
    	}); // if (process.env.NODE_ENV !== "development") {
    	//   notify(
    	//     "Notificação",
    	//     "Houve uma atualização nos dados de 2019 do município 001",

    	//     "https://cidades.tce.es.gov.br"
    	//   );
    	// }
    	function signOut() {
    		token.signOut();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layout> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Layout", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		route,
    		progressStore: progress,
    		Drawer,
    		Header,
    		Link,
    		token,
    		notify,
    		isAuthenticated,
    		ano,
    		municipio,
    		ug,
    		refresh,
    		signOut,
    		$route,
    		$token
    	});

    	$$self.$inject_state = $$props => {
    		if ("isAuthenticated" in $$props) $$invalidate(0, isAuthenticated = $$props.isAuthenticated);
    		if ("ano" in $$props) $$invalidate(1, ano = $$props.ano);
    		if ("municipio" in $$props) $$invalidate(2, municipio = $$props.municipio);
    		if ("ug" in $$props) $$invalidate(3, ug = $$props.ug);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$route*/ 32) {
    			 refresh();
    		}

    		if ($$self.$$.dirty & /*$token*/ 64) {
    			 ($$invalidate(0, isAuthenticated = token.isAuthenticated()));
    		}
    	};

    	return [
    		isAuthenticated,
    		ano,
    		municipio,
    		ug,
    		signOut,
    		$route,
    		$token,
    		refresh,
    		$$slots,
    		$$scope
    	];
    }

    class Layout$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1y, create_fragment$1z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Layout",
    			options,
    			id: create_fragment$1z.name
    		});
    	}
    }

    //tree
    const _tree = {
      "name": "root",
      "filepath": "/",
      "root": true,
      "ownMeta": {},
      "children": [
        {
          "isFile": false,
          "isDir": true,
          "file": "admin",
          "filepath": "/admin",
          "name": "admin",
          "ext": "",
          "badExt": false,
          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/admin",
          "children": [
            {
              "isFile": true,
              "isDir": false,
              "file": "index.svelte",
              "filepath": "/admin/index.svelte",
              "name": "index",
              "ext": "svelte",
              "badExt": false,
              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/admin/index.svelte",
              "isLayout": false,
              "isReset": false,
              "isIndex": true,
              "isFallback": false,
              "isPage": true,
              "ownMeta": {
                "roles": "Admin"
              },
              "meta": {
                "roles": "Admin",
                "preload": false,
                "precache-order": false,
                "precache-proximity": true,
                "recursive": true
              },
              "path": "/admin/index",
              "id": "_admin_index",
              "component": () => Admin
            },
            {
              "isFile": true,
              "isDir": false,
              "file": "_layout.svelte",
              "filepath": "/admin/_layout.svelte",
              "name": "_layout",
              "ext": "svelte",
              "badExt": false,
              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/admin/_layout.svelte",
              "isLayout": true,
              "isReset": false,
              "isIndex": false,
              "isFallback": false,
              "isPage": false,
              "ownMeta": {},
              "meta": {
                "preload": false,
                "precache-order": false,
                "precache-proximity": true,
                "recursive": true
              },
              "path": "/admin",
              "id": "_admin__layout",
              "component": () => Layout
            }
          ],
          "isLayout": false,
          "isReset": false,
          "isIndex": false,
          "isFallback": false,
          "isPage": false,
          "ownMeta": {},
          "meta": {
            "preload": false,
            "precache-order": false,
            "precache-proximity": true,
            "recursive": true
          },
          "path": "/admin"
        },
        {
          "isFile": true,
          "isDir": false,
          "file": "index.svelte",
          "filepath": "/index.svelte",
          "name": "index",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/index.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": true,
          "isFallback": false,
          "isPage": true,
          "ownMeta": {},
          "meta": {
            "preload": false,
            "precache-order": false,
            "precache-proximity": true,
            "recursive": true
          },
          "path": "/index",
          "id": "_index",
          "component": () => Pages
        },
        {
          "isFile": false,
          "isDir": true,
          "file": "municipio",
          "filepath": "/municipio",
          "name": "municipio",
          "ext": "",
          "badExt": false,
          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio",
          "children": [
            {
              "isFile": false,
              "isDir": true,
              "file": "[ano]",
              "filepath": "/municipio/[ano]",
              "name": "[ano]",
              "ext": "",
              "badExt": false,
              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]",
              "children": [
                {
                  "isFile": false,
                  "isDir": true,
                  "file": "indicadores",
                  "filepath": "/municipio/[ano]/indicadores",
                  "name": "indicadores",
                  "ext": "",
                  "badExt": false,
                  "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores",
                  "children": [
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "composicao-receita-arrecadada",
                      "filepath": "/municipio/[ano]/indicadores/composicao-receita-arrecadada",
                      "name": "composicao-receita-arrecadada",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/composicao-receita-arrecadada",
                      "children": [
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "index.svelte",
                          "filepath": "/municipio/[ano]/indicadores/composicao-receita-arrecadada/index.svelte",
                          "name": "index",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/composicao-receita-arrecadada/index.svelte",
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": true,
                          "isFallback": false,
                          "isPage": true,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/indicadores/composicao-receita-arrecadada/index",
                          "id": "_municipio__ano_indicadores_composicaoReceitaArrecadada_index",
                          "component": () => Composicao_receita_arrecadada
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores/composicao-receita-arrecadada"
                    },
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "despesas",
                      "filepath": "/municipio/[ano]/indicadores/despesas",
                      "name": "despesas",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/despesas",
                      "children": [
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "index.svelte",
                          "filepath": "/municipio/[ano]/indicadores/despesas/index.svelte",
                          "name": "index",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/despesas/index.svelte",
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": true,
                          "isFallback": false,
                          "isPage": true,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/indicadores/despesas/index",
                          "id": "_municipio__ano_indicadores_despesas_index",
                          "component": () => Despesas
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores/despesas"
                    },
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "despesas-em-destaque",
                      "filepath": "/municipio/[ano]/indicadores/despesas-em-destaque",
                      "name": "despesas-em-destaque",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/despesas-em-destaque",
                      "children": [
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "index.svelte",
                          "filepath": "/municipio/[ano]/indicadores/despesas-em-destaque/index.svelte",
                          "name": "index",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/despesas-em-destaque/index.svelte",
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": true,
                          "isFallback": false,
                          "isPage": true,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/indicadores/despesas-em-destaque/index",
                          "id": "_municipio__ano_indicadores_despesasEmDestaque_index",
                          "component": () => Despesas_em_destaque
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores/despesas-em-destaque"
                    },
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "educacao",
                      "filepath": "/municipio/[ano]/indicadores/educacao",
                      "name": "educacao",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/educacao",
                      "children": [
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "index.svelte",
                          "filepath": "/municipio/[ano]/indicadores/educacao/index.svelte",
                          "name": "index",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/educacao/index.svelte",
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": true,
                          "isFallback": false,
                          "isPage": true,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/indicadores/educacao/index",
                          "id": "_municipio__ano_indicadores_educacao_index",
                          "component": () => Educacao
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores/educacao"
                    },
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "educacao-fundeb",
                      "filepath": "/municipio/[ano]/indicadores/educacao-fundeb",
                      "name": "educacao-fundeb",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/educacao-fundeb",
                      "children": [
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "index.svelte",
                          "filepath": "/municipio/[ano]/indicadores/educacao-fundeb/index.svelte",
                          "name": "index",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/educacao-fundeb/index.svelte",
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": true,
                          "isFallback": false,
                          "isPage": true,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/indicadores/educacao-fundeb/index",
                          "id": "_municipio__ano_indicadores_educacaoFundeb_index",
                          "component": () => Educacao_fundeb
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores/educacao-fundeb"
                    },
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "iegm",
                      "filepath": "/municipio/[ano]/indicadores/iegm",
                      "name": "iegm",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/iegm",
                      "children": [
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "index.svelte",
                          "filepath": "/municipio/[ano]/indicadores/iegm/index.svelte",
                          "name": "index",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/iegm/index.svelte",
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": true,
                          "isFallback": false,
                          "isPage": true,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/indicadores/iegm/index",
                          "id": "_municipio__ano_indicadores_iegm_index",
                          "component": () => Iegm
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores/iegm"
                    },
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "pessoal",
                      "filepath": "/municipio/[ano]/indicadores/pessoal",
                      "name": "pessoal",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/pessoal",
                      "children": [
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "index.svelte",
                          "filepath": "/municipio/[ano]/indicadores/pessoal/index.svelte",
                          "name": "index",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/pessoal/index.svelte",
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": true,
                          "isFallback": false,
                          "isPage": true,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/indicadores/pessoal/index",
                          "id": "_municipio__ano_indicadores_pessoal_index",
                          "component": () => Pessoal
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores/pessoal"
                    },
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "receitas",
                      "filepath": "/municipio/[ano]/indicadores/receitas",
                      "name": "receitas",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/receitas",
                      "children": [
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "index.svelte",
                          "filepath": "/municipio/[ano]/indicadores/receitas/index.svelte",
                          "name": "index",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/receitas/index.svelte",
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": true,
                          "isFallback": false,
                          "isPage": true,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/indicadores/receitas/index",
                          "id": "_municipio__ano_indicadores_receitas_index",
                          "component": () => Receitas
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores/receitas"
                    },
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "receitas-em-destaque",
                      "filepath": "/municipio/[ano]/indicadores/receitas-em-destaque",
                      "name": "receitas-em-destaque",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/receitas-em-destaque",
                      "children": [
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "index.svelte",
                          "filepath": "/municipio/[ano]/indicadores/receitas-em-destaque/index.svelte",
                          "name": "index",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/receitas-em-destaque/index.svelte",
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": true,
                          "isFallback": false,
                          "isPage": true,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/indicadores/receitas-em-destaque/index",
                          "id": "_municipio__ano_indicadores_receitasEmDestaque_index",
                          "component": () => Receitas_em_destaque
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores/receitas-em-destaque"
                    },
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "saude",
                      "filepath": "/municipio/[ano]/indicadores/saude",
                      "name": "saude",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/saude",
                      "children": [
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "index.svelte",
                          "filepath": "/municipio/[ano]/indicadores/saude/index.svelte",
                          "name": "index",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/saude/index.svelte",
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": true,
                          "isFallback": false,
                          "isPage": true,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/indicadores/saude/index",
                          "id": "_municipio__ano_indicadores_saude_index",
                          "component": () => Saude
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores/saude"
                    },
                    {
                      "isFile": true,
                      "isDir": false,
                      "file": "_layout.svelte",
                      "filepath": "/municipio/[ano]/indicadores/_layout.svelte",
                      "name": "_layout",
                      "ext": "svelte",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/indicadores/_layout.svelte",
                      "isLayout": true,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/indicadores",
                      "id": "_municipio__ano_indicadores__layout",
                      "component": () => Layout$1
                    }
                  ],
                  "isLayout": false,
                  "isReset": false,
                  "isIndex": false,
                  "isFallback": false,
                  "isPage": false,
                  "ownMeta": {},
                  "meta": {
                    "preload": false,
                    "precache-order": false,
                    "precache-proximity": true,
                    "recursive": true
                  },
                  "path": "/municipio/:ano/indicadores"
                },
                {
                  "isFile": false,
                  "isDir": true,
                  "file": "[municipio]",
                  "filepath": "/municipio/[ano]/[municipio]",
                  "name": "[municipio]",
                  "ext": "",
                  "badExt": false,
                  "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]",
                  "children": [
                    {
                      "isFile": false,
                      "isDir": true,
                      "file": "[ug]",
                      "filepath": "/municipio/[ano]/[municipio]/[ug]",
                      "name": "[ug]",
                      "ext": "",
                      "badExt": false,
                      "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]",
                      "children": [
                        {
                          "isFile": false,
                          "isDir": true,
                          "file": "despesas",
                          "filepath": "/municipio/[ano]/[municipio]/[ug]/despesas",
                          "name": "despesas",
                          "ext": "",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/despesas",
                          "children": [
                            {
                              "isFile": false,
                              "isDir": true,
                              "file": "destino-do-dinheiro",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/despesas/destino-do-dinheiro",
                              "name": "destino-do-dinheiro",
                              "ext": "",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/despesas/destino-do-dinheiro",
                              "children": [
                                {
                                  "isFile": true,
                                  "isDir": false,
                                  "file": "index.svelte",
                                  "filepath": "/municipio/[ano]/[municipio]/[ug]/despesas/destino-do-dinheiro/index.svelte",
                                  "name": "index",
                                  "ext": "svelte",
                                  "badExt": false,
                                  "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/despesas/destino-do-dinheiro/index.svelte",
                                  "isLayout": false,
                                  "isReset": false,
                                  "isIndex": true,
                                  "isFallback": false,
                                  "isPage": true,
                                  "ownMeta": {},
                                  "meta": {
                                    "preload": false,
                                    "precache-order": false,
                                    "precache-proximity": true,
                                    "recursive": true
                                  },
                                  "path": "/municipio/:ano/:municipio/:ug/despesas/destino-do-dinheiro/index",
                                  "id": "_municipio__ano__municipio__ug_despesas_destinoDoDinheiro_index",
                                  "component": () => Destino_do_dinheiro
                                }
                              ],
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": false,
                              "isFallback": false,
                              "isPage": false,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/despesas/destino-do-dinheiro"
                            },
                            {
                              "isFile": true,
                              "isDir": false,
                              "file": "index.svelte",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/despesas/index.svelte",
                              "name": "index",
                              "ext": "svelte",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/despesas/index.svelte",
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": true,
                              "isFallback": false,
                              "isPage": true,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/despesas/index",
                              "id": "_municipio__ano__municipio__ug_despesas_index",
                              "component": () => Despesas$1
                            }
                          ],
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": false,
                          "isFallback": false,
                          "isPage": false,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/:municipio/:ug/despesas"
                        },
                        {
                          "isFile": false,
                          "isDir": true,
                          "file": "educacao",
                          "filepath": "/municipio/[ano]/[municipio]/[ug]/educacao",
                          "name": "educacao",
                          "ext": "",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/educacao",
                          "children": [
                            {
                              "isFile": true,
                              "isDir": false,
                              "file": "index.svelte",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/educacao/index.svelte",
                              "name": "index",
                              "ext": "svelte",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/educacao/index.svelte",
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": true,
                              "isFallback": false,
                              "isPage": true,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/educacao/index",
                              "id": "_municipio__ano__municipio__ug_educacao_index",
                              "component": () => Educacao$1
                            }
                          ],
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": false,
                          "isFallback": false,
                          "isPage": false,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/:municipio/:ug/educacao"
                        },
                        {
                          "isFile": false,
                          "isDir": true,
                          "file": "iegm",
                          "filepath": "/municipio/[ano]/[municipio]/[ug]/iegm",
                          "name": "iegm",
                          "ext": "",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/iegm",
                          "children": [
                            {
                              "isFile": true,
                              "isDir": false,
                              "file": "index.svelte",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/iegm/index.svelte",
                              "name": "index",
                              "ext": "svelte",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/iegm/index.svelte",
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": true,
                              "isFallback": false,
                              "isPage": true,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/iegm/index",
                              "id": "_municipio__ano__municipio__ug_iegm_index",
                              "component": () => Iegm$1
                            }
                          ],
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": false,
                          "isFallback": false,
                          "isPage": false,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/:municipio/:ug/iegm"
                        },
                        {
                          "isFile": false,
                          "isDir": true,
                          "file": "obrigacoes",
                          "filepath": "/municipio/[ano]/[municipio]/[ug]/obrigacoes",
                          "name": "obrigacoes",
                          "ext": "",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/obrigacoes",
                          "children": [
                            {
                              "isFile": true,
                              "isDir": false,
                              "file": "index.svelte",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/obrigacoes/index.svelte",
                              "name": "index",
                              "ext": "svelte",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/obrigacoes/index.svelte",
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": true,
                              "isFallback": false,
                              "isPage": true,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/obrigacoes/index",
                              "id": "_municipio__ano__municipio__ug_obrigacoes_index",
                              "component": () => Obrigacoes
                            }
                          ],
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": false,
                          "isFallback": false,
                          "isPage": false,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/:municipio/:ug/obrigacoes"
                        },
                        {
                          "isFile": false,
                          "isDir": true,
                          "file": "pessoal",
                          "filepath": "/municipio/[ano]/[municipio]/[ug]/pessoal",
                          "name": "pessoal",
                          "ext": "",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/pessoal",
                          "children": [
                            {
                              "isFile": true,
                              "isDir": false,
                              "file": "index.svelte",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/pessoal/index.svelte",
                              "name": "index",
                              "ext": "svelte",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/pessoal/index.svelte",
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": true,
                              "isFallback": false,
                              "isPage": true,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/pessoal/index",
                              "id": "_municipio__ano__municipio__ug_pessoal_index",
                              "component": () => Pessoal$1
                            }
                          ],
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": false,
                          "isFallback": false,
                          "isPage": false,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/:municipio/:ug/pessoal"
                        },
                        {
                          "isFile": false,
                          "isDir": true,
                          "file": "previdencia",
                          "filepath": "/municipio/[ano]/[municipio]/[ug]/previdencia",
                          "name": "previdencia",
                          "ext": "",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/previdencia",
                          "children": [
                            {
                              "isFile": false,
                              "isDir": true,
                              "file": "despesa",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/previdencia/despesa",
                              "name": "despesa",
                              "ext": "",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/previdencia/despesa",
                              "children": [
                                {
                                  "isFile": true,
                                  "isDir": false,
                                  "file": "index.svelte",
                                  "filepath": "/municipio/[ano]/[municipio]/[ug]/previdencia/despesa/index.svelte",
                                  "name": "index",
                                  "ext": "svelte",
                                  "badExt": false,
                                  "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/previdencia/despesa/index.svelte",
                                  "isLayout": false,
                                  "isReset": false,
                                  "isIndex": true,
                                  "isFallback": false,
                                  "isPage": true,
                                  "ownMeta": {},
                                  "meta": {
                                    "preload": false,
                                    "precache-order": false,
                                    "precache-proximity": true,
                                    "recursive": true
                                  },
                                  "path": "/municipio/:ano/:municipio/:ug/previdencia/despesa/index",
                                  "id": "_municipio__ano__municipio__ug_previdencia_despesa_index",
                                  "component": () => Despesa
                                }
                              ],
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": false,
                              "isFallback": false,
                              "isPage": false,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/previdencia/despesa"
                            },
                            {
                              "isFile": true,
                              "isDir": false,
                              "file": "index.svelte",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/previdencia/index.svelte",
                              "name": "index",
                              "ext": "svelte",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/previdencia/index.svelte",
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": true,
                              "isFallback": false,
                              "isPage": true,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/previdencia/index",
                              "id": "_municipio__ano__municipio__ug_previdencia_index",
                              "component": () => Previdencia
                            },
                            {
                              "isFile": false,
                              "isDir": true,
                              "file": "receita",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/previdencia/receita",
                              "name": "receita",
                              "ext": "",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/previdencia/receita",
                              "children": [
                                {
                                  "isFile": true,
                                  "isDir": false,
                                  "file": "index.svelte",
                                  "filepath": "/municipio/[ano]/[municipio]/[ug]/previdencia/receita/index.svelte",
                                  "name": "index",
                                  "ext": "svelte",
                                  "badExt": false,
                                  "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/previdencia/receita/index.svelte",
                                  "isLayout": false,
                                  "isReset": false,
                                  "isIndex": true,
                                  "isFallback": false,
                                  "isPage": true,
                                  "ownMeta": {},
                                  "meta": {
                                    "preload": false,
                                    "precache-order": false,
                                    "precache-proximity": true,
                                    "recursive": true
                                  },
                                  "path": "/municipio/:ano/:municipio/:ug/previdencia/receita/index",
                                  "id": "_municipio__ano__municipio__ug_previdencia_receita_index",
                                  "component": () => Receita
                                }
                              ],
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": false,
                              "isFallback": false,
                              "isPage": false,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/previdencia/receita"
                            }
                          ],
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": false,
                          "isFallback": false,
                          "isPage": false,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/:municipio/:ug/previdencia"
                        },
                        {
                          "isFile": false,
                          "isDir": true,
                          "file": "receitas",
                          "filepath": "/municipio/[ano]/[municipio]/[ug]/receitas",
                          "name": "receitas",
                          "ext": "",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/receitas",
                          "children": [
                            {
                              "isFile": true,
                              "isDir": false,
                              "file": "index.svelte",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/receitas/index.svelte",
                              "name": "index",
                              "ext": "svelte",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/receitas/index.svelte",
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": true,
                              "isFallback": false,
                              "isPage": true,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/receitas/index",
                              "id": "_municipio__ano__municipio__ug_receitas_index",
                              "component": () => Receitas$1
                            }
                          ],
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": false,
                          "isFallback": false,
                          "isPage": false,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/:municipio/:ug/receitas"
                        },
                        {
                          "isFile": false,
                          "isDir": true,
                          "file": "saude",
                          "filepath": "/municipio/[ano]/[municipio]/[ug]/saude",
                          "name": "saude",
                          "ext": "",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/saude",
                          "children": [
                            {
                              "isFile": true,
                              "isDir": false,
                              "file": "index.svelte",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/saude/index.svelte",
                              "name": "index",
                              "ext": "svelte",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/saude/index.svelte",
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": true,
                              "isFallback": false,
                              "isPage": true,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/saude/index",
                              "id": "_municipio__ano__municipio__ug_saude_index",
                              "component": () => Saude$1
                            }
                          ],
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": false,
                          "isFallback": false,
                          "isPage": false,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/:municipio/:ug/saude"
                        },
                        {
                          "isFile": false,
                          "isDir": true,
                          "file": "visao-geral",
                          "filepath": "/municipio/[ano]/[municipio]/[ug]/visao-geral",
                          "name": "visao-geral",
                          "ext": "",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/visao-geral",
                          "children": [
                            {
                              "isFile": true,
                              "isDir": false,
                              "file": "index.svelte",
                              "filepath": "/municipio/[ano]/[municipio]/[ug]/visao-geral/index.svelte",
                              "name": "index",
                              "ext": "svelte",
                              "badExt": false,
                              "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/visao-geral/index.svelte",
                              "isLayout": false,
                              "isReset": false,
                              "isIndex": true,
                              "isFallback": false,
                              "isPage": true,
                              "ownMeta": {},
                              "meta": {
                                "preload": false,
                                "precache-order": false,
                                "precache-proximity": true,
                                "recursive": true
                              },
                              "path": "/municipio/:ano/:municipio/:ug/visao-geral/index",
                              "id": "_municipio__ano__municipio__ug_visaoGeral_index",
                              "component": () => Visao_geral
                            }
                          ],
                          "isLayout": false,
                          "isReset": false,
                          "isIndex": false,
                          "isFallback": false,
                          "isPage": false,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/:municipio/:ug/visao-geral"
                        },
                        {
                          "isFile": true,
                          "isDir": false,
                          "file": "_layout.svelte",
                          "filepath": "/municipio/[ano]/[municipio]/[ug]/_layout.svelte",
                          "name": "_layout",
                          "ext": "svelte",
                          "badExt": false,
                          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/municipio/[ano]/[municipio]/[ug]/_layout.svelte",
                          "isLayout": true,
                          "isReset": false,
                          "isIndex": false,
                          "isFallback": false,
                          "isPage": false,
                          "ownMeta": {},
                          "meta": {
                            "preload": false,
                            "precache-order": false,
                            "precache-proximity": true,
                            "recursive": true
                          },
                          "path": "/municipio/:ano/:municipio/:ug",
                          "id": "_municipio__ano__municipio__ug__layout",
                          "component": () => Layout$2
                        }
                      ],
                      "isLayout": false,
                      "isReset": false,
                      "isIndex": false,
                      "isFallback": false,
                      "isPage": false,
                      "ownMeta": {},
                      "meta": {
                        "preload": false,
                        "precache-order": false,
                        "precache-proximity": true,
                        "recursive": true
                      },
                      "path": "/municipio/:ano/:municipio/:ug"
                    }
                  ],
                  "isLayout": false,
                  "isReset": false,
                  "isIndex": false,
                  "isFallback": false,
                  "isPage": false,
                  "ownMeta": {},
                  "meta": {
                    "preload": false,
                    "precache-order": false,
                    "precache-proximity": true,
                    "recursive": true
                  },
                  "path": "/municipio/:ano/:municipio"
                }
              ],
              "isLayout": false,
              "isReset": false,
              "isIndex": false,
              "isFallback": false,
              "isPage": false,
              "ownMeta": {},
              "meta": {
                "preload": false,
                "precache-order": false,
                "precache-proximity": true,
                "recursive": true
              },
              "path": "/municipio/:ano"
            }
          ],
          "isLayout": false,
          "isReset": false,
          "isIndex": false,
          "isFallback": false,
          "isPage": false,
          "ownMeta": {},
          "meta": {
            "preload": false,
            "precache-order": false,
            "precache-proximity": true,
            "recursive": true
          },
          "path": "/municipio"
        },
        {
          "isFile": true,
          "isDir": false,
          "file": "_fallback.svelte",
          "filepath": "/_fallback.svelte",
          "name": "_fallback",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/_fallback.svelte",
          "isLayout": false,
          "isReset": false,
          "isIndex": false,
          "isFallback": true,
          "isPage": false,
          "ownMeta": {},
          "meta": {
            "preload": false,
            "precache-order": false,
            "precache-proximity": true,
            "recursive": true
          },
          "path": "/_fallback",
          "id": "__fallback",
          "component": () => Fallback
        },
        {
          "isFile": true,
          "isDir": false,
          "file": "_layout.svelte",
          "filepath": "/_layout.svelte",
          "name": "_layout",
          "ext": "svelte",
          "badExt": false,
          "absolutePath": "D:/Projetos/VisualCode/Svelte/ControleSocial/src/pages/_layout.svelte",
          "isLayout": true,
          "isReset": false,
          "isIndex": false,
          "isFallback": false,
          "isPage": false,
          "ownMeta": {},
          "meta": {
            "preload": false,
            "precache-order": false,
            "precache-proximity": true,
            "recursive": true
          },
          "path": "/",
          "id": "__layout",
          "component": () => Layout$3
        }
      ],
      "isLayout": false,
      "isReset": false,
      "isIndex": false,
      "isFallback": false,
      "meta": {
        "preload": false,
        "precache-order": false,
        "precache-proximity": true,
        "recursive": true
      },
      "path": "/"
    };


    const {tree, routes: routes$1} = buildClientTree(_tree);

    /* src\App.svelte generated by Svelte v3.22.3 */

    function create_fragment$1A(ctx) {
    	let current;
    	const router = new Router({ props: { routes: routes$1 }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1z($$self, $$props, $$invalidate) {
    	setPaginationLabels({
    		first: "Primeira",
    		last: "Última",
    		next: "Próxima",
    		previous: "Anterior"
    	});

    	setTableLabels({
    		empty: "Não há registros disponíveis",
    		loading: `<span class="spinning">.</span><span class="ml-4">Obtendo dados</span>`
    	});

    	setSearchLabels({ placeholder: "Pesquisar" });

    	setSortLabels({
    		asc: { title: "Crescente", html: "&#8593;" },
    		desc: { title: "Decrescente", html: "&#8595;" },
    		unsorted: {
    			title: "Ordenação inicial",
    			html: "&#8645;"
    		}
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("App", $$slots, []);

    	$$self.$capture_state = () => ({
    		Router,
    		routes: routes$1,
    		setPaginationLabels,
    		setTableLabels,
    		setSearchLabels,
    		setSortLabels
    	});

    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1z, create_fragment$1A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$1A.name
    		});
    	}
    }

    const app = HMR(App, {
    	target: document.body
    }, 'routify-app');

    return app;

}());
//# sourceMappingURL=bundle.js.map
